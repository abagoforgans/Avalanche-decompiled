contract main {




// =====================  Runtime code  =====================


#
#  - deposit(address arg1, uint256 arg2, uint256 arg3)
#  - initialize(address arg1, uint256 arg2, address arg3, address arg4)
#  - withdraw(address arg1, uint256 arg2, uint256 arg3)
#  - withdrawAVAX(address arg1, uint256 arg2, uint256 arg3)
#  - _fallback()
#
address owner;
uint8 paused;
address token0Address;
address token1Address;
uint256 sub_9ddc230a;
uint256 sub_3266f45c;
address lpTokenAddress;
address masterChefAddress;
uint32 stor207;
uint256 stor207; offset 32
uint256 poolId;
address treasuryAddress;
address stor209;
uint256 sub_b1a41085;
uint256 sub_0b55d7c3;
uint256 sub_c8af9d6a;
mapping of uint256 sub_be892f00;
mapping of struct userInfo;

function sub_0b55d7c3(?) {
    return sub_0b55d7c3
}

function token0() {
    return token0Address
}

function userInfo(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userInfo[arg1].field_0, userInfo[arg1].field_256
}

function sub_3266f45c(?) {
    return sub_3266f45c
}

function poolId() {
    return poolId
}

function getUserBalance(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userInfo[address(arg1)].field_0
}

function masterChef() {
    return masterChefAddress
}

function paused() {
    return bool(paused)
}

function lpToken() {
    return lpTokenAddress
}

function treasury() {
    return treasuryAddress
}

function owner() {
    return owner
}

function sub_9ddc230a(?) {
    return sub_9ddc230a
}

function sub_b1a41085(?) {
    return sub_b1a41085
}

function sub_be892f00(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_be892f00[address(arg1)]
}

function sub_c8af9d6a(?) {
    return sub_c8af9d6a
}

function token1() {
    return token1Address
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_a99c5da2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_0b55d7c3 = arg1
    emit 0x549ad136: sub_0b55d7c3, arg1
}

function pauseContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpauseContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function setBot(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor209 = arg1
    emit 0x97c1aa2e: stor209, arg1
}

function setTreasury(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    treasuryAddress = arg1
    emit SetTreasury(treasuryAddress, arg1);
}

function setYieldFeePerc(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 2000:
        revert with 0, 'Invalid yield fee percentage'
    sub_b1a41085 = arg1
    emit 0xed33bc5a: sub_b1a41085, arg1
}

function getAllPool() {
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.0x93f1a40b with:
            gas gas_remaining wei
           args poolId, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function getUserPendingReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
        revert with 0, 17
    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
        revert with 0, 17
    return ((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256)
}

function sub_616094a7(?) {
    mem[96] = 0xffcd426300000000000000000000000000000000000000000000000000000000
    mem[100] = poolId
    mem[132] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.pendingTokens(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args poolId, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 128
    _4 = mem[96 len 4], Mask(224, 0, stor207.field_32)
    require uint32(stor207.field_0), Mask(224, 32, this.address) >> 32 == Mask(160, 32, this.address) >> 32
    _6 = uint32(this.address), mem[164 len 28]
    require uint32(this.address), mem[164 len 28] <= test266151307()
    require uint32(this.address), mem[164 len 28] + 127 < return_data.size + 96
    _7 = mem[uint32(this.address), mem[164 len 28] + 96]
    if mem[uint32(this.address), mem[164 len 28] + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 97
    mem[ceil32(return_data.size) + 96] = _7
    require _6 + _7 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 128 len ceil32(_7)] = mem[_6 + 128 len ceil32(_7)]
    if ceil32(_7) <= _7:
        _25 = mem[192]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _31 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _4 > !mem[_31]:
            revert with 0, 17
        mem[mem[64]] = _4 + mem[_31]
        return mem[mem[64]], _25
    mem[_7 + ceil32(return_data.size) + 128] = 0
    _26 = mem[192]
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
    staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _32 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if _4 > !mem[_32]:
        revert with 0, 17
    mem[mem[64]] = _4 + mem[_32]
    return mem[mem[64]], _26
}

function harvest() {
    require ext_code.size(masterChefAddress)
    call masterChefAddress.0x441a3e70 with:
         gas gas_remaining wei
        args poolId, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[132] = 0
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
         gas gas_remaining wei
        args 24, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[100] = this.address
    require ext_code.size(0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66)
    staticcall 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 10^16:
        mem[ceil32(return_data.size) + 100] = this.address
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1065 = mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _1069 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _1069
            require _1065 + (32 * _1069) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1069)] = mem[(2 * ceil32(return_data.size)) + _1065 + 224 len ceil32(32 * _1069)]
            if 1 >= _1069:
                revert with 0, 50
            if mem[(4 * ceil32(return_data.size)) + 256] > 25 * 10^16:
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                     gas gas_remaining wei
                    args ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2072 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2077 = mem[_2072]
                if mem[_2072] and sub_b1a41085 > -1 / mem[_2072]:
                    revert with 0, 17
                _2113 = mem[64]
                mem[mem[64] + 36] = treasuryAddress
                mem[mem[64] + 68] = _2077 * sub_b1a41085 / 10000
                _2120 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_2113 + 100] = 32
                mem[_2113 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _2148 = mem[_2120]
                mem[_2113 + 164 len ceil32(mem[_2120])] = mem[_2120 + 32 len ceil32(mem[_2120])]
                if ceil32(_2148) > _2148:
                    mem[_2148 + _2113 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_2113 + 168 len _2148 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), 0 == bool(uint32(this.address), 0)
                        if not uint32(this.address), 0:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_2113 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_2113 + 196] == bool(mem[_2113 + 196])
                        if not mem[_2113 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _2077 < _2077 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                     gas gas_remaining wei
                    args 24, _2077 - (_2077 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.0x93f1a40b with:
                        gas gas_remaining wei
                       args poolId, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _2077 - (_2077 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _2077) - (1000000000000000000 * 10^18 * _2077 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _2077) - (1000000000000000000 * 10^18 * _2077 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _2077 - (_2077 * sub_b1a41085 / 10000), _2077 * sub_b1a41085 / 10000);
        else:
            require ext_code.size(token0Address)
            staticcall token0Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= 10^15:
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1066 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1070 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require _1066 + (32 * _1070) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1070)] = mem[(4 * ceil32(return_data.size)) + _1066 + 224 len ceil32(32 * _1070)]
                if 1 >= _1070:
                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                         gas gas_remaining wei
                        args ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2073 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2078 = mem[_2073]
                    if mem[_2073] and sub_b1a41085 > -1 / mem[_2073]:
                        revert with 0, 17
                    _2114 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _2078 * sub_b1a41085 / 10000
                    _2122 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_2114 + 100] = 32
                    mem[_2114 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _2150 = mem[_2122]
                    mem[_2114 + 164 len ceil32(mem[_2122])] = mem[_2122 + 32 len ceil32(mem[_2122])]
                    if ceil32(_2150) > _2150:
                        mem[_2150 + _2114 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_2114 + 168 len _2150 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), 0 == bool(uint32(this.address), 0)
                            if not uint32(this.address), 0:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_2114 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_2114 + 196] == bool(mem[_2114 + 196])
                            if not mem[_2114 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _2078 < _2078 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                         gas gas_remaining wei
                        args 24, _2078 - (_2078 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.0x93f1a40b with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _2078 - (_2078 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _2078) - (1000000000000000000 * 10^18 * _2078 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _2078) - (1000000000000000000 * 10^18 * _2078 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(ext_call.return_data[0], _2078 - (_2078 * sub_b1a41085 / 10000), _2078 * sub_b1a41085 / 10000);
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 260] = 0
                mem[(2 * ceil32(return_data.size)) + 292] = 160
                mem[(2 * ceil32(return_data.size)) + 388] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 420
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 324] = this.address
                mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1067 = mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28]
                require mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                _1071 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225
                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
                require _1067 + (32 * _1071) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 256 len ceil32(32 * _1071)] = mem[(2 * ceil32(return_data.size)) + _1067 + 256 len ceil32(32 * _1071)]
                if 2 >= _1071:
                    revert with 0, 50
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2074 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2079 = mem[_2074]
                _2090 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2090]:
                    revert with 0, 50
                mem[_2090 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_2090]:
                    revert with 0, 50
                mem[_2090 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_2090 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_2090 + 100] = _2079
                mem[_2090 + 132] = 64
                mem[_2090 + 164] = mem[_2090]
                idx = 0
                s = _2090 + 32
                t = _2090 + 196
                while idx < mem[_2090]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _2090 + (32 * mem[_2090]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3033 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3037 = mem[_3033]
                require mem[_3033] <= test266151307()
                require _3033 + mem[_3033] + 31 < _3033 + return_data.size
                _3065 = mem[_3033 + mem[_3033]]
                if mem[_3033 + mem[_3033]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3033 + mem[_3033]]) + 1 < 0 or _3033 + ceil32(return_data.size) + ceil32(32 * mem[_3033 + mem[_3033]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3033 + ceil32(return_data.size) + ceil32(32 * mem[_3033 + mem[_3033]]) + 1
                mem[_3033 + ceil32(return_data.size)] = _3065
                require _3037 + (32 * _3065) + 32 <= return_data.size
                mem[_3033 + ceil32(return_data.size) + 32 len ceil32(32 * _3065)] = mem[_3033 + _3037 + 32 len ceil32(32 * _3065)]
                if 1 >= _3065:
                    revert with 0, 50
                if mem[_3033 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                         gas gas_remaining wei
                        args _2079
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3937 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3941 = mem[_3937]
                    if mem[_3937] and sub_b1a41085 > -1 / mem[_3937]:
                        revert with 0, 17
                    _3954 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _3941 * sub_b1a41085 / 10000
                    _3957 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_3954 + 100] = 32
                    mem[_3954 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _3981 = mem[_3957]
                    mem[_3954 + 164 len ceil32(mem[_3957])] = mem[_3957 + 32 len ceil32(mem[_3957])]
                    if ceil32(_3981) > _3981:
                        mem[_3981 + _3954 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_3954 + 168 len _3981 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_3954 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_3954 + 196] == bool(mem[_3954 + 196])
                            if not mem[_3954 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _3941 < _3941 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                         gas gas_remaining wei
                        args 24, _3941 - (_3941 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.0x93f1a40b with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _3941 - (_3941 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3941) - (1000000000000000000 * 10^18 * _3941 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _3941) - (1000000000000000000 * 10^18 * _3941 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_2079, _3941 - (_3941 * sub_b1a41085 / 10000), _3941 * sub_b1a41085 / 10000);
    else:
        mem[ceil32(return_data.size) + 96] = 2
        mem[ceil32(return_data.size) + 128] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[ceil32(return_data.size) + 160] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        mem[ceil32(return_data.size) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 228] = 0
        mem[ceil32(return_data.size) + 260] = 160
        mem[ceil32(return_data.size) + 356] = 2
        idx = 0
        s = ceil32(return_data.size) + 128
        t = ceil32(return_data.size) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(return_data.size) + 292] = this.address
        mem[ceil32(return_data.size) + 324] = block.timestamp
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (2 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _1068 = mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 223 < ceil32(return_data.size) + return_data.size + 192
        _1072 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
        if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
            revert with 0, 65
        mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
        mem[(2 * ceil32(return_data.size)) + 192] = _1072
        require _1068 + (32 * _1072) + 32 <= return_data.size
        mem[(2 * ceil32(return_data.size)) + 224 len ceil32(32 * _1072)] = mem[ceil32(return_data.size) + _1068 + 224 len ceil32(32 * _1072)]
        if 1 >= _1072:
            revert with 0, 50
        mem[mem[64] + 4] = this.address
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2075 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2080 = mem[_2075]
            _2092 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            if 0 >= mem[_2092]:
                revert with 0, 50
            mem[_2092 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            if 1 >= mem[_2092]:
                revert with 0, 50
            mem[_2092 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[_2092 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[_2092 + 100] = _2080
            mem[_2092 + 132] = 64
            mem[_2092 + 164] = mem[_2092]
            idx = 0
            s = _2092 + 32
            t = _2092 + 196
            while idx < mem[_2092]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4 len _2092 + (32 * mem[_2092]) + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3034 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3038 = mem[_3034]
            require mem[_3034] <= test266151307()
            require _3034 + mem[_3034] + 31 < _3034 + return_data.size
            _3066 = mem[_3034 + mem[_3034]]
            if mem[_3034 + mem[_3034]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_3034 + mem[_3034]]) + 1 < 0 or _3034 + ceil32(return_data.size) + ceil32(32 * mem[_3034 + mem[_3034]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _3034 + ceil32(return_data.size) + ceil32(32 * mem[_3034 + mem[_3034]]) + 1
            mem[_3034 + ceil32(return_data.size)] = _3066
            require _3038 + (32 * _3066) + 32 <= return_data.size
            mem[_3034 + ceil32(return_data.size) + 32 len ceil32(32 * _3066)] = mem[_3034 + _3038 + 32 len ceil32(32 * _3066)]
            if 1 >= _3066:
                revert with 0, 50
            if mem[_3034 + ceil32(return_data.size) + 64] > 25 * 10^16:
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                     gas gas_remaining wei
                    args _2080
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3942 = mem[_3938]
                if mem[_3938] and sub_b1a41085 > -1 / mem[_3938]:
                    revert with 0, 17
                _3955 = mem[64]
                mem[mem[64] + 36] = treasuryAddress
                mem[mem[64] + 68] = _3942 * sub_b1a41085 / 10000
                _3959 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_3955 + 100] = 32
                mem[_3955 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _3983 = mem[_3959]
                mem[_3955 + 164 len ceil32(mem[_3959])] = mem[_3959 + 32 len ceil32(mem[_3959])]
                if ceil32(_3983) > _3983:
                    mem[_3983 + _3955 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_3955 + 168 len _3983 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_3955 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3955 + 196] == bool(mem[_3955 + 196])
                        if not mem[_3955 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _3942 < _3942 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                     gas gas_remaining wei
                    args 24, _3942 - (_3942 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.0x93f1a40b with:
                        gas gas_remaining wei
                       args poolId, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _3942 - (_3942 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3942) - (1000000000000000000 * 10^18 * _3942 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _3942) - (1000000000000000000 * 10^18 * _3942 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(_2080, _3942 - (_3942 * sub_b1a41085 / 10000), _3942 * sub_b1a41085 / 10000);
        else:
            require ext_code.size(token0Address)
            staticcall token0Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2076 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2081 = mem[_2076]
            if mem[_2076] <= 10^15:
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2105 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2112 = mem[_2105]
                _2126 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2126]:
                    revert with 0, 50
                mem[_2126 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_2126]:
                    revert with 0, 50
                mem[_2126 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_2126 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_2126 + 100] = _2112
                mem[_2126 + 132] = 64
                mem[_2126 + 164] = mem[_2126]
                idx = 0
                s = _2126 + 32
                t = _2126 + 196
                while idx < mem[_2126]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _2126 + (32 * mem[_2126]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3035 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3039 = mem[_3035]
                require mem[_3035] <= test266151307()
                require _3035 + mem[_3035] + 31 < _3035 + return_data.size
                _3067 = mem[_3035 + mem[_3035]]
                if mem[_3035 + mem[_3035]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3035 + mem[_3035]]) + 1 < 0 or _3035 + ceil32(return_data.size) + ceil32(32 * mem[_3035 + mem[_3035]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3035 + ceil32(return_data.size) + ceil32(32 * mem[_3035 + mem[_3035]]) + 1
                mem[_3035 + ceil32(return_data.size)] = _3067
                require _3039 + (32 * _3067) + 32 <= return_data.size
                mem[_3035 + ceil32(return_data.size) + 32 len ceil32(32 * _3067)] = mem[_3035 + _3039 + 32 len ceil32(32 * _3067)]
                if 1 >= _3067:
                    revert with 0, 50
                if mem[_3035 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                         gas gas_remaining wei
                        args _2112
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3939 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3943 = mem[_3939]
                    if mem[_3939] and sub_b1a41085 > -1 / mem[_3939]:
                        revert with 0, 17
                    _3956 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _3943 * sub_b1a41085 / 10000
                    _3961 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_3956 + 100] = 32
                    mem[_3956 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _3985 = mem[_3961]
                    mem[_3956 + 164 len ceil32(mem[_3961])] = mem[_3961 + 32 len ceil32(mem[_3961])]
                    if ceil32(_3985) > _3985:
                        mem[_3985 + _3956 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_3956 + 168 len _3985 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_3956 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_3956 + 196] == bool(mem[_3956 + 196])
                            if not mem[_3956 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _3943 < _3943 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                         gas gas_remaining wei
                        args 24, _3943 - (_3943 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.0x93f1a40b with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _3943 - (_3943 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3943) - (1000000000000000000 * 10^18 * _3943 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _3943) - (1000000000000000000 * 10^18 * _3943 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_2112, _3943 - (_3943 * sub_b1a41085 / 10000), _3943 * sub_b1a41085 / 10000);
            else:
                _2098 = mem[64]
                mem[mem[64]] = 3
                mem[64] = mem[64] + 128
                if 0 >= mem[_2098]:
                    revert with 0, 50
                mem[_2098 + 32] = token0Address
                if 1 >= mem[_2098]:
                    revert with 0, 50
                mem[_2098 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                if 2 >= mem[_2098]:
                    revert with 0, 50
                mem[_2098 + 96] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[_2098 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_2098 + 132] = _2081
                mem[_2098 + 164] = 0
                mem[_2098 + 196] = 160
                mem[_2098 + 292] = mem[_2098]
                idx = 0
                s = _2098 + 32
                t = _2098 + 324
                while idx < mem[_2098]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_2098 + 228] = this.address
                mem[_2098 + 260] = block.timestamp
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                call ????????????????????????????????????????.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _2098 + (32 * mem[_2098]) + -mem[64] + 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3036 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3040 = mem[_3036]
                require mem[_3036] <= test266151307()
                require _3036 + mem[_3036] + 31 < _3036 + return_data.size
                _3068 = mem[_3036 + mem[_3036]]
                if mem[_3036 + mem[_3036]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3036 + mem[_3036]]) + 1 < 0 or _3036 + ceil32(return_data.size) + ceil32(32 * mem[_3036 + mem[_3036]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3036 + ceil32(return_data.size) + ceil32(32 * mem[_3036 + mem[_3036]]) + 1
                mem[_3036 + ceil32(return_data.size)] = _3068
                require _3040 + (32 * _3068) + 32 <= return_data.size
                mem[_3036 + ceil32(return_data.size) + 32 len ceil32(32 * _3068)] = mem[_3036 + _3040 + 32 len ceil32(32 * _3068)]
                if 2 >= _3068:
                    revert with 0, 50
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3940 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3944 = mem[_3940]
                _3949 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_3949]:
                    revert with 0, 50
                mem[_3949 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_3949]:
                    revert with 0, 50
                mem[_3949 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_3949 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_3949 + 100] = _3944
                mem[_3949 + 132] = 64
                mem[_3949 + 164] = mem[_3949]
                idx = 0
                s = _3949 + 32
                t = _3949 + 196
                while idx < mem[_3949]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _3949 + (32 * mem[_3949]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4526 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4527 = mem[_4526]
                require mem[_4526] <= test266151307()
                require _4526 + mem[_4526] + 31 < _4526 + return_data.size
                _4564 = mem[_4526 + mem[_4526]]
                if mem[_4526 + mem[_4526]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_4526 + mem[_4526]]) + 1 < 0 or _4526 + ceil32(return_data.size) + ceil32(32 * mem[_4526 + mem[_4526]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _4526 + ceil32(return_data.size) + ceil32(32 * mem[_4526 + mem[_4526]]) + 1
                mem[_4526 + ceil32(return_data.size)] = _4564
                require _4527 + (32 * _4564) + 32 <= return_data.size
                mem[_4526 + ceil32(return_data.size) + 32 len ceil32(32 * _4564)] = mem[_4526 + _4527 + 32 len ceil32(32 * _4564)]
                if 1 >= _4564:
                    revert with 0, 50
                if mem[_4526 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                         gas gas_remaining wei
                        args _3944
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5077 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5078 = mem[_5077]
                    if mem[_5077] and sub_b1a41085 > -1 / mem[_5077]:
                        revert with 0, 17
                    _5079 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _5078 * sub_b1a41085 / 10000
                    _5080 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5079 + 100] = 32
                    mem[_5079 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _5087 = mem[_5080]
                    mem[_5079 + 164 len ceil32(mem[_5080])] = mem[_5080 + 32 len ceil32(mem[_5080])]
                    if ceil32(_5087) > _5087:
                        mem[_5087 + _5079 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_5079 + 168 len _5087 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5079 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5079 + 196] == bool(mem[_5079 + 196])
                            if not mem[_5079 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _5078 < _5078 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                         gas gas_remaining wei
                        args 24, _5078 - (_5078 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.0x93f1a40b with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _5078 - (_5078 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _5078) - (1000000000000000000 * 10^18 * _5078 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _5078) - (1000000000000000000 * 10^18 * _5078 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_3944, _5078 - (_5078 * sub_b1a41085 / 10000), _5078 * sub_b1a41085 / 10000);
}

function claimReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(masterChefAddress)
    call masterChefAddress.0x441a3e70 with:
         gas gas_remaining wei
        args poolId, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[132] = 0
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
         gas gas_remaining wei
        args 24, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[100] = this.address
    require ext_code.size(0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66)
    staticcall 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 10^16:
        mem[ceil32(return_data.size) + 100] = this.address
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _5293 = mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _5297 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _5297
            require _5293 + (32 * _5297) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _5297)] = mem[(2 * ceil32(return_data.size)) + _5293 + 224 len ceil32(32 * _5297)]
            if 1 >= _5297:
                revert with 0, 50
            if mem[(4 * ceil32(return_data.size)) + 256] <= 25 * 10^16:
                mem[0] = arg1
                mem[32] = 214
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _11228 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        _11232 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_11228 + 100] = 32
                        mem[_11228 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        _11272 = mem[_11232]
                        mem[_11228 + 164 len ceil32(mem[_11232])] = mem[_11232 + 32 len ceil32(mem[_11232])]
                        if ceil32(_11272) > _11272:
                            mem[_11272 + _11228 + 164] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                             gas gas_remaining wei
                            args mem[_11228 + 168 len _11272 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11228 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11228 + 196] == bool(mem[_11228 + 196])
                                if not mem[_11228 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                 gas gas_remaining wei
                args ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11162 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _11167 = mem[_11162]
            if mem[_11162] and sub_b1a41085 > -1 / mem[_11162]:
                revert with 0, 17
            _11203 = mem[64]
            mem[mem[64] + 36] = treasuryAddress
            mem[mem[64] + 68] = _11167 * sub_b1a41085 / 10000
            _11212 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_11203 + 100] = 32
            mem[_11203 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            _11250 = mem[_11212]
            mem[_11203 + 164 len ceil32(mem[_11212])] = mem[_11212 + 32 len ceil32(mem[_11212])]
            if ceil32(_11250) > _11250:
                mem[_11250 + _11203 + 164] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                 gas gas_remaining wei
                args mem[_11203 + 168 len _11250 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _11167 < _11167 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                     gas gas_remaining wei
                    args 24, _11167 - (_11167 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11203 + 200] = this.address
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.0x93f1a40b with:
                        gas gas_remaining wei
                       args poolId, this.address
                mem[_11203 + 164 len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _11167 - (_11167 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _11167) - (1000000000000000000 * 10^18 * _11167 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _11167) - (1000000000000000000 * 10^18 * _11167 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _11167 - (_11167 * sub_b1a41085 / 10000), _11167 * sub_b1a41085 / 10000);
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_11203 + ceil32(return_data.size) + 200] = arg1
                        mem[_11203 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        mem[_11203 + ceil32(return_data.size) + 164] = 68
                        mem[_11203 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                        mem[_11203 + ceil32(return_data.size) + 264] = 32
                        mem[_11203 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        mem[_11203 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                        mem[_11203 + ceil32(return_data.size) + 396] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11203 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11203 + ceil32(return_data.size) + 360] == bool(mem[_11203 + ceil32(return_data.size) + 360])
                                if not mem[_11203 + ceil32(return_data.size) + 360]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11203 + 164] = return_data.size
            mem[_11203 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[_11203 + 196] == bool(mem[_11203 + 196])
                if not mem[_11203 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _11167 < _11167 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                 gas gas_remaining wei
                args 24, _11167 - (_11167 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11203 + ceil32(return_data.size) + 201] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.0x93f1a40b with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_11203 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _11167 - (_11167 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _11167) - (1000000000000000000 * 10^18 * _11167 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _11167) - (1000000000000000000 * 10^18 * _11167 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(ext_call.return_data[0], _11167 - (_11167 * sub_b1a41085 / 10000), _11167 * sub_b1a41085 / 10000);
            if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
            if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                 gas gas_remaining wei
                args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
               funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
            mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11203 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_11203 + (4 * ceil32(return_data.size)) + 334] = 32
                mem[_11203 + (4 * ceil32(return_data.size)) + 366] = 32
                mem[_11203 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
                revert with memory
                  from _11203 + (4 * ceil32(return_data.size)) + 330
                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
            if not return_data.size:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require return_data.size >= 32
            require mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
            if mem[_11203 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11203 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_11203 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_11203 + (4 * ceil32(return_data.size)) + 366] = 42
            mem[_11203 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
            mem[_11203 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
            revert with memory
              from _11203 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
        require ext_code.size(token0Address)
        staticcall token0Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 10^15:
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _5294 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _5298 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            require _5294 + (32 * _5298) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _5298)] = mem[(4 * ceil32(return_data.size)) + _5294 + 224 len ceil32(32 * _5298)]
            if 1 >= _5298:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] <= 25 * 10^16:
                mem[0] = arg1
                mem[32] = 214
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _11229 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        _11235 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_11229 + 100] = 32
                        mem[_11229 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        _11274 = mem[_11235]
                        mem[_11229 + 164 len ceil32(mem[_11235])] = mem[_11235 + 32 len ceil32(mem[_11235])]
                        if ceil32(_11274) > _11274:
                            mem[_11274 + _11229 + 164] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                             gas gas_remaining wei
                            args mem[_11229 + 168 len _11274 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11229 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11229 + 196] == bool(mem[_11229 + 196])
                                if not mem[_11229 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
                 gas gas_remaining wei
                args ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _11163 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _11168 = mem[_11163]
            if mem[_11163] and sub_b1a41085 > -1 / mem[_11163]:
                revert with 0, 17
            _11204 = mem[64]
            mem[mem[64] + 36] = treasuryAddress
            mem[mem[64] + 68] = _11168 * sub_b1a41085 / 10000
            _11216 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_11204 + 100] = 32
            mem[_11204 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            _11252 = mem[_11216]
            mem[_11204 + 164 len ceil32(mem[_11216])] = mem[_11216 + 32 len ceil32(mem[_11216])]
            if ceil32(_11252) > _11252:
                mem[_11252 + _11204 + 164] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                 gas gas_remaining wei
                args mem[_11204 + 168 len _11252 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _11168 < _11168 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                     gas gas_remaining wei
                    args 24, _11168 - (_11168 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11204 + 200] = this.address
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.0x93f1a40b with:
                        gas gas_remaining wei
                       args poolId, this.address
                mem[_11204 + 164 len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _11168 - (_11168 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _11168) - (1000000000000000000 * 10^18 * _11168 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _11168) - (1000000000000000000 * 10^18 * _11168 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _11168 - (_11168 * sub_b1a41085 / 10000), _11168 * sub_b1a41085 / 10000);
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_11204 + ceil32(return_data.size) + 200] = arg1
                        mem[_11204 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        mem[_11204 + ceil32(return_data.size) + 164] = 68
                        mem[_11204 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                        mem[_11204 + ceil32(return_data.size) + 264] = 32
                        mem[_11204 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        mem[_11204 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                        mem[_11204 + ceil32(return_data.size) + 396] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11204 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11204 + ceil32(return_data.size) + 360] == bool(mem[_11204 + ceil32(return_data.size) + 360])
                                if not mem[_11204 + ceil32(return_data.size) + 360]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11204 + 164] = return_data.size
            mem[_11204 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[_11204 + 196] == bool(mem[_11204 + 196])
                if not mem[_11204 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _11168 < _11168 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                 gas gas_remaining wei
                args 24, _11168 - (_11168 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11204 + ceil32(return_data.size) + 201] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.0x93f1a40b with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_11204 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _11168 - (_11168 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _11168) - (1000000000000000000 * 10^18 * _11168 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _11168) - (1000000000000000000 * 10^18 * _11168 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(ext_call.return_data[0], _11168 - (_11168 * sub_b1a41085 / 10000), _11168 * sub_b1a41085 / 10000);
            if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
            if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                 gas gas_remaining wei
                args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
               funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
            mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11204 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_11204 + (4 * ceil32(return_data.size)) + 334] = 32
                mem[_11204 + (4 * ceil32(return_data.size)) + 366] = 32
                mem[_11204 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
                revert with memory
                  from _11204 + (4 * ceil32(return_data.size)) + 330
                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
            if not return_data.size:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require return_data.size >= 32
            require mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
            if mem[_11204 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11204 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_11204 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_11204 + (4 * ceil32(return_data.size)) + 366] = 42
            mem[_11204 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
            mem[_11204 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
            revert with memory
              from _11204 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
        mem[(2 * ceil32(return_data.size)) + 96] = 3
        mem[(2 * ceil32(return_data.size)) + 128] = token0Address
        mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[(2 * ceil32(return_data.size)) + 192] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 260] = 0
        mem[(2 * ceil32(return_data.size)) + 292] = 160
        mem[(2 * ceil32(return_data.size)) + 388] = 3
        idx = 0
        s = (2 * ceil32(return_data.size)) + 128
        t = (2 * ceil32(return_data.size)) + 420
        while idx < 3:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(2 * ceil32(return_data.size)) + 324] = this.address
        mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 224
        require return_data.size >= 32
        _5295 = mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28]
        require mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
        _5299 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
        if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225 > test266151307():
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225
        mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
        require _5295 + (32 * _5299) + 32 <= return_data.size
        mem[(4 * ceil32(return_data.size)) + 256 len ceil32(32 * _5299)] = mem[(2 * ceil32(return_data.size)) + _5295 + 256 len ceil32(32 * _5299)]
        if 2 >= _5299:
            revert with 0, 50
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11164 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11169 = mem[_11164]
        _11180 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11180]:
            revert with 0, 50
        mem[_11180 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11180]:
            revert with 0, 50
        mem[_11180 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11180 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11180 + 100] = _11169
        mem[_11180 + 132] = 64
        mem[_11180 + 164] = mem[_11180]
        idx = 0
        s = _11180 + 32
        t = _11180 + 196
        while idx < mem[_11180]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11180 + (32 * mem[_11180]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16991 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16995 = mem[_16991]
        require mem[_16991] <= test266151307()
        require _16991 + mem[_16991] + 31 < _16991 + return_data.size
        _17047 = mem[_16991 + mem[_16991]]
        if mem[_16991 + mem[_16991]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16991 + mem[_16991]]) + 1 < 0 or _16991 + ceil32(return_data.size) + ceil32(32 * mem[_16991 + mem[_16991]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16991 + ceil32(return_data.size) + ceil32(32 * mem[_16991 + mem[_16991]]) + 1
        mem[_16991 + ceil32(return_data.size)] = _17047
        require _16995 + (32 * _17047) + 32 <= return_data.size
        mem[_16991 + ceil32(return_data.size) + 32 len ceil32(32 * _17047)] = mem[_16991 + _16995 + 32 len ceil32(32 * _17047)]
        if 1 >= _17047:
            revert with 0, 50
        if mem[_16991 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23887 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _24018 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23887 + 100] = 32
                    mem[_23887 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _24063 = mem[_24018]
                    mem[_23887 + 164 len ceil32(mem[_24018])] = mem[_24018 + 32 len ceil32(mem[_24018])]
                    if ceil32(_24063) > _24063:
                        mem[_24063 + _23887 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23887 + 168 len _24063 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23887 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23887 + 196] == bool(mem[_23887 + 196])
                            if not mem[_23887 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
             gas gas_remaining wei
            args _11169
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22890 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23086 = mem[_22890]
        if mem[_22890] and sub_b1a41085 > -1 / mem[_22890]:
            revert with 0, 17
        _23739 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _23086 * sub_b1a41085 / 10000
        _23808 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23739 + 100] = 32
        mem[_23739 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _24040 = mem[_23808]
        mem[_23739 + 164 len ceil32(mem[_23808])] = mem[_23808 + 32 len ceil32(mem[_23808])]
        if ceil32(_24040) > _24040:
            mem[_24040 + _23739 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23739 + 168 len _24040 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _23086 < _23086 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                 gas gas_remaining wei
                args 24, _23086 - (_23086 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23739 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.0x93f1a40b with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23739 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _23086 - (_23086 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23086) - (1000000000000000000 * 10^18 * _23086 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _23086) - (1000000000000000000 * 10^18 * _23086 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_11169, _23086 - (_23086 * sub_b1a41085 / 10000), _23086 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23739 + ceil32(return_data.size) + 200] = arg1
                    mem[_23739 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23739 + ceil32(return_data.size) + 164] = 68
                    mem[_23739 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23739 + ceil32(return_data.size) + 264] = 32
                    mem[_23739 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23739 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23739 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23739 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23739 + ceil32(return_data.size) + 360] == bool(mem[_23739 + ceil32(return_data.size) + 360])
                            if not mem[_23739 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23739 + 164] = return_data.size
        mem[_23739 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23739 + 196] == bool(mem[_23739 + 196])
            if not mem[_23739 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _23086 < _23086 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
             gas gas_remaining wei
            args 24, _23086 - (_23086 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23739 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.0x93f1a40b with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23739 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _23086 - (_23086 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23086) - (1000000000000000000 * 10^18 * _23086 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _23086) - (1000000000000000000 * 10^18 * _23086 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_11169, _23086 - (_23086 * sub_b1a41085 / 10000), _23086 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23739 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23739 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23739 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23739 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23739 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23739 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23739 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23739 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23739 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23739 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23739 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23739 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    mem[ceil32(return_data.size) + 96] = 2
    mem[ceil32(return_data.size) + 128] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    mem[ceil32(return_data.size) + 160] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    mem[ceil32(return_data.size) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 228] = 0
    mem[ceil32(return_data.size) + 260] = 160
    mem[ceil32(return_data.size) + 356] = 2
    idx = 0
    s = ceil32(return_data.size) + 128
    t = ceil32(return_data.size) + 388
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[ceil32(return_data.size) + 292] = this.address
    mem[ceil32(return_data.size) + 324] = block.timestamp
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _5296 = mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28]
    require mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 223 < ceil32(return_data.size) + return_data.size + 192
    _5300 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
    mem[(2 * ceil32(return_data.size)) + 192] = _5300
    require _5296 + (32 * _5300) + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 224 len ceil32(32 * _5300)] = mem[ceil32(return_data.size) + _5296 + 224 len ceil32(32 * _5300)]
    if 1 >= _5300:
        revert with 0, 50
    mem[mem[64] + 4] = this.address
    if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11165 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11170 = mem[_11165]
        _11182 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11182]:
            revert with 0, 50
        mem[_11182 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11182]:
            revert with 0, 50
        mem[_11182 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11182 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11182 + 100] = _11170
        mem[_11182 + 132] = 64
        mem[_11182 + 164] = mem[_11182]
        idx = 0
        s = _11182 + 32
        t = _11182 + 196
        while idx < mem[_11182]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11182 + (32 * mem[_11182]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16992 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16996 = mem[_16992]
        require mem[_16992] <= test266151307()
        require _16992 + mem[_16992] + 31 < _16992 + return_data.size
        _17048 = mem[_16992 + mem[_16992]]
        if mem[_16992 + mem[_16992]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16992 + mem[_16992]]) + 1 < 0 or _16992 + ceil32(return_data.size) + ceil32(32 * mem[_16992 + mem[_16992]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16992 + ceil32(return_data.size) + ceil32(32 * mem[_16992 + mem[_16992]]) + 1
        mem[_16992 + ceil32(return_data.size)] = _17048
        require _16996 + (32 * _17048) + 32 <= return_data.size
        mem[_16992 + ceil32(return_data.size) + 32 len ceil32(32 * _17048)] = mem[_16992 + _16996 + 32 len ceil32(32 * _17048)]
        if 1 >= _17048:
            revert with 0, 50
        if mem[_16992 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23888 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _24021 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23888 + 100] = 32
                    mem[_23888 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _24065 = mem[_24021]
                    mem[_23888 + 164 len ceil32(mem[_24021])] = mem[_24021 + 32 len ceil32(mem[_24021])]
                    if ceil32(_24065) > _24065:
                        mem[_24065 + _23888 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23888 + 168 len _24065 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23888 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23888 + 196] == bool(mem[_23888 + 196])
                            if not mem[_23888 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
             gas gas_remaining wei
            args _11170
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22891 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23087 = mem[_22891]
        if mem[_22891] and sub_b1a41085 > -1 / mem[_22891]:
            revert with 0, 17
        _23740 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _23087 * sub_b1a41085 / 10000
        _23812 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23740 + 100] = 32
        mem[_23740 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _24042 = mem[_23812]
        mem[_23740 + 164 len ceil32(mem[_23812])] = mem[_23812 + 32 len ceil32(mem[_23812])]
        if ceil32(_24042) > _24042:
            mem[_24042 + _23740 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23740 + 168 len _24042 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _23087 < _23087 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                 gas gas_remaining wei
                args 24, _23087 - (_23087 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23740 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.0x93f1a40b with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23740 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _23087 - (_23087 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23087) - (1000000000000000000 * 10^18 * _23087 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _23087) - (1000000000000000000 * 10^18 * _23087 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_11170, _23087 - (_23087 * sub_b1a41085 / 10000), _23087 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23740 + ceil32(return_data.size) + 200] = arg1
                    mem[_23740 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23740 + ceil32(return_data.size) + 164] = 68
                    mem[_23740 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23740 + ceil32(return_data.size) + 264] = 32
                    mem[_23740 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23740 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23740 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23740 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23740 + ceil32(return_data.size) + 360] == bool(mem[_23740 + ceil32(return_data.size) + 360])
                            if not mem[_23740 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23740 + 164] = return_data.size
        mem[_23740 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23740 + 196] == bool(mem[_23740 + 196])
            if not mem[_23740 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _23087 < _23087 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
             gas gas_remaining wei
            args 24, _23087 - (_23087 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23740 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.0x93f1a40b with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23740 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _23087 - (_23087 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23087) - (1000000000000000000 * 10^18 * _23087 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _23087) - (1000000000000000000 * 10^18 * _23087 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_11170, _23087 - (_23087 * sub_b1a41085 / 10000), _23087 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23740 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23740 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23740 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23740 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23740 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23740 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23740 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23740 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23740 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23740 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23740 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23740 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    require ext_code.size(token0Address)
    staticcall token0Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _11166 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _11171 = mem[_11166]
    if mem[_11166] <= 10^15:
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11195 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11202 = mem[_11195]
        _11220 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11220]:
            revert with 0, 50
        mem[_11220 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11220]:
            revert with 0, 50
        mem[_11220 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11220 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11220 + 100] = _11202
        mem[_11220 + 132] = 64
        mem[_11220 + 164] = mem[_11220]
        idx = 0
        s = _11220 + 32
        t = _11220 + 196
        while idx < mem[_11220]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11220 + (32 * mem[_11220]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16993 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16997 = mem[_16993]
        require mem[_16993] <= test266151307()
        require _16993 + mem[_16993] + 31 < _16993 + return_data.size
        _17049 = mem[_16993 + mem[_16993]]
        if mem[_16993 + mem[_16993]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16993 + mem[_16993]]) + 1 < 0 or _16993 + ceil32(return_data.size) + ceil32(32 * mem[_16993 + mem[_16993]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16993 + ceil32(return_data.size) + ceil32(32 * mem[_16993 + mem[_16993]]) + 1
        mem[_16993 + ceil32(return_data.size)] = _17049
        require _16997 + (32 * _17049) + 32 <= return_data.size
        mem[_16993 + ceil32(return_data.size) + 32 len ceil32(32 * _17049)] = mem[_16993 + _16997 + 32 len ceil32(32 * _17049)]
        if 1 >= _17049:
            revert with 0, 50
        if mem[_16993 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23889 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _24024 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23889 + 100] = 32
                    mem[_23889 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _24067 = mem[_24024]
                    mem[_23889 + 164 len ceil32(mem[_24024])] = mem[_24024 + 32 len ceil32(mem[_24024])]
                    if ceil32(_24067) > _24067:
                        mem[_24067 + _23889 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23889 + 168 len _24067 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23889 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23889 + 196] == bool(mem[_23889 + 196])
                            if not mem[_23889 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
             gas gas_remaining wei
            args _11202
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22892 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23088 = mem[_22892]
        if mem[_22892] and sub_b1a41085 > -1 / mem[_22892]:
            revert with 0, 17
        _23741 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _23088 * sub_b1a41085 / 10000
        _23816 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23741 + 100] = 32
        mem[_23741 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _24044 = mem[_23816]
        mem[_23741 + 164 len ceil32(mem[_23816])] = mem[_23816 + 32 len ceil32(mem[_23816])]
        if ceil32(_24044) > _24044:
            mem[_24044 + _23741 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23741 + 168 len _24044 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _23088 < _23088 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
                 gas gas_remaining wei
                args 24, _23088 - (_23088 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23741 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.0x93f1a40b with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23741 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _23088 - (_23088 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23088) - (1000000000000000000 * 10^18 * _23088 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _23088) - (1000000000000000000 * 10^18 * _23088 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_11202, _23088 - (_23088 * sub_b1a41085 / 10000), _23088 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23741 + ceil32(return_data.size) + 200] = arg1
                    mem[_23741 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23741 + ceil32(return_data.size) + 164] = 68
                    mem[_23741 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23741 + ceil32(return_data.size) + 264] = 32
                    mem[_23741 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23741 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23741 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23741 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23741 + ceil32(return_data.size) + 360] == bool(mem[_23741 + ceil32(return_data.size) + 360])
                            if not mem[_23741 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23741 + 164] = return_data.size
        mem[_23741 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23741 + 196] == bool(mem[_23741 + 196])
            if not mem[_23741 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _23088 < _23088 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
             gas gas_remaining wei
            args 24, _23088 - (_23088 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23741 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.0x93f1a40b with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23741 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _23088 - (_23088 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _23088) - (1000000000000000000 * 10^18 * _23088 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _23088) - (1000000000000000000 * 10^18 * _23088 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_11202, _23088 - (_23088 * sub_b1a41085 / 10000), _23088 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23741 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23741 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23741 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23741 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23741 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23741 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23741 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23741 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23741 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23741 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23741 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23741 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    _11188 = mem[64]
    mem[mem[64]] = 3
    mem[64] = mem[64] + 128
    if 0 >= mem[_11188]:
        revert with 0, 50
    mem[_11188 + 32] = token0Address
    if 1 >= mem[_11188]:
        revert with 0, 50
    mem[_11188 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    if 2 >= mem[_11188]:
        revert with 0, 50
    mem[_11188 + 96] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    mem[_11188 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[_11188 + 132] = _11171
    mem[_11188 + 164] = 0
    mem[_11188 + 196] = 160
    mem[_11188 + 292] = mem[_11188]
    idx = 0
    s = _11188 + 32
    t = _11188 + 324
    while idx < mem[_11188]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_11188 + 228] = this.address
    mem[_11188 + 260] = block.timestamp
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    call ????????????????????????????????????????.mem[mem[64] len 4] with:
         gas gas_remaining wei
        args mem[mem[64] + 4 len _11188 + (32 * mem[_11188]) + -mem[64] + 320]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _16994 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _16998 = mem[_16994]
    require mem[_16994] <= test266151307()
    require _16994 + mem[_16994] + 31 < _16994 + return_data.size
    _17050 = mem[_16994 + mem[_16994]]
    if mem[_16994 + mem[_16994]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_16994 + mem[_16994]]) + 1 < 0 or _16994 + ceil32(return_data.size) + ceil32(32 * mem[_16994 + mem[_16994]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _16994 + ceil32(return_data.size) + ceil32(32 * mem[_16994 + mem[_16994]]) + 1
    mem[_16994 + ceil32(return_data.size)] = _17050
    require _16998 + (32 * _17050) + 32 <= return_data.size
    mem[_16994 + ceil32(return_data.size) + 32 len ceil32(32 * _17050)] = mem[_16994 + _16998 + 32 len ceil32(32 * _17050)]
    if 2 >= _17050:
        revert with 0, 50
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
    staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _22893 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _23089 = mem[_22893]
    _23158 = mem[64]
    mem[mem[64]] = 2
    mem[64] = mem[64] + 96
    if 0 >= mem[_23158]:
        revert with 0, 50
    mem[_23158 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    if 1 >= mem[_23158]:
        revert with 0, 50
    mem[_23158 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    mem[_23158 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[_23158 + 100] = _23089
    mem[_23158 + 132] = 64
    mem[_23158 + 164] = mem[_23158]
    idx = 0
    s = _23158 + 32
    t = _23158 + 196
    while idx < mem[_23158]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len _23158 + (32 * mem[_23158]) + -mem[64] + 192]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _28011 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _28012 = mem[_28011]
    require mem[_28011] <= test266151307()
    require _28011 + mem[_28011] + 31 < _28011 + return_data.size
    _28085 = mem[_28011 + mem[_28011]]
    if mem[_28011 + mem[_28011]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_28011 + mem[_28011]]) + 1 < 0 or _28011 + ceil32(return_data.size) + ceil32(32 * mem[_28011 + mem[_28011]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _28011 + ceil32(return_data.size) + ceil32(32 * mem[_28011 + mem[_28011]]) + 1
    mem[_28011 + ceil32(return_data.size)] = _28085
    require _28012 + (32 * _28085) + 32 <= return_data.size
    mem[_28011 + ceil32(return_data.size) + 32 len ceil32(32 * _28085)] = mem[_28011 + _28012 + 32 len ceil32(32 * _28085)]
    if 1 >= _28085:
        revert with 0, 50
    if mem[_28011 + ceil32(return_data.size) + 64] <= 25 * 10^16:
        mem[0] = arg1
        mem[32] = 214
        if userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                     gas gas_remaining wei
                    args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _33449 = mem[64]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                _33642 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_33449 + 100] = 32
                mem[_33449 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _33656 = mem[_33642]
                mem[_33449 + 164 len ceil32(mem[_33642])] = mem[_33642 + 32 len ceil32(mem[_33642])]
                if ceil32(_33656) > _33656:
                    mem[_33656 + _33449 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_33449 + 168 len _33656 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_33449 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_33449 + 196] == bool(mem[_33449 + 196])
                        if not mem[_33449 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0xa59f3e0c with:
         gas gas_remaining wei
        args _23089
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _32001 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _32290 = mem[_32001]
    if mem[_32001] and sub_b1a41085 > -1 / mem[_32001]:
        revert with 0, 17
    _33251 = mem[64]
    mem[mem[64] + 36] = treasuryAddress
    mem[mem[64] + 68] = _32290 * sub_b1a41085 / 10000
    _33350 = mem[64]
    mem[mem[64]] = 68
    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
    mem[64] = mem[64] + 164
    mem[_33251 + 100] = 32
    mem[_33251 + 132] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
        revert with 0, 'Address: call to non-contract'
    _33649 = mem[_33350]
    mem[_33251 + 164 len ceil32(mem[_33350])] = mem[_33350 + 32 len ceil32(mem[_33350])]
    if ceil32(_33649) > _33649:
        mem[_33649 + _33251 + 164] = 0
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
         gas gas_remaining wei
        args mem[_33251 + 168 len _33649 - 4]
    if not return_data.size:
        if not ext_call.success:
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            revert with 0, 'SafeERC20: low-level call failed'
        if mem[96]:
            require mem[96] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _32290 < _32290 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
             gas gas_remaining wei
            args 24, _32290 - (_32290 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_33251 + 200] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.0x93f1a40b with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_33251 + 164 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _32290 - (_32290 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _32290) - (1000000000000000000 * 10^18 * _32290 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _32290) - (1000000000000000000 * 10^18 * _32290 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_23089, _32290 - (_32290 * sub_b1a41085 / 10000), _32290 * sub_b1a41085 / 10000);
        if userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
                     gas gas_remaining wei
                    args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_33251 + ceil32(return_data.size) + 200] = arg1
                mem[_33251 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                mem[_33251 + ceil32(return_data.size) + 164] = 68
                mem[_33251 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                mem[_33251 + ceil32(return_data.size) + 264] = 32
                mem[_33251 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                mem[_33251 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                mem[_33251 + ceil32(return_data.size) + 396] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                   funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_33251 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_33251 + ceil32(return_data.size) + 360] == bool(mem[_33251 + ceil32(return_data.size) + 360])
                        if not mem[_33251 + ceil32(return_data.size) + 360]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_33251 + 164] = return_data.size
    mem[_33251 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        revert with 0, 'SafeERC20: low-level call failed'
    if return_data.size:
        require return_data.size >= 32
        require mem[_33251 + 196] == bool(mem[_33251 + 196])
        if not mem[_33251 + 196]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    if _32290 < _32290 * sub_b1a41085 / 10000:
        revert with 0, 17
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0xe2bbb158 with:
         gas gas_remaining wei
        args 24, _32290 - (_32290 * sub_b1a41085 / 10000)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[_33251 + ceil32(return_data.size) + 201] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.0x93f1a40b with:
            gas gas_remaining wei
           args poolId, this.address
    mem[_33251 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if _32290 - (_32290 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _32290) - (1000000000000000000 * 10^18 * _32290 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
        revert with 0, 17
    sub_c8af9d6a += (1000000000000000000 * 10^18 * _32290) - (1000000000000000000 * 10^18 * _32290 * sub_b1a41085 / 10000) / ext_call.return_data[0]
    emit Harvest(_23089, _32290 - (_32290 * sub_b1a41085 / 10000), _32290 * sub_b1a41085 / 10000);
    if not userInfo[address(arg1)].field_0:
    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
        revert with 0, 17
    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
        revert with 0, 17
    if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
        revert with 0, 17
    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.0x441a3e70 with:
         gas gas_remaining wei
        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
        revert with 0, 'Address: call to non-contract'
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            revert with 0, 'SafeERC20: low-level call failed'
        if mem[96]:
            require mem[96] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
    mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_33251 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_33251 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_33251 + (4 * ceil32(return_data.size)) + 366] = 32
        mem[_33251 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
        revert with memory
          from _33251 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
    if not return_data.size:
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    require return_data.size >= 32
    require mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
    if mem[_33251 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_33251 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[_33251 + (4 * ceil32(return_data.size)) + 334] = 32
    mem[_33251 + (4 * ceil32(return_data.size)) + 366] = 42
    mem[_33251 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
    mem[_33251 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
    revert with memory
      from _33251 + (4 * ceil32(return_data.size)) + 330
       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
}

function sub_f2905826(?) {
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestRoundData() with:
            gas gas_remaining wei
    mem[96 len 160] = ext_call.return_data[0 len 160]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 160
    require ext_call.return_data[0] == ext_call.return_data[22 len 10]
    require ext_call.return_data[128] == ext_call.return_data[150 len 10]
    if ext_call.return_data[32] <= 0:
        revert with 0, 'Chainlink price <= 0'
    if not ext_call.return_data[96]:
        revert with 0, 'Incomplete round'
    if ext_call.return_data[150 len 10] < ext_call.return_data[22 len 10]:
        revert with 0, 'Stale price'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = token1Address
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = 1
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1257 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _1266 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _1266
            require _1257 + (32 * _1266) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1266)] = mem[(2 * ceil32(return_data.size)) + _1257 + 224 len ceil32(32 * _1266)]
            if 1 >= _1266:
                revert with 0, 50
            _2388 = mem[(4 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2433 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2388) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2433]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388) / mem[_2433] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388) / mem[_2433]:
                    revert with 0, 17
                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388) / mem[_2433] * ext_call.return_data[32] / 100 * 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2469 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2388 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2469]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / 10^sub_3266f45c) / mem[_2469] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / 10^sub_3266f45c) / mem[_2469]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / 10^sub_3266f45c) / mem[_2469] * ext_call.return_data[32] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3588 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2388 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3588]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / s * t) / mem[_3588] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / s * t) / mem[_3588]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2388 / s * t) / mem[_3588] * ext_call.return_data[32] / 100 * 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1256 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1265 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1265
                require _1256 + (32 * _1265) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1265)] = mem[(2 * ceil32(return_data.size)) + _1256 + 224 len ceil32(32 * _1265)]
                if 1 >= _1265:
                    revert with 0, 50
                _2387 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2432 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2432]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432] * ext_call.return_data[32] / 100 * 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2468 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2468]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3587 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3587]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587] * ext_call.return_data[32] / 100 * 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = s * t
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (2 * ceil32(return_data.size)) + 128
                v = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2394 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _2397 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _2397
                require _2394 + (32 * _2397) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2397)] = mem[(2 * ceil32(return_data.size)) + _2394 + 224 len ceil32(32 * _2397)]
                if 1 >= _2397:
                    revert with 0, 50
                _3478 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3626 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3478) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3626]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478) / mem[_3626] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478) / mem[_3626]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478) / mem[_3626] * ext_call.return_data[32] / 100 * 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3668 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3478 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3668]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / 10^sub_3266f45c) / mem[_3668] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / 10^sub_3266f45c) / mem[_3668]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / 10^sub_3266f45c) / mem[_3668] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4564 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3478 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4564]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / s * t) / mem[_4564] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / s * t) / mem[_4564]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3478 / s * t) / mem[_4564] * ext_call.return_data[32] / 100 * 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1254 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1263 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1263
                require _1254 + (32 * _1263) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1263)] = mem[(2 * ceil32(return_data.size)) + _1254 + 224 len ceil32(32 * _1263)]
                if 1 >= _1263:
                    revert with 0, 50
                _2385 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2431 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2385) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2431]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385) / mem[_2431] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385) / mem[_2431]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385) / mem[_2431] * ext_call.return_data[32] / 100 * 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2467 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2385 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2467]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / 10^sub_9ddc230a) / mem[_2467] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / 10^sub_9ddc230a) / mem[_2467]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / 10^sub_9ddc230a) / mem[_2467] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3586 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2385 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3586]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / s * t) / mem[_3586] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / s * t) / mem[_3586]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2385 / s * t) / mem[_3586] * ext_call.return_data[32] / 100 * 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1253 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1262 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1262
                    require _1253 + (32 * _1262) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1262)] = mem[(2 * ceil32(return_data.size)) + _1253 + 224 len ceil32(32 * _1262)]
                    if 1 >= _1262:
                        revert with 0, 50
                    _2384 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2430 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2430]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2466 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2466]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3585 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3585]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585] * ext_call.return_data[32] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2393 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2396 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2396
                    require _2393 + (32 * _2396) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2396)] = mem[(2 * ceil32(return_data.size)) + _2393 + 224 len ceil32(32 * _2396)]
                    if 1 >= _2396:
                        revert with 0, 50
                    _3477 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3625 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3477) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3625]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477) / mem[_3625] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477) / mem[_3625]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477) / mem[_3625] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3667 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3477 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3667]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / 10^sub_9ddc230a) / mem[_3667] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / 10^sub_9ddc230a) / mem[_3667]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / 10^sub_9ddc230a) / mem[_3667] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4563 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3477 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4563]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / s * t) / mem[_4563] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / s * t) / mem[_4563]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3477 / s * t) / mem[_4563] * ext_call.return_data[32] / 100 * 10^18
        else:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1251 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1260 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1260
                require _1251 + (32 * _1260) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1260)] = mem[(2 * ceil32(return_data.size)) + _1251 + 224 len ceil32(32 * _1260)]
                if 1 >= _1260:
                    revert with 0, 50
                _2382 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2436 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2436]:
                            revert with 0, 50
                        mem[_2436 + 32] = token1Address
                        if 1 >= mem[_2436]:
                            revert with 0, 50
                        mem[_2436 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2436 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2436 + 100] = 1
                        mem[_2436 + 132] = 64
                        mem[_2436 + 164] = mem[_2436]
                        idx = 0
                        s = _2436 + 32
                        t = _2436 + 196
                        while idx < mem[_2436]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2436 + (32 * mem[_2436]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3494 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3514 = mem[_3494]
                        require mem[_3494] <= test266151307()
                        require _3494 + mem[_3494] + 31 < _3494 + return_data.size
                        _3526 = mem[_3494 + mem[_3494]]
                        if mem[_3494 + mem[_3494]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3494 + mem[_3494]]) + 1 < 0 or _3494 + ceil32(return_data.size) + ceil32(32 * mem[_3494 + mem[_3494]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3494 + ceil32(return_data.size) + ceil32(32 * mem[_3494 + mem[_3494]]) + 1
                        mem[_3494 + ceil32(return_data.size)] = _3526
                        require _3514 + (32 * _3526) + 32 <= return_data.size
                        mem[_3494 + ceil32(return_data.size) + 32 len ceil32(32 * _3526)] = mem[_3494 + _3514 + 32 len ceil32(32 * _3526)]
                        if 1 >= _3526:
                            revert with 0, 50
                        _4442 = mem[_3494 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3494 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3494 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4614 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4442) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4614]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442) / mem[_4614] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442) / mem[_4614]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442) / mem[_4614] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3494 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3494 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4660 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4442 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4660]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / 10^sub_3266f45c) / mem[_4660] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / 10^sub_3266f45c) / mem[_4660]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / 10^sub_3266f45c) / mem[_4660] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3494 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3494 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5256 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4442 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5256]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / s * t) / mem[_5256] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / s * t) / mem[_5256]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4442 / s * t) / mem[_5256] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2477 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2477]:
                                revert with 0, 50
                            mem[_2477 + 32] = token1Address
                            if 1 >= mem[_2477]:
                                revert with 0, 50
                            mem[_2477 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2477 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2477 + 100] = 10^sub_3266f45c
                            mem[_2477 + 132] = 64
                            mem[_2477 + 164] = mem[_2477]
                            idx = 0
                            s = _2477 + 32
                            t = _2477 + 196
                            while idx < mem[_2477]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2477 + (32 * mem[_2477]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3493 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3513 = mem[_3493]
                            require mem[_3493] <= test266151307()
                            require _3493 + mem[_3493] + 31 < _3493 + return_data.size
                            _3525 = mem[_3493 + mem[_3493]]
                            if mem[_3493 + mem[_3493]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3493 + mem[_3493]]) + 1 < 0 or _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1
                            mem[_3493 + ceil32(return_data.size)] = _3525
                            require _3513 + (32 * _3525) + 32 <= return_data.size
                            mem[_3493 + ceil32(return_data.size) + 32 len ceil32(32 * _3525)] = mem[_3493 + _3513 + 32 len ceil32(32 * _3525)]
                            if 1 >= _3525:
                                revert with 0, 50
                            _4441 = mem[_3493 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4613 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4441) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4613]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4659 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4659]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5255 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5255]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3501 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3501]:
                                revert with 0, 50
                            mem[_3501 + 32] = token1Address
                            if 1 >= mem[_3501]:
                                revert with 0, 50
                            mem[_3501 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3501 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3501 + 100] = s * t
                            mem[_3501 + 132] = 64
                            mem[_3501 + 164] = mem[_3501]
                            idx = 0
                            s = _3501 + 32
                            t = _3501 + 196
                            while idx < mem[_3501]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3501 + (32 * mem[_3501]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4462 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4486 = mem[_4462]
                            require mem[_4462] <= test266151307()
                            require _4462 + mem[_4462] + 31 < _4462 + return_data.size
                            _4502 = mem[_4462 + mem[_4462]]
                            if mem[_4462 + mem[_4462]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4462 + mem[_4462]]) + 1 < 0 or _4462 + ceil32(return_data.size) + ceil32(32 * mem[_4462 + mem[_4462]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4462 + ceil32(return_data.size) + ceil32(32 * mem[_4462 + mem[_4462]]) + 1
                            mem[_4462 + ceil32(return_data.size)] = _4502
                            require _4486 + (32 * _4502) + 32 <= return_data.size
                            mem[_4462 + ceil32(return_data.size) + 32 len ceil32(32 * _4502)] = mem[_4462 + _4486 + 32 len ceil32(32 * _4502)]
                            if 1 >= _4502:
                                revert with 0, 50
                            _5186 = mem[_4462 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5308 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _5186) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5308]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5308] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5308]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5308] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5357 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5357]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5357] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5357]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5357] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5696 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382) + (Mask(112, 0, ext_call.return_data[32]) * _5186 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5696]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / s * t) / mem[_5696] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / s * t) / mem[_5696]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / s * t) / mem[_5696] * ext_call.return_data[32] / 100 * 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2475 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2475]:
                                revert with 0, 50
                            mem[_2475 + 32] = token1Address
                            if 1 >= mem[_2475]:
                                revert with 0, 50
                            mem[_2475 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2475 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2475 + 100] = 1
                            mem[_2475 + 132] = 64
                            mem[_2475 + 164] = mem[_2475]
                            idx = 0
                            s = _2475 + 32
                            t = _2475 + 196
                            while idx < mem[_2475]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2475 + (32 * mem[_2475]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3490 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3511 = mem[_3490]
                            require mem[_3490] <= test266151307()
                            require _3490 + mem[_3490] + 31 < _3490 + return_data.size
                            _3523 = mem[_3490 + mem[_3490]]
                            if mem[_3490 + mem[_3490]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3490 + mem[_3490]]) + 1 < 0 or _3490 + ceil32(return_data.size) + ceil32(32 * mem[_3490 + mem[_3490]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3490 + ceil32(return_data.size) + ceil32(32 * mem[_3490 + mem[_3490]]) + 1
                            mem[_3490 + ceil32(return_data.size)] = _3523
                            require _3511 + (32 * _3523) + 32 <= return_data.size
                            mem[_3490 + ceil32(return_data.size) + 32 len ceil32(32 * _3523)] = mem[_3490 + _3511 + 32 len ceil32(32 * _3523)]
                            if 1 >= _3523:
                                revert with 0, 50
                            _4439 = mem[_3490 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3490 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3490 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4612 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4439) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4612]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439) / mem[_4612] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439) / mem[_4612]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439) / mem[_4612] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3490 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3490 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4658 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4439 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4658]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / 10^sub_3266f45c) / mem[_4658] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / 10^sub_3266f45c) / mem[_4658]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / 10^sub_3266f45c) / mem[_4658] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3490 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3490 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5254 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4439 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5254]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / s * t) / mem[_5254] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / s * t) / mem[_5254]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4439 / s * t) / mem[_5254] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2537 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2537]:
                                    revert with 0, 50
                                mem[_2537 + 32] = token1Address
                                if 1 >= mem[_2537]:
                                    revert with 0, 50
                                mem[_2537 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2537 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2537 + 100] = 10^sub_3266f45c
                                mem[_2537 + 132] = 64
                                mem[_2537 + 164] = mem[_2537]
                                idx = 0
                                s = _2537 + 32
                                t = _2537 + 196
                                while idx < mem[_2537]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2537 + (32 * mem[_2537]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3489 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3510 = mem[_3489]
                                require mem[_3489] <= test266151307()
                                require _3489 + mem[_3489] + 31 < _3489 + return_data.size
                                _3522 = mem[_3489 + mem[_3489]]
                                if mem[_3489 + mem[_3489]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3489 + mem[_3489]]) + 1 < 0 or _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1
                                mem[_3489 + ceil32(return_data.size)] = _3522
                                require _3510 + (32 * _3522) + 32 <= return_data.size
                                mem[_3489 + ceil32(return_data.size) + 32 len ceil32(32 * _3522)] = mem[_3489 + _3510 + 32 len ceil32(32 * _3522)]
                                if 1 >= _3522:
                                    revert with 0, 50
                                _4438 = mem[_3489 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4611 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4611]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4657 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4657]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5253 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5253]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3499 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3499]:
                                    revert with 0, 50
                                mem[_3499 + 32] = token1Address
                                if 1 >= mem[_3499]:
                                    revert with 0, 50
                                mem[_3499 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3499 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3499 + 100] = s * t
                                mem[_3499 + 132] = 64
                                mem[_3499 + 164] = mem[_3499]
                                idx = 0
                                s = _3499 + 32
                                t = _3499 + 196
                                while idx < mem[_3499]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3499 + (32 * mem[_3499]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4461 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4485 = mem[_4461]
                                require mem[_4461] <= test266151307()
                                require _4461 + mem[_4461] + 31 < _4461 + return_data.size
                                _4501 = mem[_4461 + mem[_4461]]
                                if mem[_4461 + mem[_4461]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4461 + mem[_4461]]) + 1 < 0 or _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1
                                mem[_4461 + ceil32(return_data.size)] = _4501
                                require _4485 + (32 * _4501) + 32 <= return_data.size
                                mem[_4461 + ceil32(return_data.size) + 32 len ceil32(32 * _4501)] = mem[_4461 + _4485 + 32 len ceil32(32 * _4501)]
                                if 1 >= _4501:
                                    revert with 0, 50
                                _5185 = mem[_4461 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5307 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5185) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5307]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5356 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5356]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5695 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5695]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3595 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3595]:
                                revert with 0, 50
                            mem[_3595 + 32] = token1Address
                            if 1 >= mem[_3595]:
                                revert with 0, 50
                            mem[_3595 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3595 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3595 + 100] = 1
                            mem[_3595 + 132] = 64
                            mem[_3595 + 164] = mem[_3595]
                            idx = 0
                            u = _3595 + 32
                            v = _3595 + 196
                            while idx < mem[_3595]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3595 + (32 * mem[_3595]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4460 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4484 = mem[_4460]
                            require mem[_4460] <= test266151307()
                            require _4460 + mem[_4460] + 31 < _4460 + return_data.size
                            _4500 = mem[_4460 + mem[_4460]]
                            if mem[_4460 + mem[_4460]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4460 + mem[_4460]]) + 1 < 0 or _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1
                            mem[_4460 + ceil32(return_data.size)] = _4500
                            require _4484 + (32 * _4500) + 32 <= return_data.size
                            mem[_4460 + ceil32(return_data.size) + 32 len ceil32(32 * _4500)] = mem[_4460 + _4484 + 32 len ceil32(32 * _4500)]
                            if 1 >= _4500:
                                revert with 0, 50
                            _5184 = mem[_4460 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5306 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5184) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5306]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5355 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5355]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5694 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5184 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5694]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / u * v) / mem[_5694] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / u * v) / mem[_5694]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / u * v) / mem[_5694] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3639 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3639]:
                                    revert with 0, 50
                                mem[_3639 + 32] = token1Address
                                if 1 >= mem[_3639]:
                                    revert with 0, 50
                                mem[_3639 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3639 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3639 + 100] = 10^sub_3266f45c
                                mem[_3639 + 132] = 64
                                mem[_3639 + 164] = mem[_3639]
                                idx = 0
                                u = _3639 + 32
                                v = _3639 + 196
                                while idx < mem[_3639]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3639 + (32 * mem[_3639]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4459 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4483 = mem[_4459]
                                require mem[_4459] <= test266151307()
                                require _4459 + mem[_4459] + 31 < _4459 + return_data.size
                                _4499 = mem[_4459 + mem[_4459]]
                                if mem[_4459 + mem[_4459]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4459 + mem[_4459]]) + 1 < 0 or _4459 + ceil32(return_data.size) + ceil32(32 * mem[_4459 + mem[_4459]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4459 + ceil32(return_data.size) + ceil32(32 * mem[_4459 + mem[_4459]]) + 1
                                mem[_4459 + ceil32(return_data.size)] = _4499
                                require _4483 + (32 * _4499) + 32 <= return_data.size
                                mem[_4459 + ceil32(return_data.size) + 32 len ceil32(32 * _4499)] = mem[_4459 + _4483 + 32 len ceil32(32 * _4499)]
                                if 1 >= _4499:
                                    revert with 0, 50
                                _5183 = mem[_4459 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5305 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5305]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5354 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5354]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5693 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5693]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4469 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4469]:
                                    revert with 0, 50
                                mem[_4469 + 32] = token1Address
                                if 1 >= mem[_4469]:
                                    revert with 0, 50
                                mem[_4469 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4469 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4469 + 100] = u * v
                                mem[_4469 + 132] = 64
                                mem[_4469 + 164] = mem[_4469]
                                idx = 0
                                u = _4469 + 32
                                v = _4469 + 196
                                while idx < mem[_4469]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4469 + (32 * mem[_4469]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5194 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5203 = mem[_5194]
                                require mem[_5194] <= test266151307()
                                require _5194 + mem[_5194] + 31 < _5194 + return_data.size
                                _5210 = mem[_5194 + mem[_5194]]
                                if mem[_5194 + mem[_5194]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5194 + mem[_5194]]) + 1 < 0 or _5194 + ceil32(return_data.size) + ceil32(32 * mem[_5194 + mem[_5194]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5194 + ceil32(return_data.size) + ceil32(32 * mem[_5194 + mem[_5194]]) + 1
                                mem[_5194 + ceil32(return_data.size)] = _5210
                                require _5203 + (32 * _5210) + 32 <= return_data.size
                                mem[_5194 + ceil32(return_data.size) + 32 len ceil32(32 * _5210)] = mem[_5194 + _5203 + 32 len ceil32(32 * _5210)]
                                if 1 >= _5210:
                                    revert with 0, 50
                                _5654 = mem[_5194 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5194 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5194 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5727 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5727]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5727] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5727]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5727] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5194 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5194 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5751 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5751]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5751] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5751]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5751] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5194 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5194 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5880 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5880]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_5880] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_5880]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2382 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_5880] * ext_call.return_data[32] / 100 * 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1250 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1259 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1259
                    require _1250 + (32 * _1259) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1259)] = mem[(2 * ceil32(return_data.size)) + _1250 + 224 len ceil32(32 * _1259)]
                    if 1 >= _1259:
                        revert with 0, 50
                    _2381 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2434 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2434]:
                                revert with 0, 50
                            mem[_2434 + 32] = token1Address
                            if 1 >= mem[_2434]:
                                revert with 0, 50
                            mem[_2434 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2434 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2434 + 100] = 1
                            mem[_2434 + 132] = 64
                            mem[_2434 + 164] = mem[_2434]
                            idx = 0
                            s = _2434 + 32
                            t = _2434 + 196
                            while idx < mem[_2434]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2434 + (32 * mem[_2434]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3486 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3508 = mem[_3486]
                            require mem[_3486] <= test266151307()
                            require _3486 + mem[_3486] + 31 < _3486 + return_data.size
                            _3520 = mem[_3486 + mem[_3486]]
                            if mem[_3486 + mem[_3486]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3486 + mem[_3486]]) + 1 < 0 or _3486 + ceil32(return_data.size) + ceil32(32 * mem[_3486 + mem[_3486]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3486 + ceil32(return_data.size) + ceil32(32 * mem[_3486 + mem[_3486]]) + 1
                            mem[_3486 + ceil32(return_data.size)] = _3520
                            require _3508 + (32 * _3520) + 32 <= return_data.size
                            mem[_3486 + ceil32(return_data.size) + 32 len ceil32(32 * _3520)] = mem[_3486 + _3508 + 32 len ceil32(32 * _3520)]
                            if 1 >= _3520:
                                revert with 0, 50
                            _4434 = mem[_3486 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4609 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4434) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4609]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4609] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4609]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4609] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4656 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4656]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4656] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4656]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4656] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5251 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5251]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5251] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5251]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5251] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2472 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2472]:
                                    revert with 0, 50
                                mem[_2472 + 32] = token1Address
                                if 1 >= mem[_2472]:
                                    revert with 0, 50
                                mem[_2472 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2472 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2472 + 100] = 10^sub_3266f45c
                                mem[_2472 + 132] = 64
                                mem[_2472 + 164] = mem[_2472]
                                idx = 0
                                s = _2472 + 32
                                t = _2472 + 196
                                while idx < mem[_2472]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2472 + (32 * mem[_2472]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3485 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3507 = mem[_3485]
                                require mem[_3485] <= test266151307()
                                require _3485 + mem[_3485] + 31 < _3485 + return_data.size
                                _3519 = mem[_3485 + mem[_3485]]
                                if mem[_3485 + mem[_3485]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3485 + mem[_3485]]) + 1 < 0 or _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1
                                mem[_3485 + ceil32(return_data.size)] = _3519
                                require _3507 + (32 * _3519) + 32 <= return_data.size
                                mem[_3485 + ceil32(return_data.size) + 32 len ceil32(32 * _3519)] = mem[_3485 + _3507 + 32 len ceil32(32 * _3519)]
                                if 1 >= _3519:
                                    revert with 0, 50
                                _4433 = mem[_3485 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4608 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4433) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4608]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4655 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4655]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5250 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5250]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3497 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3497]:
                                    revert with 0, 50
                                mem[_3497 + 32] = token1Address
                                if 1 >= mem[_3497]:
                                    revert with 0, 50
                                mem[_3497 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3497 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3497 + 100] = s * t
                                mem[_3497 + 132] = 64
                                mem[_3497 + 164] = mem[_3497]
                                idx = 0
                                s = _3497 + 32
                                t = _3497 + 196
                                while idx < mem[_3497]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3497 + (32 * mem[_3497]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4456 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4481 = mem[_4456]
                                require mem[_4456] <= test266151307()
                                require _4456 + mem[_4456] + 31 < _4456 + return_data.size
                                _4497 = mem[_4456 + mem[_4456]]
                                if mem[_4456 + mem[_4456]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4456 + mem[_4456]]) + 1 < 0 or _4456 + ceil32(return_data.size) + ceil32(32 * mem[_4456 + mem[_4456]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4456 + ceil32(return_data.size) + ceil32(32 * mem[_4456 + mem[_4456]]) + 1
                                mem[_4456 + ceil32(return_data.size)] = _4497
                                require _4481 + (32 * _4497) + 32 <= return_data.size
                                mem[_4456 + ceil32(return_data.size) + 32 len ceil32(32 * _4497)] = mem[_4456 + _4481 + 32 len ceil32(32 * _4497)]
                                if 1 >= _4497:
                                    revert with 0, 50
                                _5181 = mem[_4456 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5304 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5181) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5304]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181) / mem[_5304] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181) / mem[_5304]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181) / mem[_5304] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5353 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5181 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5353]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / 10^sub_3266f45c) / mem[_5353] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / 10^sub_3266f45c) / mem[_5353]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / 10^sub_3266f45c) / mem[_5353] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5692 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5181 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5692]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / s * t) / mem[_5692] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / s * t) / mem[_5692]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5181 / s * t) / mem[_5692] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2470 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2470]:
                                    revert with 0, 50
                                mem[_2470 + 32] = token1Address
                                if 1 >= mem[_2470]:
                                    revert with 0, 50
                                mem[_2470 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2470 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2470 + 100] = 1
                                mem[_2470 + 132] = 64
                                mem[_2470 + 164] = mem[_2470]
                                idx = 0
                                s = _2470 + 32
                                t = _2470 + 196
                                while idx < mem[_2470]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2470 + (32 * mem[_2470]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3482 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3505 = mem[_3482]
                                require mem[_3482] <= test266151307()
                                require _3482 + mem[_3482] + 31 < _3482 + return_data.size
                                _3517 = mem[_3482 + mem[_3482]]
                                if mem[_3482 + mem[_3482]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3482 + mem[_3482]]) + 1 < 0 or _3482 + ceil32(return_data.size) + ceil32(32 * mem[_3482 + mem[_3482]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3482 + ceil32(return_data.size) + ceil32(32 * mem[_3482 + mem[_3482]]) + 1
                                mem[_3482 + ceil32(return_data.size)] = _3517
                                require _3505 + (32 * _3517) + 32 <= return_data.size
                                mem[_3482 + ceil32(return_data.size) + 32 len ceil32(32 * _3517)] = mem[_3482 + _3505 + 32 len ceil32(32 * _3517)]
                                if 1 >= _3517:
                                    revert with 0, 50
                                _4431 = mem[_3482 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4607 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4607]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4607] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4607]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4607] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4654 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4654]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4654] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4654]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4654] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5249 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5249]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5249] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5249]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5249] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2531 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2531]:
                                        revert with 0, 50
                                    mem[_2531 + 32] = token1Address
                                    if 1 >= mem[_2531]:
                                        revert with 0, 50
                                    mem[_2531 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2531 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2531 + 100] = 10^sub_3266f45c
                                    mem[_2531 + 132] = 64
                                    mem[_2531 + 164] = mem[_2531]
                                    idx = 0
                                    s = _2531 + 32
                                    t = _2531 + 196
                                    while idx < mem[_2531]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2531 + (32 * mem[_2531]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3481 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3504 = mem[_3481]
                                    require mem[_3481] <= test266151307()
                                    require _3481 + mem[_3481] + 31 < _3481 + return_data.size
                                    _3516 = mem[_3481 + mem[_3481]]
                                    if mem[_3481 + mem[_3481]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3481 + mem[_3481]]) + 1 < 0 or _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1
                                    mem[_3481 + ceil32(return_data.size)] = _3516
                                    require _3504 + (32 * _3516) + 32 <= return_data.size
                                    mem[_3481 + ceil32(return_data.size) + 32 len ceil32(32 * _3516)] = mem[_3481 + _3504 + 32 len ceil32(32 * _3516)]
                                    if 1 >= _3516:
                                        revert with 0, 50
                                    _4430 = mem[_3481 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4606 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4606]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4653 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_4653]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5248 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5248]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3495 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3495]:
                                        revert with 0, 50
                                    mem[_3495 + 32] = token1Address
                                    if 1 >= mem[_3495]:
                                        revert with 0, 50
                                    mem[_3495 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3495 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3495 + 100] = s * t
                                    mem[_3495 + 132] = 64
                                    mem[_3495 + 164] = mem[_3495]
                                    idx = 0
                                    s = _3495 + 32
                                    t = _3495 + 196
                                    while idx < mem[_3495]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3495 + (32 * mem[_3495]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4455 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4480 = mem[_4455]
                                    require mem[_4455] <= test266151307()
                                    require _4455 + mem[_4455] + 31 < _4455 + return_data.size
                                    _4496 = mem[_4455 + mem[_4455]]
                                    if mem[_4455 + mem[_4455]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4455 + mem[_4455]]) + 1 < 0 or _4455 + ceil32(return_data.size) + ceil32(32 * mem[_4455 + mem[_4455]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4455 + ceil32(return_data.size) + ceil32(32 * mem[_4455 + mem[_4455]]) + 1
                                    mem[_4455 + ceil32(return_data.size)] = _4496
                                    require _4480 + (32 * _4496) + 32 <= return_data.size
                                    mem[_4455 + ceil32(return_data.size) + 32 len ceil32(32 * _4496)] = mem[_4455 + _4480 + 32 len ceil32(32 * _4496)]
                                    if 1 >= _4496:
                                        revert with 0, 50
                                    _5180 = mem[_4455 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5303 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5303]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5352 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5352]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5691 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5691]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3589 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3589]:
                                    revert with 0, 50
                                mem[_3589 + 32] = token1Address
                                if 1 >= mem[_3589]:
                                    revert with 0, 50
                                mem[_3589 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3589 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3589 + 100] = 1
                                mem[_3589 + 132] = 64
                                mem[_3589 + 164] = mem[_3589]
                                idx = 0
                                u = _3589 + 32
                                v = _3589 + 196
                                while idx < mem[_3589]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3589 + (32 * mem[_3589]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4454 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4479 = mem[_4454]
                                require mem[_4454] <= test266151307()
                                require _4454 + mem[_4454] + 31 < _4454 + return_data.size
                                _4495 = mem[_4454 + mem[_4454]]
                                if mem[_4454 + mem[_4454]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4454 + mem[_4454]]) + 1 < 0 or _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1
                                mem[_4454 + ceil32(return_data.size)] = _4495
                                require _4479 + (32 * _4495) + 32 <= return_data.size
                                mem[_4454 + ceil32(return_data.size) + 32 len ceil32(32 * _4495)] = mem[_4454 + _4479 + 32 len ceil32(32 * _4495)]
                                if 1 >= _4495:
                                    revert with 0, 50
                                _5179 = mem[_4454 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5302 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5179) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5302]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5351 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5351]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5690 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5690]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / u * v) / mem[_5690] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / u * v) / mem[_5690]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / u * v) / mem[_5690] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3634 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3634]:
                                        revert with 0, 50
                                    mem[_3634 + 32] = token1Address
                                    if 1 >= mem[_3634]:
                                        revert with 0, 50
                                    mem[_3634 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3634 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3634 + 100] = 10^sub_3266f45c
                                    mem[_3634 + 132] = 64
                                    mem[_3634 + 164] = mem[_3634]
                                    idx = 0
                                    u = _3634 + 32
                                    v = _3634 + 196
                                    while idx < mem[_3634]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3634 + (32 * mem[_3634]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4453 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4478 = mem[_4453]
                                    require mem[_4453] <= test266151307()
                                    require _4453 + mem[_4453] + 31 < _4453 + return_data.size
                                    _4494 = mem[_4453 + mem[_4453]]
                                    if mem[_4453 + mem[_4453]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4453 + mem[_4453]]) + 1 < 0 or _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1
                                    mem[_4453 + ceil32(return_data.size)] = _4494
                                    require _4478 + (32 * _4494) + 32 <= return_data.size
                                    mem[_4453 + ceil32(return_data.size) + 32 len ceil32(32 * _4494)] = mem[_4453 + _4478 + 32 len ceil32(32 * _4494)]
                                    if 1 >= _4494:
                                        revert with 0, 50
                                    _5178 = mem[_4453 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5301 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5301]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5350 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5350]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5689 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5689]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4467 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4467]:
                                        revert with 0, 50
                                    mem[_4467 + 32] = token1Address
                                    if 1 >= mem[_4467]:
                                        revert with 0, 50
                                    mem[_4467 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4467 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4467 + 100] = u * v
                                    mem[_4467 + 132] = 64
                                    mem[_4467 + 164] = mem[_4467]
                                    idx = 0
                                    u = _4467 + 32
                                    v = _4467 + 196
                                    while idx < mem[_4467]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4467 + (32 * mem[_4467]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5193 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5202 = mem[_5193]
                                    require mem[_5193] <= test266151307()
                                    require _5193 + mem[_5193] + 31 < _5193 + return_data.size
                                    _5209 = mem[_5193 + mem[_5193]]
                                    if mem[_5193 + mem[_5193]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5193 + mem[_5193]]) + 1 < 0 or _5193 + ceil32(return_data.size) + ceil32(32 * mem[_5193 + mem[_5193]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5193 + ceil32(return_data.size) + ceil32(32 * mem[_5193 + mem[_5193]]) + 1
                                    mem[_5193 + ceil32(return_data.size)] = _5209
                                    require _5202 + (32 * _5209) + 32 <= return_data.size
                                    mem[_5193 + ceil32(return_data.size) + 32 len ceil32(32 * _5209)] = mem[_5193 + _5202 + 32 len ceil32(32 * _5209)]
                                    if 1 >= _5209:
                                        revert with 0, 50
                                    _5653 = mem[_5193 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5726 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5726]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5750 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5750]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5879 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5879]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879] * ext_call.return_data[32] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2392 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2395 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2395
                    require _2392 + (32 * _2395) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2395)] = mem[(2 * ceil32(return_data.size)) + _2392 + 224 len ceil32(32 * _2395)]
                    if 1 >= _2395:
                        revert with 0, 50
                    _3468 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3627 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3627]:
                                revert with 0, 50
                            mem[_3627 + 32] = token1Address
                            if 1 >= mem[_3627]:
                                revert with 0, 50
                            mem[_3627 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3627 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3627 + 100] = 1
                            mem[_3627 + 132] = 64
                            mem[_3627 + 164] = mem[_3627]
                            idx = 0
                            s = _3627 + 32
                            t = _3627 + 196
                            while idx < mem[_3627]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3627 + (32 * mem[_3627]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4450 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4476 = mem[_4450]
                            require mem[_4450] <= test266151307()
                            require _4450 + mem[_4450] + 31 < _4450 + return_data.size
                            _4492 = mem[_4450 + mem[_4450]]
                            if mem[_4450 + mem[_4450]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4450 + mem[_4450]]) + 1 < 0 or _4450 + ceil32(return_data.size) + ceil32(32 * mem[_4450 + mem[_4450]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4450 + ceil32(return_data.size) + ceil32(32 * mem[_4450 + mem[_4450]]) + 1
                            mem[_4450 + ceil32(return_data.size)] = _4492
                            require _4476 + (32 * _4492) + 32 <= return_data.size
                            mem[_4450 + ceil32(return_data.size) + 32 len ceil32(32 * _4492)] = mem[_4450 + _4476 + 32 len ceil32(32 * _4492)]
                            if 1 >= _4492:
                                revert with 0, 50
                            _5176 = mem[_4450 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4450 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4450 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5300 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5176) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5300]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5300] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5300]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5300] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4450 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4450 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5349]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5349] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5349]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5349] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4450 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4450 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5688 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5176 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5688]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / s * t) / mem[_5688] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / s * t) / mem[_5688]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / s * t) / mem[_5688] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3671 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3671]:
                                    revert with 0, 50
                                mem[_3671 + 32] = token1Address
                                if 1 >= mem[_3671]:
                                    revert with 0, 50
                                mem[_3671 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3671 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3671 + 100] = 10^sub_3266f45c
                                mem[_3671 + 132] = 64
                                mem[_3671 + 164] = mem[_3671]
                                idx = 0
                                s = _3671 + 32
                                t = _3671 + 196
                                while idx < mem[_3671]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3671 + (32 * mem[_3671]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4449 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4475 = mem[_4449]
                                require mem[_4449] <= test266151307()
                                require _4449 + mem[_4449] + 31 < _4449 + return_data.size
                                _4491 = mem[_4449 + mem[_4449]]
                                if mem[_4449 + mem[_4449]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4449 + mem[_4449]]) + 1 < 0 or _4449 + ceil32(return_data.size) + ceil32(32 * mem[_4449 + mem[_4449]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4449 + ceil32(return_data.size) + ceil32(32 * mem[_4449 + mem[_4449]]) + 1
                                mem[_4449 + ceil32(return_data.size)] = _4491
                                require _4475 + (32 * _4491) + 32 <= return_data.size
                                mem[_4449 + ceil32(return_data.size) + 32 len ceil32(32 * _4491)] = mem[_4449 + _4475 + 32 len ceil32(32 * _4491)]
                                if 1 >= _4491:
                                    revert with 0, 50
                                _5175 = mem[_4449 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5299 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5175) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5299]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5348 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5348]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5687 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5687]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4465 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4465]:
                                    revert with 0, 50
                                mem[_4465 + 32] = token1Address
                                if 1 >= mem[_4465]:
                                    revert with 0, 50
                                mem[_4465 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4465 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4465 + 100] = s * t
                                mem[_4465 + 132] = 64
                                mem[_4465 + 164] = mem[_4465]
                                idx = 0
                                s = _4465 + 32
                                t = _4465 + 196
                                while idx < mem[_4465]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4465 + (32 * mem[_4465]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5192 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5201 = mem[_5192]
                                require mem[_5192] <= test266151307()
                                require _5192 + mem[_5192] + 31 < _5192 + return_data.size
                                _5208 = mem[_5192 + mem[_5192]]
                                if mem[_5192 + mem[_5192]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5192 + mem[_5192]]) + 1 < 0 or _5192 + ceil32(return_data.size) + ceil32(32 * mem[_5192 + mem[_5192]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5192 + ceil32(return_data.size) + ceil32(32 * mem[_5192 + mem[_5192]]) + 1
                                mem[_5192 + ceil32(return_data.size)] = _5208
                                require _5201 + (32 * _5208) + 32 <= return_data.size
                                mem[_5192 + ceil32(return_data.size) + 32 len ceil32(32 * _5208)] = mem[_5192 + _5201 + 32 len ceil32(32 * _5208)]
                                if 1 >= _5208:
                                    revert with 0, 50
                                _5652 = mem[_5192 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5725 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5652) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5725]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5749 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5749]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5878 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5878]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_5878] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_5878]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_5878] * ext_call.return_data[32] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3669 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3669]:
                                    revert with 0, 50
                                mem[_3669 + 32] = token1Address
                                if 1 >= mem[_3669]:
                                    revert with 0, 50
                                mem[_3669 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3669 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3669 + 100] = 1
                                mem[_3669 + 132] = 64
                                mem[_3669 + 164] = mem[_3669]
                                idx = 0
                                s = _3669 + 32
                                t = _3669 + 196
                                while idx < mem[_3669]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3669 + (32 * mem[_3669]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4446 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4473 = mem[_4446]
                                require mem[_4446] <= test266151307()
                                require _4446 + mem[_4446] + 31 < _4446 + return_data.size
                                _4489 = mem[_4446 + mem[_4446]]
                                if mem[_4446 + mem[_4446]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4446 + mem[_4446]]) + 1 < 0 or _4446 + ceil32(return_data.size) + ceil32(32 * mem[_4446 + mem[_4446]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4446 + ceil32(return_data.size) + ceil32(32 * mem[_4446 + mem[_4446]]) + 1
                                mem[_4446 + ceil32(return_data.size)] = _4489
                                require _4473 + (32 * _4489) + 32 <= return_data.size
                                mem[_4446 + ceil32(return_data.size) + 32 len ceil32(32 * _4489)] = mem[_4446 + _4473 + 32 len ceil32(32 * _4489)]
                                if 1 >= _4489:
                                    revert with 0, 50
                                _5173 = mem[_4446 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5298 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5173) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5298]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5298] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5298]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5298] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5347 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5347]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5347] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5347]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5347] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5686 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5686]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5686] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5686]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5686] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3729 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3729]:
                                        revert with 0, 50
                                    mem[_3729 + 32] = token1Address
                                    if 1 >= mem[_3729]:
                                        revert with 0, 50
                                    mem[_3729 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3729 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3729 + 100] = 10^sub_3266f45c
                                    mem[_3729 + 132] = 64
                                    mem[_3729 + 164] = mem[_3729]
                                    idx = 0
                                    s = _3729 + 32
                                    t = _3729 + 196
                                    while idx < mem[_3729]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3729 + (32 * mem[_3729]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4445 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4472 = mem[_4445]
                                    require mem[_4445] <= test266151307()
                                    require _4445 + mem[_4445] + 31 < _4445 + return_data.size
                                    _4488 = mem[_4445 + mem[_4445]]
                                    if mem[_4445 + mem[_4445]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4445 + mem[_4445]]) + 1 < 0 or _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1
                                    mem[_4445 + ceil32(return_data.size)] = _4488
                                    require _4472 + (32 * _4488) + 32 <= return_data.size
                                    mem[_4445 + ceil32(return_data.size) + 32 len ceil32(32 * _4488)] = mem[_4445 + _4472 + 32 len ceil32(32 * _4488)]
                                    if 1 >= _4488:
                                        revert with 0, 50
                                    _5172 = mem[_4445 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5297 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5297]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5346 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5346]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5685 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5685]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4463 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4463]:
                                        revert with 0, 50
                                    mem[_4463 + 32] = token1Address
                                    if 1 >= mem[_4463]:
                                        revert with 0, 50
                                    mem[_4463 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4463 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4463 + 100] = s * t
                                    mem[_4463 + 132] = 64
                                    mem[_4463 + 164] = mem[_4463]
                                    idx = 0
                                    s = _4463 + 32
                                    t = _4463 + 196
                                    while idx < mem[_4463]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4463 + (32 * mem[_4463]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5191 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5200 = mem[_5191]
                                    require mem[_5191] <= test266151307()
                                    require _5191 + mem[_5191] + 31 < _5191 + return_data.size
                                    _5207 = mem[_5191 + mem[_5191]]
                                    if mem[_5191 + mem[_5191]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5191 + mem[_5191]]) + 1 < 0 or _5191 + ceil32(return_data.size) + ceil32(32 * mem[_5191 + mem[_5191]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5191 + ceil32(return_data.size) + ceil32(32 * mem[_5191 + mem[_5191]]) + 1
                                    mem[_5191 + ceil32(return_data.size)] = _5207
                                    require _5200 + (32 * _5207) + 32 <= return_data.size
                                    mem[_5191 + ceil32(return_data.size) + 32 len ceil32(32 * _5207)] = mem[_5191 + _5200 + 32 len ceil32(32 * _5207)]
                                    if 1 >= _5207:
                                        revert with 0, 50
                                    _5651 = mem[_5191 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5724 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5724]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5748 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5748]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5877 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5877]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877] * ext_call.return_data[32] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4565 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4565]:
                                    revert with 0, 50
                                mem[_4565 + 32] = token1Address
                                if 1 >= mem[_4565]:
                                    revert with 0, 50
                                mem[_4565 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4565 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4565 + 100] = 1
                                mem[_4565 + 132] = 64
                                mem[_4565 + 164] = mem[_4565]
                                idx = 0
                                u = _4565 + 32
                                v = _4565 + 196
                                while idx < mem[_4565]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4565 + (32 * mem[_4565]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5190 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5199 = mem[_5190]
                                require mem[_5190] <= test266151307()
                                require _5190 + mem[_5190] + 31 < _5190 + return_data.size
                                _5206 = mem[_5190 + mem[_5190]]
                                if mem[_5190 + mem[_5190]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5190 + mem[_5190]]) + 1 < 0 or _5190 + ceil32(return_data.size) + ceil32(32 * mem[_5190 + mem[_5190]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5190 + ceil32(return_data.size) + ceil32(32 * mem[_5190 + mem[_5190]]) + 1
                                mem[_5190 + ceil32(return_data.size)] = _5206
                                require _5199 + (32 * _5206) + 32 <= return_data.size
                                mem[_5190 + ceil32(return_data.size) + 32 len ceil32(32 * _5206)] = mem[_5190 + _5199 + 32 len ceil32(32 * _5206)]
                                if 1 >= _5206:
                                    revert with 0, 50
                                _5650 = mem[_5190 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5723 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5723]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5747 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5747]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5876 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5876]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_5876] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_5876]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_5876] * ext_call.return_data[32] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4617 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4617]:
                                        revert with 0, 50
                                    mem[_4617 + 32] = token1Address
                                    if 1 >= mem[_4617]:
                                        revert with 0, 50
                                    mem[_4617 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4617 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4617 + 100] = 10^sub_3266f45c
                                    mem[_4617 + 132] = 64
                                    mem[_4617 + 164] = mem[_4617]
                                    idx = 0
                                    u = _4617 + 32
                                    v = _4617 + 196
                                    while idx < mem[_4617]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4617 + (32 * mem[_4617]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5189 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5198 = mem[_5189]
                                    require mem[_5189] <= test266151307()
                                    require _5189 + mem[_5189] + 31 < _5189 + return_data.size
                                    _5205 = mem[_5189 + mem[_5189]]
                                    if mem[_5189 + mem[_5189]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5189 + mem[_5189]]) + 1 < 0 or _5189 + ceil32(return_data.size) + ceil32(32 * mem[_5189 + mem[_5189]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5189 + ceil32(return_data.size) + ceil32(32 * mem[_5189 + mem[_5189]]) + 1
                                    mem[_5189 + ceil32(return_data.size)] = _5205
                                    require _5198 + (32 * _5205) + 32 <= return_data.size
                                    mem[_5189 + ceil32(return_data.size) + 32 len ceil32(32 * _5205)] = mem[_5189 + _5198 + 32 len ceil32(32 * _5205)]
                                    if 1 >= _5205:
                                        revert with 0, 50
                                    _5649 = mem[_5189 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5722 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5722]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5746 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5746]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5875 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5875]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875] * ext_call.return_data[32] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5195 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5195]:
                                        revert with 0, 50
                                    mem[_5195 + 32] = token1Address
                                    if 1 >= mem[_5195]:
                                        revert with 0, 50
                                    mem[_5195 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5195 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5195 + 100] = u * v
                                    mem[_5195 + 132] = 64
                                    mem[_5195 + 164] = mem[_5195]
                                    idx = 0
                                    u = _5195 + 32
                                    v = _5195 + 196
                                    while idx < mem[_5195]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5195 + (32 * mem[_5195]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5655 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5656 = mem[_5655]
                                    require mem[_5655] <= test266151307()
                                    require _5655 + mem[_5655] + 31 < _5655 + return_data.size
                                    _5657 = mem[_5655 + mem[_5655]]
                                    if mem[_5655 + mem[_5655]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5655 + mem[_5655]]) + 1 < 0 or _5655 + ceil32(return_data.size) + ceil32(32 * mem[_5655 + mem[_5655]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5655 + ceil32(return_data.size) + ceil32(32 * mem[_5655 + mem[_5655]]) + 1
                                    mem[_5655 + ceil32(return_data.size)] = _5657
                                    require _5656 + (32 * _5657) + 32 <= return_data.size
                                    mem[_5655 + ceil32(return_data.size) + 32 len ceil32(32 * _5657)] = mem[_5655 + _5656 + 32 len ceil32(32 * _5657)]
                                    if 1 >= _5657:
                                        revert with 0, 50
                                    _5862 = mem[_5655 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5889 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5862) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5889]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862) / mem[_5889] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862) / mem[_5889]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862) / mem[_5889] * ext_call.return_data[32] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5893 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5862 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5893]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / 10^sub_3266f45c) / mem[_5893] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / 10^sub_3266f45c) / mem[_5893]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / 10^sub_3266f45c) / mem[_5893] * ext_call.return_data[32] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5919 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5862 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5919]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / u * v) / mem[_5919] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / u * v) / mem[_5919]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3468 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5862 / u * v) / mem[_5919] * ext_call.return_data[32] / 100 * 10^18
    return memory
      from mem[64]
       len 32
}

function getAllPoolInUSD() {
    mem[132] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.0x93f1a40b with:
            gas gas_remaining wei
           args poolId, this.address
    mem[96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if not ext_call.return_data[0]:
        return 0
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestRoundData() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 160] = ext_call.return_data[0 len 160]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 160
    require ext_call.return_data[0] == ext_call.return_data[22 len 10]
    require ext_call.return_data[128] == ext_call.return_data[150 len 10]
    if ext_call.return_data[32] <= 0:
        revert with 0, 'Chainlink price <= 0'
    if not ext_call.return_data[96]:
        revert with 0, 'Incomplete round'
    if ext_call.return_data[150 len 10] < ext_call.return_data[22 len 10]:
        revert with 0, 'Stale price'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = token1Address
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = 1
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1264 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _1273 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            require _1264 + (32 * _1273) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1273)] = mem[(4 * ceil32(return_data.size)) + _1264 + 224 len ceil32(32 * _1273)]
            if 1 >= _1273:
                revert with 0, 50
            _2395 = mem[(6 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2440 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2395) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2440]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395) / mem[_2440] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395) / mem[_2440]:
                    revert with 0, 17
                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395) / mem[_2440] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395) / mem[_2440] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2476 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2395 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2476]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / 10^sub_3266f45c) / mem[_2476] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / 10^sub_3266f45c) / mem[_2476]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / 10^sub_3266f45c) / mem[_2476] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / 10^sub_3266f45c) / mem[_2476] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3595 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2395 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3595]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / s * t) / mem[_3595] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / s * t) / mem[_3595]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / s * t) / mem[_3595] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2395 / s * t) / mem[_3595] * ext_call.return_data[32] / 100 * 10^18 / 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token1Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1263 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1272 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                require _1263 + (32 * _1272) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1272)] = mem[(4 * ceil32(return_data.size)) + _1263 + 224 len ceil32(32 * _1272)]
                if 1 >= _1272:
                    revert with 0, 50
                _2394 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2439 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2394) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2439]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394) / mem[_2439] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394) / mem[_2439]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394) / mem[_2439] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394) / mem[_2439] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2475 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2394 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2475]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / 10^sub_3266f45c) / mem[_2475] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / 10^sub_3266f45c) / mem[_2475]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / 10^sub_3266f45c) / mem[_2475] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / 10^sub_3266f45c) / mem[_2475] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2394 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3594]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / s * t) / mem[_3594] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / s * t) / mem[_3594]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / s * t) / mem[_3594] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2394 / s * t) / mem[_3594] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token1Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = s * t
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (4 * ceil32(return_data.size)) + 128
                v = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2401 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2404 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                require _2401 + (32 * _2404) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2404)] = mem[(4 * ceil32(return_data.size)) + _2401 + 224 len ceil32(32 * _2404)]
                if 1 >= _2404:
                    revert with 0, 50
                _3485 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3633 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3485) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3633]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485) / mem[_3633] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485) / mem[_3633]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485) / mem[_3633] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485) / mem[_3633] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3675 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3485 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3675]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / 10^sub_3266f45c) / mem[_3675] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / 10^sub_3266f45c) / mem[_3675]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / 10^sub_3266f45c) / mem[_3675] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / 10^sub_3266f45c) / mem[_3675] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4571 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3485 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4571]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / s * t) / mem[_4571] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / s * t) / mem[_4571]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / s * t) / mem[_4571] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3485 / s * t) / mem[_4571] * ext_call.return_data[32] / 100 * 10^18 / 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 1
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1261 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1270 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                require _1261 + (32 * _1270) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1270)] = mem[(4 * ceil32(return_data.size)) + _1261 + 224 len ceil32(32 * _1270)]
                if 1 >= _1270:
                    revert with 0, 50
                _2392 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2438 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2392) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2438]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392) / mem[_2438] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392) / mem[_2438]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392) / mem[_2438] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392) / mem[_2438] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2474 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2392 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2474]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / 10^sub_9ddc230a) / mem[_2474] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / 10^sub_9ddc230a) / mem[_2474]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / 10^sub_9ddc230a) / mem[_2474] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / 10^sub_9ddc230a) / mem[_2474] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2392 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3593]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / s * t) / mem[_3593] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / s * t) / mem[_3593]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / s * t) / mem[_3593] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2392 / s * t) / mem[_3593] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1260 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _1269 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    require _1260 + (32 * _1269) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1269)] = mem[(4 * ceil32(return_data.size)) + _1260 + 224 len ceil32(32 * _1269)]
                    if 1 >= _1269:
                        revert with 0, 50
                    _2391 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2437 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2391) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2437]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391) / mem[_2437] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391) / mem[_2437]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391) / mem[_2437] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391) / mem[_2437] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2391 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2473]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / 10^sub_9ddc230a) / mem[_2473] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / 10^sub_9ddc230a) / mem[_2473]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / 10^sub_9ddc230a) / mem[_2473] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / 10^sub_9ddc230a) / mem[_2473] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3592 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2391 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3592]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / s * t) / mem[_3592] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / s * t) / mem[_3592]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / s * t) / mem[_3592] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2391 / s * t) / mem[_3592] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = s * t
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (4 * ceil32(return_data.size)) + 128
                    v = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2400 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2403 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    require _2400 + (32 * _2403) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2403)] = mem[(4 * ceil32(return_data.size)) + _2400 + 224 len ceil32(32 * _2403)]
                    if 1 >= _2403:
                        revert with 0, 50
                    _3484 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3632 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3484) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3632]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484) / mem[_3632] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484) / mem[_3632]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484) / mem[_3632] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484) / mem[_3632] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3674 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3484 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3674]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / 10^sub_9ddc230a) / mem[_3674] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / 10^sub_9ddc230a) / mem[_3674]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / 10^sub_9ddc230a) / mem[_3674] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / 10^sub_9ddc230a) / mem[_3674] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4570 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3484 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4570]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / s * t) / mem[_4570] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / s * t) / mem[_4570]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / s * t) / mem[_4570] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3484 / s * t) / mem[_4570] * ext_call.return_data[32] / 100 * 10^18 / 10^18
        else:
            if not sub_9ddc230a:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 1
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1258 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1267 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                require _1258 + (32 * _1267) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1267)] = mem[(4 * ceil32(return_data.size)) + _1258 + 224 len ceil32(32 * _1267)]
                if 1 >= _1267:
                    revert with 0, 50
                _2389 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2443 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2443]:
                            revert with 0, 50
                        mem[_2443 + 32] = token1Address
                        if 1 >= mem[_2443]:
                            revert with 0, 50
                        mem[_2443 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2443 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2443 + 100] = 1
                        mem[_2443 + 132] = 64
                        mem[_2443 + 164] = mem[_2443]
                        idx = 0
                        s = _2443 + 32
                        t = _2443 + 196
                        while idx < mem[_2443]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2443 + (32 * mem[_2443]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3501 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3521 = mem[_3501]
                        require mem[_3501] <= test266151307()
                        require _3501 + mem[_3501] + 31 < _3501 + return_data.size
                        _3533 = mem[_3501 + mem[_3501]]
                        if mem[_3501 + mem[_3501]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3501 + mem[_3501]]) + 1 < 0 or _3501 + ceil32(return_data.size) + ceil32(32 * mem[_3501 + mem[_3501]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3501 + ceil32(return_data.size) + ceil32(32 * mem[_3501 + mem[_3501]]) + 1
                        mem[_3501 + ceil32(return_data.size)] = _3533
                        require _3521 + (32 * _3533) + 32 <= return_data.size
                        mem[_3501 + ceil32(return_data.size) + 32 len ceil32(32 * _3533)] = mem[_3501 + _3521 + 32 len ceil32(32 * _3533)]
                        if 1 >= _3533:
                            revert with 0, 50
                        _4449 = mem[_3501 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3501 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3501 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4621 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4449) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4621]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449) / mem[_4621] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449) / mem[_4621]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449) / mem[_4621] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449) / mem[_4621] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3501 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3501 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4667 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4449 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4667]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / 10^sub_3266f45c) / mem[_4667] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / 10^sub_3266f45c) / mem[_4667]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / 10^sub_3266f45c) / mem[_4667] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / 10^sub_3266f45c) / mem[_4667] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3501 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3501 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5263 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4449 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5263]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / s * t) / mem[_5263] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / s * t) / mem[_5263]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / s * t) / mem[_5263] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4449 / s * t) / mem[_5263] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2484 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2484]:
                                revert with 0, 50
                            mem[_2484 + 32] = token1Address
                            if 1 >= mem[_2484]:
                                revert with 0, 50
                            mem[_2484 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2484 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2484 + 100] = 10^sub_3266f45c
                            mem[_2484 + 132] = 64
                            mem[_2484 + 164] = mem[_2484]
                            idx = 0
                            s = _2484 + 32
                            t = _2484 + 196
                            while idx < mem[_2484]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2484 + (32 * mem[_2484]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3500 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3520 = mem[_3500]
                            require mem[_3500] <= test266151307()
                            require _3500 + mem[_3500] + 31 < _3500 + return_data.size
                            _3532 = mem[_3500 + mem[_3500]]
                            if mem[_3500 + mem[_3500]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3500 + mem[_3500]]) + 1 < 0 or _3500 + ceil32(return_data.size) + ceil32(32 * mem[_3500 + mem[_3500]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3500 + ceil32(return_data.size) + ceil32(32 * mem[_3500 + mem[_3500]]) + 1
                            mem[_3500 + ceil32(return_data.size)] = _3532
                            require _3520 + (32 * _3532) + 32 <= return_data.size
                            mem[_3500 + ceil32(return_data.size) + 32 len ceil32(32 * _3532)] = mem[_3500 + _3520 + 32 len ceil32(32 * _3532)]
                            if 1 >= _3532:
                                revert with 0, 50
                            _4448 = mem[_3500 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3500 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3500 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4620 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4448) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4620]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448) / mem[_4620] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448) / mem[_4620]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448) / mem[_4620] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448) / mem[_4620] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3500 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3500 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4666 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4448 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4666]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / 10^sub_3266f45c) / mem[_4666] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / 10^sub_3266f45c) / mem[_4666]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / 10^sub_3266f45c) / mem[_4666] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / 10^sub_3266f45c) / mem[_4666] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3500 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3500 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5262 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _4448 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5262]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / s * t) / mem[_5262] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / s * t) / mem[_5262]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / s * t) / mem[_5262] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4448 / s * t) / mem[_5262] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3508 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3508]:
                                revert with 0, 50
                            mem[_3508 + 32] = token1Address
                            if 1 >= mem[_3508]:
                                revert with 0, 50
                            mem[_3508 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3508 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3508 + 100] = s * t
                            mem[_3508 + 132] = 64
                            mem[_3508 + 164] = mem[_3508]
                            idx = 0
                            s = _3508 + 32
                            t = _3508 + 196
                            while idx < mem[_3508]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3508 + (32 * mem[_3508]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4469 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4493 = mem[_4469]
                            require mem[_4469] <= test266151307()
                            require _4469 + mem[_4469] + 31 < _4469 + return_data.size
                            _4509 = mem[_4469 + mem[_4469]]
                            if mem[_4469 + mem[_4469]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4469 + mem[_4469]]) + 1 < 0 or _4469 + ceil32(return_data.size) + ceil32(32 * mem[_4469 + mem[_4469]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4469 + ceil32(return_data.size) + ceil32(32 * mem[_4469 + mem[_4469]]) + 1
                            mem[_4469 + ceil32(return_data.size)] = _4509
                            require _4493 + (32 * _4509) + 32 <= return_data.size
                            mem[_4469 + ceil32(return_data.size) + 32 len ceil32(32 * _4509)] = mem[_4469 + _4493 + 32 len ceil32(32 * _4509)]
                            if 1 >= _4509:
                                revert with 0, 50
                            _5193 = mem[_4469 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4469 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4469 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5315 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _5193) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5315]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193) / mem[_5315] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193) / mem[_5315]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193) / mem[_5315] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193) / mem[_5315] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4469 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4469 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5364 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _5193 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5364]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / 10^sub_3266f45c) / mem[_5364] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / 10^sub_3266f45c) / mem[_5364]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / 10^sub_3266f45c) / mem[_5364] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / 10^sub_3266f45c) / mem[_5364] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4469 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4469 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5703 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389) + (Mask(112, 0, ext_call.return_data[32]) * _5193 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5703]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / s * t) / mem[_5703] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / s * t) / mem[_5703]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / s * t) / mem[_5703] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5193 / s * t) / mem[_5703] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2482 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2482]:
                                revert with 0, 50
                            mem[_2482 + 32] = token1Address
                            if 1 >= mem[_2482]:
                                revert with 0, 50
                            mem[_2482 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2482 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2482 + 100] = 1
                            mem[_2482 + 132] = 64
                            mem[_2482 + 164] = mem[_2482]
                            idx = 0
                            s = _2482 + 32
                            t = _2482 + 196
                            while idx < mem[_2482]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2482 + (32 * mem[_2482]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3497 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3518 = mem[_3497]
                            require mem[_3497] <= test266151307()
                            require _3497 + mem[_3497] + 31 < _3497 + return_data.size
                            _3530 = mem[_3497 + mem[_3497]]
                            if mem[_3497 + mem[_3497]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3497 + mem[_3497]]) + 1 < 0 or _3497 + ceil32(return_data.size) + ceil32(32 * mem[_3497 + mem[_3497]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3497 + ceil32(return_data.size) + ceil32(32 * mem[_3497 + mem[_3497]]) + 1
                            mem[_3497 + ceil32(return_data.size)] = _3530
                            require _3518 + (32 * _3530) + 32 <= return_data.size
                            mem[_3497 + ceil32(return_data.size) + 32 len ceil32(32 * _3530)] = mem[_3497 + _3518 + 32 len ceil32(32 * _3530)]
                            if 1 >= _3530:
                                revert with 0, 50
                            _4446 = mem[_3497 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3497 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3497 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4619 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4446) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4619]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446) / mem[_4619] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446) / mem[_4619]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446) / mem[_4619] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446) / mem[_4619] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3497 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3497 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4665 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4446 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4665]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / 10^sub_3266f45c) / mem[_4665] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / 10^sub_3266f45c) / mem[_4665]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / 10^sub_3266f45c) / mem[_4665] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / 10^sub_3266f45c) / mem[_4665] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3497 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3497 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5261 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4446 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5261]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / s * t) / mem[_5261] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / s * t) / mem[_5261]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / s * t) / mem[_5261] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4446 / s * t) / mem[_5261] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2544 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2544]:
                                    revert with 0, 50
                                mem[_2544 + 32] = token1Address
                                if 1 >= mem[_2544]:
                                    revert with 0, 50
                                mem[_2544 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2544 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2544 + 100] = 10^sub_3266f45c
                                mem[_2544 + 132] = 64
                                mem[_2544 + 164] = mem[_2544]
                                idx = 0
                                s = _2544 + 32
                                t = _2544 + 196
                                while idx < mem[_2544]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2544 + (32 * mem[_2544]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3496 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3517 = mem[_3496]
                                require mem[_3496] <= test266151307()
                                require _3496 + mem[_3496] + 31 < _3496 + return_data.size
                                _3529 = mem[_3496 + mem[_3496]]
                                if mem[_3496 + mem[_3496]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3496 + mem[_3496]]) + 1 < 0 or _3496 + ceil32(return_data.size) + ceil32(32 * mem[_3496 + mem[_3496]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3496 + ceil32(return_data.size) + ceil32(32 * mem[_3496 + mem[_3496]]) + 1
                                mem[_3496 + ceil32(return_data.size)] = _3529
                                require _3517 + (32 * _3529) + 32 <= return_data.size
                                mem[_3496 + ceil32(return_data.size) + 32 len ceil32(32 * _3529)] = mem[_3496 + _3517 + 32 len ceil32(32 * _3529)]
                                if 1 >= _3529:
                                    revert with 0, 50
                                _4445 = mem[_3496 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3496 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3496 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4618 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4445) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4618]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445) / mem[_4618] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445) / mem[_4618]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445) / mem[_4618] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445) / mem[_4618] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3496 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3496 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4664 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4445 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4664]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / 10^sub_3266f45c) / mem[_4664] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / 10^sub_3266f45c) / mem[_4664]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / 10^sub_3266f45c) / mem[_4664] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / 10^sub_3266f45c) / mem[_4664] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3496 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3496 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5260 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4445 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5260]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / s * t) / mem[_5260] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / s * t) / mem[_5260]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / s * t) / mem[_5260] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4445 / s * t) / mem[_5260] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3506 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3506]:
                                    revert with 0, 50
                                mem[_3506 + 32] = token1Address
                                if 1 >= mem[_3506]:
                                    revert with 0, 50
                                mem[_3506 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3506 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3506 + 100] = s * t
                                mem[_3506 + 132] = 64
                                mem[_3506 + 164] = mem[_3506]
                                idx = 0
                                s = _3506 + 32
                                t = _3506 + 196
                                while idx < mem[_3506]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3506 + (32 * mem[_3506]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4468 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4492 = mem[_4468]
                                require mem[_4468] <= test266151307()
                                require _4468 + mem[_4468] + 31 < _4468 + return_data.size
                                _4508 = mem[_4468 + mem[_4468]]
                                if mem[_4468 + mem[_4468]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4468 + mem[_4468]]) + 1 < 0 or _4468 + ceil32(return_data.size) + ceil32(32 * mem[_4468 + mem[_4468]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4468 + ceil32(return_data.size) + ceil32(32 * mem[_4468 + mem[_4468]]) + 1
                                mem[_4468 + ceil32(return_data.size)] = _4508
                                require _4492 + (32 * _4508) + 32 <= return_data.size
                                mem[_4468 + ceil32(return_data.size) + 32 len ceil32(32 * _4508)] = mem[_4468 + _4492 + 32 len ceil32(32 * _4508)]
                                if 1 >= _4508:
                                    revert with 0, 50
                                _5192 = mem[_4468 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4468 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4468 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5314 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5192) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5314]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192) / mem[_5314] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192) / mem[_5314]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192) / mem[_5314] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192) / mem[_5314] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4468 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4468 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5363 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5192 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5363]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / 10^sub_3266f45c) / mem[_5363] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / 10^sub_3266f45c) / mem[_5363]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / 10^sub_3266f45c) / mem[_5363] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / 10^sub_3266f45c) / mem[_5363] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4468 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4468 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5702 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5192 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5702]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / s * t) / mem[_5702] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / s * t) / mem[_5702]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / s * t) / mem[_5702] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5192 / s * t) / mem[_5702] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3602 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3602]:
                                revert with 0, 50
                            mem[_3602 + 32] = token1Address
                            if 1 >= mem[_3602]:
                                revert with 0, 50
                            mem[_3602 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3602 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3602 + 100] = 1
                            mem[_3602 + 132] = 64
                            mem[_3602 + 164] = mem[_3602]
                            idx = 0
                            u = _3602 + 32
                            v = _3602 + 196
                            while idx < mem[_3602]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3602 + (32 * mem[_3602]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4467 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4491 = mem[_4467]
                            require mem[_4467] <= test266151307()
                            require _4467 + mem[_4467] + 31 < _4467 + return_data.size
                            _4507 = mem[_4467 + mem[_4467]]
                            if mem[_4467 + mem[_4467]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4467 + mem[_4467]]) + 1 < 0 or _4467 + ceil32(return_data.size) + ceil32(32 * mem[_4467 + mem[_4467]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4467 + ceil32(return_data.size) + ceil32(32 * mem[_4467 + mem[_4467]]) + 1
                            mem[_4467 + ceil32(return_data.size)] = _4507
                            require _4491 + (32 * _4507) + 32 <= return_data.size
                            mem[_4467 + ceil32(return_data.size) + 32 len ceil32(32 * _4507)] = mem[_4467 + _4491 + 32 len ceil32(32 * _4507)]
                            if 1 >= _4507:
                                revert with 0, 50
                            _5191 = mem[_4467 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4467 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4467 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5313 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5191) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5313]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191) / mem[_5313] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191) / mem[_5313]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191) / mem[_5313] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191) / mem[_5313] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4467 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4467 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5362 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5191 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5362]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / 10^sub_3266f45c) / mem[_5362] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / 10^sub_3266f45c) / mem[_5362]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / 10^sub_3266f45c) / mem[_5362] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / 10^sub_3266f45c) / mem[_5362] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4467 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4467 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5701 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5191 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5701]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / u * v) / mem[_5701] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / u * v) / mem[_5701]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / u * v) / mem[_5701] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5191 / u * v) / mem[_5701] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3646 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3646]:
                                    revert with 0, 50
                                mem[_3646 + 32] = token1Address
                                if 1 >= mem[_3646]:
                                    revert with 0, 50
                                mem[_3646 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3646 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3646 + 100] = 10^sub_3266f45c
                                mem[_3646 + 132] = 64
                                mem[_3646 + 164] = mem[_3646]
                                idx = 0
                                u = _3646 + 32
                                v = _3646 + 196
                                while idx < mem[_3646]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3646 + (32 * mem[_3646]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4466 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4490 = mem[_4466]
                                require mem[_4466] <= test266151307()
                                require _4466 + mem[_4466] + 31 < _4466 + return_data.size
                                _4506 = mem[_4466 + mem[_4466]]
                                if mem[_4466 + mem[_4466]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4466 + mem[_4466]]) + 1 < 0 or _4466 + ceil32(return_data.size) + ceil32(32 * mem[_4466 + mem[_4466]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4466 + ceil32(return_data.size) + ceil32(32 * mem[_4466 + mem[_4466]]) + 1
                                mem[_4466 + ceil32(return_data.size)] = _4506
                                require _4490 + (32 * _4506) + 32 <= return_data.size
                                mem[_4466 + ceil32(return_data.size) + 32 len ceil32(32 * _4506)] = mem[_4466 + _4490 + 32 len ceil32(32 * _4506)]
                                if 1 >= _4506:
                                    revert with 0, 50
                                _5190 = mem[_4466 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4466 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4466 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5312 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5190) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5312]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190) / mem[_5312] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190) / mem[_5312]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190) / mem[_5312] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190) / mem[_5312] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4466 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4466 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5361 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5190 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5361]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / 10^sub_3266f45c) / mem[_5361] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / 10^sub_3266f45c) / mem[_5361]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / 10^sub_3266f45c) / mem[_5361] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / 10^sub_3266f45c) / mem[_5361] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4466 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4466 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5700 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5190 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5700]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / u * v) / mem[_5700] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / u * v) / mem[_5700]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / u * v) / mem[_5700] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5190 / u * v) / mem[_5700] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4476 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4476]:
                                    revert with 0, 50
                                mem[_4476 + 32] = token1Address
                                if 1 >= mem[_4476]:
                                    revert with 0, 50
                                mem[_4476 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4476 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4476 + 100] = u * v
                                mem[_4476 + 132] = 64
                                mem[_4476 + 164] = mem[_4476]
                                idx = 0
                                u = _4476 + 32
                                v = _4476 + 196
                                while idx < mem[_4476]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4476 + (32 * mem[_4476]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5201 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5210 = mem[_5201]
                                require mem[_5201] <= test266151307()
                                require _5201 + mem[_5201] + 31 < _5201 + return_data.size
                                _5217 = mem[_5201 + mem[_5201]]
                                if mem[_5201 + mem[_5201]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5201 + mem[_5201]]) + 1 < 0 or _5201 + ceil32(return_data.size) + ceil32(32 * mem[_5201 + mem[_5201]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5201 + ceil32(return_data.size) + ceil32(32 * mem[_5201 + mem[_5201]]) + 1
                                mem[_5201 + ceil32(return_data.size)] = _5217
                                require _5210 + (32 * _5217) + 32 <= return_data.size
                                mem[_5201 + ceil32(return_data.size) + 32 len ceil32(32 * _5217)] = mem[_5201 + _5210 + 32 len ceil32(32 * _5217)]
                                if 1 >= _5217:
                                    revert with 0, 50
                                _5661 = mem[_5201 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5201 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5201 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5734 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5661) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5734]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661) / mem[_5734] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661) / mem[_5734]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661) / mem[_5734] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661) / mem[_5734] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5201 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5201 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5758 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5661 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5758]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / 10^sub_3266f45c) / mem[_5758] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / 10^sub_3266f45c) / mem[_5758]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / 10^sub_3266f45c) / mem[_5758] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / 10^sub_3266f45c) / mem[_5758] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5201 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5201 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5887 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5661 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5887]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / u * v) / mem[_5887] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / u * v) / mem[_5887]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / u * v) / mem[_5887] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2389 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5661 / u * v) / mem[_5887] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1257 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _1266 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    require _1257 + (32 * _1266) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1266)] = mem[(4 * ceil32(return_data.size)) + _1257 + 224 len ceil32(32 * _1266)]
                    if 1 >= _1266:
                        revert with 0, 50
                    _2388 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2441 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2441]:
                                revert with 0, 50
                            mem[_2441 + 32] = token1Address
                            if 1 >= mem[_2441]:
                                revert with 0, 50
                            mem[_2441 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2441 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2441 + 100] = 1
                            mem[_2441 + 132] = 64
                            mem[_2441 + 164] = mem[_2441]
                            idx = 0
                            s = _2441 + 32
                            t = _2441 + 196
                            while idx < mem[_2441]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2441 + (32 * mem[_2441]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3493 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3515 = mem[_3493]
                            require mem[_3493] <= test266151307()
                            require _3493 + mem[_3493] + 31 < _3493 + return_data.size
                            _3527 = mem[_3493 + mem[_3493]]
                            if mem[_3493 + mem[_3493]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3493 + mem[_3493]]) + 1 < 0 or _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1
                            mem[_3493 + ceil32(return_data.size)] = _3527
                            require _3515 + (32 * _3527) + 32 <= return_data.size
                            mem[_3493 + ceil32(return_data.size) + 32 len ceil32(32 * _3527)] = mem[_3493 + _3515 + 32 len ceil32(32 * _3527)]
                            if 1 >= _3527:
                                revert with 0, 50
                            _4441 = mem[_3493 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4616 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4441) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4616]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4616] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4616]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4616] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4616] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4663 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4663]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4663] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4663]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4663] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4663] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5258 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5258]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5258] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5258]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5258] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5258] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2479 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2479]:
                                    revert with 0, 50
                                mem[_2479 + 32] = token1Address
                                if 1 >= mem[_2479]:
                                    revert with 0, 50
                                mem[_2479 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2479 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2479 + 100] = 10^sub_3266f45c
                                mem[_2479 + 132] = 64
                                mem[_2479 + 164] = mem[_2479]
                                idx = 0
                                s = _2479 + 32
                                t = _2479 + 196
                                while idx < mem[_2479]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2479 + (32 * mem[_2479]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3492 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3514 = mem[_3492]
                                require mem[_3492] <= test266151307()
                                require _3492 + mem[_3492] + 31 < _3492 + return_data.size
                                _3526 = mem[_3492 + mem[_3492]]
                                if mem[_3492 + mem[_3492]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3492 + mem[_3492]]) + 1 < 0 or _3492 + ceil32(return_data.size) + ceil32(32 * mem[_3492 + mem[_3492]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3492 + ceil32(return_data.size) + ceil32(32 * mem[_3492 + mem[_3492]]) + 1
                                mem[_3492 + ceil32(return_data.size)] = _3526
                                require _3514 + (32 * _3526) + 32 <= return_data.size
                                mem[_3492 + ceil32(return_data.size) + 32 len ceil32(32 * _3526)] = mem[_3492 + _3514 + 32 len ceil32(32 * _3526)]
                                if 1 >= _3526:
                                    revert with 0, 50
                                _4440 = mem[_3492 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4615 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4440) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4615]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4615] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4615]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4615] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4615] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4662 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4662]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4662] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4662]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4662] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4662] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5257 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5257]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5257] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5257]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5257] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5257] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3504 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3504]:
                                    revert with 0, 50
                                mem[_3504 + 32] = token1Address
                                if 1 >= mem[_3504]:
                                    revert with 0, 50
                                mem[_3504 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3504 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3504 + 100] = s * t
                                mem[_3504 + 132] = 64
                                mem[_3504 + 164] = mem[_3504]
                                idx = 0
                                s = _3504 + 32
                                t = _3504 + 196
                                while idx < mem[_3504]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3504 + (32 * mem[_3504]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4463 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4488 = mem[_4463]
                                require mem[_4463] <= test266151307()
                                require _4463 + mem[_4463] + 31 < _4463 + return_data.size
                                _4504 = mem[_4463 + mem[_4463]]
                                if mem[_4463 + mem[_4463]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4463 + mem[_4463]]) + 1 < 0 or _4463 + ceil32(return_data.size) + ceil32(32 * mem[_4463 + mem[_4463]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4463 + ceil32(return_data.size) + ceil32(32 * mem[_4463 + mem[_4463]]) + 1
                                mem[_4463 + ceil32(return_data.size)] = _4504
                                require _4488 + (32 * _4504) + 32 <= return_data.size
                                mem[_4463 + ceil32(return_data.size) + 32 len ceil32(32 * _4504)] = mem[_4463 + _4488 + 32 len ceil32(32 * _4504)]
                                if 1 >= _4504:
                                    revert with 0, 50
                                _5188 = mem[_4463 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4463 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4463 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5311 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _5188) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5311]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188) / mem[_5311] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188) / mem[_5311]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188) / mem[_5311] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188) / mem[_5311] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4463 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4463 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5360 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _5188 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5360]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / 10^sub_3266f45c) / mem[_5360] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / 10^sub_3266f45c) / mem[_5360]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / 10^sub_3266f45c) / mem[_5360] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / 10^sub_3266f45c) / mem[_5360] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4463 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4463 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5699 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388) + (Mask(112, 0, ext_call.return_data[32]) * _5188 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5699]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / s * t) / mem[_5699] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / s * t) / mem[_5699]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / s * t) / mem[_5699] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5188 / s * t) / mem[_5699] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2477 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2477]:
                                    revert with 0, 50
                                mem[_2477 + 32] = token1Address
                                if 1 >= mem[_2477]:
                                    revert with 0, 50
                                mem[_2477 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2477 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2477 + 100] = 1
                                mem[_2477 + 132] = 64
                                mem[_2477 + 164] = mem[_2477]
                                idx = 0
                                s = _2477 + 32
                                t = _2477 + 196
                                while idx < mem[_2477]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2477 + (32 * mem[_2477]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3489 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3512 = mem[_3489]
                                require mem[_3489] <= test266151307()
                                require _3489 + mem[_3489] + 31 < _3489 + return_data.size
                                _3524 = mem[_3489 + mem[_3489]]
                                if mem[_3489 + mem[_3489]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3489 + mem[_3489]]) + 1 < 0 or _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1
                                mem[_3489 + ceil32(return_data.size)] = _3524
                                require _3512 + (32 * _3524) + 32 <= return_data.size
                                mem[_3489 + ceil32(return_data.size) + 32 len ceil32(32 * _3524)] = mem[_3489 + _3512 + 32 len ceil32(32 * _3524)]
                                if 1 >= _3524:
                                    revert with 0, 50
                                _4438 = mem[_3489 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4614 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4614]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4614] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4614]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4614] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4614] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4661 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4661]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4661] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4661]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4661] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4661] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5256 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5256]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5256] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5256]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5256] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5256] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2538 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2538]:
                                        revert with 0, 50
                                    mem[_2538 + 32] = token1Address
                                    if 1 >= mem[_2538]:
                                        revert with 0, 50
                                    mem[_2538 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2538 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2538 + 100] = 10^sub_3266f45c
                                    mem[_2538 + 132] = 64
                                    mem[_2538 + 164] = mem[_2538]
                                    idx = 0
                                    s = _2538 + 32
                                    t = _2538 + 196
                                    while idx < mem[_2538]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2538 + (32 * mem[_2538]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3488 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3511 = mem[_3488]
                                    require mem[_3488] <= test266151307()
                                    require _3488 + mem[_3488] + 31 < _3488 + return_data.size
                                    _3523 = mem[_3488 + mem[_3488]]
                                    if mem[_3488 + mem[_3488]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3488 + mem[_3488]]) + 1 < 0 or _3488 + ceil32(return_data.size) + ceil32(32 * mem[_3488 + mem[_3488]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3488 + ceil32(return_data.size) + ceil32(32 * mem[_3488 + mem[_3488]]) + 1
                                    mem[_3488 + ceil32(return_data.size)] = _3523
                                    require _3511 + (32 * _3523) + 32 <= return_data.size
                                    mem[_3488 + ceil32(return_data.size) + 32 len ceil32(32 * _3523)] = mem[_3488 + _3511 + 32 len ceil32(32 * _3523)]
                                    if 1 >= _3523:
                                        revert with 0, 50
                                    _4437 = mem[_3488 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4613]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4613] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4613]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4613] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4613] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4660 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_4660]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4660] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4660]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4660] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4660] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5255 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5255]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5255] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5255]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5255] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5255] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3502 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3502]:
                                        revert with 0, 50
                                    mem[_3502 + 32] = token1Address
                                    if 1 >= mem[_3502]:
                                        revert with 0, 50
                                    mem[_3502 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3502 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3502 + 100] = s * t
                                    mem[_3502 + 132] = 64
                                    mem[_3502 + 164] = mem[_3502]
                                    idx = 0
                                    s = _3502 + 32
                                    t = _3502 + 196
                                    while idx < mem[_3502]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3502 + (32 * mem[_3502]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4462 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4487 = mem[_4462]
                                    require mem[_4462] <= test266151307()
                                    require _4462 + mem[_4462] + 31 < _4462 + return_data.size
                                    _4503 = mem[_4462 + mem[_4462]]
                                    if mem[_4462 + mem[_4462]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4462 + mem[_4462]]) + 1 < 0 or _4462 + ceil32(return_data.size) + ceil32(32 * mem[_4462 + mem[_4462]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4462 + ceil32(return_data.size) + ceil32(32 * mem[_4462 + mem[_4462]]) + 1
                                    mem[_4462 + ceil32(return_data.size)] = _4503
                                    require _4487 + (32 * _4503) + 32 <= return_data.size
                                    mem[_4462 + ceil32(return_data.size) + 32 len ceil32(32 * _4503)] = mem[_4462 + _4487 + 32 len ceil32(32 * _4503)]
                                    if 1 >= _4503:
                                        revert with 0, 50
                                    _5187 = mem[_4462 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5310 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5187) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5310]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187) / mem[_5310] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187) / mem[_5310]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187) / mem[_5310] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187) / mem[_5310] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5359 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5187 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5359]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / 10^sub_3266f45c) / mem[_5359] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / 10^sub_3266f45c) / mem[_5359]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / 10^sub_3266f45c) / mem[_5359] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / 10^sub_3266f45c) / mem[_5359] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4462 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4462 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5698 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5187 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5698]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / s * t) / mem[_5698] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / s * t) / mem[_5698]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / s * t) / mem[_5698] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5187 / s * t) / mem[_5698] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3596 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3596]:
                                    revert with 0, 50
                                mem[_3596 + 32] = token1Address
                                if 1 >= mem[_3596]:
                                    revert with 0, 50
                                mem[_3596 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3596 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3596 + 100] = 1
                                mem[_3596 + 132] = 64
                                mem[_3596 + 164] = mem[_3596]
                                idx = 0
                                u = _3596 + 32
                                v = _3596 + 196
                                while idx < mem[_3596]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3596 + (32 * mem[_3596]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4461 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4486 = mem[_4461]
                                require mem[_4461] <= test266151307()
                                require _4461 + mem[_4461] + 31 < _4461 + return_data.size
                                _4502 = mem[_4461 + mem[_4461]]
                                if mem[_4461 + mem[_4461]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4461 + mem[_4461]]) + 1 < 0 or _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1
                                mem[_4461 + ceil32(return_data.size)] = _4502
                                require _4486 + (32 * _4502) + 32 <= return_data.size
                                mem[_4461 + ceil32(return_data.size) + 32 len ceil32(32 * _4502)] = mem[_4461 + _4486 + 32 len ceil32(32 * _4502)]
                                if 1 >= _4502:
                                    revert with 0, 50
                                _5186 = mem[_4461 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5309 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5186) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5309]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5309] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5309]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5309] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186) / mem[_5309] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5358 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5358]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5358] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5358]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5358] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / 10^sub_3266f45c) / mem[_5358] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5697 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5186 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5697]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / u * v) / mem[_5697] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / u * v) / mem[_5697]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / u * v) / mem[_5697] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5186 / u * v) / mem[_5697] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3641 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3641]:
                                        revert with 0, 50
                                    mem[_3641 + 32] = token1Address
                                    if 1 >= mem[_3641]:
                                        revert with 0, 50
                                    mem[_3641 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3641 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3641 + 100] = 10^sub_3266f45c
                                    mem[_3641 + 132] = 64
                                    mem[_3641 + 164] = mem[_3641]
                                    idx = 0
                                    u = _3641 + 32
                                    v = _3641 + 196
                                    while idx < mem[_3641]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3641 + (32 * mem[_3641]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4460 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4485 = mem[_4460]
                                    require mem[_4460] <= test266151307()
                                    require _4460 + mem[_4460] + 31 < _4460 + return_data.size
                                    _4501 = mem[_4460 + mem[_4460]]
                                    if mem[_4460 + mem[_4460]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4460 + mem[_4460]]) + 1 < 0 or _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1
                                    mem[_4460 + ceil32(return_data.size)] = _4501
                                    require _4485 + (32 * _4501) + 32 <= return_data.size
                                    mem[_4460 + ceil32(return_data.size) + 32 len ceil32(32 * _4501)] = mem[_4460 + _4485 + 32 len ceil32(32 * _4501)]
                                    if 1 >= _4501:
                                        revert with 0, 50
                                    _5185 = mem[_4460 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5308 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5185) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5308]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5308] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5308]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5308] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5308] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5357 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5357]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5357] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5357]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5357] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5357] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5696 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5696]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / u * v) / mem[_5696] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / u * v) / mem[_5696]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / u * v) / mem[_5696] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / u * v) / mem[_5696] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4474 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4474]:
                                        revert with 0, 50
                                    mem[_4474 + 32] = token1Address
                                    if 1 >= mem[_4474]:
                                        revert with 0, 50
                                    mem[_4474 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4474 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4474 + 100] = u * v
                                    mem[_4474 + 132] = 64
                                    mem[_4474 + 164] = mem[_4474]
                                    idx = 0
                                    u = _4474 + 32
                                    v = _4474 + 196
                                    while idx < mem[_4474]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4474 + (32 * mem[_4474]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5200 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5209 = mem[_5200]
                                    require mem[_5200] <= test266151307()
                                    require _5200 + mem[_5200] + 31 < _5200 + return_data.size
                                    _5216 = mem[_5200 + mem[_5200]]
                                    if mem[_5200 + mem[_5200]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5200 + mem[_5200]]) + 1 < 0 or _5200 + ceil32(return_data.size) + ceil32(32 * mem[_5200 + mem[_5200]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5200 + ceil32(return_data.size) + ceil32(32 * mem[_5200 + mem[_5200]]) + 1
                                    mem[_5200 + ceil32(return_data.size)] = _5216
                                    require _5209 + (32 * _5216) + 32 <= return_data.size
                                    mem[_5200 + ceil32(return_data.size) + 32 len ceil32(32 * _5216)] = mem[_5200 + _5209 + 32 len ceil32(32 * _5216)]
                                    if 1 >= _5216:
                                        revert with 0, 50
                                    _5660 = mem[_5200 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5200 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5200 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5660) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5733]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660) / mem[_5733] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660) / mem[_5733]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660) / mem[_5733] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660) / mem[_5733] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5200 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5200 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5757 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5660 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5757]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / 10^sub_3266f45c) / mem[_5757] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / 10^sub_3266f45c) / mem[_5757]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / 10^sub_3266f45c) / mem[_5757] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / 10^sub_3266f45c) / mem[_5757] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5200 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5200 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5886 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5660 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5886]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / u * v) / mem[_5886] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / u * v) / mem[_5886]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / u * v) / mem[_5886] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2388 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5660 / u * v) / mem[_5886] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = s * t
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (4 * ceil32(return_data.size)) + 128
                    v = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2399 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2402 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    require _2399 + (32 * _2402) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2402)] = mem[(4 * ceil32(return_data.size)) + _2399 + 224 len ceil32(32 * _2402)]
                    if 1 >= _2402:
                        revert with 0, 50
                    _3475 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3634 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3634]:
                                revert with 0, 50
                            mem[_3634 + 32] = token1Address
                            if 1 >= mem[_3634]:
                                revert with 0, 50
                            mem[_3634 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3634 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3634 + 100] = 1
                            mem[_3634 + 132] = 64
                            mem[_3634 + 164] = mem[_3634]
                            idx = 0
                            s = _3634 + 32
                            t = _3634 + 196
                            while idx < mem[_3634]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3634 + (32 * mem[_3634]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4457 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4483 = mem[_4457]
                            require mem[_4457] <= test266151307()
                            require _4457 + mem[_4457] + 31 < _4457 + return_data.size
                            _4499 = mem[_4457 + mem[_4457]]
                            if mem[_4457 + mem[_4457]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4457 + mem[_4457]]) + 1 < 0 or _4457 + ceil32(return_data.size) + ceil32(32 * mem[_4457 + mem[_4457]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4457 + ceil32(return_data.size) + ceil32(32 * mem[_4457 + mem[_4457]]) + 1
                            mem[_4457 + ceil32(return_data.size)] = _4499
                            require _4483 + (32 * _4499) + 32 <= return_data.size
                            mem[_4457 + ceil32(return_data.size) + 32 len ceil32(32 * _4499)] = mem[_4457 + _4483 + 32 len ceil32(32 * _4499)]
                            if 1 >= _4499:
                                revert with 0, 50
                            _5183 = mem[_4457 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4457 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4457 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5307 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5183) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5307]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5307] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5307]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5307] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5307] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4457 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4457 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5356 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5356]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5356] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5356]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5356] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5356] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4457 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4457 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5695 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5695]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / s * t) / mem[_5695] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / s * t) / mem[_5695]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / s * t) / mem[_5695] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / s * t) / mem[_5695] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3678 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3678]:
                                    revert with 0, 50
                                mem[_3678 + 32] = token1Address
                                if 1 >= mem[_3678]:
                                    revert with 0, 50
                                mem[_3678 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3678 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3678 + 100] = 10^sub_3266f45c
                                mem[_3678 + 132] = 64
                                mem[_3678 + 164] = mem[_3678]
                                idx = 0
                                s = _3678 + 32
                                t = _3678 + 196
                                while idx < mem[_3678]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3678 + (32 * mem[_3678]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4456 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4482 = mem[_4456]
                                require mem[_4456] <= test266151307()
                                require _4456 + mem[_4456] + 31 < _4456 + return_data.size
                                _4498 = mem[_4456 + mem[_4456]]
                                if mem[_4456 + mem[_4456]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4456 + mem[_4456]]) + 1 < 0 or _4456 + ceil32(return_data.size) + ceil32(32 * mem[_4456 + mem[_4456]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4456 + ceil32(return_data.size) + ceil32(32 * mem[_4456 + mem[_4456]]) + 1
                                mem[_4456 + ceil32(return_data.size)] = _4498
                                require _4482 + (32 * _4498) + 32 <= return_data.size
                                mem[_4456 + ceil32(return_data.size) + 32 len ceil32(32 * _4498)] = mem[_4456 + _4482 + 32 len ceil32(32 * _4498)]
                                if 1 >= _4498:
                                    revert with 0, 50
                                _5182 = mem[_4456 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5306 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5182) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5306]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5306] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5306]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5306] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5306] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5355 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5355]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5355] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5355]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5355] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5355] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4456 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4456 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5694 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5182 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5694]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / s * t) / mem[_5694] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / s * t) / mem[_5694]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / s * t) / mem[_5694] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / s * t) / mem[_5694] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4472 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4472]:
                                    revert with 0, 50
                                mem[_4472 + 32] = token1Address
                                if 1 >= mem[_4472]:
                                    revert with 0, 50
                                mem[_4472 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4472 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4472 + 100] = s * t
                                mem[_4472 + 132] = 64
                                mem[_4472 + 164] = mem[_4472]
                                idx = 0
                                s = _4472 + 32
                                t = _4472 + 196
                                while idx < mem[_4472]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4472 + (32 * mem[_4472]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5199 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5208 = mem[_5199]
                                require mem[_5199] <= test266151307()
                                require _5199 + mem[_5199] + 31 < _5199 + return_data.size
                                _5215 = mem[_5199 + mem[_5199]]
                                if mem[_5199 + mem[_5199]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5199 + mem[_5199]]) + 1 < 0 or _5199 + ceil32(return_data.size) + ceil32(32 * mem[_5199 + mem[_5199]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5199 + ceil32(return_data.size) + ceil32(32 * mem[_5199 + mem[_5199]]) + 1
                                mem[_5199 + ceil32(return_data.size)] = _5215
                                require _5208 + (32 * _5215) + 32 <= return_data.size
                                mem[_5199 + ceil32(return_data.size) + 32 len ceil32(32 * _5215)] = mem[_5199 + _5208 + 32 len ceil32(32 * _5215)]
                                if 1 >= _5215:
                                    revert with 0, 50
                                _5659 = mem[_5199 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5199 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5199 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5732 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5659) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5732]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659) / mem[_5732] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659) / mem[_5732]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659) / mem[_5732] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659) / mem[_5732] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5199 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5199 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5756 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5659 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5756]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / 10^sub_3266f45c) / mem[_5756] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / 10^sub_3266f45c) / mem[_5756]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / 10^sub_3266f45c) / mem[_5756] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / 10^sub_3266f45c) / mem[_5756] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5199 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5199 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5885 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475) + (Mask(112, 0, ext_call.return_data[32]) * _5659 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5885]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / s * t) / mem[_5885] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / s * t) / mem[_5885]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / s * t) / mem[_5885] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5659 / s * t) / mem[_5885] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3676 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3676]:
                                    revert with 0, 50
                                mem[_3676 + 32] = token1Address
                                if 1 >= mem[_3676]:
                                    revert with 0, 50
                                mem[_3676 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3676 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3676 + 100] = 1
                                mem[_3676 + 132] = 64
                                mem[_3676 + 164] = mem[_3676]
                                idx = 0
                                s = _3676 + 32
                                t = _3676 + 196
                                while idx < mem[_3676]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3676 + (32 * mem[_3676]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4453 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4480 = mem[_4453]
                                require mem[_4453] <= test266151307()
                                require _4453 + mem[_4453] + 31 < _4453 + return_data.size
                                _4496 = mem[_4453 + mem[_4453]]
                                if mem[_4453 + mem[_4453]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4453 + mem[_4453]]) + 1 < 0 or _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1
                                mem[_4453 + ceil32(return_data.size)] = _4496
                                require _4480 + (32 * _4496) + 32 <= return_data.size
                                mem[_4453 + ceil32(return_data.size) + 32 len ceil32(32 * _4496)] = mem[_4453 + _4480 + 32 len ceil32(32 * _4496)]
                                if 1 >= _4496:
                                    revert with 0, 50
                                _5180 = mem[_4453 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5305 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5305]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5305] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5305]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5305] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5305] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5354 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5354]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5354] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5354]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5354] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5354] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5693 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5693]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5693] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5693]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5693] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5693] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3736 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3736]:
                                        revert with 0, 50
                                    mem[_3736 + 32] = token1Address
                                    if 1 >= mem[_3736]:
                                        revert with 0, 50
                                    mem[_3736 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3736 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3736 + 100] = 10^sub_3266f45c
                                    mem[_3736 + 132] = 64
                                    mem[_3736 + 164] = mem[_3736]
                                    idx = 0
                                    s = _3736 + 32
                                    t = _3736 + 196
                                    while idx < mem[_3736]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3736 + (32 * mem[_3736]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4452 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4479 = mem[_4452]
                                    require mem[_4452] <= test266151307()
                                    require _4452 + mem[_4452] + 31 < _4452 + return_data.size
                                    _4495 = mem[_4452 + mem[_4452]]
                                    if mem[_4452 + mem[_4452]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4452 + mem[_4452]]) + 1 < 0 or _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1
                                    mem[_4452 + ceil32(return_data.size)] = _4495
                                    require _4479 + (32 * _4495) + 32 <= return_data.size
                                    mem[_4452 + ceil32(return_data.size) + 32 len ceil32(32 * _4495)] = mem[_4452 + _4479 + 32 len ceil32(32 * _4495)]
                                    if 1 >= _4495:
                                        revert with 0, 50
                                    _5179 = mem[_4452 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5304 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5304]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5304] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5304]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5304] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5304] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5353 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5353]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5353] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5353]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5353] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5353] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5692 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5692]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5692] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5692]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5692] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5692] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4470 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4470]:
                                        revert with 0, 50
                                    mem[_4470 + 32] = token1Address
                                    if 1 >= mem[_4470]:
                                        revert with 0, 50
                                    mem[_4470 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4470 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4470 + 100] = s * t
                                    mem[_4470 + 132] = 64
                                    mem[_4470 + 164] = mem[_4470]
                                    idx = 0
                                    s = _4470 + 32
                                    t = _4470 + 196
                                    while idx < mem[_4470]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4470 + (32 * mem[_4470]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5198 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5207 = mem[_5198]
                                    require mem[_5198] <= test266151307()
                                    require _5198 + mem[_5198] + 31 < _5198 + return_data.size
                                    _5214 = mem[_5198 + mem[_5198]]
                                    if mem[_5198 + mem[_5198]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5198 + mem[_5198]]) + 1 < 0 or _5198 + ceil32(return_data.size) + ceil32(32 * mem[_5198 + mem[_5198]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5198 + ceil32(return_data.size) + ceil32(32 * mem[_5198 + mem[_5198]]) + 1
                                    mem[_5198 + ceil32(return_data.size)] = _5214
                                    require _5207 + (32 * _5214) + 32 <= return_data.size
                                    mem[_5198 + ceil32(return_data.size) + 32 len ceil32(32 * _5214)] = mem[_5198 + _5207 + 32 len ceil32(32 * _5214)]
                                    if 1 >= _5214:
                                        revert with 0, 50
                                    _5658 = mem[_5198 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5198 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5198 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5731 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5658) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5731]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658) / mem[_5731] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658) / mem[_5731]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658) / mem[_5731] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658) / mem[_5731] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5198 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5198 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5755 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5658 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5755]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / 10^sub_3266f45c) / mem[_5755] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / 10^sub_3266f45c) / mem[_5755]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / 10^sub_3266f45c) / mem[_5755] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / 10^sub_3266f45c) / mem[_5755] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5198 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5198 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5884 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5658 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5884]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / s * t) / mem[_5884] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / s * t) / mem[_5884]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / s * t) / mem[_5884] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5658 / s * t) / mem[_5884] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4572 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4572]:
                                    revert with 0, 50
                                mem[_4572 + 32] = token1Address
                                if 1 >= mem[_4572]:
                                    revert with 0, 50
                                mem[_4572 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4572 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4572 + 100] = 1
                                mem[_4572 + 132] = 64
                                mem[_4572 + 164] = mem[_4572]
                                idx = 0
                                u = _4572 + 32
                                v = _4572 + 196
                                while idx < mem[_4572]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4572 + (32 * mem[_4572]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5197 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5206 = mem[_5197]
                                require mem[_5197] <= test266151307()
                                require _5197 + mem[_5197] + 31 < _5197 + return_data.size
                                _5213 = mem[_5197 + mem[_5197]]
                                if mem[_5197 + mem[_5197]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5197 + mem[_5197]]) + 1 < 0 or _5197 + ceil32(return_data.size) + ceil32(32 * mem[_5197 + mem[_5197]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5197 + ceil32(return_data.size) + ceil32(32 * mem[_5197 + mem[_5197]]) + 1
                                mem[_5197 + ceil32(return_data.size)] = _5213
                                require _5206 + (32 * _5213) + 32 <= return_data.size
                                mem[_5197 + ceil32(return_data.size) + 32 len ceil32(32 * _5213)] = mem[_5197 + _5206 + 32 len ceil32(32 * _5213)]
                                if 1 >= _5213:
                                    revert with 0, 50
                                _5657 = mem[_5197 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5197 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5197 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5730 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5657) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5730]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5730] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5730]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5730] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5730] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5197 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5197 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5754 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5754]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5754] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5754]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5754] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5754] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5197 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5197 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5883 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5657 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5883]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / u * v) / mem[_5883] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / u * v) / mem[_5883]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / u * v) / mem[_5883] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / u * v) / mem[_5883] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4624 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4624]:
                                        revert with 0, 50
                                    mem[_4624 + 32] = token1Address
                                    if 1 >= mem[_4624]:
                                        revert with 0, 50
                                    mem[_4624 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4624 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4624 + 100] = 10^sub_3266f45c
                                    mem[_4624 + 132] = 64
                                    mem[_4624 + 164] = mem[_4624]
                                    idx = 0
                                    u = _4624 + 32
                                    v = _4624 + 196
                                    while idx < mem[_4624]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4624 + (32 * mem[_4624]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5196 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5205 = mem[_5196]
                                    require mem[_5196] <= test266151307()
                                    require _5196 + mem[_5196] + 31 < _5196 + return_data.size
                                    _5212 = mem[_5196 + mem[_5196]]
                                    if mem[_5196 + mem[_5196]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5196 + mem[_5196]]) + 1 < 0 or _5196 + ceil32(return_data.size) + ceil32(32 * mem[_5196 + mem[_5196]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5196 + ceil32(return_data.size) + ceil32(32 * mem[_5196 + mem[_5196]]) + 1
                                    mem[_5196 + ceil32(return_data.size)] = _5212
                                    require _5205 + (32 * _5212) + 32 <= return_data.size
                                    mem[_5196 + ceil32(return_data.size) + 32 len ceil32(32 * _5212)] = mem[_5196 + _5205 + 32 len ceil32(32 * _5212)]
                                    if 1 >= _5212:
                                        revert with 0, 50
                                    _5656 = mem[_5196 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5196 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5196 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5729 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5656) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5729]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5729] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5729]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5729] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5729] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5196 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5196 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5753 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5753]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5753] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5753]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5753] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5753] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5196 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5196 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5882 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5656 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5882]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / u * v) / mem[_5882] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / u * v) / mem[_5882]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / u * v) / mem[_5882] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / u * v) / mem[_5882] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5202 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5202]:
                                        revert with 0, 50
                                    mem[_5202 + 32] = token1Address
                                    if 1 >= mem[_5202]:
                                        revert with 0, 50
                                    mem[_5202 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5202 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5202 + 100] = u * v
                                    mem[_5202 + 132] = 64
                                    mem[_5202 + 164] = mem[_5202]
                                    idx = 0
                                    u = _5202 + 32
                                    v = _5202 + 196
                                    while idx < mem[_5202]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5202 + (32 * mem[_5202]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5662 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5663 = mem[_5662]
                                    require mem[_5662] <= test266151307()
                                    require _5662 + mem[_5662] + 31 < _5662 + return_data.size
                                    _5664 = mem[_5662 + mem[_5662]]
                                    if mem[_5662 + mem[_5662]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5662 + mem[_5662]]) + 1 < 0 or _5662 + ceil32(return_data.size) + ceil32(32 * mem[_5662 + mem[_5662]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5662 + ceil32(return_data.size) + ceil32(32 * mem[_5662 + mem[_5662]]) + 1
                                    mem[_5662 + ceil32(return_data.size)] = _5664
                                    require _5663 + (32 * _5664) + 32 <= return_data.size
                                    mem[_5662 + ceil32(return_data.size) + 32 len ceil32(32 * _5664)] = mem[_5662 + _5663 + 32 len ceil32(32 * _5664)]
                                    if 1 >= _5664:
                                        revert with 0, 50
                                    _5869 = mem[_5662 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5896 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5869) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5896]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869) / mem[_5896] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869) / mem[_5896]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869) / mem[_5896] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869) / mem[_5896] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5900 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5869 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5900]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / 10^sub_3266f45c) / mem[_5900] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / 10^sub_3266f45c) / mem[_5900]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / 10^sub_3266f45c) / mem[_5900] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / 10^sub_3266f45c) / mem[_5900] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5926 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5869 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5926]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / u * v) / mem[_5926] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / u * v) / mem[_5926]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / u * v) / mem[_5926] * ext_call.return_data[32] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3475 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5869 / u * v) / mem[_5926] * ext_call.return_data[32] / 100 * 10^18 / 10^18
    return memory
      from mem[64]
       len 32
}

function sub_ba633017(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestRoundData() with:
            gas gas_remaining wei
    mem[96 len 160] = ext_call.return_data[0 len 160]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 160
    require ext_call.return_data[0] == ext_call.return_data[22 len 10]
    require ext_call.return_data[128] == ext_call.return_data[150 len 10]
    if ext_call.return_data[32] <= 0:
        revert with 0, 'Chainlink price <= 0'
    if not ext_call.return_data[96]:
        revert with 0, 'Incomplete round'
    if ext_call.return_data[150 len 10] < ext_call.return_data[22 len 10]:
        revert with 0, 'Stale price'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = token1Address
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = 1
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1356 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _1365 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _1365
            require _1356 + (32 * _1365) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1365)] = mem[(2 * ceil32(return_data.size)) + _1356 + 224 len ceil32(32 * _1365)]
            if 1 >= _1365:
                revert with 0, 50
            _2586 = mem[(4 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2631 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2586) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2631]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586) / mem[_2631] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586) / mem[_2631]:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586) / mem[_2631] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586) / mem[_2631] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2667 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2586 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2667]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / 10^sub_3266f45c) / mem[_2667] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / 10^sub_3266f45c) / mem[_2667]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / 10^sub_3266f45c) / mem[_2667] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / 10^sub_3266f45c) / mem[_2667] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3885 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2586 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3885]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / s * t) / mem[_3885] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / s * t) / mem[_3885]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / s * t) / mem[_3885] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2586 / s * t) / mem[_3885] * ext_call.return_data[32] / 100 * 10^18 / 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1355 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1364 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1364
                require _1355 + (32 * _1364) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1364)] = mem[(2 * ceil32(return_data.size)) + _1355 + 224 len ceil32(32 * _1364)]
                if 1 >= _1364:
                    revert with 0, 50
                _2585 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2630 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2585) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2630]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585) / mem[_2630] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585) / mem[_2630]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585) / mem[_2630] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585) / mem[_2630] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2666 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2585 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2666]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / 10^sub_3266f45c) / mem[_2666] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / 10^sub_3266f45c) / mem[_2666]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / 10^sub_3266f45c) / mem[_2666] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / 10^sub_3266f45c) / mem[_2666] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3884 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2585 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3884]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / s * t) / mem[_3884] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / s * t) / mem[_3884]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / s * t) / mem[_3884] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2585 / s * t) / mem[_3884] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = s * t
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (2 * ceil32(return_data.size)) + 128
                v = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2592 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _2595 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _2595
                require _2592 + (32 * _2595) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2595)] = mem[(2 * ceil32(return_data.size)) + _2592 + 224 len ceil32(32 * _2595)]
                if 1 >= _2595:
                    revert with 0, 50
                _3775 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3923 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3775) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3923]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775) / mem[_3923] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775) / mem[_3923]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775) / mem[_3923] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775) / mem[_3923] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3965 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3775 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3965]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / 10^sub_3266f45c) / mem[_3965] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / 10^sub_3266f45c) / mem[_3965]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / 10^sub_3266f45c) / mem[_3965] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / 10^sub_3266f45c) / mem[_3965] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4952 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3775 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4952]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / s * t) / mem[_4952] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / s * t) / mem[_4952]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / s * t) / mem[_4952] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3775 / s * t) / mem[_4952] * ext_call.return_data[32] / 100 * 10^18 / 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1353 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1362 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1362
                require _1353 + (32 * _1362) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1362)] = mem[(2 * ceil32(return_data.size)) + _1353 + 224 len ceil32(32 * _1362)]
                if 1 >= _1362:
                    revert with 0, 50
                _2583 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2629 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2583) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2629]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583) / mem[_2629] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583) / mem[_2629]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583) / mem[_2629] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583) / mem[_2629] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2665 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2583 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2665]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / 10^sub_9ddc230a) / mem[_2665] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / 10^sub_9ddc230a) / mem[_2665]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / 10^sub_9ddc230a) / mem[_2665] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / 10^sub_9ddc230a) / mem[_2665] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3883 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2583 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3883]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / s * t) / mem[_3883] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / s * t) / mem[_3883]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / s * t) / mem[_3883] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2583 / s * t) / mem[_3883] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1352 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1361 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1361
                    require _1352 + (32 * _1361) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1361)] = mem[(2 * ceil32(return_data.size)) + _1352 + 224 len ceil32(32 * _1361)]
                    if 1 >= _1361:
                        revert with 0, 50
                    _2582 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2628 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2582) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2628]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582) / mem[_2628] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582) / mem[_2628]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582) / mem[_2628] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582) / mem[_2628] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2664 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2582 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2664]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / 10^sub_9ddc230a) / mem[_2664] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / 10^sub_9ddc230a) / mem[_2664]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / 10^sub_9ddc230a) / mem[_2664] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / 10^sub_9ddc230a) / mem[_2664] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3882 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2582 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3882]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / s * t) / mem[_3882] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / s * t) / mem[_3882]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / s * t) / mem[_3882] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2582 / s * t) / mem[_3882] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2591 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2594 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2594
                    require _2591 + (32 * _2594) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2594)] = mem[(2 * ceil32(return_data.size)) + _2591 + 224 len ceil32(32 * _2594)]
                    if 1 >= _2594:
                        revert with 0, 50
                    _3774 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3922 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3774) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3922]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774) / mem[_3922] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774) / mem[_3922]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774) / mem[_3922] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774) / mem[_3922] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3964 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3774 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3964]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / 10^sub_9ddc230a) / mem[_3964] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / 10^sub_9ddc230a) / mem[_3964]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / 10^sub_9ddc230a) / mem[_3964] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / 10^sub_9ddc230a) / mem[_3964] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4951 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3774 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4951]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / s * t) / mem[_4951] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / s * t) / mem[_4951]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / s * t) / mem[_4951] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3774 / s * t) / mem[_4951] * ext_call.return_data[32] / 100 * 10^18 / 10^18
        else:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1350 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1359 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1359
                require _1350 + (32 * _1359) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1359)] = mem[(2 * ceil32(return_data.size)) + _1350 + 224 len ceil32(32 * _1359)]
                if 1 >= _1359:
                    revert with 0, 50
                _2580 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2634 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2634]:
                            revert with 0, 50
                        mem[_2634 + 32] = token1Address
                        if 1 >= mem[_2634]:
                            revert with 0, 50
                        mem[_2634 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2634 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2634 + 100] = 1
                        mem[_2634 + 132] = 64
                        mem[_2634 + 164] = mem[_2634]
                        idx = 0
                        s = _2634 + 32
                        t = _2634 + 196
                        while idx < mem[_2634]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2634 + (32 * mem[_2634]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3791 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3811 = mem[_3791]
                        require mem[_3791] <= test266151307()
                        require _3791 + mem[_3791] + 31 < _3791 + return_data.size
                        _3823 = mem[_3791 + mem[_3791]]
                        if mem[_3791 + mem[_3791]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3791 + mem[_3791]]) + 1 < 0 or _3791 + ceil32(return_data.size) + ceil32(32 * mem[_3791 + mem[_3791]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3791 + ceil32(return_data.size) + ceil32(32 * mem[_3791 + mem[_3791]]) + 1
                        mem[_3791 + ceil32(return_data.size)] = _3823
                        require _3811 + (32 * _3823) + 32 <= return_data.size
                        mem[_3791 + ceil32(return_data.size) + 32 len ceil32(32 * _3823)] = mem[_3791 + _3811 + 32 len ceil32(32 * _3823)]
                        if 1 >= _3823:
                            revert with 0, 50
                        _4830 = mem[_3791 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3791 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3791 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5002 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4830) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_5002]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830) / mem[_5002] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830) / mem[_5002]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830) / mem[_5002] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830) / mem[_5002] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3791 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3791 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5048 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4830 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5048]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / 10^sub_3266f45c) / mem[_5048] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / 10^sub_3266f45c) / mem[_5048]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / 10^sub_3266f45c) / mem[_5048] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / 10^sub_3266f45c) / mem[_5048] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3791 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3791 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5727 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4830 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5727]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / s * t) / mem[_5727] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / s * t) / mem[_5727]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / s * t) / mem[_5727] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4830 / s * t) / mem[_5727] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2675 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2675]:
                                revert with 0, 50
                            mem[_2675 + 32] = token1Address
                            if 1 >= mem[_2675]:
                                revert with 0, 50
                            mem[_2675 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2675 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2675 + 100] = 10^sub_3266f45c
                            mem[_2675 + 132] = 64
                            mem[_2675 + 164] = mem[_2675]
                            idx = 0
                            s = _2675 + 32
                            t = _2675 + 196
                            while idx < mem[_2675]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2675 + (32 * mem[_2675]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3790 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3810 = mem[_3790]
                            require mem[_3790] <= test266151307()
                            require _3790 + mem[_3790] + 31 < _3790 + return_data.size
                            _3822 = mem[_3790 + mem[_3790]]
                            if mem[_3790 + mem[_3790]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3790 + mem[_3790]]) + 1 < 0 or _3790 + ceil32(return_data.size) + ceil32(32 * mem[_3790 + mem[_3790]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3790 + ceil32(return_data.size) + ceil32(32 * mem[_3790 + mem[_3790]]) + 1
                            mem[_3790 + ceil32(return_data.size)] = _3822
                            require _3810 + (32 * _3822) + 32 <= return_data.size
                            mem[_3790 + ceil32(return_data.size) + 32 len ceil32(32 * _3822)] = mem[_3790 + _3810 + 32 len ceil32(32 * _3822)]
                            if 1 >= _3822:
                                revert with 0, 50
                            _4829 = mem[_3790 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3790 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3790 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5001 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4829) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5001]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829) / mem[_5001] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829) / mem[_5001]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829) / mem[_5001] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829) / mem[_5001] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3790 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3790 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5047 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4829 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5047]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / 10^sub_3266f45c) / mem[_5047] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / 10^sub_3266f45c) / mem[_5047]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / 10^sub_3266f45c) / mem[_5047] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / 10^sub_3266f45c) / mem[_5047] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3790 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3790 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5726 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _4829 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5726]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / s * t) / mem[_5726] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / s * t) / mem[_5726]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / s * t) / mem[_5726] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4829 / s * t) / mem[_5726] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3798 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3798]:
                                revert with 0, 50
                            mem[_3798 + 32] = token1Address
                            if 1 >= mem[_3798]:
                                revert with 0, 50
                            mem[_3798 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3798 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3798 + 100] = s * t
                            mem[_3798 + 132] = 64
                            mem[_3798 + 164] = mem[_3798]
                            idx = 0
                            s = _3798 + 32
                            t = _3798 + 196
                            while idx < mem[_3798]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3798 + (32 * mem[_3798]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4850 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4874 = mem[_4850]
                            require mem[_4850] <= test266151307()
                            require _4850 + mem[_4850] + 31 < _4850 + return_data.size
                            _4890 = mem[_4850 + mem[_4850]]
                            if mem[_4850 + mem[_4850]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4850 + mem[_4850]]) + 1 < 0 or _4850 + ceil32(return_data.size) + ceil32(32 * mem[_4850 + mem[_4850]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4850 + ceil32(return_data.size) + ceil32(32 * mem[_4850 + mem[_4850]]) + 1
                            mem[_4850 + ceil32(return_data.size)] = _4890
                            require _4874 + (32 * _4890) + 32 <= return_data.size
                            mem[_4850 + ceil32(return_data.size) + 32 len ceil32(32 * _4890)] = mem[_4850 + _4874 + 32 len ceil32(32 * _4890)]
                            if 1 >= _4890:
                                revert with 0, 50
                            _5657 = mem[_4850 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4850 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4850 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5779 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _5657) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5779]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5779] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5779]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5779] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657) / mem[_5779] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4850 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4850 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5828 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5828]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5828] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5828]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5828] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / 10^sub_3266f45c) / mem[_5828] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4850 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4850 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6232 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580) + (Mask(112, 0, ext_call.return_data[32]) * _5657 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6232]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / s * t) / mem[_6232] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / s * t) / mem[_6232]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / s * t) / mem[_6232] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5657 / s * t) / mem[_6232] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2673 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2673]:
                                revert with 0, 50
                            mem[_2673 + 32] = token1Address
                            if 1 >= mem[_2673]:
                                revert with 0, 50
                            mem[_2673 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2673 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2673 + 100] = 1
                            mem[_2673 + 132] = 64
                            mem[_2673 + 164] = mem[_2673]
                            idx = 0
                            s = _2673 + 32
                            t = _2673 + 196
                            while idx < mem[_2673]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2673 + (32 * mem[_2673]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3787 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3808 = mem[_3787]
                            require mem[_3787] <= test266151307()
                            require _3787 + mem[_3787] + 31 < _3787 + return_data.size
                            _3820 = mem[_3787 + mem[_3787]]
                            if mem[_3787 + mem[_3787]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3787 + mem[_3787]]) + 1 < 0 or _3787 + ceil32(return_data.size) + ceil32(32 * mem[_3787 + mem[_3787]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3787 + ceil32(return_data.size) + ceil32(32 * mem[_3787 + mem[_3787]]) + 1
                            mem[_3787 + ceil32(return_data.size)] = _3820
                            require _3808 + (32 * _3820) + 32 <= return_data.size
                            mem[_3787 + ceil32(return_data.size) + 32 len ceil32(32 * _3820)] = mem[_3787 + _3808 + 32 len ceil32(32 * _3820)]
                            if 1 >= _3820:
                                revert with 0, 50
                            _4827 = mem[_3787 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3787 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3787 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5000 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4827) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5000]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827) / mem[_5000] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827) / mem[_5000]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827) / mem[_5000] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827) / mem[_5000] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3787 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3787 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5046 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4827 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5046]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / 10^sub_3266f45c) / mem[_5046] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / 10^sub_3266f45c) / mem[_5046]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / 10^sub_3266f45c) / mem[_5046] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / 10^sub_3266f45c) / mem[_5046] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3787 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3787 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5725 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4827 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5725]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / s * t) / mem[_5725] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / s * t) / mem[_5725]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / s * t) / mem[_5725] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4827 / s * t) / mem[_5725] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2735 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2735]:
                                    revert with 0, 50
                                mem[_2735 + 32] = token1Address
                                if 1 >= mem[_2735]:
                                    revert with 0, 50
                                mem[_2735 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2735 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2735 + 100] = 10^sub_3266f45c
                                mem[_2735 + 132] = 64
                                mem[_2735 + 164] = mem[_2735]
                                idx = 0
                                s = _2735 + 32
                                t = _2735 + 196
                                while idx < mem[_2735]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2735 + (32 * mem[_2735]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3786 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3807 = mem[_3786]
                                require mem[_3786] <= test266151307()
                                require _3786 + mem[_3786] + 31 < _3786 + return_data.size
                                _3819 = mem[_3786 + mem[_3786]]
                                if mem[_3786 + mem[_3786]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3786 + mem[_3786]]) + 1 < 0 or _3786 + ceil32(return_data.size) + ceil32(32 * mem[_3786 + mem[_3786]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3786 + ceil32(return_data.size) + ceil32(32 * mem[_3786 + mem[_3786]]) + 1
                                mem[_3786 + ceil32(return_data.size)] = _3819
                                require _3807 + (32 * _3819) + 32 <= return_data.size
                                mem[_3786 + ceil32(return_data.size) + 32 len ceil32(32 * _3819)] = mem[_3786 + _3807 + 32 len ceil32(32 * _3819)]
                                if 1 >= _3819:
                                    revert with 0, 50
                                _4826 = mem[_3786 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3786 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3786 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4999 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4826) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4999]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826) / mem[_4999] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826) / mem[_4999]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826) / mem[_4999] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826) / mem[_4999] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3786 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3786 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5045 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4826 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5045]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / 10^sub_3266f45c) / mem[_5045] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / 10^sub_3266f45c) / mem[_5045]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / 10^sub_3266f45c) / mem[_5045] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / 10^sub_3266f45c) / mem[_5045] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3786 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3786 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5724 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4826 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5724]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / s * t) / mem[_5724] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / s * t) / mem[_5724]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / s * t) / mem[_5724] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4826 / s * t) / mem[_5724] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3796 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3796]:
                                    revert with 0, 50
                                mem[_3796 + 32] = token1Address
                                if 1 >= mem[_3796]:
                                    revert with 0, 50
                                mem[_3796 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3796 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3796 + 100] = s * t
                                mem[_3796 + 132] = 64
                                mem[_3796 + 164] = mem[_3796]
                                idx = 0
                                s = _3796 + 32
                                t = _3796 + 196
                                while idx < mem[_3796]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3796 + (32 * mem[_3796]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4849 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4873 = mem[_4849]
                                require mem[_4849] <= test266151307()
                                require _4849 + mem[_4849] + 31 < _4849 + return_data.size
                                _4889 = mem[_4849 + mem[_4849]]
                                if mem[_4849 + mem[_4849]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4849 + mem[_4849]]) + 1 < 0 or _4849 + ceil32(return_data.size) + ceil32(32 * mem[_4849 + mem[_4849]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4849 + ceil32(return_data.size) + ceil32(32 * mem[_4849 + mem[_4849]]) + 1
                                mem[_4849 + ceil32(return_data.size)] = _4889
                                require _4873 + (32 * _4889) + 32 <= return_data.size
                                mem[_4849 + ceil32(return_data.size) + 32 len ceil32(32 * _4889)] = mem[_4849 + _4873 + 32 len ceil32(32 * _4889)]
                                if 1 >= _4889:
                                    revert with 0, 50
                                _5656 = mem[_4849 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4849 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4849 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5778 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5656) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5778]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5778] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5778]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5778] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656) / mem[_5778] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4849 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4849 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5827 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5827]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5827] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5827]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5827] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / 10^sub_3266f45c) / mem[_5827] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4849 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4849 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6231 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5656 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6231]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / s * t) / mem[_6231] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / s * t) / mem[_6231]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / s * t) / mem[_6231] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5656 / s * t) / mem[_6231] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3892 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3892]:
                                revert with 0, 50
                            mem[_3892 + 32] = token1Address
                            if 1 >= mem[_3892]:
                                revert with 0, 50
                            mem[_3892 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3892 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3892 + 100] = 1
                            mem[_3892 + 132] = 64
                            mem[_3892 + 164] = mem[_3892]
                            idx = 0
                            u = _3892 + 32
                            v = _3892 + 196
                            while idx < mem[_3892]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3892 + (32 * mem[_3892]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4848 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4872 = mem[_4848]
                            require mem[_4848] <= test266151307()
                            require _4848 + mem[_4848] + 31 < _4848 + return_data.size
                            _4888 = mem[_4848 + mem[_4848]]
                            if mem[_4848 + mem[_4848]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4848 + mem[_4848]]) + 1 < 0 or _4848 + ceil32(return_data.size) + ceil32(32 * mem[_4848 + mem[_4848]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4848 + ceil32(return_data.size) + ceil32(32 * mem[_4848 + mem[_4848]]) + 1
                            mem[_4848 + ceil32(return_data.size)] = _4888
                            require _4872 + (32 * _4888) + 32 <= return_data.size
                            mem[_4848 + ceil32(return_data.size) + 32 len ceil32(32 * _4888)] = mem[_4848 + _4872 + 32 len ceil32(32 * _4888)]
                            if 1 >= _4888:
                                revert with 0, 50
                            _5655 = mem[_4848 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4848 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4848 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5777 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5655) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5777]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655) / mem[_5777] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655) / mem[_5777]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655) / mem[_5777] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655) / mem[_5777] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4848 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4848 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5826 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5655 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5826]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / 10^sub_3266f45c) / mem[_5826] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / 10^sub_3266f45c) / mem[_5826]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / 10^sub_3266f45c) / mem[_5826] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / 10^sub_3266f45c) / mem[_5826] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4848 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4848 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6230 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5655 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6230]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / u * v) / mem[_6230] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / u * v) / mem[_6230]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / u * v) / mem[_6230] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5655 / u * v) / mem[_6230] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3936 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3936]:
                                    revert with 0, 50
                                mem[_3936 + 32] = token1Address
                                if 1 >= mem[_3936]:
                                    revert with 0, 50
                                mem[_3936 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3936 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3936 + 100] = 10^sub_3266f45c
                                mem[_3936 + 132] = 64
                                mem[_3936 + 164] = mem[_3936]
                                idx = 0
                                u = _3936 + 32
                                v = _3936 + 196
                                while idx < mem[_3936]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3936 + (32 * mem[_3936]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4847 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4871 = mem[_4847]
                                require mem[_4847] <= test266151307()
                                require _4847 + mem[_4847] + 31 < _4847 + return_data.size
                                _4887 = mem[_4847 + mem[_4847]]
                                if mem[_4847 + mem[_4847]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4847 + mem[_4847]]) + 1 < 0 or _4847 + ceil32(return_data.size) + ceil32(32 * mem[_4847 + mem[_4847]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4847 + ceil32(return_data.size) + ceil32(32 * mem[_4847 + mem[_4847]]) + 1
                                mem[_4847 + ceil32(return_data.size)] = _4887
                                require _4871 + (32 * _4887) + 32 <= return_data.size
                                mem[_4847 + ceil32(return_data.size) + 32 len ceil32(32 * _4887)] = mem[_4847 + _4871 + 32 len ceil32(32 * _4887)]
                                if 1 >= _4887:
                                    revert with 0, 50
                                _5654 = mem[_4847 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4847 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4847 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5776 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5776]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5776] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5776]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5776] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654) / mem[_5776] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4847 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4847 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5825 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5825]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5825] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5825]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5825] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / 10^sub_3266f45c) / mem[_5825] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4847 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4847 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6229 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6229]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_6229] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_6229]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_6229] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5654 / u * v) / mem[_6229] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4857 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4857]:
                                    revert with 0, 50
                                mem[_4857 + 32] = token1Address
                                if 1 >= mem[_4857]:
                                    revert with 0, 50
                                mem[_4857 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4857 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4857 + 100] = u * v
                                mem[_4857 + 132] = 64
                                mem[_4857 + 164] = mem[_4857]
                                idx = 0
                                u = _4857 + 32
                                v = _4857 + 196
                                while idx < mem[_4857]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4857 + (32 * mem[_4857]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5665 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5674 = mem[_5665]
                                require mem[_5665] <= test266151307()
                                require _5665 + mem[_5665] + 31 < _5665 + return_data.size
                                _5681 = mem[_5665 + mem[_5665]]
                                if mem[_5665 + mem[_5665]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5665 + mem[_5665]]) + 1 < 0 or _5665 + ceil32(return_data.size) + ceil32(32 * mem[_5665 + mem[_5665]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5665 + ceil32(return_data.size) + ceil32(32 * mem[_5665 + mem[_5665]]) + 1
                                mem[_5665 + ceil32(return_data.size)] = _5681
                                require _5674 + (32 * _5681) + 32 <= return_data.size
                                mem[_5665 + ceil32(return_data.size) + 32 len ceil32(32 * _5681)] = mem[_5665 + _5674 + 32 len ceil32(32 * _5681)]
                                if 1 >= _5681:
                                    revert with 0, 50
                                _6190 = mem[_5665 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5665 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5665 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6263 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6190) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6263]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190) / mem[_6263] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190) / mem[_6263]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190) / mem[_6263] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190) / mem[_6263] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5665 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5665 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6287 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6190 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6287]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / 10^sub_3266f45c) / mem[_6287] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / 10^sub_3266f45c) / mem[_6287]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / 10^sub_3266f45c) / mem[_6287] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / 10^sub_3266f45c) / mem[_6287] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5665 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5665 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6449 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6190 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6449]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / u * v) / mem[_6449] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / u * v) / mem[_6449]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / u * v) / mem[_6449] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2580 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6190 / u * v) / mem[_6449] * ext_call.return_data[32] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1349 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1358 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1358
                    require _1349 + (32 * _1358) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1358)] = mem[(2 * ceil32(return_data.size)) + _1349 + 224 len ceil32(32 * _1358)]
                    if 1 >= _1358:
                        revert with 0, 50
                    _2579 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2632 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2632]:
                                revert with 0, 50
                            mem[_2632 + 32] = token1Address
                            if 1 >= mem[_2632]:
                                revert with 0, 50
                            mem[_2632 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2632 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2632 + 100] = 1
                            mem[_2632 + 132] = 64
                            mem[_2632 + 164] = mem[_2632]
                            idx = 0
                            s = _2632 + 32
                            t = _2632 + 196
                            while idx < mem[_2632]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2632 + (32 * mem[_2632]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3783 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3805 = mem[_3783]
                            require mem[_3783] <= test266151307()
                            require _3783 + mem[_3783] + 31 < _3783 + return_data.size
                            _3817 = mem[_3783 + mem[_3783]]
                            if mem[_3783 + mem[_3783]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3783 + mem[_3783]]) + 1 < 0 or _3783 + ceil32(return_data.size) + ceil32(32 * mem[_3783 + mem[_3783]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3783 + ceil32(return_data.size) + ceil32(32 * mem[_3783 + mem[_3783]]) + 1
                            mem[_3783 + ceil32(return_data.size)] = _3817
                            require _3805 + (32 * _3817) + 32 <= return_data.size
                            mem[_3783 + ceil32(return_data.size) + 32 len ceil32(32 * _3817)] = mem[_3783 + _3805 + 32 len ceil32(32 * _3817)]
                            if 1 >= _3817:
                                revert with 0, 50
                            _4822 = mem[_3783 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4997 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4822) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4997]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4997] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4997]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4997] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4997] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5044 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5044]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5044] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5044]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5044] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5044] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5722 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5722]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5722] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5722]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5722] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5722] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2670 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2670]:
                                    revert with 0, 50
                                mem[_2670 + 32] = token1Address
                                if 1 >= mem[_2670]:
                                    revert with 0, 50
                                mem[_2670 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2670 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2670 + 100] = 10^sub_3266f45c
                                mem[_2670 + 132] = 64
                                mem[_2670 + 164] = mem[_2670]
                                idx = 0
                                s = _2670 + 32
                                t = _2670 + 196
                                while idx < mem[_2670]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2670 + (32 * mem[_2670]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3782 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3804 = mem[_3782]
                                require mem[_3782] <= test266151307()
                                require _3782 + mem[_3782] + 31 < _3782 + return_data.size
                                _3816 = mem[_3782 + mem[_3782]]
                                if mem[_3782 + mem[_3782]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3782 + mem[_3782]]) + 1 < 0 or _3782 + ceil32(return_data.size) + ceil32(32 * mem[_3782 + mem[_3782]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3782 + ceil32(return_data.size) + ceil32(32 * mem[_3782 + mem[_3782]]) + 1
                                mem[_3782 + ceil32(return_data.size)] = _3816
                                require _3804 + (32 * _3816) + 32 <= return_data.size
                                mem[_3782 + ceil32(return_data.size) + 32 len ceil32(32 * _3816)] = mem[_3782 + _3804 + 32 len ceil32(32 * _3816)]
                                if 1 >= _3816:
                                    revert with 0, 50
                                _4821 = mem[_3782 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4996 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4821) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4996]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4996] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4996]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4996] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4996] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5043 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5043]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5043] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5043]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5043] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5043] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5721 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5721]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5721] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5721]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5721] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5721] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3794 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3794]:
                                    revert with 0, 50
                                mem[_3794 + 32] = token1Address
                                if 1 >= mem[_3794]:
                                    revert with 0, 50
                                mem[_3794 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3794 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3794 + 100] = s * t
                                mem[_3794 + 132] = 64
                                mem[_3794 + 164] = mem[_3794]
                                idx = 0
                                s = _3794 + 32
                                t = _3794 + 196
                                while idx < mem[_3794]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3794 + (32 * mem[_3794]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4844 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4869 = mem[_4844]
                                require mem[_4844] <= test266151307()
                                require _4844 + mem[_4844] + 31 < _4844 + return_data.size
                                _4885 = mem[_4844 + mem[_4844]]
                                if mem[_4844 + mem[_4844]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4844 + mem[_4844]]) + 1 < 0 or _4844 + ceil32(return_data.size) + ceil32(32 * mem[_4844 + mem[_4844]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4844 + ceil32(return_data.size) + ceil32(32 * mem[_4844 + mem[_4844]]) + 1
                                mem[_4844 + ceil32(return_data.size)] = _4885
                                require _4869 + (32 * _4885) + 32 <= return_data.size
                                mem[_4844 + ceil32(return_data.size) + 32 len ceil32(32 * _4885)] = mem[_4844 + _4869 + 32 len ceil32(32 * _4885)]
                                if 1 >= _4885:
                                    revert with 0, 50
                                _5652 = mem[_4844 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4844 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4844 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5775 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _5652) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5775]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5775] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5775]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5775] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5775] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4844 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4844 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5824 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5824]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5824] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5824]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5824] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5824] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4844 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4844 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6228 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6228]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_6228] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_6228]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_6228] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / s * t) / mem[_6228] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2668 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2668]:
                                    revert with 0, 50
                                mem[_2668 + 32] = token1Address
                                if 1 >= mem[_2668]:
                                    revert with 0, 50
                                mem[_2668 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2668 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2668 + 100] = 1
                                mem[_2668 + 132] = 64
                                mem[_2668 + 164] = mem[_2668]
                                idx = 0
                                s = _2668 + 32
                                t = _2668 + 196
                                while idx < mem[_2668]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2668 + (32 * mem[_2668]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3779 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3802 = mem[_3779]
                                require mem[_3779] <= test266151307()
                                require _3779 + mem[_3779] + 31 < _3779 + return_data.size
                                _3814 = mem[_3779 + mem[_3779]]
                                if mem[_3779 + mem[_3779]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3779 + mem[_3779]]) + 1 < 0 or _3779 + ceil32(return_data.size) + ceil32(32 * mem[_3779 + mem[_3779]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3779 + ceil32(return_data.size) + ceil32(32 * mem[_3779 + mem[_3779]]) + 1
                                mem[_3779 + ceil32(return_data.size)] = _3814
                                require _3802 + (32 * _3814) + 32 <= return_data.size
                                mem[_3779 + ceil32(return_data.size) + 32 len ceil32(32 * _3814)] = mem[_3779 + _3802 + 32 len ceil32(32 * _3814)]
                                if 1 >= _3814:
                                    revert with 0, 50
                                _4819 = mem[_3779 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4995 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4995]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4995] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4995]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4995] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4995] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5042 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5042]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5042] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5042]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5042] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5042] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5720 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5720]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5720] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5720]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5720] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5720] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2729 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2729]:
                                        revert with 0, 50
                                    mem[_2729 + 32] = token1Address
                                    if 1 >= mem[_2729]:
                                        revert with 0, 50
                                    mem[_2729 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2729 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2729 + 100] = 10^sub_3266f45c
                                    mem[_2729 + 132] = 64
                                    mem[_2729 + 164] = mem[_2729]
                                    idx = 0
                                    s = _2729 + 32
                                    t = _2729 + 196
                                    while idx < mem[_2729]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2729 + (32 * mem[_2729]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3778 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3801 = mem[_3778]
                                    require mem[_3778] <= test266151307()
                                    require _3778 + mem[_3778] + 31 < _3778 + return_data.size
                                    _3813 = mem[_3778 + mem[_3778]]
                                    if mem[_3778 + mem[_3778]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3778 + mem[_3778]]) + 1 < 0 or _3778 + ceil32(return_data.size) + ceil32(32 * mem[_3778 + mem[_3778]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3778 + ceil32(return_data.size) + ceil32(32 * mem[_3778 + mem[_3778]]) + 1
                                    mem[_3778 + ceil32(return_data.size)] = _3813
                                    require _3801 + (32 * _3813) + 32 <= return_data.size
                                    mem[_3778 + ceil32(return_data.size) + 32 len ceil32(32 * _3813)] = mem[_3778 + _3801 + 32 len ceil32(32 * _3813)]
                                    if 1 >= _3813:
                                        revert with 0, 50
                                    _4818 = mem[_3778 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4994 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4994]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4994] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4994]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4994] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4994] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5041 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5041]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5041] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5041]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5041] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5041] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5719 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5719]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5719] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5719]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5719] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5719] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3792 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3792]:
                                        revert with 0, 50
                                    mem[_3792 + 32] = token1Address
                                    if 1 >= mem[_3792]:
                                        revert with 0, 50
                                    mem[_3792 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3792 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3792 + 100] = s * t
                                    mem[_3792 + 132] = 64
                                    mem[_3792 + 164] = mem[_3792]
                                    idx = 0
                                    s = _3792 + 32
                                    t = _3792 + 196
                                    while idx < mem[_3792]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3792 + (32 * mem[_3792]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4843 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4868 = mem[_4843]
                                    require mem[_4843] <= test266151307()
                                    require _4843 + mem[_4843] + 31 < _4843 + return_data.size
                                    _4884 = mem[_4843 + mem[_4843]]
                                    if mem[_4843 + mem[_4843]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4843 + mem[_4843]]) + 1 < 0 or _4843 + ceil32(return_data.size) + ceil32(32 * mem[_4843 + mem[_4843]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4843 + ceil32(return_data.size) + ceil32(32 * mem[_4843 + mem[_4843]]) + 1
                                    mem[_4843 + ceil32(return_data.size)] = _4884
                                    require _4868 + (32 * _4884) + 32 <= return_data.size
                                    mem[_4843 + ceil32(return_data.size) + 32 len ceil32(32 * _4884)] = mem[_4843 + _4868 + 32 len ceil32(32 * _4884)]
                                    if 1 >= _4884:
                                        revert with 0, 50
                                    _5651 = mem[_4843 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4843 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4843 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5774 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5774]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5774] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5774]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5774] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5774] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4843 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4843 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5823 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5823]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5823] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5823]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5823] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5823] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4843 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4843 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6227 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6227]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_6227] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_6227]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_6227] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_6227] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3886 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3886]:
                                    revert with 0, 50
                                mem[_3886 + 32] = token1Address
                                if 1 >= mem[_3886]:
                                    revert with 0, 50
                                mem[_3886 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3886 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3886 + 100] = 1
                                mem[_3886 + 132] = 64
                                mem[_3886 + 164] = mem[_3886]
                                idx = 0
                                u = _3886 + 32
                                v = _3886 + 196
                                while idx < mem[_3886]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3886 + (32 * mem[_3886]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4842 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4867 = mem[_4842]
                                require mem[_4842] <= test266151307()
                                require _4842 + mem[_4842] + 31 < _4842 + return_data.size
                                _4883 = mem[_4842 + mem[_4842]]
                                if mem[_4842 + mem[_4842]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4842 + mem[_4842]]) + 1 < 0 or _4842 + ceil32(return_data.size) + ceil32(32 * mem[_4842 + mem[_4842]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4842 + ceil32(return_data.size) + ceil32(32 * mem[_4842 + mem[_4842]]) + 1
                                mem[_4842 + ceil32(return_data.size)] = _4883
                                require _4867 + (32 * _4883) + 32 <= return_data.size
                                mem[_4842 + ceil32(return_data.size) + 32 len ceil32(32 * _4883)] = mem[_4842 + _4867 + 32 len ceil32(32 * _4883)]
                                if 1 >= _4883:
                                    revert with 0, 50
                                _5650 = mem[_4842 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5773 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5773]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5773] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5773]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5773] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5773] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5822 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5822]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5822] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5822]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5822] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5822] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6226 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6226]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_6226] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_6226]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_6226] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / u * v) / mem[_6226] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3931 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3931]:
                                        revert with 0, 50
                                    mem[_3931 + 32] = token1Address
                                    if 1 >= mem[_3931]:
                                        revert with 0, 50
                                    mem[_3931 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3931 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3931 + 100] = 10^sub_3266f45c
                                    mem[_3931 + 132] = 64
                                    mem[_3931 + 164] = mem[_3931]
                                    idx = 0
                                    u = _3931 + 32
                                    v = _3931 + 196
                                    while idx < mem[_3931]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3931 + (32 * mem[_3931]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4841 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4866 = mem[_4841]
                                    require mem[_4841] <= test266151307()
                                    require _4841 + mem[_4841] + 31 < _4841 + return_data.size
                                    _4882 = mem[_4841 + mem[_4841]]
                                    if mem[_4841 + mem[_4841]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4841 + mem[_4841]]) + 1 < 0 or _4841 + ceil32(return_data.size) + ceil32(32 * mem[_4841 + mem[_4841]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4841 + ceil32(return_data.size) + ceil32(32 * mem[_4841 + mem[_4841]]) + 1
                                    mem[_4841 + ceil32(return_data.size)] = _4882
                                    require _4866 + (32 * _4882) + 32 <= return_data.size
                                    mem[_4841 + ceil32(return_data.size) + 32 len ceil32(32 * _4882)] = mem[_4841 + _4866 + 32 len ceil32(32 * _4882)]
                                    if 1 >= _4882:
                                        revert with 0, 50
                                    _5649 = mem[_4841 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5772 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5772]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5772] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5772]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5772] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5772] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5821 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5821]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5821] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5821]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5821] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5821] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6225 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6225]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_6225] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_6225]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_6225] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_6225] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4855 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4855]:
                                        revert with 0, 50
                                    mem[_4855 + 32] = token1Address
                                    if 1 >= mem[_4855]:
                                        revert with 0, 50
                                    mem[_4855 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4855 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4855 + 100] = u * v
                                    mem[_4855 + 132] = 64
                                    mem[_4855 + 164] = mem[_4855]
                                    idx = 0
                                    u = _4855 + 32
                                    v = _4855 + 196
                                    while idx < mem[_4855]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4855 + (32 * mem[_4855]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5664 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5673 = mem[_5664]
                                    require mem[_5664] <= test266151307()
                                    require _5664 + mem[_5664] + 31 < _5664 + return_data.size
                                    _5680 = mem[_5664 + mem[_5664]]
                                    if mem[_5664 + mem[_5664]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5664 + mem[_5664]]) + 1 < 0 or _5664 + ceil32(return_data.size) + ceil32(32 * mem[_5664 + mem[_5664]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5664 + ceil32(return_data.size) + ceil32(32 * mem[_5664 + mem[_5664]]) + 1
                                    mem[_5664 + ceil32(return_data.size)] = _5680
                                    require _5673 + (32 * _5680) + 32 <= return_data.size
                                    mem[_5664 + ceil32(return_data.size) + 32 len ceil32(32 * _5680)] = mem[_5664 + _5673 + 32 len ceil32(32 * _5680)]
                                    if 1 >= _5680:
                                        revert with 0, 50
                                    _6189 = mem[_5664 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5664 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5664 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6262 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6189) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6262]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189) / mem[_6262] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189) / mem[_6262]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189) / mem[_6262] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189) / mem[_6262] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5664 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5664 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6286 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6189 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6286]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / 10^sub_3266f45c) / mem[_6286] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / 10^sub_3266f45c) / mem[_6286]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / 10^sub_3266f45c) / mem[_6286] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / 10^sub_3266f45c) / mem[_6286] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5664 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5664 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6448 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6189 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6448]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / u * v) / mem[_6448] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / u * v) / mem[_6448]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / u * v) / mem[_6448] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2579 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6189 / u * v) / mem[_6448] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2590 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2593 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2593
                    require _2590 + (32 * _2593) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2593)] = mem[(2 * ceil32(return_data.size)) + _2590 + 224 len ceil32(32 * _2593)]
                    if 1 >= _2593:
                        revert with 0, 50
                    _3765 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3924 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3924]:
                                revert with 0, 50
                            mem[_3924 + 32] = token1Address
                            if 1 >= mem[_3924]:
                                revert with 0, 50
                            mem[_3924 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3924 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3924 + 100] = 1
                            mem[_3924 + 132] = 64
                            mem[_3924 + 164] = mem[_3924]
                            idx = 0
                            s = _3924 + 32
                            t = _3924 + 196
                            while idx < mem[_3924]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3924 + (32 * mem[_3924]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4838 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4864 = mem[_4838]
                            require mem[_4838] <= test266151307()
                            require _4838 + mem[_4838] + 31 < _4838 + return_data.size
                            _4880 = mem[_4838 + mem[_4838]]
                            if mem[_4838 + mem[_4838]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4838 + mem[_4838]]) + 1 < 0 or _4838 + ceil32(return_data.size) + ceil32(32 * mem[_4838 + mem[_4838]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4838 + ceil32(return_data.size) + ceil32(32 * mem[_4838 + mem[_4838]]) + 1
                            mem[_4838 + ceil32(return_data.size)] = _4880
                            require _4864 + (32 * _4880) + 32 <= return_data.size
                            mem[_4838 + ceil32(return_data.size) + 32 len ceil32(32 * _4880)] = mem[_4838 + _4864 + 32 len ceil32(32 * _4880)]
                            if 1 >= _4880:
                                revert with 0, 50
                            _5647 = mem[_4838 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4838 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4838 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5771 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5647) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5771]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5771] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5771]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5771] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5771] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4838 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4838 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5820 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5820]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5820] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5820]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5820] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5820] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4838 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4838 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6224 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5647 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6224]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / s * t) / mem[_6224] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / s * t) / mem[_6224]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / s * t) / mem[_6224] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / s * t) / mem[_6224] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3968 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3968]:
                                    revert with 0, 50
                                mem[_3968 + 32] = token1Address
                                if 1 >= mem[_3968]:
                                    revert with 0, 50
                                mem[_3968 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3968 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3968 + 100] = 10^sub_3266f45c
                                mem[_3968 + 132] = 64
                                mem[_3968 + 164] = mem[_3968]
                                idx = 0
                                s = _3968 + 32
                                t = _3968 + 196
                                while idx < mem[_3968]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3968 + (32 * mem[_3968]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4837 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4863 = mem[_4837]
                                require mem[_4837] <= test266151307()
                                require _4837 + mem[_4837] + 31 < _4837 + return_data.size
                                _4879 = mem[_4837 + mem[_4837]]
                                if mem[_4837 + mem[_4837]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4837 + mem[_4837]]) + 1 < 0 or _4837 + ceil32(return_data.size) + ceil32(32 * mem[_4837 + mem[_4837]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4837 + ceil32(return_data.size) + ceil32(32 * mem[_4837 + mem[_4837]]) + 1
                                mem[_4837 + ceil32(return_data.size)] = _4879
                                require _4863 + (32 * _4879) + 32 <= return_data.size
                                mem[_4837 + ceil32(return_data.size) + 32 len ceil32(32 * _4879)] = mem[_4837 + _4863 + 32 len ceil32(32 * _4879)]
                                if 1 >= _4879:
                                    revert with 0, 50
                                _5646 = mem[_4837 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4837 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4837 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5770 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5646) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5770]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5770] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5770]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5770] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5770] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4837 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4837 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5819 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5819]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5819] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5819]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5819] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5819] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4837 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4837 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6223 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6223]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / s * t) / mem[_6223] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / s * t) / mem[_6223]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / s * t) / mem[_6223] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / s * t) / mem[_6223] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4853 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4853]:
                                    revert with 0, 50
                                mem[_4853 + 32] = token1Address
                                if 1 >= mem[_4853]:
                                    revert with 0, 50
                                mem[_4853 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4853 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4853 + 100] = s * t
                                mem[_4853 + 132] = 64
                                mem[_4853 + 164] = mem[_4853]
                                idx = 0
                                s = _4853 + 32
                                t = _4853 + 196
                                while idx < mem[_4853]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4853 + (32 * mem[_4853]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5663 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5672 = mem[_5663]
                                require mem[_5663] <= test266151307()
                                require _5663 + mem[_5663] + 31 < _5663 + return_data.size
                                _5679 = mem[_5663 + mem[_5663]]
                                if mem[_5663 + mem[_5663]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5663 + mem[_5663]]) + 1 < 0 or _5663 + ceil32(return_data.size) + ceil32(32 * mem[_5663 + mem[_5663]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5663 + ceil32(return_data.size) + ceil32(32 * mem[_5663 + mem[_5663]]) + 1
                                mem[_5663 + ceil32(return_data.size)] = _5679
                                require _5672 + (32 * _5679) + 32 <= return_data.size
                                mem[_5663 + ceil32(return_data.size) + 32 len ceil32(32 * _5679)] = mem[_5663 + _5672 + 32 len ceil32(32 * _5679)]
                                if 1 >= _5679:
                                    revert with 0, 50
                                _6188 = mem[_5663 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5663 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5663 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6261 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _6188) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6261]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188) / mem[_6261] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188) / mem[_6261]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188) / mem[_6261] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188) / mem[_6261] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5663 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5663 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6285 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _6188 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6285]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / 10^sub_3266f45c) / mem[_6285] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / 10^sub_3266f45c) / mem[_6285]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / 10^sub_3266f45c) / mem[_6285] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / 10^sub_3266f45c) / mem[_6285] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5663 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5663 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6447 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765) + (Mask(112, 0, ext_call.return_data[32]) * _6188 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6447]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / s * t) / mem[_6447] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / s * t) / mem[_6447]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / s * t) / mem[_6447] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6188 / s * t) / mem[_6447] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3966 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3966]:
                                    revert with 0, 50
                                mem[_3966 + 32] = token1Address
                                if 1 >= mem[_3966]:
                                    revert with 0, 50
                                mem[_3966 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3966 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3966 + 100] = 1
                                mem[_3966 + 132] = 64
                                mem[_3966 + 164] = mem[_3966]
                                idx = 0
                                s = _3966 + 32
                                t = _3966 + 196
                                while idx < mem[_3966]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3966 + (32 * mem[_3966]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4834 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4861 = mem[_4834]
                                require mem[_4834] <= test266151307()
                                require _4834 + mem[_4834] + 31 < _4834 + return_data.size
                                _4877 = mem[_4834 + mem[_4834]]
                                if mem[_4834 + mem[_4834]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4834 + mem[_4834]]) + 1 < 0 or _4834 + ceil32(return_data.size) + ceil32(32 * mem[_4834 + mem[_4834]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4834 + ceil32(return_data.size) + ceil32(32 * mem[_4834 + mem[_4834]]) + 1
                                mem[_4834 + ceil32(return_data.size)] = _4877
                                require _4861 + (32 * _4877) + 32 <= return_data.size
                                mem[_4834 + ceil32(return_data.size) + 32 len ceil32(32 * _4877)] = mem[_4834 + _4861 + 32 len ceil32(32 * _4877)]
                                if 1 >= _4877:
                                    revert with 0, 50
                                _5644 = mem[_4834 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5769 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5644) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5769]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5769] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5769]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5769] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5769] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5818 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5818]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5818] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5818]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5818] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5818] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6222 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6222]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6222] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6222]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6222] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6222] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4026 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4026]:
                                        revert with 0, 50
                                    mem[_4026 + 32] = token1Address
                                    if 1 >= mem[_4026]:
                                        revert with 0, 50
                                    mem[_4026 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4026 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4026 + 100] = 10^sub_3266f45c
                                    mem[_4026 + 132] = 64
                                    mem[_4026 + 164] = mem[_4026]
                                    idx = 0
                                    s = _4026 + 32
                                    t = _4026 + 196
                                    while idx < mem[_4026]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4026 + (32 * mem[_4026]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4833 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4860 = mem[_4833]
                                    require mem[_4833] <= test266151307()
                                    require _4833 + mem[_4833] + 31 < _4833 + return_data.size
                                    _4876 = mem[_4833 + mem[_4833]]
                                    if mem[_4833 + mem[_4833]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4833 + mem[_4833]]) + 1 < 0 or _4833 + ceil32(return_data.size) + ceil32(32 * mem[_4833 + mem[_4833]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4833 + ceil32(return_data.size) + ceil32(32 * mem[_4833 + mem[_4833]]) + 1
                                    mem[_4833 + ceil32(return_data.size)] = _4876
                                    require _4860 + (32 * _4876) + 32 <= return_data.size
                                    mem[_4833 + ceil32(return_data.size) + 32 len ceil32(32 * _4876)] = mem[_4833 + _4860 + 32 len ceil32(32 * _4876)]
                                    if 1 >= _4876:
                                        revert with 0, 50
                                    _5643 = mem[_4833 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5768 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5768]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5768] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5768]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5768] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5768] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5817 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5817]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5817] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5817]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5817] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5817] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6221 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6221]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6221] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6221]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6221] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6221] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4851 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4851]:
                                        revert with 0, 50
                                    mem[_4851 + 32] = token1Address
                                    if 1 >= mem[_4851]:
                                        revert with 0, 50
                                    mem[_4851 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4851 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4851 + 100] = s * t
                                    mem[_4851 + 132] = 64
                                    mem[_4851 + 164] = mem[_4851]
                                    idx = 0
                                    s = _4851 + 32
                                    t = _4851 + 196
                                    while idx < mem[_4851]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4851 + (32 * mem[_4851]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5662 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5671 = mem[_5662]
                                    require mem[_5662] <= test266151307()
                                    require _5662 + mem[_5662] + 31 < _5662 + return_data.size
                                    _5678 = mem[_5662 + mem[_5662]]
                                    if mem[_5662 + mem[_5662]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5662 + mem[_5662]]) + 1 < 0 or _5662 + ceil32(return_data.size) + ceil32(32 * mem[_5662 + mem[_5662]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5662 + ceil32(return_data.size) + ceil32(32 * mem[_5662 + mem[_5662]]) + 1
                                    mem[_5662 + ceil32(return_data.size)] = _5678
                                    require _5671 + (32 * _5678) + 32 <= return_data.size
                                    mem[_5662 + ceil32(return_data.size) + 32 len ceil32(32 * _5678)] = mem[_5662 + _5671 + 32 len ceil32(32 * _5678)]
                                    if 1 >= _5678:
                                        revert with 0, 50
                                    _6187 = mem[_5662 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6260 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6187) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6260]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187) / mem[_6260] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187) / mem[_6260]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187) / mem[_6260] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187) / mem[_6260] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6284 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6187 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6284]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / 10^sub_3266f45c) / mem[_6284] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / 10^sub_3266f45c) / mem[_6284]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / 10^sub_3266f45c) / mem[_6284] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / 10^sub_3266f45c) / mem[_6284] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5662 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5662 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6446 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6187 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6446]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / s * t) / mem[_6446] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / s * t) / mem[_6446]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / s * t) / mem[_6446] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6187 / s * t) / mem[_6446] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4953 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4953]:
                                    revert with 0, 50
                                mem[_4953 + 32] = token1Address
                                if 1 >= mem[_4953]:
                                    revert with 0, 50
                                mem[_4953 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4953 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4953 + 100] = 1
                                mem[_4953 + 132] = 64
                                mem[_4953 + 164] = mem[_4953]
                                idx = 0
                                u = _4953 + 32
                                v = _4953 + 196
                                while idx < mem[_4953]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4953 + (32 * mem[_4953]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5661 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5670 = mem[_5661]
                                require mem[_5661] <= test266151307()
                                require _5661 + mem[_5661] + 31 < _5661 + return_data.size
                                _5677 = mem[_5661 + mem[_5661]]
                                if mem[_5661 + mem[_5661]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5661 + mem[_5661]]) + 1 < 0 or _5661 + ceil32(return_data.size) + ceil32(32 * mem[_5661 + mem[_5661]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5661 + ceil32(return_data.size) + ceil32(32 * mem[_5661 + mem[_5661]]) + 1
                                mem[_5661 + ceil32(return_data.size)] = _5677
                                require _5670 + (32 * _5677) + 32 <= return_data.size
                                mem[_5661 + ceil32(return_data.size) + 32 len ceil32(32 * _5677)] = mem[_5661 + _5670 + 32 len ceil32(32 * _5677)]
                                if 1 >= _5677:
                                    revert with 0, 50
                                _6186 = mem[_5661 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5661 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5661 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6259 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6186) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6259]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186) / mem[_6259] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186) / mem[_6259]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186) / mem[_6259] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186) / mem[_6259] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5661 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5661 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6283 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6186 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6283]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / 10^sub_3266f45c) / mem[_6283] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / 10^sub_3266f45c) / mem[_6283]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / 10^sub_3266f45c) / mem[_6283] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / 10^sub_3266f45c) / mem[_6283] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5661 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5661 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6445 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6186 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6445]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / u * v) / mem[_6445] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / u * v) / mem[_6445]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / u * v) / mem[_6445] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6186 / u * v) / mem[_6445] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _5005 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5005]:
                                        revert with 0, 50
                                    mem[_5005 + 32] = token1Address
                                    if 1 >= mem[_5005]:
                                        revert with 0, 50
                                    mem[_5005 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5005 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5005 + 100] = 10^sub_3266f45c
                                    mem[_5005 + 132] = 64
                                    mem[_5005 + 164] = mem[_5005]
                                    idx = 0
                                    u = _5005 + 32
                                    v = _5005 + 196
                                    while idx < mem[_5005]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5005 + (32 * mem[_5005]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5660 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5669 = mem[_5660]
                                    require mem[_5660] <= test266151307()
                                    require _5660 + mem[_5660] + 31 < _5660 + return_data.size
                                    _5676 = mem[_5660 + mem[_5660]]
                                    if mem[_5660 + mem[_5660]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5660 + mem[_5660]]) + 1 < 0 or _5660 + ceil32(return_data.size) + ceil32(32 * mem[_5660 + mem[_5660]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5660 + ceil32(return_data.size) + ceil32(32 * mem[_5660 + mem[_5660]]) + 1
                                    mem[_5660 + ceil32(return_data.size)] = _5676
                                    require _5669 + (32 * _5676) + 32 <= return_data.size
                                    mem[_5660 + ceil32(return_data.size) + 32 len ceil32(32 * _5676)] = mem[_5660 + _5669 + 32 len ceil32(32 * _5676)]
                                    if 1 >= _5676:
                                        revert with 0, 50
                                    _6185 = mem[_5660 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5660 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5660 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6258 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6185) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6258]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185) / mem[_6258] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185) / mem[_6258]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185) / mem[_6258] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185) / mem[_6258] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5660 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5660 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6282 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6185 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6282]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / 10^sub_3266f45c) / mem[_6282] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / 10^sub_3266f45c) / mem[_6282]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / 10^sub_3266f45c) / mem[_6282] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / 10^sub_3266f45c) / mem[_6282] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5660 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5660 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6444 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6185 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6444]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / u * v) / mem[_6444] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / u * v) / mem[_6444]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / u * v) / mem[_6444] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6185 / u * v) / mem[_6444] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5666 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5666]:
                                        revert with 0, 50
                                    mem[_5666 + 32] = token1Address
                                    if 1 >= mem[_5666]:
                                        revert with 0, 50
                                    mem[_5666 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5666 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5666 + 100] = u * v
                                    mem[_5666 + 132] = 64
                                    mem[_5666 + 164] = mem[_5666]
                                    idx = 0
                                    u = _5666 + 32
                                    v = _5666 + 196
                                    while idx < mem[_5666]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5666 + (32 * mem[_5666]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6191 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6192 = mem[_6191]
                                    require mem[_6191] <= test266151307()
                                    require _6191 + mem[_6191] + 31 < _6191 + return_data.size
                                    _6193 = mem[_6191 + mem[_6191]]
                                    if mem[_6191 + mem[_6191]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_6191 + mem[_6191]]) + 1 < 0 or _6191 + ceil32(return_data.size) + ceil32(32 * mem[_6191 + mem[_6191]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _6191 + ceil32(return_data.size) + ceil32(32 * mem[_6191 + mem[_6191]]) + 1
                                    mem[_6191 + ceil32(return_data.size)] = _6193
                                    require _6192 + (32 * _6193) + 32 <= return_data.size
                                    mem[_6191 + ceil32(return_data.size) + 32 len ceil32(32 * _6193)] = mem[_6191 + _6192 + 32 len ceil32(32 * _6193)]
                                    if 1 >= _6193:
                                        revert with 0, 50
                                    _6431 = mem[_6191 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_6191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6191 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6458 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6431) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6458]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431) / mem[_6458] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431) / mem[_6458]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431) / mem[_6458] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431) / mem[_6458] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_6191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6191 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6462 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6431 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6462]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / 10^sub_3266f45c) / mem[_6462] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / 10^sub_3266f45c) / mem[_6462]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / 10^sub_3266f45c) / mem[_6462] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / 10^sub_3266f45c) / mem[_6462] * ext_call.return_data[32] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_6191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6191 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6497 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6431 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6497]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / u * v) / mem[_6497] and ext_call.return_data[32] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / u * v) / mem[_6497]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / u * v) / mem[_6497] * ext_call.return_data[32] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3765 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6431 / u * v) / mem[_6497] * ext_call.return_data[32] / 100 * 10^18 / 10^18
    return memory
      from mem[64]
       len 32
}



}

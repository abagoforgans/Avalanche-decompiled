contract main {




// =====================  Runtime code  =====================


#
#  - withTokenFrom(address arg1, uint256 arg2)
#  - swapTokenForTokenWithoutEncrypt(address[] arg1, address arg2, uint256 arg3, uint256 arg4, uint8 arg5, bool arg6)
#  - withToken(address arg1, uint256 arg2)
#  - depositToken(address arg1, uint256 arg2)
#
address owner;
mapping of uint8 stor1;
mapping of address router;

function isWhitelisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor1[address(arg1)])
}

function getRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    return router[address(arg1)]
}

function owner() {
    return owner
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require msg.sender == owner
    if arg1:
        owner = arg1
}

function withdrawEth(uint256 arg1) {
    require calldata.size - 4 >= 32
    require msg.sender == owner
    if arg1:
        call msg.sender with:
           value arg1 wei
             gas gas_remaining wei
    else:
        call msg.sender with:
           value eth.balance(this.address) wei
             gas gas_remaining wei
    if not ext_call.success:
        revert with 0, 'withdraw eth failed'
}

function getFactory(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function factoryFor(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function approveToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    call arg1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args this.address, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function getPair(address arg1, address arg2, address arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function pairFor(address arg1, address arg2, address arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function addRouter(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    if arg1.length <= 0:
        revert with 0, 'router address is empty'
    idx = 0
    while idx < arg1.length:
        if idx >= arg1.length:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 2
        router[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + 140 len 20]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function add(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require msg.sender == owner
    if arg1.length <= 0:
        revert with 0, 'address length is 0'
    idx = 0
    while idx < arg1.length:
        if idx >= arg1.length:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 1
        stor1[mem[(32 * idx) + 140 len 20]] = 1
        if idx >= arg1.length:
            revert with 0, 50
        emit AddedToWhitelist(mem[(32 * idx) + 140 len 20]);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function remove(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require msg.sender == owner
    if arg1.length <= 0:
        revert with 0, 'address length is 0'
    idx = 0
    while idx < arg1.length:
        if idx >= arg1.length:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 1
        stor1[mem[(32 * idx) + 140 len 20]] = 0
        if idx >= arg1.length:
            revert with 0, 50
        emit RemovedFromWhitelist(mem[(32 * idx) + 140 len 20]);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function swapExactTokensForTokensSF(uint256 arg1, uint256 arg2, address[] arg3, address arg4, address arg5, uint256 arg6) {
    require calldata.size - 4 >= 192
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    require arg4 == arg4
    require arg5 == arg5
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    if not arg3.length:
        revert with 0, 50
    require cd[(arg3 + 36)] == address(cd[(arg3 + 36)])
    if arg1:
        idx = 0
        s = 292
        t = arg3 + 36
        while idx < arg3.length:
            require cd[t] == address(cd[t])
            mem[s] = address(cd[t])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(router[address(arg5)])
        call router[address(arg5)].swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args arg1, arg2, Array(len=arg3.length, data=mem[292 len 32 * arg3.length]), address(arg4), arg6
    else:
        staticcall address(cd[(arg3 + 36)]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        idx = 0
        s = ceil32(return_data.size) + 292
        t = arg3 + 36
        while idx < arg3.length:
            require cd[t] == address(cd[t])
            mem[s] = address(cd[t])
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(router[address(arg5)])
        call router[address(arg5)].swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], arg2, Array(len=arg3.length, data=mem[ceil32(return_data.size) + 292 len 32 * arg3.length]), address(arg4), arg6
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function getAmountsOut(address arg1, uint256 arg2, address[] arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg3.length) + 97 < 96 or ceil32(32 * arg3.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = arg3 + 36
    s = 128
    while idx < arg3 + (32 * arg3.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    mem[ceil32(32 * arg3.length) + 97] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * arg3.length) + 101] = arg2
    mem[ceil32(32 * arg3.length) + 133] = 64
    mem[ceil32(32 * arg3.length) + 165] = arg3.length
    idx = 0
    s = 128
    t = ceil32(32 * arg3.length) + 197
    while idx < arg3.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    staticcall arg1.getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args arg2, Array(len=arg3.length, data=mem[ceil32(32 * arg3.length) + 197 len 32 * arg3.length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * arg3.length) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * arg3.length) + ceil32(return_data.size) + 97
    require return_data.size >= 32
    _31 = mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32
    require mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require ceil32(32 * arg3.length) + return_data.size + 97 > ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 128
    _32 = mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97]
    if mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97]) + 1 < 0 or ceil32(32 * arg3.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97]) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg3.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97]) + 98
    mem[ceil32(32 * arg3.length) + ceil32(return_data.size) + 97] = mem[ceil32(32 * arg3.length) + mem[ceil32(32 * arg3.length) + 97 len 4], Mask(224, 32, arg2) >> 32 + 97]
    require _31 + (32 * _32) + 32 <= return_data.size
    mem[ceil32(32 * arg3.length) + ceil32(return_data.size) + 129 len ceil32(32 * _32)] = mem[ceil32(32 * arg3.length) + _31 + 129 len ceil32(32 * _32)]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _32
    mem[mem[64] + 64 len 32 * _32] = mem[ceil32(32 * arg3.length) + ceil32(return_data.size) + 129 len 32 * _32]
    return Array(len=_32, data=mem[mem[64] + 64 len 32 * _32])
}

function getReserves(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    if arg1.length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
        revert with 0, 17
    if 2 * arg1.length > test266151307():
        revert with 0, 65
    mem[96] = 2 * arg1.length
    mem[64] = (64 * arg1.length) + 128
    if not uint255(arg1.length):
        idx = 0
        while idx < arg1.length:
            if idx > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                revert with 0, 17
            if idx >= arg1.length:
                revert with 0, 50
            require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
            staticcall address(cd[((32 * idx) + arg1 + 36)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _38 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _40 = mem[_38]
            require mem[_38] == mem[_38 + 18 len 14]
            require mem[_38 + 32] == mem[_38 + 50 len 14]
            require mem[_38 + 64] == mem[_38 + 92 len 4]
            if 2 * idx >= mem[96]:
                revert with 0, 50
            if 1 > !(2 * idx):
                revert with 0, 17
            if (2 * idx) + 1 >= mem[96]:
                revert with 0, 50
            mem[(32 * (2 * idx) + 1) + 128] = mem[_38 + 50 len 14]
            mem[(64 * idx) + 128] = Mask(112, 0, _40)
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        mem[128 len 64 * arg1.length] = call.data[calldata.size len 64 * arg1.length]
        idx = 0
        while idx < arg1.length:
            if idx > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                revert with 0, 17
            if idx >= arg1.length:
                revert with 0, 50
            require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
            staticcall address(cd[((32 * idx) + arg1 + 36)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _39 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _41 = mem[_39]
            require mem[_39] == mem[_39 + 18 len 14]
            require mem[_39 + 32] == mem[_39 + 50 len 14]
            require mem[_39 + 64] == mem[_39 + 92 len 4]
            if 2 * idx >= mem[96]:
                revert with 0, 50
            if 1 > !(2 * idx):
                revert with 0, 17
            if (2 * idx) + 1 >= mem[96]:
                revert with 0, 50
            mem[(32 * (2 * idx) + 1) + 128] = mem[_39 + 50 len 14]
            mem[(64 * idx) + 128] = Mask(112, 0, _41)
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[96]
    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
}

function approveToRouter(address[] arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg1.length) + 97
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require arg2 == arg2
    mem[0] = msg.sender
    mem[32] = 1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    if arg1.length <= 0:
        revert with 0, 'token address length is invalid'
    idx = 0
    while idx < arg1.length:
        if idx >= mem[96]:
            revert with 0, 50
        _278 = mem[(32 * idx) + 128]
        if not arg3:
            _281 = mem[64]
            mem[mem[64] + 36] = arg2
            mem[mem[64] + 68] = arg3
            _283 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_283 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_283 + 36 len 28]
            mem[64] = _281 + 164
            mem[_281 + 100] = 32
            mem[_281 + 132] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(_278)):
                revert with 0, 'Address: call to non-contract'
            _289 = mem[_283]
            s = 0
            while s < _289:
                mem[s + _281 + 164] = mem[s + _283 + 32]
                s = s + 32
                continue 
            if ceil32(_289) > _289:
                mem[_289 + _281 + 164] = 0
            call address(_278).mem[_281 + 164 len 4] with:
                 gas gas_remaining wei
                args mem[_281 + 168 len _289 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[_281 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_281 + 168] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _281 + 232] = mem[idx + _281 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_281 + 232]
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[64] = _281 + ceil32(return_data.size) + 165
                mem[_281 + 164] = return_data.size
                mem[_281 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_281 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_281 + ceil32(return_data.size) + 169] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _281 + ceil32(return_data.size) + 233] = mem[idx + _281 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_281 + ceil32(return_data.size) + 233]
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_281 + 196] == bool(mem[_281 + 196])
                    if not mem[_281 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = arg2
            staticcall address(_278).0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, arg2
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _282 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_282]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            _291 = mem[64]
            mem[mem[64] + 36] = arg2
            mem[mem[64] + 68] = arg3
            _293 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_293 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_293 + 36 len 28]
            mem[64] = _291 + 164
            mem[_291 + 100] = 32
            mem[_291 + 132] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(_278)):
                revert with 0, 'Address: call to non-contract'
            _300 = mem[_293]
            s = 0
            while s < _300:
                mem[s + _291 + 164] = mem[s + _293 + 32]
                s = s + 32
                continue 
            if ceil32(_300) > _300:
                mem[_300 + _291 + 164] = 0
            call address(_278).mem[_291 + 164 len 4] with:
                 gas gas_remaining wei
                args mem[_291 + 168 len _300 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    mem[_291 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_291 + 168] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _291 + 232] = mem[idx + _291 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_291 + 232]
                if mem[96]:
                    require mem[96] >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[64] = _291 + ceil32(return_data.size) + 165
                mem[_291 + 164] = return_data.size
                mem[_291 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_291 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[_291 + ceil32(return_data.size) + 169] = 32
                    idx = 0
                    while idx < 32:
                        mem[idx + _291 + ceil32(return_data.size) + 233] = mem[idx + _291 + 132]
                        idx = idx + 32
                        continue 
                    revert with 0, 32, 32, mem[_291 + ceil32(return_data.size) + 233]
                if return_data.size:
                    require return_data.size >= 32
                    require mem[_291 + 196] == bool(mem[_291 + 196])
                    if not mem[_291 + 196]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function swapTT_e11(address[] arg1, address arg2, uint256 arg3, uint256 arg4, uint8 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    require arg2 == arg2
    require arg5 == arg5
    mem[0] = msg.sender
    mem[32] = 1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    if 0 >= arg1.length:
        revert with 0, 50
    _138 = mem[128]
    if arg3 != 0:
        if arg3 <= 0:
            revert with 0, 'no in'
        if arg4:
            if arg4 <= 0:
                revert with 0, 'not aom'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + 97] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + 101] = arg3
            mem[ceil32(32 * arg1.length) + 133] = arg4
            mem[ceil32(32 * arg1.length) + 165] = 160
            mem[ceil32(32 * arg1.length) + 261] = arg1.length
            idx = 0
            s = 128
            t = ceil32(32 * arg1.length) + 293
            while idx < arg1.length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + 197] = this.address
            mem[ceil32(32 * arg1.length) + 229] = block.timestamp + 1800
            call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg3, arg4, Array(len=arg1.length, data=mem[ceil32(32 * arg1.length) + 293 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 97
            require return_data.size >= 32
            _280 = mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32
            require mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require ceil32(32 * arg1.length) + return_data.size + 97 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 128
            _284 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]
            if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 98 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 98
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]
            require _280 + (32 * _284) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 129 len ceil32(32 * _284)] = mem[ceil32(32 * arg1.length) + _280 + 129 len ceil32(32 * _284)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _284
            mem[mem[64] + 64 len 32 * _284] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 129 len 32 * _284]
            return Array(len=_284, data=mem[mem[64] + 64 len 32 * _284])
        mem[ceil32(32 * arg1.length) + 97] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + 101] = arg3
        mem[ceil32(32 * arg1.length) + 133] = 64
        mem[ceil32(32 * arg1.length) + 165] = arg1.length
        idx = 0
        s = 128
        t = ceil32(32 * arg1.length) + 197
        while idx < arg1.length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall arg2.getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args arg3, Array(len=arg1.length, data=mem[ceil32(32 * arg1.length) + 197 len 32 * arg1.length])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 97
        require return_data.size >= 32
        _282 = mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32
        require mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
        require ceil32(32 * arg1.length) + return_data.size + 97 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 128
        _286 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]
        if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 98 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]) + 98
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 97 len 4], Mask(224, 32, arg3) >> 32 + 97]
        require _282 + (32 * _286) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 129 len ceil32(32 * _286)] = mem[ceil32(32 * arg1.length) + _282 + 129 len ceil32(32 * _286)]
        if _286 <= 0:
            revert with 0, 'no out amounts'
        if _286 < 1:
            revert with 0, 17
        if _286 - 1 >= _286:
            revert with 0, 50
        if mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] and arg5 > -1 / mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129]:
            revert with 0, 17
        if not mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129]:
            if mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 > !(mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 % 100):
                revert with 0, 17
            require mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 == (100 * mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100) + (mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 % 100)
            if mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 <= 0:
                revert with 0, 'not aom'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = arg3
            mem[mem[64] + 36] = mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = arg1.length
            idx = 0
            s = 128
            t = mem[64] + 196
            while idx < arg1.length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg3, mem[mem[64] + 36], Array(len=arg1.length, data=mem[mem[64] + 196 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _472 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _476 = mem[_472]
            require mem[_472] <= test266151307()
            require _472 + return_data.size > _472 + mem[_472] + 31
            _480 = mem[_472 + mem[_472]]
            if mem[_472 + mem[_472]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_472 + mem[_472]]) + 1 < 0 or _472 + ceil32(return_data.size) + ceil32(32 * mem[_472 + mem[_472]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _472 + ceil32(return_data.size) + ceil32(32 * mem[_472 + mem[_472]]) + 1
            mem[_472 + ceil32(return_data.size)] = _480
            require _476 + (32 * _480) + 32 <= return_data.size
            mem[_472 + ceil32(return_data.size) + 32 len ceil32(32 * _480)] = mem[_472 + _476 + 32 len ceil32(32 * _480)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _480
            mem[mem[64] + 64 len 32 * _480] = mem[_472 + ceil32(return_data.size) + 32 len 32 * _480]
            return Array(len=_480, data=mem[mem[64] + 64 len 32 * _480])
        if not mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129]:
            revert with 0, 18
        require mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] == arg5
        if mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 > !(mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 % 100):
            revert with 0, 17
        require mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 == (100 * mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100) + (mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 % 100)
        if mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100 <= 0:
            revert with 0, 'not aom'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = arg3
        mem[mem[64] + 36] = mem[(32 * _286 - 1) + ceil32(32 * arg1.length) + ceil32(return_data.size) + 129] * arg5 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = arg1.length
        idx = 0
        s = 128
        t = mem[64] + 196
        while idx < arg1.length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args arg3, mem[mem[64] + 36], Array(len=arg1.length, data=mem[mem[64] + 196 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _473 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _477 = mem[_473]
        require mem[_473] <= test266151307()
        require _473 + return_data.size > _473 + mem[_473] + 31
        _481 = mem[_473 + mem[_473]]
        if mem[_473 + mem[_473]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_473 + mem[_473]]) + 1 < 0 or _473 + ceil32(return_data.size) + ceil32(32 * mem[_473 + mem[_473]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _473 + ceil32(return_data.size) + ceil32(32 * mem[_473 + mem[_473]]) + 1
        mem[_473 + ceil32(return_data.size)] = _481
        require _477 + (32 * _481) + 32 <= return_data.size
        mem[_473 + ceil32(return_data.size) + 32 len ceil32(32 * _481)] = mem[_473 + _477 + 32 len ceil32(32 * _481)]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _481
        mem[mem[64] + 64 len 32 * _481] = mem[_473 + ceil32(return_data.size) + 32 len 32 * _481]
        return Array(len=_481, data=mem[mem[64] + 64 len 32 * _481])
    mem[ceil32(32 * arg1.length) + 101] = this.address
    staticcall address(_138).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(32 * arg1.length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'no in'
    if arg4:
        if arg4 <= 0:
            revert with 0, 'not aom'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 101] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 133] = arg4
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 165] = 160
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = arg1.length
        idx = 0
        s = 128
        t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
        while idx < arg1.length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = this.address
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = block.timestamp + 1800
        call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], arg4, Array(len=arg1.length, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 97
        require return_data.size >= 32
        _281 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 97 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 128
        _285 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]
        if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 98 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 98
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 97] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]
        require _281 + (32 * _285) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129 len ceil32(32 * _285)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _281 + 129 len ceil32(32 * _285)]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _285
        mem[mem[64] + 64 len 32 * _285] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129 len 32 * _285]
        return Array(len=_285, data=mem[mem[64] + 64 len 32 * _285])
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 101] = ext_call.return_data[0]
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 133] = 64
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 165] = arg1.length
    idx = 0
    s = 128
    t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 197
    while idx < arg1.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    staticcall arg2.getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args ext_call.return_data[0], Array(len=arg1.length, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197 len 32 * arg1.length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 97
    require return_data.size >= 32
    _283 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28]
    require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] <= test266151307()
    require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 97 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 128
    _287 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]
    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]) + 98
    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 97] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 97 len 4], ext_call.return_data[0 len 28] + 97]
    require _283 + (32 * _287) + 32 <= return_data.size
    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129 len ceil32(32 * _287)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _283 + 129 len ceil32(32 * _287)]
    if _287 <= 0:
        revert with 0, 'no out amounts'
    if _287 < 1:
        revert with 0, 17
    if _287 - 1 >= _287:
        revert with 0, 50
    _399 = mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129]
    if mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] and arg5 > -1 / mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129]:
        revert with 0, 17
    if not mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129]:
        if mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 > !(mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 % 100):
            revert with 0, 17
        require mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 == (100 * mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100) + (mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 % 100)
        if mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 <= 0:
            revert with 0, 'not aom'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _399 * arg5 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = arg1.length
        idx = 0
        s = 128
        t = mem[64] + 196
        while idx < arg1.length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _399 * arg5 / 100, Array(len=arg1.length, data=mem[mem[64] + 196 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _474 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _478 = mem[_474]
        require mem[_474] <= test266151307()
        require _474 + return_data.size > _474 + mem[_474] + 31
        _482 = mem[_474 + mem[_474]]
        if mem[_474 + mem[_474]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_474 + mem[_474]]) + 1 < 0 or _474 + ceil32(return_data.size) + ceil32(32 * mem[_474 + mem[_474]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _474 + ceil32(return_data.size) + ceil32(32 * mem[_474 + mem[_474]]) + 1
        mem[_474 + ceil32(return_data.size)] = _482
        require _478 + (32 * _482) + 32 <= return_data.size
        mem[_474 + ceil32(return_data.size) + 32 len ceil32(32 * _482)] = mem[_474 + _478 + 32 len ceil32(32 * _482)]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _482
        mem[mem[64] + 64 len 32 * _482] = mem[_474 + ceil32(return_data.size) + 32 len 32 * _482]
        return Array(len=_482, data=mem[mem[64] + 64 len 32 * _482])
    if not mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129]:
        revert with 0, 18
    require mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] == arg5
    if mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    if 100 * mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 > !(mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 % 100):
        revert with 0, 17
    require mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 == (100 * mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100) + (mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 % 100)
    if mem[(32 * _287 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 129] * arg5 / 100 <= 0:
        revert with 0, 'not aom'
    if 1800 > !block.timestamp:
        revert with 0, 17
    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = ext_call.return_data[0]
    mem[mem[64] + 36] = _399 * arg5 / 100
    mem[mem[64] + 68] = 160
    mem[mem[64] + 164] = arg1.length
    idx = 0
    s = 128
    t = mem[64] + 196
    while idx < arg1.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 100] = this.address
    mem[mem[64] + 132] = block.timestamp + 1800
    call arg2.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args ext_call.return_data[0], _399 * arg5 / 100, Array(len=arg1.length, data=mem[mem[64] + 196 len 32 * arg1.length]), address(this.address), block.timestamp + 1800
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _475 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _479 = mem[_475]
    require mem[_475] <= test266151307()
    require _475 + return_data.size > _475 + mem[_475] + 31
    _483 = mem[_475 + mem[_475]]
    if mem[_475 + mem[_475]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_475 + mem[_475]]) + 1 < 0 or _475 + ceil32(return_data.size) + ceil32(32 * mem[_475 + mem[_475]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _475 + ceil32(return_data.size) + ceil32(32 * mem[_475 + mem[_475]]) + 1
    mem[_475 + ceil32(return_data.size)] = _483
    require _479 + (32 * _483) + 32 <= return_data.size
    mem[_475 + ceil32(return_data.size) + 32 len ceil32(32 * _483)] = mem[_475 + _479 + 32 len ceil32(32 * _483)]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _483
    mem[mem[64] + 64 len 32 * _483] = mem[_475 + ceil32(return_data.size) + 32 len 32 * _483]
    return Array(len=_483, data=mem[mem[64] + 64 len 32 * _483])
}

function swapTokenForToken(address[] arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = arg1 + 36
    s = 128
    while idx < arg1 + (32 * arg1.length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    mem[0] = msg.sender
    mem[32] = 1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    mem[ceil32(32 * arg1.length) + 97] = 2
    mem[ceil32(32 * arg1.length) + 129 len 64] = call.data[calldata.size len 64]
    if Mask(1, 85, arg2) >> 85:
        if 0 >= arg1.length:
            revert with 0, 50
        mem[ceil32(32 * arg1.length) + 129] = address(mem[128] xor address(arg2) >> 96)
        if 1 >= arg1.length:
            revert with 0, 50
        mem[ceil32(32 * arg1.length) + 161] = address(mem[160] xor address(arg2) >> 96)
        if Mask(85, 0, arg2):
            if Mask(85, 0, arg2) <= 0:
                revert with 0, 'NO_IN'
            if 3 >= arg1.length:
                revert with 0, 50
            _5990 = mem[224]
            if 1 == Mask(1, 94, arg2) >> 94:
                if 2 >= arg1.length:
                    revert with 0, 50
                _6001 = mem[192]
                mem[ceil32(32 * arg1.length) + 229] = address(mem[192] xor address(arg2) >> 96)
                mem[ceil32(32 * arg1.length) + 261] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + 193] = 68
                mem[ceil32(32 * arg1.length) + 225 len 4] = unknown_0xa9059cbb(?????)
                mem[ceil32(32 * arg1.length) + 293 len 96] = 0, mem[ceil32(32 * arg1.length) + 229], arg2 << 171, mem[ceil32(32 * arg1.length) + 293 len 28]
                mem[ceil32(32 * arg1.length) + 361] = 0
                call mem[ceil32(32 * arg1.length) + 141 len 20].mem[ceil32(32 * arg1.length) + 293 len 4] with:
                     gas gas_remaining wei
                    args mem[ceil32(32 * arg1.length) + 297 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'TRANSFER_FAILED'
                    if not arg1.length:
                        mem[ceil32(32 * arg1.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * arg1.length) + 297] = Mask(85, 0, arg2)
                        mem[ceil32(32 * arg1.length) + 329] = 64
                        mem[ceil32(32 * arg1.length) + 361] = 2
                        idx = 0
                        s = ceil32(32 * arg1.length) + 129
                        t = ceil32(32 * arg1.length) + 393
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + 393 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(32 * arg1.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _18111 = mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139
                        require mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                        require ceil32(32 * arg1.length) + return_data.size + 293 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 324
                        _18219 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                        if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294 > test266151307():
                            revert with 0, 65
                        mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294
                        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                        require _18111 + (32 * _18219) + 32 <= return_data.size
                        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len ceil32(32 * _18219)] = mem[ceil32(32 * arg1.length) + _18111 + 325 len ceil32(32 * _18219)]
                        if 1 >= _18219:
                            revert with 0, 50
                        _23126 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                        if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] < arg3:
                            revert with 0, 'INSUFFICIENT_OUT'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                            if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                            if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                                if Mask(1, 93, arg2) >> 93 != 1:
                                    mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                    call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args 0, _23126, this.address
                                else:
                                    _23980 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_23980 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_23980 + 36] = 0
                                    mem[_23980 + 68] = _23126
                                    mem[_23980 + 100] = this.address
                                    mem[_23980 + 132] = 128
                                    mem[_23980 + 164] = mem[_23980]
                                    mem[_23980 + 196 len ceil32(mem[_23980])] = mem[_23980 + 32 len ceil32(mem[_23980])]
                                    if ceil32(mem[_23980]) > mem[_23980]:
                                        mem[mem[_23980] + _23980 + 196] = 0
                                    require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                    call address(_6001 xor address(arg2) >> 96) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_23980]) + _23980 + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _18219
                                mem[mem[64] + 64 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                                return Array(len=_18219, data=mem[mem[64] + 64 len 32 * _18219])
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _18219
                                mem[mem[64] + 64 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                                return Array(len=_18219, data=mem[mem[64] + 64 len 32 * _18219])
                            _23983 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_23983 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_23983 + 36] = _23126
                            mem[_23983 + 68] = 0
                            mem[_23983 + 100] = this.address
                            mem[_23983 + 132] = 128
                            mem[_23983 + 164] = mem[_23983]
                            mem[_23983 + 196 len ceil32(mem[_23983])] = mem[_23983 + 32 len ceil32(mem[_23983])]
                            if ceil32(mem[_23983]) > mem[_23983]:
                                mem[mem[_23983] + _23983 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args _23126, 0, address(this.address), 128, mem[_23983], mem[_23983 + 196 len ceil32(mem[_23983])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_23983 + 32] = 32
                            mem[_23983 + 64] = _18219
                            mem[_23983 + 96 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                            return memory
                              from mem[64]
                               len _23983 + (32 * _18219) + -mem[64] + 96
                        if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _23126, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _18219
                                mem[mem[64] + 64 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                                return Array(len=_18219, data=mem[mem[64] + 64 len 32 * _18219])
                            _23986 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_23986 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_23986 + 36] = 0
                            mem[_23986 + 68] = _23126
                            mem[_23986 + 100] = this.address
                            mem[_23986 + 132] = 128
                            mem[_23986 + 164] = mem[_23986]
                            mem[_23986 + 196 len ceil32(mem[_23986])] = mem[_23986 + 32 len ceil32(mem[_23986])]
                            if ceil32(mem[_23986]) > mem[_23986]:
                                mem[mem[_23986] + _23986 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _23126, address(this.address), 128, mem[_23986], mem[_23986 + 196 len ceil32(mem[_23986])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_23986 + 32] = 32
                            mem[_23986 + 64] = _18219
                            mem[_23986 + 96 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                            return memory
                              from mem[64]
                               len _23986 + (32 * _18219) + -mem[64] + 96
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18219
                            mem[mem[64] + 64 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                            return Array(len=_18219, data=mem[mem[64] + 64 len 32 * _18219])
                        _23989 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_23989 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_23989 + 36] = _23126
                        mem[_23989 + 68] = 0
                        mem[_23989 + 100] = this.address
                        mem[_23989 + 132] = 128
                        mem[_23989 + 164] = mem[_23989]
                        mem[_23989 + 196 len ceil32(mem[_23989])] = mem[_23989 + 32 len ceil32(mem[_23989])]
                        if ceil32(mem[_23989]) > mem[_23989]:
                            mem[mem[_23989] + _23989 + 196] = 0
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _23126, 0, address(this.address), 128, mem[_23989], mem[_23989 + 196 len ceil32(mem[_23989])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_23989 + 32] = 32
                        mem[_23989 + 64] = _18219
                        mem[_23989 + 96 len 32 * _18219] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18219]
                        return memory
                          from mem[64]
                           len _23989 + (32 * _18219) + -mem[64] + 96
                    require arg1.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'TRANSFER_FAILED'
                    mem[ceil32(32 * arg1.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + 297] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + 329] = 64
                    mem[ceil32(32 * arg1.length) + 361] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + 393
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + 393 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
                    require return_data.size >= 32
                    _18112 = mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + return_data.size + 293 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 324
                    _18220 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                    if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                    require _18112 + (32 * _18220) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len ceil32(32 * _18220)] = mem[ceil32(32 * arg1.length) + _18112 + 325 len ceil32(32 * _18220)]
                    var79002 = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * _18220) + 325
                    if 1 >= _18220:
                        revert with 0, 50
                    _23127 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] < arg3:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _23127, this.address
                            else:
                                _23992 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_23992 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_23992 + 36] = 0
                                mem[_23992 + 68] = _23127
                                mem[_23992 + 100] = this.address
                                mem[_23992 + 132] = 128
                                mem[_23992 + 164] = mem[_23992]
                                mem[_23992 + 196 len ceil32(mem[_23992])] = mem[_23992 + 32 len ceil32(mem[_23992])]
                                if ceil32(mem[_23992]) > mem[_23992]:
                                    mem[mem[_23992] + _23992 + 196] = 0
                                require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                call address(_6001 xor address(arg2) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_23992]) + _23992 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18220
                            mem[mem[64] + 64 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                            return Array(len=_18220, data=mem[mem[64] + 64 len 32 * _18220])
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18220
                            mem[mem[64] + 64 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                            return Array(len=_18220, data=mem[mem[64] + 64 len 32 * _18220])
                        _23995 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_23995 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_23995 + 36] = _23127
                        mem[_23995 + 68] = 0
                        mem[_23995 + 100] = this.address
                        mem[_23995 + 132] = 128
                        mem[_23995 + 164] = mem[_23995]
                        mem[_23995 + 196 len ceil32(mem[_23995])] = mem[_23995 + 32 len ceil32(mem[_23995])]
                        if ceil32(mem[_23995]) > mem[_23995]:
                            mem[mem[_23995] + _23995 + 196] = 0
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _23127, 0, address(this.address), 128, mem[_23995], mem[_23995 + 196 len ceil32(mem[_23995])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_23995 + 32] = 32
                        mem[_23995 + 64] = _18220
                        mem[_23995 + 96 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                        return memory
                          from mem[64]
                           len _23995 + (32 * _18220) + -mem[64] + 96
                    if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23127, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18220
                            mem[mem[64] + 64 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                            return Array(len=_18220, data=mem[mem[64] + 64 len 32 * _18220])
                        _23998 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_23998 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_23998 + 36] = 0
                        mem[_23998 + 68] = _23127
                        mem[_23998 + 100] = this.address
                        mem[_23998 + 132] = 128
                        mem[_23998 + 164] = mem[_23998]
                        mem[_23998 + 196 len ceil32(mem[_23998])] = mem[_23998 + 32 len ceil32(mem[_23998])]
                        if ceil32(mem[_23998]) > mem[_23998]:
                            mem[mem[_23998] + _23998 + 196] = 0
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23127, address(this.address), 128, mem[_23998], mem[_23998 + 196 len ceil32(mem[_23998])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_23998 + 32] = 32
                        mem[_23998 + 64] = _18220
                        mem[_23998 + 96 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                        return memory
                          from mem[64]
                           len _23998 + (32 * _18220) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18220
                        mem[mem[64] + 64 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                        return Array(len=_18220, data=mem[mem[64] + 64 len 32 * _18220])
                    _24001 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24001 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24001 + 36] = _23127
                    mem[_24001 + 68] = 0
                    mem[_24001 + 100] = this.address
                    mem[_24001 + 132] = 128
                    mem[_24001 + 164] = mem[_24001]
                    mem[_24001 + 196 len ceil32(mem[_24001])] = mem[_24001 + 32 len ceil32(mem[_24001])]
                    if ceil32(mem[_24001]) > mem[_24001]:
                        mem[mem[_24001] + _24001 + 196] = 0
                    require ext_code.size(address(_6001 xor address(arg2) >> 96))
                    call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _23127, 0, address(this.address), 128, mem[_24001], mem[_24001 + 196 len ceil32(mem[_24001])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24001 + 32] = 32
                    mem[_24001 + 64] = _18220
                    mem[_24001 + 96 len 32 * _18220] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18220]
                    return memory
                      from mem[64]
                       len _24001 + (32 * _18220) + -mem[64] + 96
                mem[ceil32(32 * arg1.length) + 293] = return_data.size
                mem[ceil32(32 * arg1.length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not return_data.size:
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 298] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 330] = 64
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 362] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 394
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 394 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294
                    require return_data.size >= 32
                    _18113 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 325
                    _18221 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = _18221
                    require _18113 + (32 * _18221) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len ceil32(32 * _18221)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18113 + 326 len ceil32(32 * _18221)]
                    if 1 >= _18221:
                        revert with 0, 50
                    _23128 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358] < arg3:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6001 xor address(arg2) >> 96))
                                call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _23128, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _18221
                                mem[mem[64] + 64 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                                return Array(len=_18221, data=mem[mem[64] + 64 len 32 * _18221])
                            _24004 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24004 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24004 + 36] = 0
                            mem[_24004 + 68] = _23128
                            mem[_24004 + 100] = this.address
                            mem[_24004 + 132] = 128
                            mem[_24004 + 164] = mem[_24004]
                            mem[_24004 + 196 len ceil32(mem[_24004])] = mem[_24004 + 32 len ceil32(mem[_24004])]
                            if ceil32(mem[_24004]) > mem[_24004]:
                                mem[mem[_24004] + _24004 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _23128, address(this.address), 128, mem[_24004], mem[_24004 + 196 len ceil32(mem[_24004])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_24004 + 32] = 32
                            mem[_24004 + 64] = _18221
                            mem[_24004 + 96 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                            return memory
                              from mem[64]
                               len _24004 + (32 * _18221) + -mem[64] + 96
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18221
                            mem[mem[64] + 64 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                            return Array(len=_18221, data=mem[mem[64] + 64 len 32 * _18221])
                        _24007 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24007 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24007 + 36] = _23128
                        mem[_24007 + 68] = 0
                        mem[_24007 + 100] = this.address
                        mem[_24007 + 132] = 128
                        mem[_24007 + 164] = mem[_24007]
                        mem[_24007 + 196 len ceil32(mem[_24007])] = mem[_24007 + 32 len ceil32(mem[_24007])]
                        if ceil32(mem[_24007]) > mem[_24007]:
                            mem[mem[_24007] + _24007 + 196] = 0
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _23128, 0, address(this.address), 128, mem[_24007], mem[_24007 + 196 len ceil32(mem[_24007])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24007 + 32] = 32
                        mem[_24007 + 64] = _18221
                        mem[_24007 + 96 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                        return memory
                          from mem[64]
                           len _24007 + (32 * _18221) + -mem[64] + 96
                    if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23128, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18221
                            mem[mem[64] + 64 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                            return Array(len=_18221, data=mem[mem[64] + 64 len 32 * _18221])
                        _24010 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24010 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24010 + 36] = 0
                        mem[_24010 + 68] = _23128
                        mem[_24010 + 100] = this.address
                        mem[_24010 + 132] = 128
                        mem[_24010 + 164] = mem[_24010]
                        mem[_24010 + 196 len ceil32(mem[_24010])] = mem[_24010 + 32 len ceil32(mem[_24010])]
                        if ceil32(mem[_24010]) > mem[_24010]:
                            mem[mem[_24010] + _24010 + 196] = 0
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23128, address(this.address), 128, mem[_24010], mem[_24010 + 196 len ceil32(mem[_24010])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24010 + 32] = 32
                        mem[_24010 + 64] = _18221
                        mem[_24010 + 96 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                        return memory
                          from mem[64]
                           len _24010 + (32 * _18221) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6001 xor address(arg2) >> 96))
                        call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18221
                        mem[mem[64] + 64 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                        return Array(len=_18221, data=mem[mem[64] + 64 len 32 * _18221])
                    _24013 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24013 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24013 + 36] = _23128
                    mem[_24013 + 68] = 0
                    mem[_24013 + 100] = this.address
                    mem[_24013 + 132] = 128
                    mem[_24013 + 164] = mem[_24013]
                    mem[_24013 + 196 len ceil32(mem[_24013])] = mem[_24013 + 32 len ceil32(mem[_24013])]
                    if ceil32(mem[_24013]) > mem[_24013]:
                        mem[mem[_24013] + _24013 + 196] = 0
                    require ext_code.size(address(_6001 xor address(arg2) >> 96))
                    call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _23128, 0, address(this.address), 128, mem[_24013], mem[_24013 + 196 len ceil32(mem[_24013])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24013 + 32] = 32
                    mem[_24013 + 64] = _18221
                    mem[_24013 + 96 len 32 * _18221] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18221]
                    return memory
                      from mem[64]
                       len _24013 + (32 * _18221) + -mem[64] + 96
                require return_data.size >= 32
                require mem[ceil32(32 * arg1.length) + 325] == bool(mem[ceil32(32 * arg1.length) + 325])
                if not mem[ceil32(32 * arg1.length) + 325]:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 298] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 330] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 362] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 394
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 394 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294
                require return_data.size >= 32
                _18114 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 325
                _18222 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = _18222
                require _18114 + (32 * _18222) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len ceil32(32 * _18222)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18114 + 326 len ceil32(32 * _18222)]
                var79002 = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * _18222) + 326
                if 1 >= _18222:
                    revert with 0, 50
                _23129 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23129, this.address
                        else:
                            _24016 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24016 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24016 + 36] = 0
                            mem[_24016 + 68] = _23129
                            mem[_24016 + 100] = this.address
                            mem[_24016 + 132] = 128
                            mem[_24016 + 164] = mem[_24016]
                            mem[_24016 + 196 len ceil32(mem[_24016])] = mem[_24016 + 32 len ceil32(mem[_24016])]
                            if ceil32(mem[_24016]) > mem[_24016]:
                                mem[mem[_24016] + _24016 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24016]) + _24016 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _24019 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24019 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24019 + 36] = _23129
                            mem[_24019 + 68] = 0
                            mem[_24019 + 100] = this.address
                            mem[_24019 + 132] = 128
                            mem[_24019 + 164] = mem[_24019]
                            mem[_24019 + 196 len ceil32(mem[_24019])] = mem[_24019 + 32 len ceil32(mem[_24019])]
                            if ceil32(mem[_24019]) > mem[_24019]:
                                mem[mem[_24019] + _24019 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24019]) + _24019 + -mem[64] + 192]
                else:
                    if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23129, this.address
                        else:
                            _24022 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24022 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24022 + 36] = 0
                            mem[_24022 + 68] = _23129
                            mem[_24022 + 100] = this.address
                            mem[_24022 + 132] = 128
                            mem[_24022 + 164] = mem[_24022]
                            mem[_24022 + 196 len ceil32(mem[_24022])] = mem[_24022 + 32 len ceil32(mem[_24022])]
                            if ceil32(mem[_24022]) > mem[_24022]:
                                mem[mem[_24022] + _24022 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24022]) + _24022 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _24025 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24025 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24025 + 36] = _23129
                            mem[_24025 + 68] = 0
                            mem[_24025 + 100] = this.address
                            mem[_24025 + 132] = 128
                            mem[_24025 + 164] = mem[_24025]
                            mem[_24025 + 196 len ceil32(mem[_24025])] = mem[_24025 + 32 len ceil32(mem[_24025])]
                            if ceil32(mem[_24025]) > mem[_24025]:
                                mem[mem[_24025] + _24025 + 196] = 0
                            require ext_code.size(address(_6001 xor address(arg2) >> 96))
                            call address(_6001 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24025]) + _24025 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18222
                mem[mem[64] + 64 len 32 * _18222] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18222]
                return Array(len=_18222, data=mem[mem[64] + 64 len 32 * _18222])
            mem[ceil32(32 * arg1.length) + 197] = this.address
            mem[ceil32(32 * arg1.length) + 229] = address(_5990 xor address(arg2) >> 96)
            staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(_5990 xor address(arg2) >> 96)
            mem[ceil32(32 * arg1.length) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                if arg3:
                    if arg3 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = arg3
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = 160
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 389
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = this.address
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 389 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _11986 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 193 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 224
                    _12010 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = _12010
                    require _11986 + (32 * _12010) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len ceil32(32 * _12010)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _11986 + 225 len ceil32(32 * _12010)]
                    var67002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _12010) + 225
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = arg1.length
                    mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                    return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _11990 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 193 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 224
                _12062 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = _12062
                require _11990 + (32 * _12062) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len ceil32(32 * _12062)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _11990 + 225 len ceil32(32 * _12062)]
                if _12062 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _12062 < 1:
                    revert with 0, 17
                if _12062 - 1 >= _12062:
                    revert with 0, 50
                if mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                    revert with 0, 17
                if not mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                    if mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, arg2)
                    mem[mem[64] + 36] = mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22994 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23226 = mem[_22994]
                    require mem[_22994] <= test266151307()
                    require _22994 + return_data.size > _22994 + mem[_22994] + 31
                    _23458 = mem[_22994 + mem[_22994]]
                    if mem[_22994 + mem[_22994]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_22994 + mem[_22994]]) + 1 < 0 or _22994 + ceil32(return_data.size) + ceil32(32 * mem[_22994 + mem[_22994]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _22994 + ceil32(return_data.size) + ceil32(32 * mem[_22994 + mem[_22994]]) + 1
                    mem[_22994 + ceil32(return_data.size)] = _23458
                    require _23226 + (32 * _23458) + 32 <= return_data.size
                    mem[_22994 + ceil32(return_data.size) + 32 len ceil32(32 * _23458)] = mem[_22994 + _23226 + 32 len ceil32(32 * _23458)]
                    mem[mem[64]] = 32
                    _28010 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                    mem[mem[64] + 64 len 32 * _28010] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 32 * _28010]
                    return 32, mem[mem[64] + 32 len (32 * _28010) + 32]
                if not mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                    revert with 0, 18
                require mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] == Mask(7, 86, arg2) >> 86
                if mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[(32 * _12062 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22995 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23227 = mem[_22995]
                require mem[_22995] <= test266151307()
                require _22995 + return_data.size > _22995 + mem[_22995] + 31
                _23459 = mem[_22995 + mem[_22995]]
                if mem[_22995 + mem[_22995]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_22995 + mem[_22995]]) + 1 < 0 or _22995 + ceil32(return_data.size) + ceil32(32 * mem[_22995 + mem[_22995]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _22995 + ceil32(return_data.size) + ceil32(32 * mem[_22995 + mem[_22995]]) + 1
                mem[_22995 + ceil32(return_data.size)] = _23459
                require _23227 + (32 * _23459) + 32 <= return_data.size
                mem[_22995 + ceil32(return_data.size) + 32 len ceil32(32 * _23459)] = mem[_22995 + _23227 + 32 len ceil32(32 * _23459)]
                mem[mem[64]] = 32
                _28011 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 64 len 32 * _28011] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 32 * _28011]
                return 32, mem[mem[64] + 32 len (32 * _28011) + 32]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = this.address
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(_5990 xor address(arg2) >> 96)
            staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(_5990 xor address(arg2) >> 96)
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = address(_5990 xor address(arg2) >> 96)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 68
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229 len 28] = address(_5990 xor address(arg2) >> 96) << 64
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = 32
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325] = 'SafeERC20: low-level call failed'
            if not ext_code.size(mem[ceil32(32 * arg1.length) + 141 len 20]):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 96] = approve(address arg1, uint256 arg2), address(_5990 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
            var56001 = 96
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 0
            call mem[ceil32(32 * arg1.length) + 141 len 20] with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_5990 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_5990 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg1.length:
                        revert with memory
                          from 128
                           len arg1.length
                    revert with 0, 'SafeERC20: low-level call failed'
                if not arg1.length:
                    if arg3:
                        if arg3 <= 0:
                            revert with 0, 'INVALID_AOM'
                        if 1800 > !block.timestamp:
                            revert with 0, 17
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = arg3
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 160
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 521] = 2
                        idx = 0
                        s = ceil32(32 * arg1.length) + 129
                        t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457] = this.address
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                        call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                        require return_data.size >= 32
                        _18067 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                        require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                        require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                        _18172 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                        if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                            revert with 0, 65
                        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18172
                        require _18067 + (32 * _18172) + 32 <= return_data.size
                        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18172)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18067 + 389 len ceil32(32 * _18172)]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = arg1.length
                        mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                        var106001 = arg1.length
                        return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = 64
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _18103 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                    _18211 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                    if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18211
                    require _18103 + (32 * _18211) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18211)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18103 + 389 len ceil32(32 * _18211)]
                    if _18211 <= 0:
                        revert with 0, 'NO_OUT_AMOUNTS'
                    if _18211 < 1:
                        revert with 0, 17
                    if _18211 - 1 >= _18211:
                        revert with 0, 50
                    _23566 = mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]
                    if mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                        revert with 0, 17
                    if not mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                        if mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                            revert with 0, 17
                        if 100 * mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                            revert with 0, 17
                        require mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                        if mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                            revert with 0, 'INVALID_AOM'
                        if 1800 > !block.timestamp:
                            revert with 0, 17
                        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = Mask(85, 0, arg2)
                        mem[mem[64] + 36] = _23566 * Mask(7, 86, arg2) >> 86 / 100
                        mem[mem[64] + 68] = 160
                        mem[mem[64] + 164] = 2
                        idx = 0
                        s = ceil32(32 * arg1.length) + 129
                        t = mem[64] + 196
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 100] = this.address
                        mem[mem[64] + 132] = block.timestamp + 1800
                        call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2 << 171, _23566 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _27948 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _28282 = mem[_27948]
                        require mem[_27948] <= test266151307()
                        require _27948 + return_data.size > _27948 + mem[_27948] + 31
                        _28356 = mem[_27948 + mem[_27948]]
                        if mem[_27948 + mem[_27948]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_27948 + mem[_27948]]) + 1 < 0 or _27948 + ceil32(return_data.size) + ceil32(32 * mem[_27948 + mem[_27948]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _27948 + ceil32(return_data.size) + ceil32(32 * mem[_27948 + mem[_27948]]) + 1
                        mem[_27948 + ceil32(return_data.size)] = _28356
                        require _28282 + (32 * _28356) + 32 <= return_data.size
                        mem[_27948 + ceil32(return_data.size) + 32 len ceil32(32 * _28356)] = mem[_27948 + _28282 + 32 len ceil32(32 * _28356)]
                        var155002 = _27948 + ceil32(return_data.size) + ceil32(32 * _28356) + 32
                        mem[mem[64]] = 32
                        _30490 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 64 len 32 * _30490] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30490]
                        return 32, mem[mem[64] + 32 len (32 * _30490) + 32]
                    if not mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                        revert with 0, 18
                    require mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
                    if mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _18211 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, arg2)
                    mem[mem[64] + 36] = _23566 * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, _23566 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _27949 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _28283 = mem[_27949]
                    require mem[_27949] <= test266151307()
                    require _27949 + return_data.size > _27949 + mem[_27949] + 31
                    _28357 = mem[_27949 + mem[_27949]]
                    if mem[_27949 + mem[_27949]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_27949 + mem[_27949]]) + 1 < 0 or _27949 + ceil32(return_data.size) + ceil32(32 * mem[_27949 + mem[_27949]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _27949 + ceil32(return_data.size) + ceil32(32 * mem[_27949 + mem[_27949]]) + 1
                    mem[_27949 + ceil32(return_data.size)] = _28357
                    require _28283 + (32 * _28357) + 32 <= return_data.size
                    mem[_27949 + ceil32(return_data.size) + 32 len ceil32(32 * _28357)] = mem[_27949 + _28283 + 32 len ceil32(32 * _28357)]
                    mem[mem[64]] = 32
                    _30491 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 64 len 32 * _30491] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30491]
                    return 32, mem[mem[64] + 32 len (32 * _30491) + 32]
                require arg1.length >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if arg3:
                    if arg3 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = arg3
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _18068 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                    _18173 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                    if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18173
                    require _18068 + (32 * _18173) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18173)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18068 + 389 len ceil32(32 * _18173)]
                    var106002 = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * _18173) + 389
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = arg1.length
                    mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                    return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = 64
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18104 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                _18212 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18212
                require _18104 + (32 * _18212) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18212)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18104 + 389 len ceil32(32 * _18212)]
                if _18212 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _18212 < 1:
                    revert with 0, 17
                if _18212 - 1 >= _18212:
                    revert with 0, 50
                if mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    revert with 0, 17
                if not mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    if mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, arg2)
                    mem[mem[64] + 36] = mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _27950 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _28284 = mem[_27950]
                    require mem[_27950] <= test266151307()
                    require _27950 + return_data.size > _27950 + mem[_27950] + 31
                    _28358 = mem[_27950 + mem[_27950]]
                    if mem[_27950 + mem[_27950]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_27950 + mem[_27950]]) + 1 < 0 or _27950 + ceil32(return_data.size) + ceil32(32 * mem[_27950 + mem[_27950]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _27950 + ceil32(return_data.size) + ceil32(32 * mem[_27950 + mem[_27950]]) + 1
                    mem[_27950 + ceil32(return_data.size)] = _28358
                    require _28284 + (32 * _28358) + 32 <= return_data.size
                    mem[_27950 + ceil32(return_data.size) + 32 len ceil32(32 * _28358)] = mem[_27950 + _28284 + 32 len ceil32(32 * _28358)]
                    mem[mem[64]] = 32
                    _30492 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 64 len 32 * _30492] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30492]
                    return 32, mem[mem[64] + 32 len (32 * _30492) + 32]
                if not mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    revert with 0, 18
                require mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
                if mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[(32 * _18212 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27951 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28285 = mem[_27951]
                require mem[_27951] <= test266151307()
                require _27951 + return_data.size > _27951 + mem[_27951] + 31
                _28359 = mem[_27951 + mem[_27951]]
                if mem[_27951 + mem[_27951]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27951 + mem[_27951]]) + 1 < 0 or _27951 + ceil32(return_data.size) + ceil32(32 * mem[_27951 + mem[_27951]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27951 + ceil32(return_data.size) + ceil32(32 * mem[_27951 + mem[_27951]]) + 1
                mem[_27951 + ceil32(return_data.size)] = _28359
                require _28285 + (32 * _28359) + 32 <= return_data.size
                mem[_27951 + ceil32(return_data.size) + 32 len ceil32(32 * _28359)] = mem[_27951 + _28285 + 32 len ceil32(32 * _28359)]
                mem[mem[64]] = 32
                _30493 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30493] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30493]
                return 32, mem[mem[64] + 32 len (32 * _30493) + 32]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = return_data.size
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if arg3:
                    if arg3 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _18069 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
                    _18174 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
                    if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18174
                    require _18069 + (32 * _18174) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18174)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18069 + 390 len ceil32(32 * _18174)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = arg1.length
                    mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                    var106001 = arg1.length
                    return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                require return_data.size >= 32
                _18105 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
                _18213 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18213
                require _18105 + (32 * _18213) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18213)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18105 + 390 len ceil32(32 * _18213)]
                if _18213 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _18213 < 1:
                    revert with 0, 17
                if _18213 - 1 >= _18213:
                    revert with 0, 50
                if mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                    revert with 0, 17
                if not mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                    if mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, arg2)
                    mem[mem[64] + 36] = mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _27952 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _28286 = mem[_27952]
                    require mem[_27952] <= test266151307()
                    require _27952 + return_data.size > _27952 + mem[_27952] + 31
                    _28360 = mem[_27952 + mem[_27952]]
                    if mem[_27952 + mem[_27952]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_27952 + mem[_27952]]) + 1 < 0 or _27952 + ceil32(return_data.size) + ceil32(32 * mem[_27952 + mem[_27952]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _27952 + ceil32(return_data.size) + ceil32(32 * mem[_27952 + mem[_27952]]) + 1
                    mem[_27952 + ceil32(return_data.size)] = _28360
                    require _28286 + (32 * _28360) + 32 <= return_data.size
                    mem[_27952 + ceil32(return_data.size) + 32 len ceil32(32 * _28360)] = mem[_27952 + _28286 + 32 len ceil32(32 * _28360)]
                    var155002 = _27952 + ceil32(return_data.size) + ceil32(32 * _28360) + 32
                    mem[mem[64]] = 32
                    _30494 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 64 len 32 * _30494] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30494]
                    return 32, mem[mem[64] + 32 len (32 * _30494) + 32]
                if not mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                    revert with 0, 18
                require mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
                if mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _18213 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27953 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28287 = mem[_27953]
                require mem[_27953] <= test266151307()
                require _27953 + return_data.size > _27953 + mem[_27953] + 31
                _28361 = mem[_27953 + mem[_27953]]
                if mem[_27953 + mem[_27953]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27953 + mem[_27953]]) + 1 < 0 or _27953 + ceil32(return_data.size) + ceil32(32 * mem[_27953 + mem[_27953]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27953 + ceil32(return_data.size) + ceil32(32 * mem[_27953 + mem[_27953]]) + 1
                mem[_27953 + ceil32(return_data.size)] = _28361
                require _28287 + (32 * _28361) + 32 <= return_data.size
                mem[_27953 + ceil32(return_data.size) + 32 len ceil32(32 * _28361)] = mem[_27953 + _28287 + 32 len ceil32(32 * _28361)]
                mem[mem[64]] = 32
                _30495 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 64 len 32 * _30495] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30495]
                return 32, mem[mem[64] + 32 len (32 * _30495) + 32]
            require return_data.size >= 32
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389] == bool(mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389])
            if not mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
                call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                require return_data.size >= 32
                _18070 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
                _18175 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18175
                require _18070 + (32 * _18175) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18175)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18070 + 390 len ceil32(32 * _18175)]
                var106002 = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18175) + 390
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_5990 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18106 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
            _18214 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18214
            require _18106 + (32 * _18214) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18214)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18106 + 390 len ceil32(32 * _18214)]
            if _18214 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18214 < 1:
                revert with 0, 17
            if _18214 - 1 >= _18214:
                revert with 0, 50
            if mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 17
            if not mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                if mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27954 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28288 = mem[_27954]
                require mem[_27954] <= test266151307()
                require _27954 + return_data.size > _27954 + mem[_27954] + 31
                _28362 = mem[_27954 + mem[_27954]]
                if mem[_27954 + mem[_27954]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27954 + mem[_27954]]) + 1 < 0 or _27954 + ceil32(return_data.size) + ceil32(32 * mem[_27954 + mem[_27954]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27954 + ceil32(return_data.size) + ceil32(32 * mem[_27954 + mem[_27954]]) + 1
                mem[_27954 + ceil32(return_data.size)] = _28362
                require _28288 + (32 * _28362) + 32 <= return_data.size
                mem[_27954 + ceil32(return_data.size) + 32 len ceil32(32 * _28362)] = mem[_27954 + _28288 + 32 len ceil32(32 * _28362)]
                mem[mem[64]] = 32
                _30496 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 64 len 32 * _30496] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30496]
                return 32, mem[mem[64] + 32 len (32 * _30496) + 32]
            if not mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 18
            require mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, arg2)
            mem[mem[64] + 36] = mem[(32 * _18214 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_5990 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27955 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28289 = mem[_27955]
            require mem[_27955] <= test266151307()
            require _27955 + return_data.size > _27955 + mem[_27955] + 31
            _28363 = mem[_27955 + mem[_27955]]
            if mem[_27955 + mem[_27955]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27955 + mem[_27955]]) + 1 < 0 or _27955 + ceil32(return_data.size) + ceil32(32 * mem[_27955 + mem[_27955]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27955 + ceil32(return_data.size) + ceil32(32 * mem[_27955 + mem[_27955]]) + 1
            mem[_27955 + ceil32(return_data.size)] = _28363
            require _28289 + (32 * _28363) + 32 <= return_data.size
            mem[_27955 + ceil32(return_data.size) + 32 len ceil32(32 * _28363)] = mem[_27955 + _28289 + 32 len ceil32(32 * _28363)]
            mem[mem[64]] = 32
            _30497 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30497] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30497]
            return 32, mem[mem[64] + 32 len (32 * _30497) + 32]
        mem[ceil32(32 * arg1.length) + 197] = this.address
        staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(32 * arg1.length) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0, 'NO_IN'
        if 3 >= arg1.length:
            revert with 0, 50
        _6031 = mem[224]
        if 1 == Mask(1, 94, arg2) >> 94:
            if 2 >= arg1.length:
                revert with 0, 50
            _6042 = mem[192]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(mem[192] xor address(arg2) >> 96)
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 68
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 225 len 4] = unknown_0xa9059cbb(?????)
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 96] = 0, mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229], ext_call.return_data[0], mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 28]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 0
            call mem[ceil32(32 * arg1.length) + 141 len 20].mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not arg1.length:
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297] = ext_call.return_data[0]
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 329] = 64
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 393
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 393 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
                    require return_data.size >= 32
                    _18128 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 293 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 324
                    _18236 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                    require _18128 + (32 * _18236) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len ceil32(32 * _18236)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18128 + 325 len ceil32(32 * _18236)]
                    var79002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _18236) + 325
                    if 1 >= _18236:
                        revert with 0, 50
                    _23158 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                    if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] < arg3:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6042 xor address(arg2) >> 96))
                                call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _23158, this.address
                            else:
                                _24076 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_24076 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_24076 + 36] = 0
                                mem[_24076 + 68] = _23158
                                mem[_24076 + 100] = this.address
                                mem[_24076 + 132] = 128
                                mem[_24076 + 164] = mem[_24076]
                                mem[_24076 + 196 len ceil32(mem[_24076])] = mem[_24076 + 32 len ceil32(mem[_24076])]
                                if ceil32(mem[_24076]) > mem[_24076]:
                                    mem[mem[_24076] + _24076 + 196] = 0
                                require ext_code.size(address(_6042 xor address(arg2) >> 96))
                                call address(_6042 xor address(arg2) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_24076]) + _24076 + -mem[64] + 192]
                        else:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6042 xor address(arg2) >> 96))
                                call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _24079 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_24079 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_24079 + 36] = _23158
                                mem[_24079 + 68] = 0
                                mem[_24079 + 100] = this.address
                                mem[_24079 + 132] = 128
                                mem[_24079 + 164] = mem[_24079]
                                mem[_24079 + 196 len ceil32(mem[_24079])] = mem[_24079 + 32 len ceil32(mem[_24079])]
                                if ceil32(mem[_24079]) > mem[_24079]:
                                    mem[mem[_24079] + _24079 + 196] = 0
                                require ext_code.size(address(_6042 xor address(arg2) >> 96))
                                call address(_6042 xor address(arg2) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_24079]) + _24079 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18236
                        mem[mem[64] + 64 len 32 * _18236] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18236]
                        return Array(len=_18236, data=mem[mem[64] + 64 len 32 * _18236])
                    if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23158, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18236
                            mem[mem[64] + 64 len 32 * _18236] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18236]
                            return Array(len=_18236, data=mem[mem[64] + 64 len 32 * _18236])
                        _24082 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24082 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24082 + 36] = 0
                        mem[_24082 + 68] = _23158
                        mem[_24082 + 100] = this.address
                        mem[_24082 + 132] = 128
                        mem[_24082 + 164] = mem[_24082]
                        mem[_24082 + 196 len ceil32(mem[_24082])] = mem[_24082 + 32 len ceil32(mem[_24082])]
                        if ceil32(mem[_24082]) > mem[_24082]:
                            mem[mem[_24082] + _24082 + 196] = 0
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23158, address(this.address), 128, mem[_24082], mem[_24082 + 196 len ceil32(mem[_24082])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24082 + 32] = 32
                        mem[_24082 + 64] = _18236
                        mem[_24082 + 96 len 32 * _18236] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18236]
                        return memory
                          from mem[64]
                           len _24082 + (32 * _18236) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18236
                        mem[mem[64] + 64 len 32 * _18236] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18236]
                        return Array(len=_18236, data=mem[mem[64] + 64 len 32 * _18236])
                    _24085 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24085 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24085 + 36] = _23158
                    mem[_24085 + 68] = 0
                    mem[_24085 + 100] = this.address
                    mem[_24085 + 132] = 128
                    mem[_24085 + 164] = mem[_24085]
                    mem[_24085 + 196 len ceil32(mem[_24085])] = mem[_24085 + 32 len ceil32(mem[_24085])]
                    if ceil32(mem[_24085]) > mem[_24085]:
                        mem[mem[_24085] + _24085 + 196] = 0
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _23158, 0, address(this.address), 128, mem[_24085], mem[_24085 + 196 len ceil32(mem[_24085])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24085 + 32] = 32
                    mem[_24085 + 64] = _18236
                    mem[_24085 + 96 len 32 * _18236] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18236]
                    return memory
                      from mem[64]
                       len _24085 + (32 * _18236) + -mem[64] + 96
                require arg1.length >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 329] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 393
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 393 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
                require return_data.size >= 32
                _18129 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 293 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 324
                _18237 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                require _18129 + (32 * _18237) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len ceil32(32 * _18237)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18129 + 325 len ceil32(32 * _18237)]
                var85002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _18237) + 325
                if 1 >= _18237:
                    revert with 0, 50
                _23159 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23159, this.address
                        else:
                            _24088 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24088 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24088 + 36] = 0
                            mem[_24088 + 68] = _23159
                            mem[_24088 + 100] = this.address
                            mem[_24088 + 132] = 128
                            mem[_24088 + 164] = mem[_24088]
                            mem[_24088 + 196 len ceil32(mem[_24088])] = mem[_24088 + 32 len ceil32(mem[_24088])]
                            if ceil32(mem[_24088]) > mem[_24088]:
                                mem[mem[_24088] + _24088 + 196] = 0
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24088]) + _24088 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _24091 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24091 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24091 + 36] = _23159
                            mem[_24091 + 68] = 0
                            mem[_24091 + 100] = this.address
                            mem[_24091 + 132] = 128
                            mem[_24091 + 164] = mem[_24091]
                            mem[_24091 + 196 len ceil32(mem[_24091])] = mem[_24091 + 32 len ceil32(mem[_24091])]
                            if ceil32(mem[_24091]) > mem[_24091]:
                                mem[mem[_24091] + _24091 + 196] = 0
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24091]) + _24091 + -mem[64] + 192]
                else:
                    if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23159, this.address
                        else:
                            _24094 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24094 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24094 + 36] = 0
                            mem[_24094 + 68] = _23159
                            mem[_24094 + 100] = this.address
                            mem[_24094 + 132] = 128
                            mem[_24094 + 164] = mem[_24094]
                            mem[_24094 + 196 len ceil32(mem[_24094])] = mem[_24094 + 32 len ceil32(mem[_24094])]
                            if ceil32(mem[_24094]) > mem[_24094]:
                                mem[mem[_24094] + _24094 + 196] = 0
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24094]) + _24094 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _24097 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24097 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24097 + 36] = _23159
                            mem[_24097 + 68] = 0
                            mem[_24097 + 100] = this.address
                            mem[_24097 + 132] = 128
                            mem[_24097 + 164] = mem[_24097]
                            mem[_24097 + 196 len ceil32(mem[_24097])] = mem[_24097 + 32 len ceil32(mem[_24097])]
                            if ceil32(mem[_24097]) > mem[_24097]:
                                mem[mem[_24097] + _24097 + 196] = 0
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24097]) + _24097 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18237
                mem[mem[64] + 64 len 32 * _18237] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18237]
                return Array(len=_18237, data=mem[mem[64] + 64 len 32 * _18237])
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = return_data.size
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not return_data.size:
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                require return_data.size >= 32
                _18130 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 325
                _18238 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
                require _18130 + (32 * _18238) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len ceil32(32 * _18238)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + _18130 + 326 len ceil32(32 * _18238)]
                var79002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18238) + 326
                if 1 >= _18238:
                    revert with 0, 50
                _23160 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6042 xor address(arg2) >> 96))
                            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23160, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18238
                            mem[mem[64] + 64 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                            return Array(len=_18238, data=mem[mem[64] + 64 len 32 * _18238])
                        _24100 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24100 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24100 + 36] = 0
                        mem[_24100 + 68] = _23160
                        mem[_24100 + 100] = this.address
                        mem[_24100 + 132] = 128
                        mem[_24100 + 164] = mem[_24100]
                        mem[_24100 + 196 len ceil32(mem[_24100])] = mem[_24100 + 32 len ceil32(mem[_24100])]
                        if ceil32(mem[_24100]) > mem[_24100]:
                            mem[mem[_24100] + _24100 + 196] = 0
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23160, address(this.address), 128, mem[_24100], mem[_24100 + 196 len ceil32(mem[_24100])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24100 + 32] = 32
                        mem[_24100 + 64] = _18238
                        mem[_24100 + 96 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                        return memory
                          from mem[64]
                           len _24100 + (32 * _18238) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18238
                        mem[mem[64] + 64 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                        return Array(len=_18238, data=mem[mem[64] + 64 len 32 * _18238])
                    _24103 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24103 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24103 + 36] = _23160
                    mem[_24103 + 68] = 0
                    mem[_24103 + 100] = this.address
                    mem[_24103 + 132] = 128
                    mem[_24103 + 164] = mem[_24103]
                    mem[_24103 + 196 len ceil32(mem[_24103])] = mem[_24103 + 32 len ceil32(mem[_24103])]
                    if ceil32(mem[_24103]) > mem[_24103]:
                        mem[mem[_24103] + _24103 + 196] = 0
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _23160, 0, address(this.address), 128, mem[_24103], mem[_24103 + 196 len ceil32(mem[_24103])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24103 + 32] = 32
                    mem[_24103 + 64] = _18238
                    mem[_24103 + 96 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                    return memory
                      from mem[64]
                       len _24103 + (32 * _18238) + -mem[64] + 96
                if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23160, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18238
                        mem[mem[64] + 64 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                        return Array(len=_18238, data=mem[mem[64] + 64 len 32 * _18238])
                    _24106 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24106 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24106 + 36] = 0
                    mem[_24106 + 68] = _23160
                    mem[_24106 + 100] = this.address
                    mem[_24106 + 132] = 128
                    mem[_24106 + 164] = mem[_24106]
                    mem[_24106 + 196 len ceil32(mem[_24106])] = mem[_24106 + 32 len ceil32(mem[_24106])]
                    if ceil32(mem[_24106]) > mem[_24106]:
                        mem[mem[_24106] + _24106 + 196] = 0
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _23160, address(this.address), 128, mem[_24106], mem[_24106 + 196 len ceil32(mem[_24106])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24106 + 32] = 32
                    mem[_24106 + 64] = _18238
                    mem[_24106 + 96 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                    return memory
                      from mem[64]
                       len _24106 + (32 * _18238) + -mem[64] + 96
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _24109 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24109 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24109 + 36] = _23160
                    mem[_24109 + 68] = 0
                    mem[_24109 + 100] = this.address
                    mem[_24109 + 132] = 128
                    mem[_24109 + 164] = mem[_24109]
                    mem[_24109 + 196 len ceil32(mem[_24109])] = mem[_24109 + 32 len ceil32(mem[_24109])]
                    if ceil32(mem[_24109]) > mem[_24109]:
                        mem[mem[_24109] + _24109 + 196] = 0
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_24109]) + _24109 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18238
                mem[mem[64] + 64 len 32 * _18238] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18238]
                return Array(len=_18238, data=mem[mem[64] + 64 len 32 * _18238])
            require return_data.size >= 32
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325] == bool(mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325])
            if not mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = 64
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
            require return_data.size >= 32
            _18131 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 325
            _18239 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
            require _18131 + (32 * _18239) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len ceil32(32 * _18239)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + _18131 + 326 len ceil32(32 * _18239)]
            var85002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18239) + 326
            if 1 >= _18239:
                revert with 0, 50
            _23161 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] < arg3:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * arg1.length) + 141 len 20] < mem[ceil32(32 * arg1.length) + 173 len 20]:
                if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23161, this.address
                    else:
                        _24112 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24112 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24112 + 36] = 0
                        mem[_24112 + 68] = _23161
                        mem[_24112 + 100] = this.address
                        mem[_24112 + 132] = 128
                        mem[_24112 + 164] = mem[_24112]
                        mem[_24112 + 196 len ceil32(mem[_24112])] = mem[_24112 + 32 len ceil32(mem[_24112])]
                        if ceil32(mem[_24112]) > mem[_24112]:
                            mem[mem[_24112] + _24112 + 196] = 0
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24112]) + _24112 + -mem[64] + 192]
                else:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24115 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24115 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24115 + 36] = _23161
                        mem[_24115 + 68] = 0
                        mem[_24115 + 100] = this.address
                        mem[_24115 + 132] = 128
                        mem[_24115 + 164] = mem[_24115]
                        mem[_24115 + 196 len ceil32(mem[_24115])] = mem[_24115 + 32 len ceil32(mem[_24115])]
                        if ceil32(mem[_24115]) > mem[_24115]:
                            mem[mem[_24115] + _24115 + 196] = 0
                        require ext_code.size(address(_6042 xor address(arg2) >> 96))
                        call address(_6042 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24115]) + _24115 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18239
                mem[mem[64] + 64 len 32 * _18239] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18239]
                return Array(len=_18239, data=mem[mem[64] + 64 len 32 * _18239])
            if not mem[ceil32(32 * arg1.length) + 173 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 173 len 20]:
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _23161, this.address
                else:
                    _24118 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24118 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24118 + 36] = 0
                    mem[_24118 + 68] = _23161
                    mem[_24118 + 100] = this.address
                    mem[_24118 + 132] = 128
                    mem[_24118 + 164] = mem[_24118]
                    mem[_24118 + 196 len ceil32(mem[_24118])] = mem[_24118 + 32 len ceil32(mem[_24118])]
                    if ceil32(mem[_24118]) > mem[_24118]:
                        mem[mem[_24118] + _24118 + 196] = 0
                    require ext_code.size(address(_6042 xor address(arg2) >> 96))
                    call address(_6042 xor address(arg2) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_24118]) + _24118 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18239
                mem[mem[64] + 64 len 32 * _18239] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18239]
                return Array(len=_18239, data=mem[mem[64] + 64 len 32 * _18239])
            if Mask(1, 93, arg2) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_6042 xor address(arg2) >> 96))
                call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18239
                mem[mem[64] + 64 len 32 * _18239] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18239]
                return Array(len=_18239, data=mem[mem[64] + 64 len 32 * _18239])
            _24121 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_24121 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_24121 + 36] = _23161
            mem[_24121 + 68] = 0
            mem[_24121 + 100] = this.address
            mem[_24121 + 132] = 128
            mem[_24121 + 164] = mem[_24121]
            mem[_24121 + 196 len ceil32(mem[_24121])] = mem[_24121 + 32 len ceil32(mem[_24121])]
            if ceil32(mem[_24121]) > mem[_24121]:
                mem[mem[_24121] + _24121 + 196] = 0
            require ext_code.size(address(_6042 xor address(arg2) >> 96))
            call address(_6042 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _23161, 0, address(this.address), 128, mem[_24121], mem[_24121 + 196 len ceil32(mem[_24121])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_24121 + 32] = 32
            mem[_24121 + 64] = _18239
            mem[_24121 + 96 len 32 * _18239] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18239]
            return memory
              from mem[64]
               len _24121 + (32 * _18239) + -mem[64] + 96
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = this.address
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(_6031 xor address(arg2) >> 96)
        staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_6031 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = arg3
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 160
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = this.address
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _11987 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 193 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224
                _12023 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
                require _11987 + (32 * _12023) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len ceil32(32 * _12023)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _11987 + 225 len ceil32(32 * _12023)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = 64
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _11995 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 193 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224
            _12075 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _11995 + (32 * _12075) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len ceil32(32 * _12075)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _11995 + 225 len ceil32(32 * _12075)]
            if _12075 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _12075 < 1:
                revert with 0, 17
            if _12075 - 1 >= _12075:
                revert with 0, 50
            if mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
                revert with 0, 17
            if not mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
                if mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23020 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23252 = mem[_23020]
                require mem[_23020] <= test266151307()
                require _23020 + return_data.size > _23020 + mem[_23020] + 31
                _23484 = mem[_23020 + mem[_23020]]
                if mem[_23020 + mem[_23020]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_23020 + mem[_23020]]) + 1 < 0 or _23020 + ceil32(return_data.size) + ceil32(32 * mem[_23020 + mem[_23020]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _23020 + ceil32(return_data.size) + ceil32(32 * mem[_23020 + mem[_23020]]) + 1
                mem[_23020 + ceil32(return_data.size)] = _23484
                require _23252 + (32 * _23484) + 32 <= return_data.size
                mem[_23020 + ceil32(return_data.size) + 32 len ceil32(32 * _23484)] = mem[_23020 + _23252 + 32 len ceil32(32 * _23484)]
                mem[mem[64]] = 32
                _28076 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 64 len 32 * _28076] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 32 * _28076]
                return 32, mem[mem[64] + 32 len (32 * _28076) + 32]
            if not mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
                revert with 0, 18
            require mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _12075 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23021 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23253 = mem[_23021]
            require mem[_23021] <= test266151307()
            require _23021 + return_data.size > _23021 + mem[_23021] + 31
            _23485 = mem[_23021 + mem[_23021]]
            if mem[_23021 + mem[_23021]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_23021 + mem[_23021]]) + 1 < 0 or _23021 + ceil32(return_data.size) + ceil32(32 * mem[_23021 + mem[_23021]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _23021 + ceil32(return_data.size) + ceil32(32 * mem[_23021 + mem[_23021]]) + 1
            mem[_23021 + ceil32(return_data.size)] = _23485
            require _23253 + (32 * _23485) + 32 <= return_data.size
            mem[_23021 + ceil32(return_data.size) + 32 len ceil32(32 * _23485)] = mem[_23021 + _23253 + 32 len ceil32(32 * _23485)]
            mem[mem[64]] = 32
            _28077 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 64 len 32 * _28077] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 32 * _28077]
            return 32, mem[mem[64] + 32 len (32 * _28077) + 32]
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = this.address
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = address(_6031 xor address(arg2) >> 96)
        staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_6031 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 229] = address(_6031 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 261] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = 68
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 229 len 28] = address(_6031 xor address(arg2) >> 96) << 64
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 4] = approve(address arg1, uint256 arg2)
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 293] = 32
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 325] = 'SafeERC20: low-level call failed'
        if not ext_code.size(mem[ceil32(32 * arg1.length) + 141 len 20]):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 96] = approve(address arg1, uint256 arg2), address(_6031 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 0
        call mem[ceil32(32 * arg1.length) + 141 len 20] with:
           funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_6031 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_6031 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if arg1.length:
                    revert with memory
                      from 128
                       len arg1.length
                revert with 0, 'SafeERC20: low-level call failed'
            if not arg1.length:
                if arg3:
                    if arg3 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = arg3
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                    call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _18076 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
                    _18182 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18182
                    require _18076 + (32 * _18182) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18182)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18076 + 389 len ceil32(32 * _18182)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = arg1.length
                    mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                    var112001 = arg1.length
                    return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = 64
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18120 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
                _18228 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18228
                require _18120 + (32 * _18228) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18228)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18120 + 389 len ceil32(32 * _18228)]
                if _18228 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _18228 < 1:
                    revert with 0, 17
                if _18228 - 1 >= _18228:
                    revert with 0, 50
                if mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                    revert with 0, 17
                if not mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                    if mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    mem[mem[64] + 36] = mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _27966 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _28298 = mem[_27966]
                    require mem[_27966] <= test266151307()
                    require _27966 + return_data.size > _27966 + mem[_27966] + 31
                    _28374 = mem[_27966 + mem[_27966]]
                    if mem[_27966 + mem[_27966]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_27966 + mem[_27966]]) + 1 < 0 or _27966 + ceil32(return_data.size) + ceil32(32 * mem[_27966 + mem[_27966]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _27966 + ceil32(return_data.size) + ceil32(32 * mem[_27966 + mem[_27966]]) + 1
                    mem[_27966 + ceil32(return_data.size)] = _28374
                    require _28298 + (32 * _28374) + 32 <= return_data.size
                    mem[_27966 + ceil32(return_data.size) + 32 len ceil32(32 * _28374)] = mem[_27966 + _28298 + 32 len ceil32(32 * _28374)]
                    mem[mem[64]] = 32
                    _30506 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 64 len 32 * _30506] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30506]
                    return 32, mem[mem[64] + 32 len (32 * _30506) + 32]
                if not mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                    revert with 0, 18
                require mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
                if mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _18228 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27967 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28299 = mem[_27967]
                require mem[_27967] <= test266151307()
                require _27967 + return_data.size > _27967 + mem[_27967] + 31
                _28375 = mem[_27967 + mem[_27967]]
                if mem[_27967 + mem[_27967]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27967 + mem[_27967]]) + 1 < 0 or _27967 + ceil32(return_data.size) + ceil32(32 * mem[_27967 + mem[_27967]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27967 + ceil32(return_data.size) + ceil32(32 * mem[_27967 + mem[_27967]]) + 1
                mem[_27967 + ceil32(return_data.size)] = _28375
                require _28299 + (32 * _28375) + 32 <= return_data.size
                mem[_27967 + ceil32(return_data.size) + 32 len ceil32(32 * _28375)] = mem[_27967 + _28299 + 32 len ceil32(32 * _28375)]
                mem[mem[64]] = 32
                _30507 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30507] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30507]
                return 32, mem[mem[64] + 32 len (32 * _30507) + 32]
            require arg1.length >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = arg3
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 160
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 521] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457] = this.address
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18077 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
                _18183 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18183
                require _18077 + (32 * _18183) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18183)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18077 + 389 len ceil32(32 * _18183)]
                var112002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * _18183) + 389
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = 64
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
            require return_data.size >= 32
            _18121 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
            _18229 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18229
            require _18121 + (32 * _18229) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18229)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18121 + 389 len ceil32(32 * _18229)]
            var110002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * _18229) + 389
            if _18229 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18229 < 1:
                revert with 0, 17
            if _18229 - 1 >= _18229:
                revert with 0, 50
            if mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                revert with 0, 17
            if not mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                if mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27968 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28300 = mem[_27968]
                require mem[_27968] <= test266151307()
                require _27968 + return_data.size > _27968 + mem[_27968] + 31
                _28376 = mem[_27968 + mem[_27968]]
                if mem[_27968 + mem[_27968]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27968 + mem[_27968]]) + 1 < 0 or _27968 + ceil32(return_data.size) + ceil32(32 * mem[_27968 + mem[_27968]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27968 + ceil32(return_data.size) + ceil32(32 * mem[_27968 + mem[_27968]]) + 1
                mem[_27968 + ceil32(return_data.size)] = _28376
                require _28300 + (32 * _28376) + 32 <= return_data.size
                mem[_27968 + ceil32(return_data.size) + 32 len ceil32(32 * _28376)] = mem[_27968 + _28300 + 32 len ceil32(32 * _28376)]
                mem[mem[64]] = 32
                _30508 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30508] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30508]
                return 32, mem[mem[64] + 32 len (32 * _30508) + 32]
            if not mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                revert with 0, 18
            require mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _18229 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27969 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28301 = mem[_27969]
            require mem[_27969] <= test266151307()
            require _27969 + return_data.size > _27969 + mem[_27969] + 31
            _28377 = mem[_27969 + mem[_27969]]
            if mem[_27969 + mem[_27969]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27969 + mem[_27969]]) + 1 < 0 or _27969 + ceil32(return_data.size) + ceil32(32 * mem[_27969 + mem[_27969]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27969 + ceil32(return_data.size) + ceil32(32 * mem[_27969 + mem[_27969]]) + 1
            mem[_27969 + ceil32(return_data.size)] = _28377
            require _28301 + (32 * _28377) + 32 <= return_data.size
            mem[_27969 + ceil32(return_data.size) + 32 len ceil32(32 * _28377)] = mem[_27969 + _28301 + 32 len ceil32(32 * _28377)]
            mem[mem[64]] = 32
            _30509 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 64 len 32 * _30509] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30509]
            return 32, mem[mem[64] + 32 len (32 * _30509) + 32]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = return_data.size
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if not return_data.size:
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                require return_data.size >= 32
                _18078 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
                _18184 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                require _18078 + (32 * _18184) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18184)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18078 + 390 len ceil32(32 * _18184)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                var112001 = arg1.length
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18122 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
            _18230 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            require _18122 + (32 * _18230) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18230)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18122 + 390 len ceil32(32 * _18230)]
            if _18230 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18230 < 1:
                revert with 0, 17
            if _18230 - 1 >= _18230:
                revert with 0, 50
            if mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 17
            if not mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                if mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27970 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28302 = mem[_27970]
                require mem[_27970] <= test266151307()
                require _27970 + return_data.size > _27970 + mem[_27970] + 31
                _28378 = mem[_27970 + mem[_27970]]
                if mem[_27970 + mem[_27970]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27970 + mem[_27970]]) + 1 < 0 or _27970 + ceil32(return_data.size) + ceil32(32 * mem[_27970 + mem[_27970]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27970 + ceil32(return_data.size) + ceil32(32 * mem[_27970 + mem[_27970]]) + 1
                mem[_27970 + ceil32(return_data.size)] = _28378
                require _28302 + (32 * _28378) + 32 <= return_data.size
                mem[_27970 + ceil32(return_data.size) + 32 len ceil32(32 * _28378)] = mem[_27970 + _28302 + 32 len ceil32(32 * _28378)]
                mem[mem[64]] = 32
                _30510 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 64 len 32 * _30510] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30510]
                return 32, mem[mem[64] + 32 len (32 * _30510) + 32]
            if not mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 18
            require mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _18230 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27971 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28303 = mem[_27971]
            require mem[_27971] <= test266151307()
            require _27971 + return_data.size > _27971 + mem[_27971] + 31
            _28379 = mem[_27971 + mem[_27971]]
            if mem[_27971 + mem[_27971]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27971 + mem[_27971]]) + 1 < 0 or _27971 + ceil32(return_data.size) + ceil32(32 * mem[_27971 + mem[_27971]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27971 + ceil32(return_data.size) + ceil32(32 * mem[_27971 + mem[_27971]]) + 1
            mem[_27971 + ceil32(return_data.size)] = _28379
            require _28303 + (32 * _28379) + 32 <= return_data.size
            mem[_27971 + ceil32(return_data.size) + 32 len ceil32(32 * _28379)] = mem[_27971 + _28303 + 32 len ceil32(32 * _28379)]
            mem[mem[64]] = 32
            _30511 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30511] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30511]
            return 32, mem[mem[64] + 32 len (32 * _30511) + 32]
        require return_data.size >= 32
        require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == bool(mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389])
        if not mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if arg3:
            if arg3 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
            call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18079 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
            _18185 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            require _18079 + (32 * _18185) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18185)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18079 + 390 len ceil32(32 * _18185)]
            var112002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18185) + 390
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1.length
            mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
            return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_6031 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
        require return_data.size >= 32
        _18123 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
        _18231 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        require _18123 + (32 * _18231) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18231)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18123 + 390 len ceil32(32 * _18231)]
        var110002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18231) + 390
        if _18231 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _18231 < 1:
            revert with 0, 17
        if _18231 - 1 >= _18231:
            revert with 0, 50
        _23577 = mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        if mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 17
        if not mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            if mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = _23577 * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _23577 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27972 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28304 = mem[_27972]
            require mem[_27972] <= test266151307()
            require _27972 + return_data.size > _27972 + mem[_27972] + 31
            _28380 = mem[_27972 + mem[_27972]]
            if mem[_27972 + mem[_27972]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27972 + mem[_27972]]) + 1 < 0 or _27972 + ceil32(return_data.size) + ceil32(32 * mem[_27972 + mem[_27972]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27972 + ceil32(return_data.size) + ceil32(32 * mem[_27972 + mem[_27972]]) + 1
            mem[_27972 + ceil32(return_data.size)] = _28380
            require _28304 + (32 * _28380) + 32 <= return_data.size
            mem[_27972 + ceil32(return_data.size) + 32 len ceil32(32 * _28380)] = mem[_27972 + _28304 + 32 len ceil32(32 * _28380)]
            mem[mem[64]] = 32
            _30512 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30512] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30512]
            return 32, mem[mem[64] + 32 len (32 * _30512) + 32]
        if not mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 18
        require mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
        if mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _18231 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _23577 * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_6031 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _23577 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _27973 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _28305 = mem[_27973]
        require mem[_27973] <= test266151307()
        require _27973 + return_data.size > _27973 + mem[_27973] + 31
        _28381 = mem[_27973 + mem[_27973]]
        if mem[_27973 + mem[_27973]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_27973 + mem[_27973]]) + 1 < 0 or _27973 + ceil32(return_data.size) + ceil32(32 * mem[_27973 + mem[_27973]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _27973 + ceil32(return_data.size) + ceil32(32 * mem[_27973 + mem[_27973]]) + 1
        mem[_27973 + ceil32(return_data.size)] = _28381
        require _28305 + (32 * _28381) + 32 <= return_data.size
        mem[_27973 + ceil32(return_data.size) + 32 len ceil32(32 * _28381)] = mem[_27973 + _28305 + 32 len ceil32(32 * _28381)]
        mem[mem[64]] = 32
        _30513 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 64 len 32 * _30513] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30513]
        return 32, mem[mem[64] + 32 len (32 * _30513) + 32]
    if 1 >= arg1.length:
        revert with 0, 50
    mem[ceil32(32 * arg1.length) + 129] = address(mem[160] xor address(arg2) >> 96)
    if 0 >= arg1.length:
        revert with 0, 50
    mem[ceil32(32 * arg1.length) + 161] = address(mem[128] xor address(arg2) >> 96)
    if Mask(85, 0, arg2):
        if Mask(85, 0, arg2) <= 0:
            revert with 0, 'NO_IN'
        if 3 >= arg1.length:
            revert with 0, 50
        _5993 = mem[224]
        if 1 == Mask(1, 94, arg2) >> 94:
            if 2 >= arg1.length:
                revert with 0, 50
            _6005 = mem[192]
            mem[ceil32(32 * arg1.length) + 229] = address(mem[192] xor address(arg2) >> 96)
            mem[ceil32(32 * arg1.length) + 261] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + 193] = 68
            mem[ceil32(32 * arg1.length) + 225 len 4] = unknown_0xa9059cbb(?????)
            mem[ceil32(32 * arg1.length) + 293 len 96] = 0, mem[ceil32(32 * arg1.length) + 229], arg2 << 171, mem[ceil32(32 * arg1.length) + 293 len 28]
            mem[ceil32(32 * arg1.length) + 361] = 0
            call mem[ceil32(32 * arg1.length) + 141 len 20].mem[ceil32(32 * arg1.length) + 293 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(32 * arg1.length) + 297 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not arg1.length:
                    mem[ceil32(32 * arg1.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + 297] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + 329] = 64
                    mem[ceil32(32 * arg1.length) + 361] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + 393
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + 393 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
                    require return_data.size >= 32
                    _18145 = mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + return_data.size + 293 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 324
                    _18253 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                    if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                    require _18145 + (32 * _18253) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len ceil32(32 * _18253)] = mem[ceil32(32 * arg1.length) + _18145 + 325 len ceil32(32 * _18253)]
                    if 1 >= _18253:
                        revert with 0, 50
                    _23190 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                    if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] < arg3:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                        if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                            if Mask(1, 93, arg2) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                                call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _23190, this.address
                            else:
                                _24172 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_24172 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_24172 + 36] = 0
                                mem[_24172 + 68] = _23190
                                mem[_24172 + 100] = this.address
                                mem[_24172 + 132] = 128
                                mem[_24172 + 164] = mem[_24172]
                                mem[_24172 + 196 len ceil32(mem[_24172])] = mem[_24172 + 32 len ceil32(mem[_24172])]
                                if ceil32(mem[_24172]) > mem[_24172]:
                                    mem[mem[_24172] + _24172 + 196] = 0
                                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                                call address(_6005 xor address(arg2) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_24172]) + _24172 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18253
                            mem[mem[64] + 64 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                            return Array(len=_18253, data=mem[mem[64] + 64 len 32 * _18253])
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18253
                            mem[mem[64] + 64 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                            return Array(len=_18253, data=mem[mem[64] + 64 len 32 * _18253])
                        _24175 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24175 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24175 + 36] = _23190
                        mem[_24175 + 68] = 0
                        mem[_24175 + 100] = this.address
                        mem[_24175 + 132] = 128
                        mem[_24175 + 164] = mem[_24175]
                        mem[_24175 + 196 len ceil32(mem[_24175])] = mem[_24175 + 32 len ceil32(mem[_24175])]
                        if ceil32(mem[_24175]) > mem[_24175]:
                            mem[mem[_24175] + _24175 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _23190, 0, address(this.address), 128, mem[_24175], mem[_24175 + 196 len ceil32(mem[_24175])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24175 + 32] = 32
                        mem[_24175 + 64] = _18253
                        mem[_24175 + 96 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                        return memory
                          from mem[64]
                           len _24175 + (32 * _18253) + -mem[64] + 96
                    if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23190, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18253
                            mem[mem[64] + 64 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                            return Array(len=_18253, data=mem[mem[64] + 64 len 32 * _18253])
                        _24178 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24178 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24178 + 36] = 0
                        mem[_24178 + 68] = _23190
                        mem[_24178 + 100] = this.address
                        mem[_24178 + 132] = 128
                        mem[_24178 + 164] = mem[_24178]
                        mem[_24178 + 196 len ceil32(mem[_24178])] = mem[_24178 + 32 len ceil32(mem[_24178])]
                        if ceil32(mem[_24178]) > mem[_24178]:
                            mem[mem[_24178] + _24178 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23190, address(this.address), 128, mem[_24178], mem[_24178 + 196 len ceil32(mem[_24178])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24178 + 32] = 32
                        mem[_24178 + 64] = _18253
                        mem[_24178 + 96 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                        return memory
                          from mem[64]
                           len _24178 + (32 * _18253) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24181 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24181 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24181 + 36] = _23190
                        mem[_24181 + 68] = 0
                        mem[_24181 + 100] = this.address
                        mem[_24181 + 132] = 128
                        mem[_24181 + 164] = mem[_24181]
                        mem[_24181 + 196 len ceil32(mem[_24181])] = mem[_24181 + 32 len ceil32(mem[_24181])]
                        if ceil32(mem[_24181]) > mem[_24181]:
                            mem[mem[_24181] + _24181 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24181]) + _24181 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18253
                    mem[mem[64] + 64 len 32 * _18253] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18253]
                    return Array(len=_18253, data=mem[mem[64] + 64 len 32 * _18253])
                require arg1.length >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * arg1.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + 297] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + 329] = 64
                mem[ceil32(32 * arg1.length) + 361] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + 393
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + 393 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
                require return_data.size >= 32
                _18146 = mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + return_data.size + 293 > ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 324
                _18254 = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                if mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]) + 294
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = mem[ceil32(32 * arg1.length) + mem[ceil32(32 * arg1.length) + 293 len 4], Mask(85, 0, arg2) << 139 + 293]
                require _18146 + (32 * _18254) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len ceil32(32 * _18254)] = mem[ceil32(32 * arg1.length) + _18146 + 325 len ceil32(32 * _18254)]
                var79002 = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(32 * _18254) + 325
                if 1 >= _18254:
                    revert with 0, 50
                _23191 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23191, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18254
                            mem[mem[64] + 64 len 32 * _18254] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18254]
                            return Array(len=_18254, data=mem[mem[64] + 64 len 32 * _18254])
                        _24184 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24184 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24184 + 36] = 0
                        mem[_24184 + 68] = _23191
                        mem[_24184 + 100] = this.address
                        mem[_24184 + 132] = 128
                        mem[_24184 + 164] = mem[_24184]
                        mem[_24184 + 196 len ceil32(mem[_24184])] = mem[_24184 + 32 len ceil32(mem[_24184])]
                        if ceil32(mem[_24184]) > mem[_24184]:
                            mem[mem[_24184] + _24184 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23191, address(this.address), 128, mem[_24184], mem[_24184 + 196 len ceil32(mem[_24184])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24184 + 32] = 32
                        mem[_24184 + 64] = _18254
                        mem[_24184 + 96 len 32 * _18254] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18254]
                        return memory
                          from mem[64]
                           len _24184 + (32 * _18254) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24187 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24187 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24187 + 36] = _23191
                        mem[_24187 + 68] = 0
                        mem[_24187 + 100] = this.address
                        mem[_24187 + 132] = 128
                        mem[_24187 + 164] = mem[_24187]
                        mem[_24187 + 196 len ceil32(mem[_24187])] = mem[_24187 + 32 len ceil32(mem[_24187])]
                        if ceil32(mem[_24187]) > mem[_24187]:
                            mem[mem[_24187] + _24187 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24187]) + _24187 + -mem[64] + 192]
                else:
                    if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23191, this.address
                        else:
                            _24190 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24190 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24190 + 36] = 0
                            mem[_24190 + 68] = _23191
                            mem[_24190 + 100] = this.address
                            mem[_24190 + 132] = 128
                            mem[_24190 + 164] = mem[_24190]
                            mem[_24190 + 196 len ceil32(mem[_24190])] = mem[_24190 + 32 len ceil32(mem[_24190])]
                            if ceil32(mem[_24190]) > mem[_24190]:
                                mem[mem[_24190] + _24190 + 196] = 0
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24190]) + _24190 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _24193 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_24193 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_24193 + 36] = _23191
                            mem[_24193 + 68] = 0
                            mem[_24193 + 100] = this.address
                            mem[_24193 + 132] = 128
                            mem[_24193 + 164] = mem[_24193]
                            mem[_24193 + 196 len ceil32(mem[_24193])] = mem[_24193 + 32 len ceil32(mem[_24193])]
                            if ceil32(mem[_24193]) > mem[_24193]:
                                mem[mem[_24193] + _24193 + 196] = 0
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_24193]) + _24193 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18254
                mem[mem[64] + 64 len 32 * _18254] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len 32 * _18254]
                return Array(len=_18254, data=mem[mem[64] + 64 len 32 * _18254])
            mem[ceil32(32 * arg1.length) + 293] = return_data.size
            mem[ceil32(32 * arg1.length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not return_data.size:
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 298] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 330] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 362] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 394
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 394 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294
                require return_data.size >= 32
                _18147 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 325
                _18255 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = _18255
                require _18147 + (32 * _18255) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len ceil32(32 * _18255)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18147 + 326 len ceil32(32 * _18255)]
                if 1 >= _18255:
                    revert with 0, 50
                _23192 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6005 xor address(arg2) >> 96))
                            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23192, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18255
                            mem[mem[64] + 64 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                            return Array(len=_18255, data=mem[mem[64] + 64 len 32 * _18255])
                        _24196 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24196 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24196 + 36] = 0
                        mem[_24196 + 68] = _23192
                        mem[_24196 + 100] = this.address
                        mem[_24196 + 132] = 128
                        mem[_24196 + 164] = mem[_24196]
                        mem[_24196 + 196 len ceil32(mem[_24196])] = mem[_24196 + 32 len ceil32(mem[_24196])]
                        if ceil32(mem[_24196]) > mem[_24196]:
                            mem[mem[_24196] + _24196 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23192, address(this.address), 128, mem[_24196], mem[_24196 + 196 len ceil32(mem[_24196])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24196 + 32] = 32
                        mem[_24196 + 64] = _18255
                        mem[_24196 + 96 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                        return memory
                          from mem[64]
                           len _24196 + (32 * _18255) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24199 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24199 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24199 + 36] = _23192
                        mem[_24199 + 68] = 0
                        mem[_24199 + 100] = this.address
                        mem[_24199 + 132] = 128
                        mem[_24199 + 164] = mem[_24199]
                        mem[_24199 + 196 len ceil32(mem[_24199])] = mem[_24199 + 32 len ceil32(mem[_24199])]
                        if ceil32(mem[_24199]) > mem[_24199]:
                            mem[mem[_24199] + _24199 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24199]) + _24199 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18255
                    mem[mem[64] + 64 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                    return Array(len=_18255, data=mem[mem[64] + 64 len 32 * _18255])
                if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23192, this.address
                    else:
                        _24202 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24202 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24202 + 36] = 0
                        mem[_24202 + 68] = _23192
                        mem[_24202 + 100] = this.address
                        mem[_24202 + 132] = 128
                        mem[_24202 + 164] = mem[_24202]
                        mem[_24202 + 196 len ceil32(mem[_24202])] = mem[_24202 + 32 len ceil32(mem[_24202])]
                        if ceil32(mem[_24202]) > mem[_24202]:
                            mem[mem[_24202] + _24202 + 196] = 0
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24202]) + _24202 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18255
                    mem[mem[64] + 64 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                    return Array(len=_18255, data=mem[mem[64] + 64 len 32 * _18255])
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6005 xor address(arg2) >> 96))
                    call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18255
                    mem[mem[64] + 64 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                    return Array(len=_18255, data=mem[mem[64] + 64 len 32 * _18255])
                _24205 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24205 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24205 + 36] = _23192
                mem[_24205 + 68] = 0
                mem[_24205 + 100] = this.address
                mem[_24205 + 132] = 128
                mem[_24205 + 164] = mem[_24205]
                mem[_24205 + 196 len ceil32(mem[_24205])] = mem[_24205 + 32 len ceil32(mem[_24205])]
                if ceil32(mem[_24205]) > mem[_24205]:
                    mem[mem[_24205] + _24205 + 196] = 0
                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _23192, 0, address(this.address), 128, mem[_24205], mem[_24205 + 196 len ceil32(mem[_24205])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24205 + 32] = 32
                mem[_24205 + 64] = _18255
                mem[_24205 + 96 len 32 * _18255] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18255]
                return memory
                  from mem[64]
                   len _24205 + (32 * _18255) + -mem[64] + 96
            require return_data.size >= 32
            require mem[ceil32(32 * arg1.length) + 325] == bool(mem[ceil32(32 * arg1.length) + 325])
            if not mem[ceil32(32 * arg1.length) + 325]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 298] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 330] = 64
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 362] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 394
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 394 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294
            require return_data.size >= 32
            _18148 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 325
            _18256 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 1 < 0 or ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 294 len 4], Mask(85, 0, arg2) << 139 + 294]) + 295
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = _18256
            require _18148 + (32 * _18256) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len ceil32(32 * _18256)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18148 + 326 len ceil32(32 * _18256)]
            var79002 = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * _18256) + 326
            if 1 >= _18256:
                revert with 0, 50
            _23193 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358] < arg3:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6005 xor address(arg2) >> 96))
                        call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23193, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18256
                        mem[mem[64] + 64 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                        return Array(len=_18256, data=mem[mem[64] + 64 len 32 * _18256])
                    _24208 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24208 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24208 + 36] = 0
                    mem[_24208 + 68] = _23193
                    mem[_24208 + 100] = this.address
                    mem[_24208 + 132] = 128
                    mem[_24208 + 164] = mem[_24208]
                    mem[_24208 + 196 len ceil32(mem[_24208])] = mem[_24208 + 32 len ceil32(mem[_24208])]
                    if ceil32(mem[_24208]) > mem[_24208]:
                        mem[mem[_24208] + _24208 + 196] = 0
                    require ext_code.size(address(_6005 xor address(arg2) >> 96))
                    call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _23193, address(this.address), 128, mem[_24208], mem[_24208 + 196 len ceil32(mem[_24208])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24208 + 32] = 32
                    mem[_24208 + 64] = _18256
                    mem[_24208 + 96 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                    return memory
                      from mem[64]
                       len _24208 + (32 * _18256) + -mem[64] + 96
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6005 xor address(arg2) >> 96))
                    call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18256
                    mem[mem[64] + 64 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                    return Array(len=_18256, data=mem[mem[64] + 64 len 32 * _18256])
                _24211 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24211 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24211 + 36] = _23193
                mem[_24211 + 68] = 0
                mem[_24211 + 100] = this.address
                mem[_24211 + 132] = 128
                mem[_24211 + 164] = mem[_24211]
                mem[_24211 + 196 len ceil32(mem[_24211])] = mem[_24211 + 32 len ceil32(mem[_24211])]
                if ceil32(mem[_24211]) > mem[_24211]:
                    mem[mem[_24211] + _24211 + 196] = 0
                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _23193, 0, address(this.address), 128, mem[_24211], mem[_24211 + 196 len ceil32(mem[_24211])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24211 + 32] = 32
                mem[_24211 + 64] = _18256
                mem[_24211 + 96 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                return memory
                  from mem[64]
                   len _24211 + (32 * _18256) + -mem[64] + 96
            if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6005 xor address(arg2) >> 96))
                    call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _23193, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18256
                    mem[mem[64] + 64 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                    return Array(len=_18256, data=mem[mem[64] + 64 len 32 * _18256])
                _24214 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24214 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24214 + 36] = 0
                mem[_24214 + 68] = _23193
                mem[_24214 + 100] = this.address
                mem[_24214 + 132] = 128
                mem[_24214 + 164] = mem[_24214]
                mem[_24214 + 196 len ceil32(mem[_24214])] = mem[_24214 + 32 len ceil32(mem[_24214])]
                if ceil32(mem[_24214]) > mem[_24214]:
                    mem[mem[_24214] + _24214 + 196] = 0
                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _23193, address(this.address), 128, mem[_24214], mem[_24214 + 196 len ceil32(mem[_24214])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24214 + 32] = 32
                mem[_24214 + 64] = _18256
                mem[_24214 + 96 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                return memory
                  from mem[64]
                   len _24214 + (32 * _18256) + -mem[64] + 96
            if Mask(1, 93, arg2) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 358]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_6005 xor address(arg2) >> 96))
                call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18256
                mem[mem[64] + 64 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
                return Array(len=_18256, data=mem[mem[64] + 64 len 32 * _18256])
            _24217 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_24217 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_24217 + 36] = _23193
            mem[_24217 + 68] = 0
            mem[_24217 + 100] = this.address
            mem[_24217 + 132] = 128
            mem[_24217 + 164] = mem[_24217]
            mem[_24217 + 196 len ceil32(mem[_24217])] = mem[_24217 + 32 len ceil32(mem[_24217])]
            if ceil32(mem[_24217]) > mem[_24217]:
                mem[mem[_24217] + _24217 + 196] = 0
            require ext_code.size(address(_6005 xor address(arg2) >> 96))
            call address(_6005 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _23193, 0, address(this.address), 128, mem[_24217], mem[_24217 + 196 len ceil32(mem[_24217])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_24217 + 32] = 32
            mem[_24217 + 64] = _18256
            mem[_24217 + 96 len 32 * _18256] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 32 * _18256]
            return memory
              from mem[64]
               len _24217 + (32 * _18256) + -mem[64] + 96
        mem[ceil32(32 * arg1.length) + 197] = this.address
        mem[ceil32(32 * arg1.length) + 229] = address(_5993 xor address(arg2) >> 96)
        staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_5993 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = arg3
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = 160
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 357] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 389
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = this.address
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 389 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _11988 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 193 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 224
                _12036 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = _12036
                require _11988 + (32 * _12036) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len ceil32(32 * _12036)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _11988 + 225 len ceil32(32 * _12036)]
                var67002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _12036) + 225
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = 64
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 293
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _12000 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 193 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 224
            _12088 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193 len 4], Mask(85, 0, arg2) << 139 + 193]) + 194
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = _12088
            require _12000 + (32 * _12088) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len ceil32(32 * _12088)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _12000 + 225 len ceil32(32 * _12088)]
            if _12088 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _12088 < 1:
                revert with 0, 17
            if _12088 - 1 >= _12088:
                revert with 0, 50
            if mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                revert with 0, 17
            if not mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                if mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23046 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23278 = mem[_23046]
                require mem[_23046] <= test266151307()
                require _23046 + return_data.size > _23046 + mem[_23046] + 31
                _23510 = mem[_23046 + mem[_23046]]
                if mem[_23046 + mem[_23046]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_23046 + mem[_23046]]) + 1 < 0 or _23046 + ceil32(return_data.size) + ceil32(32 * mem[_23046 + mem[_23046]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _23046 + ceil32(return_data.size) + ceil32(32 * mem[_23046 + mem[_23046]]) + 1
                mem[_23046 + ceil32(return_data.size)] = _23510
                require _23278 + (32 * _23510) + 32 <= return_data.size
                mem[_23046 + ceil32(return_data.size) + 32 len ceil32(32 * _23510)] = mem[_23046 + _23278 + 32 len ceil32(32 * _23510)]
                mem[mem[64]] = 32
                _28142 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
                mem[mem[64] + 64 len 32 * _28142] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 32 * _28142]
                return 32, mem[mem[64] + 32 len (32 * _28142) + 32]
            if not mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225]:
                revert with 0, 18
            require mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, arg2)
            mem[mem[64] + 36] = mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, mem[(32 * _12088 - 1) + ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23047 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23279 = mem[_23047]
            require mem[_23047] <= test266151307()
            require _23047 + return_data.size > _23047 + mem[_23047] + 31
            _23511 = mem[_23047 + mem[_23047]]
            if mem[_23047 + mem[_23047]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_23047 + mem[_23047]]) + 1 < 0 or _23047 + ceil32(return_data.size) + ceil32(32 * mem[_23047 + mem[_23047]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _23047 + ceil32(return_data.size) + ceil32(32 * mem[_23047 + mem[_23047]]) + 1
            mem[_23047 + ceil32(return_data.size)] = _23511
            require _23279 + (32 * _23511) + 32 <= return_data.size
            mem[_23047 + ceil32(return_data.size) + 32 len ceil32(32 * _23511)] = mem[_23047 + _23279 + 32 len ceil32(32 * _23511)]
            mem[mem[64]] = 32
            _28143 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 64 len 32 * _28143] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 32 * _28143]
            return 32, mem[mem[64] + 32 len (32 * _28143) + 32]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = this.address
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(_5993 xor address(arg2) >> 96)
        staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_5993 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = address(_5993 xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 68
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229 len 28] = address(_5993 xor address(arg2) >> 96) << 64
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 225 len 4] = approve(address arg1, uint256 arg2)
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = 32
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325] = 'SafeERC20: low-level call failed'
        if not ext_code.size(mem[ceil32(32 * arg1.length) + 141 len 20]):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 96] = approve(address arg1, uint256 arg2), address(_5993 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
        var56001 = 96
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 0
        call mem[ceil32(32 * arg1.length) + 141 len 20] with:
           funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_5993 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_5993 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if arg1.length:
                    revert with memory
                      from 128
                       len arg1.length
                revert with 0, 'SafeERC20: low-level call failed'
            if not arg1.length:
                if arg3:
                    if arg3 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = arg3
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                    call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _18085 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                    require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                    require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                    _18192 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                    if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18192
                    require _18085 + (32 * _18192) + 32 <= return_data.size
                    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18192)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18085 + 389 len ceil32(32 * _18192)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = arg1.length
                    mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                    var106001 = arg1.length
                    return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = 64
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18137 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                _18245 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18245
                require _18137 + (32 * _18245) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18245)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18137 + 389 len ceil32(32 * _18245)]
                if _18245 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _18245 < 1:
                    revert with 0, 17
                if _18245 - 1 >= _18245:
                    revert with 0, 50
                _23582 = mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]
                if mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    revert with 0, 17
                if not mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    if mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                    if mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, arg2)
                    mem[mem[64] + 36] = _23582 * Mask(7, 86, arg2) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * arg1.length) + 129
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg2 << 171, _23582 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _27984 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _28314 = mem[_27984]
                    require mem[_27984] <= test266151307()
                    require _27984 + return_data.size > _27984 + mem[_27984] + 31
                    _28392 = mem[_27984 + mem[_27984]]
                    if mem[_27984 + mem[_27984]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_27984 + mem[_27984]]) + 1 < 0 or _27984 + ceil32(return_data.size) + ceil32(32 * mem[_27984 + mem[_27984]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _27984 + ceil32(return_data.size) + ceil32(32 * mem[_27984 + mem[_27984]]) + 1
                    mem[_27984 + ceil32(return_data.size)] = _28392
                    require _28314 + (32 * _28392) + 32 <= return_data.size
                    mem[_27984 + ceil32(return_data.size) + 32 len ceil32(32 * _28392)] = mem[_27984 + _28314 + 32 len ceil32(32 * _28392)]
                    var155002 = _27984 + ceil32(return_data.size) + ceil32(32 * _28392) + 32
                    mem[mem[64]] = 32
                    _30522 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                    mem[mem[64] + 64 len 32 * _30522] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30522]
                    return 32, mem[mem[64] + 32 len (32 * _30522) + 32]
                if not mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                    revert with 0, 18
                require mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
                if mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18245 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = _23582 * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, _23582 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27985 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28315 = mem[_27985]
                require mem[_27985] <= test266151307()
                require _27985 + return_data.size > _27985 + mem[_27985] + 31
                _28393 = mem[_27985 + mem[_27985]]
                if mem[_27985 + mem[_27985]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27985 + mem[_27985]]) + 1 < 0 or _27985 + ceil32(return_data.size) + ceil32(32 * mem[_27985 + mem[_27985]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27985 + ceil32(return_data.size) + ceil32(32 * mem[_27985 + mem[_27985]]) + 1
                mem[_27985 + ceil32(return_data.size)] = _28393
                require _28315 + (32 * _28393) + 32 <= return_data.size
                mem[_27985 + ceil32(return_data.size) + 32 len ceil32(32 * _28393)] = mem[_27985 + _28315 + 32 len ceil32(32 * _28393)]
                mem[mem[64]] = 32
                _30523 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30523] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30523]
                return 32, mem[mem[64] + 32 len (32 * _30523) + 32]
            require arg1.length >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = arg3
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 160
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 521] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457] = this.address
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18086 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
                _18193 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18193
                require _18086 + (32 * _18193) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18193)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18086 + 389 len ceil32(32 * _18193)]
                var106002 = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * _18193) + 389
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 361] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 393] = 64
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 425] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 457 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357
            require return_data.size >= 32
            _18138 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 388
            _18246 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357 len 4], Mask(85, 0, arg2) << 139 + 357]) + 358
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = _18246
            require _18138 + (32 * _18246) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len ceil32(32 * _18246)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _18138 + 389 len ceil32(32 * _18246)]
            if _18246 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18246 < 1:
                revert with 0, 17
            if _18246 - 1 >= _18246:
                revert with 0, 50
            if mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                revert with 0, 17
            if not mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                if mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27986 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28316 = mem[_27986]
                require mem[_27986] <= test266151307()
                require _27986 + return_data.size > _27986 + mem[_27986] + 31
                _28394 = mem[_27986 + mem[_27986]]
                if mem[_27986 + mem[_27986]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27986 + mem[_27986]]) + 1 < 0 or _27986 + ceil32(return_data.size) + ceil32(32 * mem[_27986 + mem[_27986]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27986 + ceil32(return_data.size) + ceil32(32 * mem[_27986 + mem[_27986]]) + 1
                mem[_27986 + ceil32(return_data.size)] = _28394
                require _28316 + (32 * _28394) + 32 <= return_data.size
                mem[_27986 + ceil32(return_data.size) + 32 len ceil32(32 * _28394)] = mem[_27986 + _28316 + 32 len ceil32(32 * _28394)]
                mem[mem[64]] = 32
                _30524 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30524] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30524]
                return 32, mem[mem[64] + 32 len (32 * _30524) + 32]
            if not mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
                revert with 0, 18
            require mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, arg2)
            mem[mem[64] + 36] = mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, mem[(32 * _18246 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27987 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28317 = mem[_27987]
            require mem[_27987] <= test266151307()
            require _27987 + return_data.size > _27987 + mem[_27987] + 31
            _28395 = mem[_27987 + mem[_27987]]
            if mem[_27987 + mem[_27987]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27987 + mem[_27987]]) + 1 < 0 or _27987 + ceil32(return_data.size) + ceil32(32 * mem[_27987 + mem[_27987]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27987 + ceil32(return_data.size) + ceil32(32 * mem[_27987 + mem[_27987]]) + 1
            mem[_27987 + ceil32(return_data.size)] = _28395
            require _28317 + (32 * _28395) + 32 <= return_data.size
            mem[_27987 + ceil32(return_data.size) + 32 len ceil32(32 * _28395)] = mem[_27987 + _28317 + 32 len ceil32(32 * _28395)]
            mem[mem[64]] = 32
            _30525 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 64 len 32 * _30525] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len 32 * _30525]
            return 32, mem[mem[64] + 32 len (32 * _30525) + 32]
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = return_data.size
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if not return_data.size:
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                require return_data.size >= 32
                _18087 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
                require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
                require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
                _18194 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18194
                require _18087 + (32 * _18194) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18194)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18087 + 390 len ceil32(32 * _18194)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                var106001 = arg1.length
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18139 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
            _18247 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18247
            require _18139 + (32 * _18247) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18247)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18139 + 390 len ceil32(32 * _18247)]
            if _18247 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18247 < 1:
                revert with 0, 17
            if _18247 - 1 >= _18247:
                revert with 0, 50
            _23584 = mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            if mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 17
            if not mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                if mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, arg2)
                mem[mem[64] + 36] = mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg2 << 171, _23584 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _27988 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28318 = mem[_27988]
                require mem[_27988] <= test266151307()
                require _27988 + return_data.size > _27988 + mem[_27988] + 31
                _28396 = mem[_27988 + mem[_27988]]
                if mem[_27988 + mem[_27988]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_27988 + mem[_27988]]) + 1 < 0 or _27988 + ceil32(return_data.size) + ceil32(32 * mem[_27988 + mem[_27988]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _27988 + ceil32(return_data.size) + ceil32(32 * mem[_27988 + mem[_27988]]) + 1
                mem[_27988 + ceil32(return_data.size)] = _28396
                require _28318 + (32 * _28396) + 32 <= return_data.size
                mem[_27988 + ceil32(return_data.size) + 32 len ceil32(32 * _28396)] = mem[_27988 + _28318 + 32 len ceil32(32 * _28396)]
                var155002 = _27988 + ceil32(return_data.size) + ceil32(32 * _28396) + 32
                mem[mem[64]] = 32
                _30526 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 64 len 32 * _30526] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30526]
                return 32, mem[mem[64] + 32 len (32 * _30526) + 32]
            if not mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
                revert with 0, 18
            require mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, arg2)
            mem[mem[64] + 36] = mem[(32 * _18247 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, _23584 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27989 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28319 = mem[_27989]
            require mem[_27989] <= test266151307()
            require _27989 + return_data.size > _27989 + mem[_27989] + 31
            _28397 = mem[_27989 + mem[_27989]]
            if mem[_27989 + mem[_27989]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27989 + mem[_27989]]) + 1 < 0 or _27989 + ceil32(return_data.size) + ceil32(32 * mem[_27989 + mem[_27989]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27989 + ceil32(return_data.size) + ceil32(32 * mem[_27989 + mem[_27989]]) + 1
            mem[_27989 + ceil32(return_data.size)] = _28397
            require _28319 + (32 * _28397) + 32 <= return_data.size
            mem[_27989 + ceil32(return_data.size) + 32 len ceil32(32 * _28397)] = mem[_27989 + _28319 + 32 len ceil32(32 * _28397)]
            mem[mem[64]] = 32
            _30527 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30527] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30527]
            return 32, mem[mem[64] + 32 len (32 * _30527) + 32]
        require return_data.size >= 32
        require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389] == bool(mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389])
        if not mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if arg3:
            if arg3 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
            call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18088 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
            _18195 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18195
            require _18088 + (32 * _18195) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18195)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18088 + 390 len ceil32(32 * _18195)]
            var106002 = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18195) + 390
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1.length
            mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
            return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = Mask(85, 0, arg2)
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_5993 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args arg2 << 171, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
        require return_data.size >= 32
        _18140 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139
        require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 <= test266151307()
        require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 389
        _18248 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]
        if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], Mask(85, 0, arg2) << 139 + 358]) + 359
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = _18248
        require _18140 + (32 * _18248) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18248)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _18140 + 390 len ceil32(32 * _18248)]
        if _18248 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _18248 < 1:
            revert with 0, 17
        if _18248 - 1 >= _18248:
            revert with 0, 50
        _23585 = mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        if mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 17
        if not mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            if mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, arg2)
            mem[mem[64] + 36] = mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg2 << 171, _23585 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _27990 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28320 = mem[_27990]
            require mem[_27990] <= test266151307()
            require _27990 + return_data.size > _27990 + mem[_27990] + 31
            _28398 = mem[_27990 + mem[_27990]]
            if mem[_27990 + mem[_27990]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_27990 + mem[_27990]]) + 1 < 0 or _27990 + ceil32(return_data.size) + ceil32(32 * mem[_27990 + mem[_27990]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _27990 + ceil32(return_data.size) + ceil32(32 * mem[_27990 + mem[_27990]]) + 1
            mem[_27990 + ceil32(return_data.size)] = _28398
            require _28320 + (32 * _28398) + 32 <= return_data.size
            mem[_27990 + ceil32(return_data.size) + 32 len ceil32(32 * _28398)] = mem[_27990 + _28320 + 32 len ceil32(32 * _28398)]
            mem[mem[64]] = 32
            _30528 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30528] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30528]
            return 32, mem[mem[64] + 32 len (32 * _30528) + 32]
        if not mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 18
        require mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
        if mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = Mask(85, 0, arg2)
        mem[mem[64] + 36] = mem[(32 * _18248 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_5993 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args arg2 << 171, _23585 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _27991 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _28321 = mem[_27991]
        require mem[_27991] <= test266151307()
        require _27991 + return_data.size > _27991 + mem[_27991] + 31
        _28399 = mem[_27991 + mem[_27991]]
        if mem[_27991 + mem[_27991]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_27991 + mem[_27991]]) + 1 < 0 or _27991 + ceil32(return_data.size) + ceil32(32 * mem[_27991 + mem[_27991]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _27991 + ceil32(return_data.size) + ceil32(32 * mem[_27991 + mem[_27991]]) + 1
        mem[_27991 + ceil32(return_data.size)] = _28399
        require _28321 + (32 * _28399) + 32 <= return_data.size
        mem[_27991 + ceil32(return_data.size) + 32 len ceil32(32 * _28399)] = mem[_27991 + _28321 + 32 len ceil32(32 * _28399)]
        mem[mem[64]] = 32
        _30529 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 64 len 32 * _30529] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30529]
        return 32, mem[mem[64] + 32 len (32 * _30529) + 32]
    mem[ceil32(32 * arg1.length) + 197] = this.address
    staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(32 * arg1.length) + 193] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'NO_IN'
    if 3 >= arg1.length:
        revert with 0, 50
    _6034 = mem[224]
    if 1 == Mask(1, 94, arg2) >> 94:
        if 2 >= arg1.length:
            revert with 0, 50
        _6046 = mem[192]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(mem[192] xor address(arg2) >> 96)
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 261] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = 68
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 225 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 96] = 0, mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229], ext_call.return_data[0], mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 28]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 0
        call mem[ceil32(32 * arg1.length) + 141 len 20].mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not arg1.length:
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 329] = 64
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 393
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 393 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
                require return_data.size >= 32
                _18162 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 293 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 324
                _18270 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                require _18162 + (32 * _18270) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len ceil32(32 * _18270)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18162 + 325 len ceil32(32 * _18270)]
                var79002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _18270) + 325
                if 1 >= _18270:
                    revert with 0, 50
                _23222 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] < arg3:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                        if Mask(1, 93, arg2) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_6046 xor address(arg2) >> 96))
                            call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _23222, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _18270
                            mem[mem[64] + 64 len 32 * _18270] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18270]
                            return Array(len=_18270, data=mem[mem[64] + 64 len 32 * _18270])
                        _24268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24268 + 36] = 0
                        mem[_24268 + 68] = _23222
                        mem[_24268 + 100] = this.address
                        mem[_24268 + 132] = 128
                        mem[_24268 + 164] = mem[_24268]
                        mem[_24268 + 196 len ceil32(mem[_24268])] = mem[_24268 + 32 len ceil32(mem[_24268])]
                        if ceil32(mem[_24268]) > mem[_24268]:
                            mem[mem[_24268] + _24268 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _23222, address(this.address), 128, mem[_24268], mem[_24268 + 196 len ceil32(mem[_24268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_24268 + 32] = 32
                        mem[_24268 + 64] = _18270
                        mem[_24268 + 96 len 32 * _18270] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18270]
                        return memory
                          from mem[64]
                           len _24268 + (32 * _18270) + -mem[64] + 96
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18270
                        mem[mem[64] + 64 len 32 * _18270] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18270]
                        return Array(len=_18270, data=mem[mem[64] + 64 len 32 * _18270])
                    _24271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24271 + 36] = _23222
                    mem[_24271 + 68] = 0
                    mem[_24271 + 100] = this.address
                    mem[_24271 + 132] = 128
                    mem[_24271 + 164] = mem[_24271]
                    mem[_24271 + 196 len ceil32(mem[_24271])] = mem[_24271 + 32 len ceil32(mem[_24271])]
                    if ceil32(mem[_24271]) > mem[_24271]:
                        mem[mem[_24271] + _24271 + 196] = 0
                    require ext_code.size(address(_6046 xor address(arg2) >> 96))
                    call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _23222, 0, address(this.address), 128, mem[_24271], mem[_24271 + 196 len ceil32(mem[_24271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24271 + 32] = 32
                    mem[_24271 + 64] = _18270
                    mem[_24271 + 96 len 32 * _18270] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18270]
                    return memory
                      from mem[64]
                       len _24271 + (32 * _18270) + -mem[64] + 96
                if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23222, this.address
                    else:
                        _24274 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24274 + 36] = 0
                        mem[_24274 + 68] = _23222
                        mem[_24274 + 100] = this.address
                        mem[_24274 + 132] = 128
                        mem[_24274 + 164] = mem[_24274]
                        mem[_24274 + 196 len ceil32(mem[_24274])] = mem[_24274 + 32 len ceil32(mem[_24274])]
                        if ceil32(mem[_24274]) > mem[_24274]:
                            mem[mem[_24274] + _24274 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24274]) + _24274 + -mem[64] + 192]
                else:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24277 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24277 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24277 + 36] = _23222
                        mem[_24277 + 68] = 0
                        mem[_24277 + 100] = this.address
                        mem[_24277 + 132] = 128
                        mem[_24277 + 164] = mem[_24277]
                        mem[_24277 + 196 len ceil32(mem[_24277])] = mem[_24277 + 32 len ceil32(mem[_24277])]
                        if ceil32(mem[_24277]) > mem[_24277]:
                            mem[mem[_24277] + _24277 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24277]) + _24277 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18270
                mem[mem[64] + 64 len 32 * _18270] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18270]
                return Array(len=_18270, data=mem[mem[64] + 64 len 32 * _18270])
            require arg1.length >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 297] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 329] = 64
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 361] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + ceil32(return_data.size) + 393
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 393 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
            require return_data.size >= 32
            _18163 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + ceil32(return_data.size) + return_data.size + 293 > ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 324
            _18271 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 294
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293 len 4], ext_call.return_data[0 len 28] + 293]
            require _18163 + (32 * _18271) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len ceil32(32 * _18271)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + _18163 + 325 len ceil32(32 * _18271)]
            var85002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(32 * _18271) + 325
            if 1 >= _18271:
                revert with 0, 50
            _23223 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] < arg3:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23223, this.address
                    else:
                        _24280 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24280 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24280 + 36] = 0
                        mem[_24280 + 68] = _23223
                        mem[_24280 + 100] = this.address
                        mem[_24280 + 132] = 128
                        mem[_24280 + 164] = mem[_24280]
                        mem[_24280 + 196 len ceil32(mem[_24280])] = mem[_24280 + 32 len ceil32(mem[_24280])]
                        if ceil32(mem[_24280]) > mem[_24280]:
                            mem[mem[_24280] + _24280 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24280]) + _24280 + -mem[64] + 192]
                else:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24283 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24283 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24283 + 36] = _23223
                        mem[_24283 + 68] = 0
                        mem[_24283 + 100] = this.address
                        mem[_24283 + 132] = 128
                        mem[_24283 + 164] = mem[_24283]
                        mem[_24283 + 196 len ceil32(mem[_24283])] = mem[_24283 + 32 len ceil32(mem[_24283])]
                        if ceil32(mem[_24283]) > mem[_24283]:
                            mem[mem[_24283] + _24283 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24283]) + _24283 + -mem[64] + 192]
            else:
                if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23223, this.address
                    else:
                        _24286 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24286 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24286 + 36] = 0
                        mem[_24286 + 68] = _23223
                        mem[_24286 + 100] = this.address
                        mem[_24286 + 132] = 128
                        mem[_24286 + 164] = mem[_24286]
                        mem[_24286 + 196 len ceil32(mem[_24286])] = mem[_24286 + 32 len ceil32(mem[_24286])]
                        if ceil32(mem[_24286]) > mem[_24286]:
                            mem[mem[_24286] + _24286 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24286]) + _24286 + -mem[64] + 192]
                else:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _24289 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_24289 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_24289 + 36] = _23223
                        mem[_24289 + 68] = 0
                        mem[_24289 + 100] = this.address
                        mem[_24289 + 132] = 128
                        mem[_24289 + 164] = mem[_24289]
                        mem[_24289 + 196 len ceil32(mem[_24289])] = mem[_24289 + 32 len ceil32(mem[_24289])]
                        if ceil32(mem[_24289]) > mem[_24289]:
                            mem[mem[_24289] + _24289 + 196] = 0
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_24289]) + _24289 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _18271
            mem[mem[64] + 64 len 32 * _18271] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325 len 32 * _18271]
            return Array(len=_18271, data=mem[mem[64] + 64 len 32 * _18271])
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 293] = return_data.size
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'TRANSFER_FAILED'
        if not return_data.size:
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = 64
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
            require return_data.size >= 32
            _18164 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 325
            _18272 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
            if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
            require _18164 + (32 * _18272) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len ceil32(32 * _18272)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + _18164 + 326 len ceil32(32 * _18272)]
            var79002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18272) + 326
            if 1 >= _18272:
                revert with 0, 50
            _23224 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] < arg3:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
                if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                    if Mask(1, 93, arg2) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_6046 xor address(arg2) >> 96))
                        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _23224, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _18272
                        mem[mem[64] + 64 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                        return Array(len=_18272, data=mem[mem[64] + 64 len 32 * _18272])
                    _24292 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_24292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_24292 + 36] = 0
                    mem[_24292 + 68] = _23224
                    mem[_24292 + 100] = this.address
                    mem[_24292 + 132] = 128
                    mem[_24292 + 164] = mem[_24292]
                    mem[_24292 + 196 len ceil32(mem[_24292])] = mem[_24292 + 32 len ceil32(mem[_24292])]
                    if ceil32(mem[_24292]) > mem[_24292]:
                        mem[mem[_24292] + _24292 + 196] = 0
                    require ext_code.size(address(_6046 xor address(arg2) >> 96))
                    call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _23224, address(this.address), 128, mem[_24292], mem[_24292 + 196 len ceil32(mem[_24292])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_24292 + 32] = 32
                    mem[_24292 + 64] = _18272
                    mem[_24292 + 96 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                    return memory
                      from mem[64]
                       len _24292 + (32 * _18272) + -mem[64] + 96
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6046 xor address(arg2) >> 96))
                    call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18272
                    mem[mem[64] + 64 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                    return Array(len=_18272, data=mem[mem[64] + 64 len 32 * _18272])
                _24295 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24295 + 36] = _23224
                mem[_24295 + 68] = 0
                mem[_24295 + 100] = this.address
                mem[_24295 + 132] = 128
                mem[_24295 + 164] = mem[_24295]
                mem[_24295 + 196 len ceil32(mem[_24295])] = mem[_24295 + 32 len ceil32(mem[_24295])]
                if ceil32(mem[_24295]) > mem[_24295]:
                    mem[mem[_24295] + _24295 + 196] = 0
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _23224, 0, address(this.address), 128, mem[_24295], mem[_24295 + 196 len ceil32(mem[_24295])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24295 + 32] = 32
                mem[_24295 + 64] = _18272
                mem[_24295 + 96 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                return memory
                  from mem[64]
                   len _24295 + (32 * _18272) + -mem[64] + 96
            if not uint64(mem[128] xor address(arg2) >> 96) << 96:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6046 xor address(arg2) >> 96))
                    call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _23224, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18272
                    mem[mem[64] + 64 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                    return Array(len=_18272, data=mem[mem[64] + 64 len 32 * _18272])
                _24298 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24298 + 36] = 0
                mem[_24298 + 68] = _23224
                mem[_24298 + 100] = this.address
                mem[_24298 + 132] = 128
                mem[_24298 + 164] = mem[_24298]
                mem[_24298 + 196 len ceil32(mem[_24298])] = mem[_24298 + 32 len ceil32(mem[_24298])]
                if ceil32(mem[_24298]) > mem[_24298]:
                    mem[mem[_24298] + _24298 + 196] = 0
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _23224, address(this.address), 128, mem[_24298], mem[_24298 + 196 len ceil32(mem[_24298])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24298 + 32] = 32
                mem[_24298 + 64] = _18272
                mem[_24298 + 96 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                return memory
                  from mem[64]
                   len _24298 + (32 * _18272) + -mem[64] + 96
            if Mask(1, 93, arg2) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18272
                mem[mem[64] + 64 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
                return Array(len=_18272, data=mem[mem[64] + 64 len 32 * _18272])
            _24301 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_24301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_24301 + 36] = _23224
            mem[_24301 + 68] = 0
            mem[_24301 + 100] = this.address
            mem[_24301 + 132] = 128
            mem[_24301 + 164] = mem[_24301]
            mem[_24301 + 196 len ceil32(mem[_24301])] = mem[_24301 + 32 len ceil32(mem[_24301])]
            if ceil32(mem[_24301]) > mem[_24301]:
                mem[mem[_24301] + _24301 + 196] = 0
            require ext_code.size(address(_6046 xor address(arg2) >> 96))
            call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _23224, 0, address(this.address), 128, mem[_24301], mem[_24301 + 196 len ceil32(mem[_24301])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_24301 + 32] = 32
            mem[_24301 + 64] = _18272
            mem[_24301 + 96 len 32 * _18272] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18272]
            return memory
              from mem[64]
               len _24301 + (32 * _18272) + -mem[64] + 96
        require return_data.size >= 32
        require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325] == bool(mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325])
        if not mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 325]:
            revert with 0, 'TRANSFER_FAILED'
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 298] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = 64
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 394 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
        require return_data.size >= 32
        _18165 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 294 > ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 325
        _18273 = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
        if mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 1 < 0 or ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]) + 295
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + 294 len 4], ext_call.return_data[0 len 28] + 294]
        require _18165 + (32 * _18273) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len ceil32(32 * _18273)] = mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + ceil32(return_data.size) + _18165 + 326 len ceil32(32 * _18273)]
        var85002 = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18273) + 326
        if 1 >= _18273:
            revert with 0, 50
        _23225 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] < arg3:
            revert with 0, 'INSUFFICIENT_OUT'
        if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
        if mem[ceil32(32 * arg1.length) + 141 len 20] < uint64(mem[128] xor address(arg2) >> 96) << 96:
            if not mem[ceil32(32 * arg1.length) + 141 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * arg1.length) + 141 len 20] == mem[ceil32(32 * arg1.length) + 141 len 20]:
                if Mask(1, 93, arg2) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_6046 xor address(arg2) >> 96))
                    call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _23225, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _18273
                    mem[mem[64] + 64 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
                    return Array(len=_18273, data=mem[mem[64] + 64 len 32 * _18273])
                _24304 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24304 + 36] = 0
                mem[_24304 + 68] = _23225
                mem[_24304 + 100] = this.address
                mem[_24304 + 132] = 128
                mem[_24304 + 164] = mem[_24304]
                mem[_24304 + 196 len ceil32(mem[_24304])] = mem[_24304 + 32 len ceil32(mem[_24304])]
                if ceil32(mem[_24304]) > mem[_24304]:
                    mem[mem[_24304] + _24304 + 196] = 0
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _23225, address(this.address), 128, mem[_24304], mem[_24304 + 196 len ceil32(mem[_24304])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_24304 + 32] = 32
                mem[_24304 + 64] = _18273
                mem[_24304 + 96 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
                return memory
                  from mem[64]
                   len _24304 + (32 * _18273) + -mem[64] + 96
            if Mask(1, 93, arg2) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
            else:
                _24307 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_24307 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_24307 + 36] = _23225
                mem[_24307 + 68] = 0
                mem[_24307 + 100] = this.address
                mem[_24307 + 132] = 128
                mem[_24307 + 164] = mem[_24307]
                mem[_24307 + 196 len ceil32(mem[_24307])] = mem[_24307 + 32 len ceil32(mem[_24307])]
                if ceil32(mem[_24307]) > mem[_24307]:
                    mem[mem[_24307] + _24307 + 196] = 0
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_24307]) + _24307 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _18273
            mem[mem[64] + 64 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
            return Array(len=_18273, data=mem[mem[64] + 64 len 32 * _18273])
        if not uint64(mem[128] xor address(arg2) >> 96) << 96:
            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
        if mem[ceil32(32 * arg1.length) + 141 len 20] == uint64(mem[128] xor address(arg2) >> 96) << 96:
            if Mask(1, 93, arg2) >> 93 != 1:
                mem[mem[64] + 36] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_6046 xor address(arg2) >> 96))
                call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args 0, _23225, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _18273
                mem[mem[64] + 64 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
                return Array(len=_18273, data=mem[mem[64] + 64 len 32 * _18273])
            _24310 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_24310 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_24310 + 36] = 0
            mem[_24310 + 68] = _23225
            mem[_24310 + 100] = this.address
            mem[_24310 + 132] = 128
            mem[_24310 + 164] = mem[_24310]
            mem[_24310 + 196 len ceil32(mem[_24310])] = mem[_24310 + 32 len ceil32(mem[_24310])]
            if ceil32(mem[_24310]) > mem[_24310]:
                mem[mem[_24310] + _24310 + 196] = 0
            require ext_code.size(address(_6046 xor address(arg2) >> 96))
            call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _23225, address(this.address), 128, mem[_24310], mem[_24310 + 196 len ceil32(mem[_24310])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_24310 + 32] = 32
            mem[_24310 + 64] = _18273
            mem[_24310 + 96 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
            return memory
              from mem[64]
               len _24310 + (32 * _18273) + -mem[64] + 96
        if Mask(1, 93, arg2) >> 93 != 1:
            mem[mem[64] + 4] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 36] = 0
            mem[mem[64] + 68] = this.address
            require ext_code.size(address(_6046 xor address(arg2) >> 96))
            call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args mem[mem[64] + 4], 0, this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _18273
            mem[mem[64] + 64 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
            return Array(len=_18273, data=mem[mem[64] + 64 len 32 * _18273])
        _24313 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_24313 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_24313 + 36] = _23225
        mem[_24313 + 68] = 0
        mem[_24313 + 100] = this.address
        mem[_24313 + 132] = 128
        mem[_24313 + 164] = mem[_24313]
        mem[_24313 + 196 len ceil32(mem[_24313])] = mem[_24313 + 32 len ceil32(mem[_24313])]
        if ceil32(mem[_24313]) > mem[_24313]:
            mem[mem[_24313] + _24313 + 196] = 0
        require ext_code.size(address(_6046 xor address(arg2) >> 96))
        call address(_6046 xor address(arg2) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
             gas gas_remaining wei
            args _23225, 0, address(this.address), 128, mem[_24313], mem[_24313 + 196 len ceil32(mem[_24313])]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_24313 + 32] = 32
        mem[_24313 + 64] = _18273
        mem[_24313 + 96 len 32 * _18273] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326 len 32 * _18273]
        return memory
          from mem[64]
           len _24313 + (32 * _18273) + -mem[64] + 96
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 197] = this.address
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 229] = address(_6034 xor address(arg2) >> 96)
    staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
            gas gas_remaining wei
           args this.address, address(_6034 xor address(arg2) >> 96)
    mem[ceil32(32 * arg1.length) + ceil32(return_data.size) + 193] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        if arg3:
            if arg3 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = arg3
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 325] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _11989 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 193 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224
            _12049 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _11989 + (32 * _12049) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len ceil32(32 * _12049)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _11989 + 225 len ceil32(32 * _12049)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1.length
            mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
            return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = 64
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 261] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 293 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _12005 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + return_data.size + 193 > ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224
        _12101 = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
        if mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
        require _12005 + (32 * _12101) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len ceil32(32 * _12101)] = mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + _12005 + 225 len ceil32(32 * _12101)]
        if _12101 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _12101 < 1:
            revert with 0, 17
        if _12101 - 1 >= _12101:
            revert with 0, 50
        if mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
            revert with 0, 17
        if not mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
            if mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23072 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23304 = mem[_23072]
            require mem[_23072] <= test266151307()
            require _23072 + return_data.size > _23072 + mem[_23072] + 31
            _23536 = mem[_23072 + mem[_23072]]
            if mem[_23072 + mem[_23072]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_23072 + mem[_23072]]) + 1 < 0 or _23072 + ceil32(return_data.size) + ceil32(32 * mem[_23072 + mem[_23072]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _23072 + ceil32(return_data.size) + ceil32(32 * mem[_23072 + mem[_23072]]) + 1
            mem[_23072 + ceil32(return_data.size)] = _23536
            require _23304 + (32 * _23536) + 32 <= return_data.size
            mem[_23072 + ceil32(return_data.size) + 32 len ceil32(32 * _23536)] = mem[_23072 + _23304 + 32 len ceil32(32 * _23536)]
            mem[mem[64]] = 32
            _28208 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
            mem[mem[64] + 64 len 32 * _28208] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 32 * _28208]
            return 32, mem[mem[64] + 32 len (32 * _28208) + 32]
        if not mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225]:
            revert with 0, 18
        require mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] == Mask(7, 86, arg2) >> 86
        if mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], mem[(32 * _12101 - 1) + ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23073 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23305 = mem[_23073]
        require mem[_23073] <= test266151307()
        require _23073 + return_data.size > _23073 + mem[_23073] + 31
        _23537 = mem[_23073 + mem[_23073]]
        if mem[_23073 + mem[_23073]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_23073 + mem[_23073]]) + 1 < 0 or _23073 + ceil32(return_data.size) + ceil32(32 * mem[_23073 + mem[_23073]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _23073 + ceil32(return_data.size) + ceil32(32 * mem[_23073 + mem[_23073]]) + 1
        mem[_23073 + ceil32(return_data.size)] = _23537
        require _23305 + (32 * _23537) + 32 <= return_data.size
        mem[_23073 + ceil32(return_data.size) + 32 len ceil32(32 * _23537)] = mem[_23073 + _23305 + 32 len ceil32(32 * _23537)]
        mem[mem[64]] = 32
        _28209 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193]
        mem[mem[64] + 64 len 32 * _28209] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 32 * _28209]
        return 32, mem[mem[64] + 32 len (32 * _28209) + 32]
    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 197] = this.address
    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 229] = address(_6034 xor address(arg2) >> 96)
    staticcall mem[ceil32(32 * arg1.length) + 141 len 20].0xdd62ed3e with:
            gas gas_remaining wei
           args this.address, address(_6034 xor address(arg2) >> 96)
    mem[ceil32(32 * arg1.length) + (2 * ceil32(return_data.size)) + 193] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 229] = address(_6034 xor address(arg2) >> 96)
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 261] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 193] = 68
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 229 len 28] = address(_6034 xor address(arg2) >> 96) << 64
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 225 len 4] = approve(address arg1, uint256 arg2)
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 293] = 32
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 325] = 'SafeERC20: low-level call failed'
    if not ext_code.size(mem[ceil32(32 * arg1.length) + 141 len 20]):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 96] = approve(address arg1, uint256 arg2), address(_6034 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 0
    call mem[ceil32(32 * arg1.length) + 141 len 20] with:
       funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_6034 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_6034 xor address(arg2) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if arg1.length:
                revert with memory
                  from 128
                   len arg1.length
            revert with 0, 'SafeERC20: low-level call failed'
        if not arg1.length:
            if arg3:
                if arg3 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = arg3
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 160
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 521] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457] = this.address
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
                call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
                require return_data.size >= 32
                _18094 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
                _18202 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18202
                require _18094 + (32 * _18202) + 32 <= return_data.size
                mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18202)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18094 + 389 len ceil32(32 * _18202)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = arg1.length
                mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
                var112001 = arg1.length
                return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = 64
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
            require return_data.size >= 32
            _18154 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
            _18262 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18262
            require _18154 + (32 * _18262) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18262)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18154 + 389 len ceil32(32 * _18262)]
            if _18262 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _18262 < 1:
                revert with 0, 17
            if _18262 - 1 >= _18262:
                revert with 0, 50
            if mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                revert with 0, 17
            if not mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                if mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
                if mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * arg1.length) + 129
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _28002 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _28330 = mem[_28002]
                require mem[_28002] <= test266151307()
                require _28002 + return_data.size > _28002 + mem[_28002] + 31
                _28410 = mem[_28002 + mem[_28002]]
                if mem[_28002 + mem[_28002]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_28002 + mem[_28002]]) + 1 < 0 or _28002 + ceil32(return_data.size) + ceil32(32 * mem[_28002 + mem[_28002]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _28002 + ceil32(return_data.size) + ceil32(32 * mem[_28002 + mem[_28002]]) + 1
                mem[_28002 + ceil32(return_data.size)] = _28410
                require _28330 + (32 * _28410) + 32 <= return_data.size
                mem[_28002 + ceil32(return_data.size) + 32 len ceil32(32 * _28410)] = mem[_28002 + _28330 + 32 len ceil32(32 * _28410)]
                mem[mem[64]] = 32
                _30538 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
                mem[mem[64] + 64 len 32 * _30538] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30538]
                return 32, mem[mem[64] + 32 len (32 * _30538) + 32]
            if not mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
                revert with 0, 18
            require mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
            if mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _18262 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _28003 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28331 = mem[_28003]
            require mem[_28003] <= test266151307()
            require _28003 + return_data.size > _28003 + mem[_28003] + 31
            _28411 = mem[_28003 + mem[_28003]]
            if mem[_28003 + mem[_28003]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_28003 + mem[_28003]]) + 1 < 0 or _28003 + ceil32(return_data.size) + ceil32(32 * mem[_28003 + mem[_28003]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _28003 + ceil32(return_data.size) + ceil32(32 * mem[_28003 + mem[_28003]]) + 1
            mem[_28003 + ceil32(return_data.size)] = _28411
            require _28331 + (32 * _28411) + 32 <= return_data.size
            mem[_28003 + ceil32(return_data.size) + 32 len ceil32(32 * _28411)] = mem[_28003 + _28331 + 32 len ceil32(32 * _28411)]
            mem[mem[64]] = 32
            _30539 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 64 len 32 * _30539] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30539]
            return 32, mem[mem[64] + 32 len (32 * _30539) + 32]
        require arg1.length >= 32
        require mem[128] == bool(mem[128])
        if not mem[128]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if arg3:
            if arg3 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = arg3
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 160
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 521] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457] = this.address
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 489] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
            require return_data.size >= 32
            _18095 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
            _18203 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18203
            require _18095 + (32 * _18203) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18203)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18095 + 389 len ceil32(32 * _18203)]
            var112002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * _18203) + 389
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1.length
            mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
            return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 393] = 64
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 425] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 457 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357
        require return_data.size >= 32
        _18155 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + return_data.size + 357 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388
        _18263 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
        if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357] = _18263
        require _18155 + (32 * _18263) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len ceil32(32 * _18263)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + _18155 + 389 len ceil32(32 * _18263)]
        var110002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(32 * _18263) + 389
        if _18263 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _18263 < 1:
            revert with 0, 17
        if _18263 - 1 >= _18263:
            revert with 0, 50
        if mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
            revert with 0, 17
        if not mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
            if mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _28004 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28332 = mem[_28004]
            require mem[_28004] <= test266151307()
            require _28004 + return_data.size > _28004 + mem[_28004] + 31
            _28412 = mem[_28004 + mem[_28004]]
            if mem[_28004 + mem[_28004]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_28004 + mem[_28004]]) + 1 < 0 or _28004 + ceil32(return_data.size) + ceil32(32 * mem[_28004 + mem[_28004]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _28004 + ceil32(return_data.size) + ceil32(32 * mem[_28004 + mem[_28004]]) + 1
            mem[_28004 + ceil32(return_data.size)] = _28412
            require _28332 + (32 * _28412) + 32 <= return_data.size
            mem[_28004 + ceil32(return_data.size) + 32 len ceil32(32 * _28412)] = mem[_28004 + _28332 + 32 len ceil32(32 * _28412)]
            mem[mem[64]] = 32
            _30540 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
            mem[mem[64] + 64 len 32 * _30540] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30540]
            return 32, mem[mem[64] + 32 len (32 * _30540) + 32]
        if not mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389]:
            revert with 0, 18
        require mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] == Mask(7, 86, arg2) >> 86
        if mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], mem[(32 * _18263 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389] * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _28005 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _28333 = mem[_28005]
        require mem[_28005] <= test266151307()
        require _28005 + return_data.size > _28005 + mem[_28005] + 31
        _28413 = mem[_28005 + mem[_28005]]
        if mem[_28005 + mem[_28005]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_28005 + mem[_28005]]) + 1 < 0 or _28005 + ceil32(return_data.size) + ceil32(32 * mem[_28005 + mem[_28005]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _28005 + ceil32(return_data.size) + ceil32(32 * mem[_28005 + mem[_28005]]) + 1
        mem[_28005 + ceil32(return_data.size)] = _28413
        require _28333 + (32 * _28413) + 32 <= return_data.size
        mem[_28005 + ceil32(return_data.size) + 32 len ceil32(32 * _28413)] = mem[_28005 + _28333 + 32 len ceil32(32 * _28413)]
        mem[mem[64]] = 32
        _30541 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 357]
        mem[mem[64] + 64 len 32 * _30541] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + 389 len 32 * _30541]
        return 32, mem[mem[64] + 32 len (32 * _30541) + 32]
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 357] = return_data.size
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        revert with 0, 'SafeERC20: low-level call failed'
    if not return_data.size:
        if arg3:
            if arg3 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
            require return_data.size >= 32
            _18096 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
            _18204 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
            require _18096 + (32 * _18204) + 32 <= return_data.size
            mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18204)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18096 + 390 len ceil32(32 * _18204)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1.length
            mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
            var112001 = arg1.length
            return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
        require return_data.size >= 32
        _18156 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
        _18264 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        require _18156 + (32 * _18264) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18264)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18156 + 390 len ceil32(32 * _18264)]
        if _18264 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _18264 < 1:
            revert with 0, 17
        if _18264 - 1 >= _18264:
            revert with 0, 50
        _23592 = mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        if mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 17
        if not mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            if mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
            if mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = _23592 * Mask(7, 86, arg2) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * arg1.length) + 129
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _23592 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _28006 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _28334 = mem[_28006]
            require mem[_28006] <= test266151307()
            require _28006 + return_data.size > _28006 + mem[_28006] + 31
            _28414 = mem[_28006 + mem[_28006]]
            if mem[_28006 + mem[_28006]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_28006 + mem[_28006]]) + 1 < 0 or _28006 + ceil32(return_data.size) + ceil32(32 * mem[_28006 + mem[_28006]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _28006 + ceil32(return_data.size) + ceil32(32 * mem[_28006 + mem[_28006]]) + 1
            mem[_28006 + ceil32(return_data.size)] = _28414
            require _28334 + (32 * _28414) + 32 <= return_data.size
            mem[_28006 + ceil32(return_data.size) + 32 len ceil32(32 * _28414)] = mem[_28006 + _28334 + 32 len ceil32(32 * _28414)]
            mem[mem[64]] = 32
            _30542 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
            mem[mem[64] + 64 len 32 * _30542] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30542]
            return 32, mem[mem[64] + 32 len (32 * _30542) + 32]
        if not mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
            revert with 0, 18
        require mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
        if mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _18264 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _23592 * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _23592 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _28007 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _28335 = mem[_28007]
        require mem[_28007] <= test266151307()
        require _28007 + return_data.size > _28007 + mem[_28007] + 31
        _28415 = mem[_28007 + mem[_28007]]
        if mem[_28007 + mem[_28007]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_28007 + mem[_28007]]) + 1 < 0 or _28007 + ceil32(return_data.size) + ceil32(32 * mem[_28007 + mem[_28007]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _28007 + ceil32(return_data.size) + ceil32(32 * mem[_28007 + mem[_28007]]) + 1
        mem[_28007 + ceil32(return_data.size)] = _28415
        require _28335 + (32 * _28415) + 32 <= return_data.size
        mem[_28007 + ceil32(return_data.size) + 32 len ceil32(32 * _28415)] = mem[_28007 + _28335 + 32 len ceil32(32 * _28415)]
        mem[mem[64]] = 32
        _30543 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 64 len 32 * _30543] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30543]
        return 32, mem[mem[64] + 32 len (32 * _30543) + 32]
    require return_data.size >= 32
    require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389] == bool(mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389])
    if not mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + 389]:
        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    if arg3:
        if arg3 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = arg3
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = block.timestamp + 1800
        call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], arg3, Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
        require return_data.size >= 32
        _18097 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
        _18205 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
        require _18097 + (32 * _18205) + 32 <= return_data.size
        mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18205)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18097 + 390 len ceil32(32 * _18205)]
        var112002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18205) + 390
        mem[mem[64]] = 32
        mem[mem[64] + 32] = arg1.length
        mem[mem[64] + 64 len 32 * arg1.length] = mem[128 len 32 * arg1.length]
        return Array(len=arg1.length, data=mem[mem[64] + 64 len 32 * arg1.length])
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 64
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 2
    idx = 0
    s = ceil32(32 * arg1.length) + 129
    t = ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    staticcall address(_6034 xor address(arg2) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
    require return_data.size >= 32
    _18157 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
    require mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
    require ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358 > ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389
    _18265 = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
    if mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0 or ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
    mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
    require _18157 + (32 * _18265) + 32 <= return_data.size
    mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len ceil32(32 * _18265)] = mem[ceil32(32 * arg1.length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _18157 + 390 len ceil32(32 * _18265)]
    var110002 = ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _18265) + 390
    if _18265 <= 0:
        revert with 0, 'NO_OUT_AMOUNTS'
    if _18265 < 1:
        revert with 0, 17
    if _18265 - 1 >= _18265:
        revert with 0, 50
    _23593 = mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
    if mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] and Mask(7, 86, arg2) >> 86 > -1 / mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
        revert with 0, 17
    if not mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
        if mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
        if mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _23593 * Mask(7, 86, arg2) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * arg1.length) + 129
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _23593 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _28008 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _28336 = mem[_28008]
        require mem[_28008] <= test266151307()
        require _28008 + return_data.size > _28008 + mem[_28008] + 31
        _28416 = mem[_28008 + mem[_28008]]
        if mem[_28008 + mem[_28008]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_28008 + mem[_28008]]) + 1 < 0 or _28008 + ceil32(return_data.size) + ceil32(32 * mem[_28008 + mem[_28008]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _28008 + ceil32(return_data.size) + ceil32(32 * mem[_28008 + mem[_28008]]) + 1
        mem[_28008 + ceil32(return_data.size)] = _28416
        require _28336 + (32 * _28416) + 32 <= return_data.size
        mem[_28008 + ceil32(return_data.size) + 32 len ceil32(32 * _28416)] = mem[_28008 + _28336 + 32 len ceil32(32 * _28416)]
        mem[mem[64]] = 32
        _30544 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
        mem[mem[64] + 64 len 32 * _30544] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30544]
        return 32, mem[mem[64] + 32 len (32 * _30544) + 32]
    if not mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]:
        revert with 0, 18
    require mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] == Mask(7, 86, arg2) >> 86
    if mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    if 100 * mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 > !(mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100):
        revert with 0, 17
    require mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 == (100 * mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100) + (mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 % 100)
    if mem[(32 * _18265 - 1) + ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] * Mask(7, 86, arg2) >> 86 / 100 <= 0:
        revert with 0, 'INVALID_AOM'
    if 1800 > !block.timestamp:
        revert with 0, 17
    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = ext_call.return_data[0]
    mem[mem[64] + 36] = _23593 * Mask(7, 86, arg2) >> 86 / 100
    mem[mem[64] + 68] = 160
    mem[mem[64] + 164] = 2
    idx = 0
    s = ceil32(32 * arg1.length) + 129
    t = mem[64] + 196
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 100] = this.address
    mem[mem[64] + 132] = block.timestamp + 1800
    call address(_6034 xor address(arg2) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args ext_call.return_data[0], _23593 * Mask(7, 86, arg2) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _28009 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _28337 = mem[_28009]
    require mem[_28009] <= test266151307()
    require _28009 + return_data.size > _28009 + mem[_28009] + 31
    _28417 = mem[_28009 + mem[_28009]]
    if mem[_28009 + mem[_28009]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_28009 + mem[_28009]]) + 1 < 0 or _28009 + ceil32(return_data.size) + ceil32(32 * mem[_28009 + mem[_28009]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _28009 + ceil32(return_data.size) + ceil32(32 * mem[_28009 + mem[_28009]]) + 1
    mem[_28009 + ceil32(return_data.size)] = _28417
    require _28337 + (32 * _28417) + 32 <= return_data.size
    mem[_28009 + ceil32(return_data.size) + 32 len ceil32(32 * _28417)] = mem[_28009 + _28337 + 32 len ceil32(32 * _28417)]
    mem[mem[64]] = 32
    _30545 = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358]
    mem[mem[64] + 64 len 32 * _30545] = mem[ceil32(32 * arg1.length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 32 * _30545]
    return 32, mem[mem[64] + 32 len (32 * _30545) + 32]
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
    if unknown_0x61ca6463(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0xbb7b9c76(?????) <= uint32(call.func_hash) >> 224:
            if uint32(call.func_hash) >> 224 != unknown_0xbb7b9c76(?????):
                if unknown_0xc311d049(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require msg.sender == owner
                    if cd[4]:
                        call msg.sender with:
                           value cd[4] wei
                             gas gas_remaining wei
                    else:
                        call msg.sender with:
                           value eth.balance(this.address) wei
                             gas gas_remaining wei
                    if not ext_call.success:
                        revert with 0, 'withdraw eth failed'
                else:
                    if unknown_0xc4c1c94f(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] <= test266151307()
                        require cd[4] + 35 < calldata.size
                        if ('cd', 4).length > test266151307():
                            revert with 0, 65
                        if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                            revert with 0, 65
                        require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                        idx = cd[4] + 36
                        s = 160
                        while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                            require cd[idx] == address(cd[idx])
                            mem[s] = cd[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        require msg.sender == owner
                        if ('cd', 4).length <= 0:
                            revert with 0, 'address length is 0'
                        idx = 0
                        while idx < ('cd', 4).length:
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + 172 len 20]
                            mem[32] = 1
                            stor1[mem[(32 * idx) + 172 len 20]] = 1
                            if idx >= ('cd', 4).length:
                                revert with 0, 50
                            emit AddedToWhitelist(mem[(32 * idx) + 172 len 20]);
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        if unknown_0xebcc9df6(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] <= test266151307()
                            require cd[4] + 35 < calldata.size
                            if ('cd', 4).length > test266151307():
                                revert with 0, 65
                            if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                                revert with 0, 65
                            require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                            idx = cd[4] + 36
                            s = 160
                            while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                                require cd[idx] == address(cd[idx])
                                mem[s] = cd[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if not stor1[address(msg.sender)]:
                                revert with 0, 'Fuck you'
                            if ('cd', 4).length <= 0:
                                revert with 0, 'router address is empty'
                            idx = 0
                            while idx < ('cd', 4).length:
                                if idx >= ('cd', 4).length:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + 172 len 20]
                                mem[32] = 2
                                router[mem[(32 * idx) + 172 len 20]] = mem[(32 * idx) + 172 len 20]
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if uint32(call.func_hash) >> 224 != unknown_0xee0223e8(?????):
                                require unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224
                                require not msg.value
                                require calldata.size - 4 >= 32
                                require cd[4] == address(cd[4])
                                require msg.sender == owner
                                if address(cd[4]):
                                    owner = address(cd[4])
                            else:
                                require not msg.value
                                require calldata.size - 4 >= 192
                                require cd[68] <= test266151307()
                                require cd[68] + 35 < calldata.size
                                require ('cd', 68).length <= test266151307()
                                require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
                                require cd[100] == address(cd[100])
                                require cd[132] == address(cd[132])
                                if not stor1[address(msg.sender)]:
                                    revert with 0, 'Fuck you'
                                if not ('cd', 68).length:
                                    revert with 0, 50
                                require ('cd', 68)[0] == address(('cd', 68)[0])
                                if cd[4]:
                                    idx = 0
                                    s = 324
                                    t = cd[68] + 36
                                    while idx < ('cd', 68).length:
                                        require cd[t] == address(cd[t])
                                        mem[s] = address(cd[t])
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(router[address(cd[132])])
                                    call router[address(cd[132])].swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args cd[4], cd[36], Array(len=('cd', 68).length, data=mem[324 len 32 * ('cd', 68).length]), address(cd[100]), cd[164]
                                else:
                                    staticcall address(('cd', 68)[0]).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    s = ceil32(return_data.size) + 324
                                    t = cd[68] + 36
                                    while idx < ('cd', 68).length:
                                        require cd[t] == address(cd[t])
                                        mem[s] = address(cd[t])
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(router[address(cd[132])])
                                    call router[address(cd[132])].swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], cd[36], Array(len=('cd', 68).length, data=mem[ceil32(return_data.size) + 324 len 32 * ('cd', 68).length]), address(cd[100]), cd[164]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] == address(cd[4])
            require cd[68] <= test266151307()
            require cd[68] + 35 < calldata.size
            if ('cd', 68).length > test266151307():
                revert with 0, 65
            if ceil32(32 * ('cd', 68).length) + 129 < 128 or ceil32(32 * ('cd', 68).length) + 129 > test266151307():
                revert with 0, 65
            mem[128] = ('cd', 68).length
            require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
            idx = cd[68] + 36
            s = 160
            while idx < cd[68] + (32 * ('cd', 68).length) + 36:
                require cd[idx] == address(cd[idx])
                mem[s] = cd[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[ceil32(32 * ('cd', 68).length) + 129] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 68).length) + 133] = cd[36]
            mem[ceil32(32 * ('cd', 68).length) + 165] = 64
            mem[ceil32(32 * ('cd', 68).length) + 197] = ('cd', 68).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 68).length) + 229
            while idx < ('cd', 68).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(cd[4]).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36], Array(len=('cd', 68).length, data=mem[ceil32(32 * ('cd', 68).length) + 229 len 32 * ('cd', 68).length])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 68).length) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 129
            require return_data.size >= 32
            _23412 = mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32
            require mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 <= test266151307()
            require ceil32(32 * ('cd', 68).length) + return_data.size + 129 > ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 160
            _23547 = mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129]
            if mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129]) + 1 < 0 or ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129]) + 130 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129]) + 130
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 129] = mem[ceil32(32 * ('cd', 68).length) + mem[ceil32(32 * ('cd', 68).length) + 129 len 4], Mask(224, 32, cd[36]) >> 32 + 129]
            require _23412 + (32 * _23547) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 161 len ceil32(32 * _23547)] = mem[ceil32(32 * ('cd', 68).length) + _23412 + 161 len ceil32(32 * _23547)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _23547
            mem[mem[64] + 64 len 32 * _23547] = mem[ceil32(32 * ('cd', 68).length) + ceil32(return_data.size) + 161 len 32 * _23547]
            return Array(len=_23547, data=mem[mem[64] + 64 len 32 * _23547])
        if unknown_0x61ca6463(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 32
            require cd[4] == address(cd[4])
            staticcall address(cd[4]).factory() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            return ext_call.return_data[12 len 20]
        if unknown_0x61e0b77f(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] == address(cd[4])
            require cd[36] == address(cd[36])
            require cd[68] == address(cd[68])
            staticcall address(cd[4]).factory() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                    gas gas_remaining wei
                   args address(cd[36]), address(cd[68])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            return ext_call.return_data[12 len 20]
        if unknown_0x6d91c0e2(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] == address(cd[4])
            require cd[36] == address(cd[36])
            require cd[68] == address(cd[68])
            staticcall address(cd[4]).factory() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                    gas gas_remaining wei
                   args address(cd[36]), address(cd[68])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            return ext_call.return_data[12 len 20]
        if unknown_0x8369166d(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 32
            require cd[4] == address(cd[4])
            if not stor1[address(msg.sender)]:
                revert with 0, 'Fuck you'
            return router[address(cd[4])]
        if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return owner
        require unknown_0x9149c6ea(?????) == uint32(call.func_hash) >> 224
        require calldata.size - 4 >= 160
        require cd[4] <= test266151307()
        require cd[4] + 35 < calldata.size
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
            revert with 0, 65
        mem[128] = ('cd', 4).length
        require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
        idx = cd[4] + 36
        s = 160
        while idx < cd[4] + (32 * ('cd', 4).length) + 36:
            require cd[idx] == address(cd[idx])
            mem[s] = cd[idx]
            idx = idx + 32
            s = s + 32
            continue 
        require cd[36] == address(cd[36])
        require cd[132] == uint8(cd[132])
        mem[0] = msg.sender
        mem[32] = 1
        if not stor1[address(msg.sender)]:
            revert with 0, 'Fuck you'
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        _12035 = mem[160]
        if cd[68] != 0:
            if cd[68] <= 0:
                revert with 0, 'no in'
            if cd[100]:
                if cd[100] <= 0:
                    revert with 0, 'not aom'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + 129] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + 133] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + 165] = cd[100]
                mem[ceil32(32 * ('cd', 4).length) + 197] = 160
                mem[ceil32(32 * ('cd', 4).length) + 293] = ('cd', 4).length
                idx = 0
                s = 160
                t = ceil32(32 * ('cd', 4).length) + 325
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + 229] = this.address
                mem[ceil32(32 * ('cd', 4).length) + 261] = block.timestamp + 1800
                call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[68], cd[100], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + 325 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129
                require return_data.size >= 32
                _23378 = mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32
                require mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + return_data.size + 129 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 160
                _23481 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]
                if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 130 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 130
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]
                require _23378 + (32 * _23481) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161 len ceil32(32 * _23481)] = mem[ceil32(32 * ('cd', 4).length) + _23378 + 161 len ceil32(32 * _23481)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _23481
                mem[mem[64] + 64 len 32 * _23481] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161 len 32 * _23481]
                return Array(len=_23481, data=mem[mem[64] + 64 len 32 * _23481])
            mem[ceil32(32 * ('cd', 4).length) + 129] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + 133] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + 165] = 64
            mem[ceil32(32 * ('cd', 4).length) + 197] = ('cd', 4).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 4).length) + 229
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[68], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + 229 len 32 * ('cd', 4).length])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129
            require return_data.size >= 32
            _23410 = mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32
            require mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + return_data.size + 129 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 160
            _23545 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]
            if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 130 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]) + 130
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 129 len 4], Mask(224, 32, cd[68]) >> 32 + 129]
            require _23410 + (32 * _23545) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161 len ceil32(32 * _23545)] = mem[ceil32(32 * ('cd', 4).length) + _23410 + 161 len ceil32(32 * _23545)]
            if _23545 <= 0:
                revert with 0, 'no out amounts'
            if _23545 < 1:
                revert with 0, 17
            if _23545 - 1 >= _23545:
                revert with 0, 50
            if mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] and uint8(cd[132]) > -1 / mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161]:
                revert with 0, 17
            if not mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161]:
                if mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 > !(mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) % 100):
                    revert with 0, 17
                require mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) == (100 * mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100) + (mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) % 100)
                if mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 <= 0:
                    revert with 0, 'not aom'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = cd[68]
                mem[mem[64] + 36] = mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = ('cd', 4).length
                idx = 0
                s = 160
                t = mem[64] + 196
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[68], mem[mem[64] + 36], Array(len=('cd', 4).length, data=mem[mem[64] + 196 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _44169 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _44437 = mem[_44169]
                require mem[_44169] <= test266151307()
                require _44169 + return_data.size > _44169 + mem[_44169] + 31
                _44753 = mem[_44169 + mem[_44169]]
                if mem[_44169 + mem[_44169]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_44169 + mem[_44169]]) + 1 < 0 or _44169 + ceil32(return_data.size) + ceil32(32 * mem[_44169 + mem[_44169]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _44169 + ceil32(return_data.size) + ceil32(32 * mem[_44169 + mem[_44169]]) + 1
                mem[_44169 + ceil32(return_data.size)] = _44753
                require _44437 + (32 * _44753) + 32 <= return_data.size
                mem[_44169 + ceil32(return_data.size) + 32 len ceil32(32 * _44753)] = mem[_44169 + _44437 + 32 len ceil32(32 * _44753)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _44753
                mem[mem[64] + 64 len 32 * _44753] = mem[_44169 + ceil32(return_data.size) + 32 len 32 * _44753]
                return Array(len=_44753, data=mem[mem[64] + 64 len 32 * _44753])
            if not mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161]:
                revert with 0, 18
            require mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] == uint8(cd[132])
            if mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 > !(mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) % 100):
                revert with 0, 17
            require mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) == (100 * mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100) + (mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) % 100)
            if mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100 <= 0:
                revert with 0, 'not aom'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = cd[68]
            mem[mem[64] + 36] = mem[(32 * _23545 - 1) + ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 161] * uint8(cd[132]) / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = ('cd', 4).length
            idx = 0
            s = 160
            t = mem[64] + 196
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[68], mem[mem[64] + 36], Array(len=('cd', 4).length, data=mem[mem[64] + 196 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _44170 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44438 = mem[_44170]
            require mem[_44170] <= test266151307()
            require _44170 + return_data.size > _44170 + mem[_44170] + 31
            _44754 = mem[_44170 + mem[_44170]]
            if mem[_44170 + mem[_44170]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_44170 + mem[_44170]]) + 1 < 0 or _44170 + ceil32(return_data.size) + ceil32(32 * mem[_44170 + mem[_44170]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _44170 + ceil32(return_data.size) + ceil32(32 * mem[_44170 + mem[_44170]]) + 1
            mem[_44170 + ceil32(return_data.size)] = _44754
            require _44438 + (32 * _44754) + 32 <= return_data.size
            mem[_44170 + ceil32(return_data.size) + 32 len ceil32(32 * _44754)] = mem[_44170 + _44438 + 32 len ceil32(32 * _44754)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _44754
            mem[mem[64] + 64 len 32 * _44754] = mem[_44170 + ceil32(return_data.size) + 32 len 32 * _44754]
            return Array(len=_44754, data=mem[mem[64] + 64 len 32 * _44754])
        mem[ceil32(32 * ('cd', 4).length) + 133] = this.address
        staticcall address(_12035).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(32 * ('cd', 4).length) + 129] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0, 'no in'
        if cd[100]:
            if cd[100] <= 0:
                revert with 0, 'not aom'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 133] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 165] = cd[100]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 197] = 160
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = ('cd', 4).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = this.address
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = block.timestamp + 1800
            call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], cd[100], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129
            require return_data.size >= 32
            _23379 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 129 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 160
            _23482 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 130 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 130
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]
            require _23379 + (32 * _23482) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161 len ceil32(32 * _23482)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23379 + 161 len ceil32(32 * _23482)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _23482
            mem[mem[64] + 64 len 32 * _23482] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161 len 32 * _23482]
            return Array(len=_23482, data=mem[mem[64] + 64 len 32 * _23482])
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 133] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 165] = 64
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 197] = ('cd', 4).length
        idx = 0
        s = 160
        t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229
        while idx < ('cd', 4).length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229 len 32 * ('cd', 4).length])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129
        require return_data.size >= 32
        _23411 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 129 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 160
        _23546 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]
        if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 130 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]) + 130
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129 len 4], ext_call.return_data[0 len 28] + 129]
        require _23411 + (32 * _23546) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161 len ceil32(32 * _23546)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23411 + 161 len ceil32(32 * _23546)]
        if _23546 <= 0:
            revert with 0, 'no out amounts'
        if _23546 < 1:
            revert with 0, 17
        if _23546 - 1 >= _23546:
            revert with 0, 50
        _34678 = mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161]
        if mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] and uint8(cd[132]) > -1 / mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161]:
            revert with 0, 17
        if not mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161]:
            if mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 > !(mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) % 100):
                revert with 0, 17
            require mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) == (100 * mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100) + (mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) % 100)
            if mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 <= 0:
                revert with 0, 'not aom'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = ('cd', 4).length
            idx = 0
            s = 160
            t = mem[64] + 196
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _34678 * uint8(cd[132]) / 100, Array(len=('cd', 4).length, data=mem[mem[64] + 196 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _44171 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44439 = mem[_44171]
            require mem[_44171] <= test266151307()
            require _44171 + return_data.size > _44171 + mem[_44171] + 31
            _44755 = mem[_44171 + mem[_44171]]
            if mem[_44171 + mem[_44171]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_44171 + mem[_44171]]) + 1 < 0 or _44171 + ceil32(return_data.size) + ceil32(32 * mem[_44171 + mem[_44171]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _44171 + ceil32(return_data.size) + ceil32(32 * mem[_44171 + mem[_44171]]) + 1
            mem[_44171 + ceil32(return_data.size)] = _44755
            require _44439 + (32 * _44755) + 32 <= return_data.size
            mem[_44171 + ceil32(return_data.size) + 32 len ceil32(32 * _44755)] = mem[_44171 + _44439 + 32 len ceil32(32 * _44755)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _44755
            mem[mem[64] + 64 len 32 * _44755] = mem[_44171 + ceil32(return_data.size) + 32 len 32 * _44755]
            return Array(len=_44755, data=mem[mem[64] + 64 len 32 * _44755])
        if not mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161]:
            revert with 0, 18
        require mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] == uint8(cd[132])
        if mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 > !(mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) % 100):
            revert with 0, 17
        require mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) == (100 * mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100) + (mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) % 100)
        if mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100 <= 0:
            revert with 0, 'not aom'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _23546 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161] * uint8(cd[132]) / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = ('cd', 4).length
        idx = 0
        s = 160
        t = mem[64] + 196
        while idx < ('cd', 4).length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(cd[36]).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _34678 * uint8(cd[132]) / 100, Array(len=('cd', 4).length, data=mem[mem[64] + 196 len 32 * ('cd', 4).length]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _44172 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _44440 = mem[_44172]
        require mem[_44172] <= test266151307()
        require _44172 + return_data.size > _44172 + mem[_44172] + 31
        _44756 = mem[_44172 + mem[_44172]]
        if mem[_44172 + mem[_44172]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_44172 + mem[_44172]]) + 1 < 0 or _44172 + ceil32(return_data.size) + ceil32(32 * mem[_44172 + mem[_44172]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _44172 + ceil32(return_data.size) + ceil32(32 * mem[_44172 + mem[_44172]]) + 1
        mem[_44172 + ceil32(return_data.size)] = _44756
        require _44440 + (32 * _44756) + 32 <= return_data.size
        mem[_44172 + ceil32(return_data.size) + 32 len ceil32(32 * _44756)] = mem[_44172 + _44440 + 32 len ceil32(32 * _44756)]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _44756
        mem[mem[64] + 64 len 32 * _44756] = mem[_44172 + ceil32(return_data.size) + 32 len 32 * _44756]
        return Array(len=_44756, data=mem[mem[64] + 64 len 32 * _44756])
    if unknown_0x2e0faf48(?????) > uint32(call.func_hash) >> 224:
        if withTokenFrom(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            require msg.sender == owner
            if cd[36]:
                mem[164] = this.address
                mem[196] = msg.sender
                mem[228] = cd[36]
                mem[128] = 100
                mem[164 len 28] = address(this.address) << 64
                mem[160 len 4] = unknown_0x23b872dd(?????)
                mem[260] = 32
                mem[292] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(cd[4])):
                    revert with 0, 'Address: call to non-contract'
                mem[324 len 128] = unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, cd[36], 0
                mem[424] = 0
                call address(cd[4]) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, cd[36], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, cd[36], 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    require not mem[96]
                mem[356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[356] == bool(mem[356])
                    if not mem[356]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[132] = this.address
                staticcall address(cd[4]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 164] = this.address
                mem[ceil32(return_data.size) + 196] = msg.sender
                mem[ceil32(return_data.size) + 228] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 128] = 100
                mem[ceil32(return_data.size) + 164 len 28] = address(this.address) << 64
                mem[ceil32(return_data.size) + 160 len 4] = unknown_0x23b872dd(?????)
                mem[ceil32(return_data.size) + 260] = 32
                mem[ceil32(return_data.size) + 292] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(cd[4])):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 324 len 128] = unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, ext_call.return_data[0], 0
                mem[ceil32(return_data.size) + 424] = 0
                call address(cd[4]) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, ext_call.return_data[0], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), address(this.address) << 64, 0, msg.sender, ext_call.return_data[0], 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 356] == bool(mem[ceil32(return_data.size) + 356])
                        if not mem[ceil32(return_data.size) + 356]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if approveToken(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if not stor1[address(msg.sender)]:
                revert with 0, 'Fuck you'
            call address(cd[4]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args this.address, cd[36]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if unknown_0x1c576c2c(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 96
            require cd[4] <= test266151307()
            require cd[4] + 35 < calldata.size
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + 129
            mem[128] = ('cd', 4).length
            require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
            idx = cd[4] + 36
            s = 160
            while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                require cd[idx] == address(cd[idx])
                mem[s] = cd[idx]
                idx = idx + 32
                s = s + 32
                continue 
            require cd[36] == address(cd[36])
            mem[0] = msg.sender
            mem[32] = 1
            if not stor1[address(msg.sender)]:
                revert with 0, 'Fuck you'
            if ('cd', 4).length <= 0:
                revert with 0, 'token address length is invalid'
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[128]:
                    revert with 0, 50
                _23213 = mem[(32 * idx) + 160]
                if not cd[68]:
                    _23303 = mem[64]
                    mem[mem[64] + 36] = address(cd[36])
                    mem[mem[64] + 68] = cd[68]
                    _23372 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_23372 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_23372 + 36 len 28]
                    mem[64] = _23303 + 164
                    mem[_23303 + 100] = 32
                    mem[_23303 + 132] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(_23213)):
                        revert with 0, 'Address: call to non-contract'
                    _23548 = mem[_23372]
                    s = 0
                    while s < _23548:
                        mem[s + _23303 + 164] = mem[s + _23372 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_23548) > _23548:
                        mem[_23548 + _23303 + 164] = 0
                    call address(_23213).mem[_23303 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_23303 + 168 len _23548 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_23303 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_23303 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _23303 + 232] = mem[idx + _23303 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_23303 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _23303 + ceil32(return_data.size) + 165
                        mem[_23303 + 164] = return_data.size
                        mem[_23303 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_23303 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_23303 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _23303 + ceil32(return_data.size) + 233] = mem[idx + _23303 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_23303 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23303 + 196] == bool(mem[_23303 + 196])
                            if not mem[_23303 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(cd[36])
                    staticcall address(_23213).0xdd62ed3e with:
                            gas gas_remaining wei
                           args this.address, address(cd[36])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23304 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_23304]:
                        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                    _23550 = mem[64]
                    mem[mem[64] + 36] = address(cd[36])
                    mem[mem[64] + 68] = cd[68]
                    _23576 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_23576 + 32] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or mem[_23576 + 36 len 28]
                    mem[64] = _23550 + 164
                    mem[_23550 + 100] = 32
                    mem[_23550 + 132] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(_23213)):
                        revert with 0, 'Address: call to non-contract'
                    _23708 = mem[_23576]
                    s = 0
                    while s < _23708:
                        mem[s + _23550 + 164] = mem[s + _23576 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_23708) > _23708:
                        mem[_23708 + _23550 + 164] = 0
                    call address(_23213).mem[_23550 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_23550 + 168 len _23708 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_23550 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_23550 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _23550 + 232] = mem[idx + _23550 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_23550 + 232]
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[64] = _23550 + ceil32(return_data.size) + 165
                        mem[_23550 + 164] = return_data.size
                        mem[_23550 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_23550 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_23550 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _23550 + ceil32(return_data.size) + 233] = mem[idx + _23550 + 132]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_23550 + ceil32(return_data.size) + 233]
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23550 + 196] == bool(mem[_23550 + 196])
                            if not mem[_23550 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
        if uint32(call.func_hash) >> 224 != unknown_0x1e65f2f0(?????):
            require unknown_0x25e34347(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            require msg.sender == owner
            if cd[36]:
                mem[164] = msg.sender
                mem[196] = cd[36]
                mem[128] = 68
                mem[164 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[160 len 4] = unknown_0xa9059cbb(?????)
                mem[228] = 32
                mem[260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(cd[4])):
                    revert with 0, 'Address: call to non-contract'
                mem[292 len 96] = unknown_0xa9059cbb(?????), msg.sender, cd[36], 0
                mem[360] = 0
                call address(cd[4]) with:
                   funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, cd[36], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, cd[36], 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    require not mem[96]
                mem[324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[324] == bool(mem[324])
                    if not mem[324]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[132] = this.address
                staticcall address(cd[4]).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 164] = msg.sender
                mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 128] = 68
                mem[ceil32(return_data.size) + 164 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 160 len 4] = unknown_0xa9059cbb(?????)
                mem[ceil32(return_data.size) + 228] = 32
                mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(cd[4])):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 292 len 96] = unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0
                mem[ceil32(return_data.size) + 360] = 0
                call address(cd[4]) with:
                   funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                        if not mem[ceil32(return_data.size) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        require calldata.size - 4 >= 192
        require cd[4] <= test266151307()
        require cd[4] + 35 < calldata.size
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
            revert with 0, 65
        mem[128] = ('cd', 4).length
        require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
        idx = cd[4] + 36
        s = 160
        while idx < cd[4] + (32 * ('cd', 4).length) + 36:
            require cd[idx] == address(cd[idx])
            mem[s] = cd[idx]
            idx = idx + 32
            s = s + 32
            continue 
        require cd[36] == address(cd[36])
        require cd[132] == uint8(cd[132])
        require cd[164] == bool(cd[164])
        mem[0] = msg.sender
        mem[32] = 1
        if not stor1[address(msg.sender)]:
            revert with 0, 'Fuck you'
        if ('cd', 4).length <= 1:
            revert with 0, 'INVALID_PATHS'
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'NO_IN'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            _12213 = mem[160]
            if 1 >= ('cd', 4).length:
                revert with 0, 50
            _12249 = mem[192]
            staticcall address(cd[36]).factory() with:
                    gas gas_remaining wei
            mem[ceil32(32 * ('cd', 4).length) + 129] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 133] = address(_12213)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 165] = address(_12249)
            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                    gas gas_remaining wei
                   args address(_12213), address(_12249)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            _12714 = mem[160]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 165] = ext_call.return_data[12 len 20]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 197] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129] = 68
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 161 len 4] = unknown_0xa9059cbb(?????)
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 96] = 0, ext_call.return_data[12 len 20], cd[68], mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 28]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 297] = 0
            call address(_12714).mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 233 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not mem[96]:
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 233] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 265] = 64
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 297] = ('cd', 4).length
                    idx = 0
                    s = 160
                    t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 329
                    while idx < ('cd', 4).length:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args cd[68], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 329 len 32 * ('cd', 4).length])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229
                    require return_data.size >= 32
                    _34443 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32
                    require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 229 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 260
                    _34597 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 230 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 230
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]
                    require _34443 + (32 * _34597) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len ceil32(32 * _34597)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34443 + 261 len ceil32(32 * _34597)]
                    if 1 >= _34597:
                        revert with 0, 50
                    _44193 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                    if cd[100] != 0:
                        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100]:
                            revert with 0, 'INSUFFICIENT_OUT'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if 1 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[204 len 20]:
                            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                        if mem[172 len 20] < mem[204 len 20]:
                            if not mem[172 len 20]:
                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                            if 0 >= ('cd', 4).length:
                                revert with 0, 50
                            if mem[172 len 20] == mem[172 len 20]:
                                if not cd[164]:
                                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args 0, _44193, this.address
                                else:
                                    _45743 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_45743 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_45743 + 36] = 0
                                    mem[_45743 + 68] = _44193
                                    mem[_45743 + 100] = this.address
                                    mem[_45743 + 132] = 128
                                    mem[_45743 + 164] = mem[_45743]
                                    mem[_45743 + 196 len ceil32(mem[_45743])] = mem[_45743 + 32 len ceil32(mem[_45743])]
                                    if ceil32(mem[_45743]) > mem[_45743]:
                                        mem[mem[_45743] + _45743 + 196] = 0
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_45743]) + _45743 + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            _45746 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45746 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45746 + 36] = _44193
                            mem[_45746 + 68] = 0
                            mem[_45746 + 100] = this.address
                            mem[_45746 + 132] = 128
                            mem[_45746 + 164] = mem[_45746]
                            mem[_45746 + 196 len ceil32(mem[_45746])] = mem[_45746 + 32 len ceil32(mem[_45746])]
                            if ceil32(mem[_45746]) > mem[_45746]:
                                mem[mem[_45746] + _45746 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args _44193, 0, address(this.address), 128, mem[_45746], mem[_45746 + 196 len ceil32(mem[_45746])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_45746 + 32] = 32
                            mem[_45746 + 64] = _34597
                            mem[_45746 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return memory
                              from mem[64]
                               len _45746 + (32 * _34597) + -mem[64] + 96
                        if not mem[204 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[204 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44193, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            _45749 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45749 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45749 + 36] = 0
                            mem[_45749 + 68] = _44193
                            mem[_45749 + 100] = this.address
                            mem[_45749 + 132] = 128
                            mem[_45749 + 164] = mem[_45749]
                            mem[_45749 + 196 len ceil32(mem[_45749])] = mem[_45749 + 32 len ceil32(mem[_45749])]
                            if ceil32(mem[_45749]) > mem[_45749]:
                                mem[mem[_45749] + _45749 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44193, address(this.address), 128, mem[_45749], mem[_45749 + 196 len ceil32(mem[_45749])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_45749 + 32] = 32
                            mem[_45749 + 64] = _34597
                            mem[_45749 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return memory
                              from mem[64]
                               len _45749 + (32 * _34597) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34597
                            mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                        _45752 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45752 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45752 + 36] = _44193
                        mem[_45752 + 68] = 0
                        mem[_45752 + 100] = this.address
                        mem[_45752 + 132] = 128
                        mem[_45752 + 164] = mem[_45752]
                        mem[_45752 + 196 len ceil32(mem[_45752])] = mem[_45752 + 32 len ceil32(mem[_45752])]
                        if ceil32(mem[_45752]) > mem[_45752]:
                            mem[mem[_45752] + _45752 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44193, 0, address(this.address), 128, mem[_45752], mem[_45752 + 196 len ceil32(mem[_45752])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45752 + 32] = 32
                        mem[_45752 + 64] = _34597
                        mem[_45752 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                        return memory
                          from mem[64]
                           len _45752 + (32 * _34597) + -mem[64] + 96
                    if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                        revert with 0, 17
                    if not cd[100]:
                        if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                            revert with 0, 17
                        if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                            revert with 0, 17
                        require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                            revert with 0, 'INSUFFICIENT_OUT'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if 1 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[204 len 20]:
                            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                        if mem[172 len 20] < mem[204 len 20]:
                            if not mem[172 len 20]:
                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                            if 0 >= ('cd', 4).length:
                                revert with 0, 50
                            if mem[172 len 20] == mem[172 len 20]:
                                if not cd[164]:
                                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args 0, _44193, this.address
                                else:
                                    _49743 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_49743 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_49743 + 36] = 0
                                    mem[_49743 + 68] = _44193
                                    mem[_49743 + 100] = this.address
                                    mem[_49743 + 132] = 128
                                    mem[_49743 + 164] = mem[_49743]
                                    mem[_49743 + 196 len ceil32(mem[_49743])] = mem[_49743 + 32 len ceil32(mem[_49743])]
                                    if ceil32(mem[_49743]) > mem[_49743]:
                                        mem[mem[_49743] + _49743 + 196] = 0
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_49743]) + _49743 + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            _49746 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_49746 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_49746 + 36] = _44193
                            mem[_49746 + 68] = 0
                            mem[_49746 + 100] = this.address
                            mem[_49746 + 132] = 128
                            mem[_49746 + 164] = mem[_49746]
                            mem[_49746 + 196 len ceil32(mem[_49746])] = mem[_49746 + 32 len ceil32(mem[_49746])]
                            if ceil32(mem[_49746]) > mem[_49746]:
                                mem[mem[_49746] + _49746 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args _44193, 0, address(this.address), 128, mem[_49746], mem[_49746 + 196 len ceil32(mem[_49746])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_49746 + 32] = 32
                            mem[_49746 + 64] = _34597
                            mem[_49746 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return memory
                              from mem[64]
                               len _49746 + (32 * _34597) + -mem[64] + 96
                        if not mem[204 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[204 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44193, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            _49749 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_49749 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_49749 + 36] = 0
                            mem[_49749 + 68] = _44193
                            mem[_49749 + 100] = this.address
                            mem[_49749 + 132] = 128
                            mem[_49749 + 164] = mem[_49749]
                            mem[_49749 + 196 len ceil32(mem[_49749])] = mem[_49749 + 32 len ceil32(mem[_49749])]
                            if ceil32(mem[_49749]) > mem[_49749]:
                                mem[mem[_49749] + _49749 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44193, address(this.address), 128, mem[_49749], mem[_49749 + 196 len ceil32(mem[_49749])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_49749 + 32] = 32
                            mem[_49749 + 64] = _34597
                            mem[_49749 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return memory
                              from mem[64]
                               len _49749 + (32 * _34597) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _49752 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_49752 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_49752 + 36] = _44193
                            mem[_49752 + 68] = 0
                            mem[_49752 + 100] = this.address
                            mem[_49752 + 132] = 128
                            mem[_49752 + 164] = mem[_49752]
                            mem[_49752 + 196 len ceil32(mem[_49752])] = mem[_49752 + 32 len ceil32(mem[_49752])]
                            if ceil32(mem[_49752]) > mem[_49752]:
                                mem[mem[_49752] + _49752 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_49752]) + _49752 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34597
                        mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                        return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                    if not cd[100]:
                        revert with 0, 18
                    require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44193, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34597
                                mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                                return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                            _50259 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50259 + 36] = 0
                            mem[_50259 + 68] = _44193
                            mem[_50259 + 100] = this.address
                            mem[_50259 + 132] = 128
                            mem[_50259 + 164] = mem[_50259]
                            mem[_50259 + 196 len ceil32(mem[_50259])] = mem[_50259 + 32 len ceil32(mem[_50259])]
                            if ceil32(mem[_50259]) > mem[_50259]:
                                mem[mem[_50259] + _50259 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44193, address(this.address), 128, mem[_50259], mem[_50259 + 196 len ceil32(mem[_50259])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_50259 + 32] = 32
                            mem[_50259 + 64] = _34597
                            mem[_50259 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                            return memory
                              from mem[64]
                               len _50259 + (32 * _34597) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _50262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50262 + 36] = _44193
                            mem[_50262 + 68] = 0
                            mem[_50262 + 100] = this.address
                            mem[_50262 + 132] = 128
                            mem[_50262 + 164] = mem[_50262]
                            mem[_50262 + 196 len ceil32(mem[_50262])] = mem[_50262 + 32 len ceil32(mem[_50262])]
                            if ceil32(mem[_50262]) > mem[_50262]:
                                mem[mem[_50262] + _50262 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50262]) + _50262 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34597
                        mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                        return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44193, this.address
                        else:
                            _50265 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50265 + 36] = 0
                            mem[_50265 + 68] = _44193
                            mem[_50265 + 100] = this.address
                            mem[_50265 + 132] = 128
                            mem[_50265 + 164] = mem[_50265]
                            mem[_50265 + 196 len ceil32(mem[_50265])] = mem[_50265 + 32 len ceil32(mem[_50265])]
                            if ceil32(mem[_50265]) > mem[_50265]:
                                mem[mem[_50265] + _50265 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50265]) + _50265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34597
                        mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                        return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34597
                        mem[mem[64] + 64 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                        return Array(len=_34597, data=mem[mem[64] + 64 len 32 * _34597])
                    _50268 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_50268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_50268 + 36] = _44193
                    mem[_50268 + 68] = 0
                    mem[_50268 + 100] = this.address
                    mem[_50268 + 132] = 128
                    mem[_50268 + 164] = mem[_50268]
                    mem[_50268 + 196 len ceil32(mem[_50268])] = mem[_50268 + 32 len ceil32(mem[_50268])]
                    if ceil32(mem[_50268]) > mem[_50268]:
                        mem[mem[_50268] + _50268 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44193, 0, address(this.address), 128, mem[_50268], mem[_50268 + 196 len ceil32(mem[_50268])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_50268 + 32] = 32
                    mem[_50268 + 64] = _34597
                    mem[_50268 + 96 len 32 * _34597] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34597]
                    return memory
                      from mem[64]
                       len _50268 + (32 * _34597) + -mem[64] + 96
                require mem[96] >= 32
                require ('cd', 4).length == bool(('cd', 4).length)
                if not ('cd', 4).length:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 233] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 265] = 64
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 297] = ('cd', 4).length
                idx = 0
                s = 160
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 329
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[68], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 329 len 32 * ('cd', 4).length])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229
                require return_data.size >= 32
                _34444 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 229 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 260
                _34598 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 230 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]) + 230
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229 len 4], Mask(224, 32, cd[68]) >> 32 + 229]
                require _34444 + (32 * _34598) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len ceil32(32 * _34598)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34444 + 261 len ceil32(32 * _34598)]
                if 1 >= _34598:
                    revert with 0, 50
                _44194 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                if cd[100] != 0:
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44194, this.address
                            else:
                                _45755 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45755 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45755 + 36] = 0
                                mem[_45755 + 68] = _44194
                                mem[_45755 + 100] = this.address
                                mem[_45755 + 132] = 128
                                mem[_45755 + 164] = mem[_45755]
                                mem[_45755 + 196 len ceil32(mem[_45755])] = mem[_45755 + 32 len ceil32(mem[_45755])]
                                if ceil32(mem[_45755]) > mem[_45755]:
                                    mem[mem[_45755] + _45755 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45755]) + _45755 + -mem[64] + 192]
                        else:
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _45758 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45758 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45758 + 36] = _44194
                                mem[_45758 + 68] = 0
                                mem[_45758 + 100] = this.address
                                mem[_45758 + 132] = 128
                                mem[_45758 + 164] = mem[_45758]
                                mem[_45758 + 196 len ceil32(mem[_45758])] = mem[_45758 + 32 len ceil32(mem[_45758])]
                                if ceil32(mem[_45758]) > mem[_45758]:
                                    mem[mem[_45758] + _45758 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45758]) + _45758 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34598
                        mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44194, this.address
                        else:
                            _45761 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45761 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45761 + 36] = 0
                            mem[_45761 + 68] = _44194
                            mem[_45761 + 100] = this.address
                            mem[_45761 + 132] = 128
                            mem[_45761 + 164] = mem[_45761]
                            mem[_45761 + 196 len ceil32(mem[_45761])] = mem[_45761 + 32 len ceil32(mem[_45761])]
                            if ceil32(mem[_45761]) > mem[_45761]:
                                mem[mem[_45761] + _45761 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45761]) + _45761 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34598
                        mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34598
                        mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                    _45764 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45764 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45764 + 36] = _44194
                    mem[_45764 + 68] = 0
                    mem[_45764 + 100] = this.address
                    mem[_45764 + 132] = 128
                    mem[_45764 + 164] = mem[_45764]
                    mem[_45764 + 196 len ceil32(mem[_45764])] = mem[_45764 + 32 len ceil32(mem[_45764])]
                    if ceil32(mem[_45764]) > mem[_45764]:
                        mem[mem[_45764] + _45764 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44194, 0, address(this.address), 128, mem[_45764], mem[_45764 + 196 len ceil32(mem[_45764])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45764 + 32] = 32
                    mem[_45764 + 64] = _34598
                    mem[_45764 + 96 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                    return memory
                      from mem[64]
                       len _45764 + (32 * _34598) + -mem[64] + 96
                if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                    revert with 0, 17
                if not cd[100]:
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44194, this.address
                            else:
                                _49759 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49759 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49759 + 36] = 0
                                mem[_49759 + 68] = _44194
                                mem[_49759 + 100] = this.address
                                mem[_49759 + 132] = 128
                                mem[_49759 + 164] = mem[_49759]
                                mem[_49759 + 196 len ceil32(mem[_49759])] = mem[_49759 + 32 len ceil32(mem[_49759])]
                                if ceil32(mem[_49759]) > mem[_49759]:
                                    mem[mem[_49759] + _49759 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49759]) + _49759 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34598
                            mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                            return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34598
                            mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                            return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                        _49762 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49762 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49762 + 36] = _44194
                        mem[_49762 + 68] = 0
                        mem[_49762 + 100] = this.address
                        mem[_49762 + 132] = 128
                        mem[_49762 + 164] = mem[_49762]
                        mem[_49762 + 196 len ceil32(mem[_49762])] = mem[_49762 + 32 len ceil32(mem[_49762])]
                        if ceil32(mem[_49762]) > mem[_49762]:
                            mem[mem[_49762] + _49762 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44194, 0, address(this.address), 128, mem[_49762], mem[_49762 + 196 len ceil32(mem[_49762])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49762 + 32] = 32
                        mem[_49762 + 64] = _34598
                        mem[_49762 + 96 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return memory
                          from mem[64]
                           len _49762 + (32 * _34598) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44194, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34598
                            mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                            return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                        _49765 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49765 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49765 + 36] = 0
                        mem[_49765 + 68] = _44194
                        mem[_49765 + 100] = this.address
                        mem[_49765 + 132] = 128
                        mem[_49765 + 164] = mem[_49765]
                        mem[_49765 + 196 len ceil32(mem[_49765])] = mem[_49765 + 32 len ceil32(mem[_49765])]
                        if ceil32(mem[_49765]) > mem[_49765]:
                            mem[mem[_49765] + _49765 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44194, address(this.address), 128, mem[_49765], mem[_49765 + 196 len ceil32(mem[_49765])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49765 + 32] = 32
                        mem[_49765 + 64] = _34598
                        mem[_49765 + 96 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return memory
                          from mem[64]
                           len _49765 + (32 * _34598) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _49768 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49768 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49768 + 36] = _44194
                        mem[_49768 + 68] = 0
                        mem[_49768 + 100] = this.address
                        mem[_49768 + 132] = 128
                        mem[_49768 + 164] = mem[_49768]
                        mem[_49768 + 196 len ceil32(mem[_49768])] = mem[_49768 + 32 len ceil32(mem[_49768])]
                        if ceil32(mem[_49768]) > mem[_49768]:
                            mem[mem[_49768] + _49768 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49768]) + _49768 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34598
                    mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                    return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                if not cd[100]:
                    revert with 0, 18
                require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                    revert with 0, 17
                require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44194, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34598
                            mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                            return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                        _50275 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50275 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50275 + 36] = 0
                        mem[_50275 + 68] = _44194
                        mem[_50275 + 100] = this.address
                        mem[_50275 + 132] = 128
                        mem[_50275 + 164] = mem[_50275]
                        mem[_50275 + 196 len ceil32(mem[_50275])] = mem[_50275 + 32 len ceil32(mem[_50275])]
                        if ceil32(mem[_50275]) > mem[_50275]:
                            mem[mem[_50275] + _50275 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44194, address(this.address), 128, mem[_50275], mem[_50275 + 196 len ceil32(mem[_50275])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_50275 + 32] = 32
                        mem[_50275 + 64] = _34598
                        mem[_50275 + 96 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                        return memory
                          from mem[64]
                           len _50275 + (32 * _34598) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _50278 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50278 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50278 + 36] = _44194
                        mem[_50278 + 68] = 0
                        mem[_50278 + 100] = this.address
                        mem[_50278 + 132] = 128
                        mem[_50278 + 164] = mem[_50278]
                        mem[_50278 + 196 len ceil32(mem[_50278])] = mem[_50278 + 32 len ceil32(mem[_50278])]
                        if ceil32(mem[_50278]) > mem[_50278]:
                            mem[mem[_50278] + _50278 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_50278]) + _50278 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34598
                    mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                    return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44194, this.address
                    else:
                        _50281 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50281 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50281 + 36] = 0
                        mem[_50281 + 68] = _44194
                        mem[_50281 + 100] = this.address
                        mem[_50281 + 132] = 128
                        mem[_50281 + 164] = mem[_50281]
                        mem[_50281 + 196 len ceil32(mem[_50281])] = mem[_50281 + 32 len ceil32(mem[_50281])]
                        if ceil32(mem[_50281]) > mem[_50281]:
                            mem[mem[_50281] + _50281 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_50281]) + _50281 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34598
                    mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                    return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34598
                    mem[mem[64] + 64 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                    return Array(len=_34598, data=mem[mem[64] + 64 len 32 * _34598])
                _50284 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50284 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50284 + 36] = _44194
                mem[_50284 + 68] = 0
                mem[_50284 + 100] = this.address
                mem[_50284 + 132] = 128
                mem[_50284 + 164] = mem[_50284]
                mem[_50284 + 196 len ceil32(mem[_50284])] = mem[_50284 + 32 len ceil32(mem[_50284])]
                if ceil32(mem[_50284]) > mem[_50284]:
                    mem[mem[_50284] + _50284 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44194, 0, address(this.address), 128, mem[_50284], mem[_50284 + 196 len ceil32(mem[_50284])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_50284 + 32] = 32
                mem[_50284 + 64] = _34598
                mem[_50284 + 96 len 32 * _34598] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 32 * _34598]
                return memory
                  from mem[64]
                   len _50284 + (32 * _34598) + -mem[64] + 96
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not return_data.size:
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 234] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = 64
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 298] = ('cd', 4).length
                idx = 0
                s = 160
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 330
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[68], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 330 len 32 * ('cd', 4).length])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230
                require return_data.size >= 32
                _34445 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 230 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 261
                _34599 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 231 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 231
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = _34599
                require _34445 + (32 * _34599) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len ceil32(32 * _34599)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34445 + 262 len ceil32(32 * _34599)]
                if 1 >= _34599:
                    revert with 0, 50
                _44195 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                if cd[100] != 0:
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44195, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34599
                                mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                                return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                            _45767 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45767 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45767 + 36] = 0
                            mem[_45767 + 68] = _44195
                            mem[_45767 + 100] = this.address
                            mem[_45767 + 132] = 128
                            mem[_45767 + 164] = mem[_45767]
                            mem[_45767 + 196 len ceil32(mem[_45767])] = mem[_45767 + 32 len ceil32(mem[_45767])]
                            if ceil32(mem[_45767]) > mem[_45767]:
                                mem[mem[_45767] + _45767 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44195, address(this.address), 128, mem[_45767], mem[_45767 + 196 len ceil32(mem[_45767])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_45767 + 32] = 32
                            mem[_45767 + 64] = _34599
                            mem[_45767 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                            return memory
                              from mem[64]
                               len _45767 + (32 * _34599) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34599
                            mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                            return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                        _45770 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45770 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45770 + 36] = _44195
                        mem[_45770 + 68] = 0
                        mem[_45770 + 100] = this.address
                        mem[_45770 + 132] = 128
                        mem[_45770 + 164] = mem[_45770]
                        mem[_45770 + 196 len ceil32(mem[_45770])] = mem[_45770 + 32 len ceil32(mem[_45770])]
                        if ceil32(mem[_45770]) > mem[_45770]:
                            mem[mem[_45770] + _45770 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44195, 0, address(this.address), 128, mem[_45770], mem[_45770 + 196 len ceil32(mem[_45770])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45770 + 32] = 32
                        mem[_45770 + 64] = _34599
                        mem[_45770 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return memory
                          from mem[64]
                           len _45770 + (32 * _34599) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44195, this.address
                        else:
                            _45773 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45773 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45773 + 36] = 0
                            mem[_45773 + 68] = _44195
                            mem[_45773 + 100] = this.address
                            mem[_45773 + 132] = 128
                            mem[_45773 + 164] = mem[_45773]
                            mem[_45773 + 196 len ceil32(mem[_45773])] = mem[_45773 + 32 len ceil32(mem[_45773])]
                            if ceil32(mem[_45773]) > mem[_45773]:
                                mem[mem[_45773] + _45773 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45773]) + _45773 + -mem[64] + 192]
                    else:
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _45776 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45776 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45776 + 36] = _44195
                            mem[_45776 + 68] = 0
                            mem[_45776 + 100] = this.address
                            mem[_45776 + 132] = 128
                            mem[_45776 + 164] = mem[_45776]
                            mem[_45776 + 196 len ceil32(mem[_45776])] = mem[_45776 + 32 len ceil32(mem[_45776])]
                            if ceil32(mem[_45776]) > mem[_45776]:
                                mem[mem[_45776] + _45776 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45776]) + _45776 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34599
                    mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                    return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                    revert with 0, 17
                if not cd[100]:
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44195, this.address
                            else:
                                _49775 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49775 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49775 + 36] = 0
                                mem[_49775 + 68] = _44195
                                mem[_49775 + 100] = this.address
                                mem[_49775 + 132] = 128
                                mem[_49775 + 164] = mem[_49775]
                                mem[_49775 + 196 len ceil32(mem[_49775])] = mem[_49775 + 32 len ceil32(mem[_49775])]
                                if ceil32(mem[_49775]) > mem[_49775]:
                                    mem[mem[_49775] + _49775 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49775]) + _49775 + -mem[64] + 192]
                        else:
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _49778 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49778 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49778 + 36] = _44195
                                mem[_49778 + 68] = 0
                                mem[_49778 + 100] = this.address
                                mem[_49778 + 132] = 128
                                mem[_49778 + 164] = mem[_49778]
                                mem[_49778 + 196 len ceil32(mem[_49778])] = mem[_49778 + 32 len ceil32(mem[_49778])]
                                if ceil32(mem[_49778]) > mem[_49778]:
                                    mem[mem[_49778] + _49778 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49778]) + _49778 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34599
                        mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44195, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34599
                            mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                            return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                        _49781 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49781 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49781 + 36] = 0
                        mem[_49781 + 68] = _44195
                        mem[_49781 + 100] = this.address
                        mem[_49781 + 132] = 128
                        mem[_49781 + 164] = mem[_49781]
                        mem[_49781 + 196 len ceil32(mem[_49781])] = mem[_49781 + 32 len ceil32(mem[_49781])]
                        if ceil32(mem[_49781]) > mem[_49781]:
                            mem[mem[_49781] + _49781 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44195, address(this.address), 128, mem[_49781], mem[_49781 + 196 len ceil32(mem[_49781])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49781 + 32] = 32
                        mem[_49781 + 64] = _34599
                        mem[_49781 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return memory
                          from mem[64]
                           len _49781 + (32 * _34599) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34599
                        mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                    _49784 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_49784 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_49784 + 36] = _44195
                    mem[_49784 + 68] = 0
                    mem[_49784 + 100] = this.address
                    mem[_49784 + 132] = 128
                    mem[_49784 + 164] = mem[_49784]
                    mem[_49784 + 196 len ceil32(mem[_49784])] = mem[_49784 + 32 len ceil32(mem[_49784])]
                    if ceil32(mem[_49784]) > mem[_49784]:
                        mem[mem[_49784] + _49784 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44195, 0, address(this.address), 128, mem[_49784], mem[_49784 + 196 len ceil32(mem[_49784])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_49784 + 32] = 32
                    mem[_49784 + 64] = _34599
                    mem[_49784 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                    return memory
                      from mem[64]
                       len _49784 + (32 * _34599) + -mem[64] + 96
                if not cd[100]:
                    revert with 0, 18
                require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                    revert with 0, 17
                require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44195, this.address
                        else:
                            _50291 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50291 + 36] = 0
                            mem[_50291 + 68] = _44195
                            mem[_50291 + 100] = this.address
                            mem[_50291 + 132] = 128
                            mem[_50291 + 164] = mem[_50291]
                            mem[_50291 + 196 len ceil32(mem[_50291])] = mem[_50291 + 32 len ceil32(mem[_50291])]
                            if ceil32(mem[_50291]) > mem[_50291]:
                                mem[mem[_50291] + _50291 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50291]) + _50291 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34599
                        mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34599
                        mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                    _50294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_50294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_50294 + 36] = _44195
                    mem[_50294 + 68] = 0
                    mem[_50294 + 100] = this.address
                    mem[_50294 + 132] = 128
                    mem[_50294 + 164] = mem[_50294]
                    mem[_50294 + 196 len ceil32(mem[_50294])] = mem[_50294 + 32 len ceil32(mem[_50294])]
                    if ceil32(mem[_50294]) > mem[_50294]:
                        mem[mem[_50294] + _50294 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44195, 0, address(this.address), 128, mem[_50294], mem[_50294 + 196 len ceil32(mem[_50294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_50294 + 32] = 32
                    mem[_50294 + 64] = _34599
                    mem[_50294 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                    return memory
                      from mem[64]
                       len _50294 + (32 * _34599) + -mem[64] + 96
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44195, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34599
                        mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                        return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                    _50297 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_50297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_50297 + 36] = 0
                    mem[_50297 + 68] = _44195
                    mem[_50297 + 100] = this.address
                    mem[_50297 + 132] = 128
                    mem[_50297 + 164] = mem[_50297]
                    mem[_50297 + 196 len ceil32(mem[_50297])] = mem[_50297 + 32 len ceil32(mem[_50297])]
                    if ceil32(mem[_50297]) > mem[_50297]:
                        mem[mem[_50297] + _50297 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44195, address(this.address), 128, mem[_50297], mem[_50297 + 196 len ceil32(mem[_50297])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_50297 + 32] = 32
                    mem[_50297 + 64] = _34599
                    mem[_50297 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                    return memory
                      from mem[64]
                       len _50297 + (32 * _34599) + -mem[64] + 96
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34599
                    mem[mem[64] + 64 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                    return Array(len=_34599, data=mem[mem[64] + 64 len 32 * _34599])
                _50300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50300 + 36] = _44195
                mem[_50300 + 68] = 0
                mem[_50300 + 100] = this.address
                mem[_50300 + 132] = 128
                mem[_50300 + 164] = mem[_50300]
                mem[_50300 + 196 len ceil32(mem[_50300])] = mem[_50300 + 32 len ceil32(mem[_50300])]
                if ceil32(mem[_50300]) > mem[_50300]:
                    mem[mem[_50300] + _50300 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44195, 0, address(this.address), 128, mem[_50300], mem[_50300 + 196 len ceil32(mem[_50300])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_50300 + 32] = 32
                mem[_50300 + 64] = _34599
                mem[_50300 + 96 len 32 * _34599] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34599]
                return memory
                  from mem[64]
                   len _50300 + (32 * _34599) + -mem[64] + 96
            require return_data.size >= 32
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] == bool(mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261])
            if not mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 234] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 298] = ('cd', 4).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 330
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[68], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 330 len 32 * ('cd', 4).length])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230
            require return_data.size >= 32
            _34446 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 230 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 261
            _34600 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 231 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], Mask(224, 32, cd[68]) >> 32 + 230]) + 231
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = _34600
            require _34446 + (32 * _34600) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len ceil32(32 * _34600)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34446 + 262 len ceil32(32 * _34600)]
            if 1 >= _34600:
                revert with 0, 50
            _44196 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
            if cd[100] != 0:
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44196, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34600
                            mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                            return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
                        _45779 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45779 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45779 + 36] = 0
                        mem[_45779 + 68] = _44196
                        mem[_45779 + 100] = this.address
                        mem[_45779 + 132] = 128
                        mem[_45779 + 164] = mem[_45779]
                        mem[_45779 + 196 len ceil32(mem[_45779])] = mem[_45779 + 32 len ceil32(mem[_45779])]
                        if ceil32(mem[_45779]) > mem[_45779]:
                            mem[mem[_45779] + _45779 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44196, address(this.address), 128, mem[_45779], mem[_45779 + 196 len ceil32(mem[_45779])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45779 + 32] = 32
                        mem[_45779 + 64] = _34600
                        mem[_45779 + 96 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                        return memory
                          from mem[64]
                           len _45779 + (32 * _34600) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34600
                        mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                        return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
                    _45782 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45782 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45782 + 36] = _44196
                    mem[_45782 + 68] = 0
                    mem[_45782 + 100] = this.address
                    mem[_45782 + 132] = 128
                    mem[_45782 + 164] = mem[_45782]
                    mem[_45782 + 196 len ceil32(mem[_45782])] = mem[_45782 + 32 len ceil32(mem[_45782])]
                    if ceil32(mem[_45782]) > mem[_45782]:
                        mem[mem[_45782] + _45782 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44196, 0, address(this.address), 128, mem[_45782], mem[_45782 + 196 len ceil32(mem[_45782])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45782 + 32] = 32
                    mem[_45782 + 64] = _34600
                    mem[_45782 + 96 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                    return memory
                      from mem[64]
                       len _45782 + (32 * _34600) + -mem[64] + 96
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44196, this.address
                    else:
                        _45785 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45785 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45785 + 36] = 0
                        mem[_45785 + 68] = _44196
                        mem[_45785 + 100] = this.address
                        mem[_45785 + 132] = 128
                        mem[_45785 + 164] = mem[_45785]
                        mem[_45785 + 196 len ceil32(mem[_45785])] = mem[_45785 + 32 len ceil32(mem[_45785])]
                        if ceil32(mem[_45785]) > mem[_45785]:
                            mem[mem[_45785] + _45785 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45785]) + _45785 + -mem[64] + 192]
                else:
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45788 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45788 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45788 + 36] = _44196
                        mem[_45788 + 68] = 0
                        mem[_45788 + 100] = this.address
                        mem[_45788 + 132] = 128
                        mem[_45788 + 164] = mem[_45788]
                        mem[_45788 + 196 len ceil32(mem[_45788])] = mem[_45788 + 32 len ceil32(mem[_45788])]
                        if ceil32(mem[_45788]) > mem[_45788]:
                            mem[mem[_45788] + _45788 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45788]) + _45788 + -mem[64] + 192]
            else:
                if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                    revert with 0, 17
                if not cd[100]:
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44196, this.address
                            else:
                                _49791 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49791 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49791 + 36] = 0
                                mem[_49791 + 68] = _44196
                                mem[_49791 + 100] = this.address
                                mem[_49791 + 132] = 128
                                mem[_49791 + 164] = mem[_49791]
                                mem[_49791 + 196 len ceil32(mem[_49791])] = mem[_49791 + 32 len ceil32(mem[_49791])]
                                if ceil32(mem[_49791]) > mem[_49791]:
                                    mem[mem[_49791] + _49791 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49791]) + _49791 + -mem[64] + 192]
                        else:
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _49794 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49794 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49794 + 36] = _44196
                                mem[_49794 + 68] = 0
                                mem[_49794 + 100] = this.address
                                mem[_49794 + 132] = 128
                                mem[_49794 + 164] = mem[_49794]
                                mem[_49794 + 196 len ceil32(mem[_49794])] = mem[_49794 + 32 len ceil32(mem[_49794])]
                                if ceil32(mem[_49794]) > mem[_49794]:
                                    mem[mem[_49794] + _49794 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49794]) + _49794 + -mem[64] + 192]
                    else:
                        if not mem[204 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[204 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44196, this.address
                            else:
                                _49797 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49797 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49797 + 36] = 0
                                mem[_49797 + 68] = _44196
                                mem[_49797 + 100] = this.address
                                mem[_49797 + 132] = 128
                                mem[_49797 + 164] = mem[_49797]
                                mem[_49797 + 196 len ceil32(mem[_49797])] = mem[_49797 + 32 len ceil32(mem[_49797])]
                                if ceil32(mem[_49797]) > mem[_49797]:
                                    mem[mem[_49797] + _49797 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49797]) + _49797 + -mem[64] + 192]
                        else:
                            if not cd[164]:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _49800 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49800 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49800 + 36] = _44196
                                mem[_49800 + 68] = 0
                                mem[_49800 + 100] = this.address
                                mem[_49800 + 132] = 128
                                mem[_49800 + 164] = mem[_49800]
                                mem[_49800 + 196 len ceil32(mem[_49800])] = mem[_49800 + 32 len ceil32(mem[_49800])]
                                if ceil32(mem[_49800]) > mem[_49800]:
                                    mem[mem[_49800] + _49800 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49800]) + _49800 + -mem[64] + 192]
                else:
                    if not cd[100]:
                        revert with 0, 18
                    require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44196, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34600
                                mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                                return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
                            _50307 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50307 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50307 + 36] = 0
                            mem[_50307 + 68] = _44196
                            mem[_50307 + 100] = this.address
                            mem[_50307 + 132] = 128
                            mem[_50307 + 164] = mem[_50307]
                            mem[_50307 + 196 len ceil32(mem[_50307])] = mem[_50307 + 32 len ceil32(mem[_50307])]
                            if ceil32(mem[_50307]) > mem[_50307]:
                                mem[mem[_50307] + _50307 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44196, address(this.address), 128, mem[_50307], mem[_50307 + 196 len ceil32(mem[_50307])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_50307 + 32] = 32
                            mem[_50307 + 64] = _34600
                            mem[_50307 + 96 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                            return memory
                              from mem[64]
                               len _50307 + (32 * _34600) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34600
                            mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                            return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
                        _50310 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50310 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50310 + 36] = _44196
                        mem[_50310 + 68] = 0
                        mem[_50310 + 100] = this.address
                        mem[_50310 + 132] = 128
                        mem[_50310 + 164] = mem[_50310]
                        mem[_50310 + 196 len ceil32(mem[_50310])] = mem[_50310 + 32 len ceil32(mem[_50310])]
                        if ceil32(mem[_50310]) > mem[_50310]:
                            mem[mem[_50310] + _50310 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44196, 0, address(this.address), 128, mem[_50310], mem[_50310 + 196 len ceil32(mem[_50310])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_50310 + 32] = 32
                        mem[_50310 + 64] = _34600
                        mem[_50310 + 96 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                        return memory
                          from mem[64]
                           len _50310 + (32 * _34600) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44196, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34600
                            mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                            return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
                        _50313 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50313 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50313 + 36] = 0
                        mem[_50313 + 68] = _44196
                        mem[_50313 + 100] = this.address
                        mem[_50313 + 132] = 128
                        mem[_50313 + 164] = mem[_50313]
                        mem[_50313 + 196 len ceil32(mem[_50313])] = mem[_50313 + 32 len ceil32(mem[_50313])]
                        if ceil32(mem[_50313]) > mem[_50313]:
                            mem[mem[_50313] + _50313 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44196, address(this.address), 128, mem[_50313], mem[_50313 + 196 len ceil32(mem[_50313])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_50313 + 32] = 32
                        mem[_50313 + 64] = _34600
                        mem[_50313 + 96 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
                        return memory
                          from mem[64]
                           len _50313 + (32 * _34600) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _50316 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50316 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50316 + 36] = _44196
                        mem[_50316 + 68] = 0
                        mem[_50316 + 100] = this.address
                        mem[_50316 + 132] = 128
                        mem[_50316 + 164] = mem[_50316]
                        mem[_50316 + 196 len ceil32(mem[_50316])] = mem[_50316 + 32 len ceil32(mem[_50316])]
                        if ceil32(mem[_50316]) > mem[_50316]:
                            mem[mem[_50316] + _50316 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_50316]) + _50316 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34600
            mem[mem[64] + 64 len 32 * _34600] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34600]
            return Array(len=_34600, data=mem[mem[64] + 64 len 32 * _34600])
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        _12203 = mem[160]
        mem[ceil32(32 * ('cd', 4).length) + 133] = this.address
        staticcall address(_12203).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(32 * ('cd', 4).length) + 129] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0, 'NO_IN'
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        _12368 = mem[160]
        if 1 >= ('cd', 4).length:
            revert with 0, 50
        _12391 = mem[192]
        staticcall address(cd[36]).factory() with:
                gas gas_remaining wei
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 129] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 133] = address(_12368)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 165] = address(_12391)
        staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(_12368), address(_12391)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        _12894 = mem[160]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 165] = ext_call.return_data[12 len 20]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 129] = 68
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 161 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 96] = 0, ext_call.return_data[12 len 20], ext_call.return_data[0], mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 28]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 297] = 0
        call address(_12894).mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 233 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not mem[96]:
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 233] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 265] = 64
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 297] = ('cd', 4).length
                idx = 0
                s = 160
                t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 329
                while idx < ('cd', 4).length:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 329 len 32 * ('cd', 4).length])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 229
                require return_data.size >= 32
                _34451 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 229 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 260
                _34605 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 230 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 230
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 229] = _34605
                require _34451 + (32 * _34605) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len ceil32(32 * _34605)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34451 + 261 len ceil32(32 * _34605)]
                if 1 >= _34605:
                    revert with 0, 50
                _44201 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                if cd[100] != 0:
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44201, this.address
                            else:
                                _45839 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45839 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45839 + 36] = 0
                                mem[_45839 + 68] = _44201
                                mem[_45839 + 100] = this.address
                                mem[_45839 + 132] = 128
                                mem[_45839 + 164] = mem[_45839]
                                mem[_45839 + 196 len ceil32(mem[_45839])] = mem[_45839 + 32 len ceil32(mem[_45839])]
                                if ceil32(mem[_45839]) > mem[_45839]:
                                    mem[mem[_45839] + _45839 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45839]) + _45839 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34605
                            mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                            return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34605
                            mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                            return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                        _45842 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45842 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45842 + 36] = _44201
                        mem[_45842 + 68] = 0
                        mem[_45842 + 100] = this.address
                        mem[_45842 + 132] = 128
                        mem[_45842 + 164] = mem[_45842]
                        mem[_45842 + 196 len ceil32(mem[_45842])] = mem[_45842 + 32 len ceil32(mem[_45842])]
                        if ceil32(mem[_45842]) > mem[_45842]:
                            mem[mem[_45842] + _45842 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44201, 0, address(this.address), 128, mem[_45842], mem[_45842 + 196 len ceil32(mem[_45842])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45842 + 32] = 32
                        mem[_45842 + 64] = _34605
                        mem[_45842 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                        return memory
                          from mem[64]
                           len _45842 + (32 * _34605) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44201, this.address
                        else:
                            _45845 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45845 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45845 + 36] = 0
                            mem[_45845 + 68] = _44201
                            mem[_45845 + 100] = this.address
                            mem[_45845 + 132] = 128
                            mem[_45845 + 164] = mem[_45845]
                            mem[_45845 + 196 len ceil32(mem[_45845])] = mem[_45845 + 32 len ceil32(mem[_45845])]
                            if ceil32(mem[_45845]) > mem[_45845]:
                                mem[mem[_45845] + _45845 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45845]) + _45845 + -mem[64] + 192]
                    else:
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _45848 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45848 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45848 + 36] = _44201
                            mem[_45848 + 68] = 0
                            mem[_45848 + 100] = this.address
                            mem[_45848 + 132] = 128
                            mem[_45848 + 164] = mem[_45848]
                            mem[_45848 + 196 len ceil32(mem[_45848])] = mem[_45848 + 32 len ceil32(mem[_45848])]
                            if ceil32(mem[_45848]) > mem[_45848]:
                                mem[mem[_45848] + _45848 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45848]) + _45848 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34605
                    mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                    return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                    revert with 0, 17
                if not cd[100]:
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44201, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34605
                                mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                                return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                            _49871 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_49871 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_49871 + 36] = 0
                            mem[_49871 + 68] = _44201
                            mem[_49871 + 100] = this.address
                            mem[_49871 + 132] = 128
                            mem[_49871 + 164] = mem[_49871]
                            mem[_49871 + 196 len ceil32(mem[_49871])] = mem[_49871 + 32 len ceil32(mem[_49871])]
                            if ceil32(mem[_49871]) > mem[_49871]:
                                mem[mem[_49871] + _49871 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44201, address(this.address), 128, mem[_49871], mem[_49871 + 196 len ceil32(mem[_49871])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_49871 + 32] = 32
                            mem[_49871 + 64] = _34605
                            mem[_49871 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                            return memory
                              from mem[64]
                               len _49871 + (32 * _34605) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34605
                            mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                            return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                        _49874 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49874 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49874 + 36] = _44201
                        mem[_49874 + 68] = 0
                        mem[_49874 + 100] = this.address
                        mem[_49874 + 132] = 128
                        mem[_49874 + 164] = mem[_49874]
                        mem[_49874 + 196 len ceil32(mem[_49874])] = mem[_49874 + 32 len ceil32(mem[_49874])]
                        if ceil32(mem[_49874]) > mem[_49874]:
                            mem[mem[_49874] + _49874 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44201, 0, address(this.address), 128, mem[_49874], mem[_49874 + 196 len ceil32(mem[_49874])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49874 + 32] = 32
                        mem[_49874 + 64] = _34605
                        mem[_49874 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                        return memory
                          from mem[64]
                           len _49874 + (32 * _34605) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44201, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34605
                            mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                            return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                        _49877 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49877 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49877 + 36] = 0
                        mem[_49877 + 68] = _44201
                        mem[_49877 + 100] = this.address
                        mem[_49877 + 132] = 128
                        mem[_49877 + 164] = mem[_49877]
                        mem[_49877 + 196 len ceil32(mem[_49877])] = mem[_49877 + 32 len ceil32(mem[_49877])]
                        if ceil32(mem[_49877]) > mem[_49877]:
                            mem[mem[_49877] + _49877 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44201, address(this.address), 128, mem[_49877], mem[_49877 + 196 len ceil32(mem[_49877])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49877 + 32] = 32
                        mem[_49877 + 64] = _34605
                        mem[_49877 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                        return memory
                          from mem[64]
                           len _49877 + (32 * _34605) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34605
                        mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                        return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                    _49880 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_49880 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_49880 + 36] = _44201
                    mem[_49880 + 68] = 0
                    mem[_49880 + 100] = this.address
                    mem[_49880 + 132] = 128
                    mem[_49880 + 164] = mem[_49880]
                    mem[_49880 + 196 len ceil32(mem[_49880])] = mem[_49880 + 32 len ceil32(mem[_49880])]
                    if ceil32(mem[_49880]) > mem[_49880]:
                        mem[mem[_49880] + _49880 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44201, 0, address(this.address), 128, mem[_49880], mem[_49880 + 196 len ceil32(mem[_49880])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_49880 + 32] = 32
                    mem[_49880 + 64] = _34605
                    mem[_49880 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                    return memory
                      from mem[64]
                       len _49880 + (32 * _34605) + -mem[64] + 96
                if not cd[100]:
                    revert with 0, 18
                require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                    revert with 0, 17
                require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44201, this.address
                        else:
                            _50387 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50387 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50387 + 36] = 0
                            mem[_50387 + 68] = _44201
                            mem[_50387 + 100] = this.address
                            mem[_50387 + 132] = 128
                            mem[_50387 + 164] = mem[_50387]
                            mem[_50387 + 196 len ceil32(mem[_50387])] = mem[_50387 + 32 len ceil32(mem[_50387])]
                            if ceil32(mem[_50387]) > mem[_50387]:
                                mem[mem[_50387] + _50387 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50387]) + _50387 + -mem[64] + 192]
                    else:
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _50390 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50390 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50390 + 36] = _44201
                            mem[_50390 + 68] = 0
                            mem[_50390 + 100] = this.address
                            mem[_50390 + 132] = 128
                            mem[_50390 + 164] = mem[_50390]
                            mem[_50390 + 196 len ceil32(mem[_50390])] = mem[_50390 + 32 len ceil32(mem[_50390])]
                            if ceil32(mem[_50390]) > mem[_50390]:
                                mem[mem[_50390] + _50390 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50390]) + _50390 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34605
                    mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                    return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44201, this.address
                    else:
                        _50393 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50393 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50393 + 36] = 0
                        mem[_50393 + 68] = _44201
                        mem[_50393 + 100] = this.address
                        mem[_50393 + 132] = 128
                        mem[_50393 + 164] = mem[_50393]
                        mem[_50393 + 196 len ceil32(mem[_50393])] = mem[_50393 + 32 len ceil32(mem[_50393])]
                        if ceil32(mem[_50393]) > mem[_50393]:
                            mem[mem[_50393] + _50393 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_50393]) + _50393 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34605
                    mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                    return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34605
                    mem[mem[64] + 64 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                    return Array(len=_34605, data=mem[mem[64] + 64 len 32 * _34605])
                _50396 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50396 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50396 + 36] = _44201
                mem[_50396 + 68] = 0
                mem[_50396 + 100] = this.address
                mem[_50396 + 132] = 128
                mem[_50396 + 164] = mem[_50396]
                mem[_50396 + 196 len ceil32(mem[_50396])] = mem[_50396 + 32 len ceil32(mem[_50396])]
                if ceil32(mem[_50396]) > mem[_50396]:
                    mem[mem[_50396] + _50396 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44201, 0, address(this.address), 128, mem[_50396], mem[_50396 + 196 len ceil32(mem[_50396])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_50396 + 32] = 32
                mem[_50396 + 64] = _34605
                mem[_50396 + 96 len 32 * _34605] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34605]
                return memory
                  from mem[64]
                   len _50396 + (32 * _34605) + -mem[64] + 96
            require mem[96] >= 32
            require ('cd', 4).length == bool(('cd', 4).length)
            if not ('cd', 4).length:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 233] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 265] = 64
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 297] = ('cd', 4).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 329
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 329 len 32 * ('cd', 4).length])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 229
            require return_data.size >= 32
            _34452 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 229 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 260
            _34606 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 230 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229 len 4], ext_call.return_data[0 len 28] + 229]) + 230
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 229] = _34606
            require _34452 + (32 * _34606) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len ceil32(32 * _34606)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34452 + 261 len ceil32(32 * _34606)]
            if 1 >= _34606:
                revert with 0, 50
            _44202 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
            if cd[100] != 0:
                if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44202, this.address
                        else:
                            _45851 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45851 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45851 + 36] = 0
                            mem[_45851 + 68] = _44202
                            mem[_45851 + 100] = this.address
                            mem[_45851 + 132] = 128
                            mem[_45851 + 164] = mem[_45851]
                            mem[_45851 + 196 len ceil32(mem[_45851])] = mem[_45851 + 32 len ceil32(mem[_45851])]
                            if ceil32(mem[_45851]) > mem[_45851]:
                                mem[mem[_45851] + _45851 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45851]) + _45851 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34606
                        mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34606
                        mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                    _45854 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45854 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45854 + 36] = _44202
                    mem[_45854 + 68] = 0
                    mem[_45854 + 100] = this.address
                    mem[_45854 + 132] = 128
                    mem[_45854 + 164] = mem[_45854]
                    mem[_45854 + 196 len ceil32(mem[_45854])] = mem[_45854 + 32 len ceil32(mem[_45854])]
                    if ceil32(mem[_45854]) > mem[_45854]:
                        mem[mem[_45854] + _45854 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44202, 0, address(this.address), 128, mem[_45854], mem[_45854 + 196 len ceil32(mem[_45854])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45854 + 32] = 32
                    mem[_45854 + 64] = _34606
                    mem[_45854 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                    return memory
                      from mem[64]
                       len _45854 + (32 * _34606) + -mem[64] + 96
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44202, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34606
                        mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                    _45857 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45857 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45857 + 36] = 0
                    mem[_45857 + 68] = _44202
                    mem[_45857 + 100] = this.address
                    mem[_45857 + 132] = 128
                    mem[_45857 + 164] = mem[_45857]
                    mem[_45857 + 196 len ceil32(mem[_45857])] = mem[_45857 + 32 len ceil32(mem[_45857])]
                    if ceil32(mem[_45857]) > mem[_45857]:
                        mem[mem[_45857] + _45857 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44202, address(this.address), 128, mem[_45857], mem[_45857 + 196 len ceil32(mem[_45857])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45857 + 32] = 32
                    mem[_45857 + 64] = _34606
                    mem[_45857 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                    return memory
                      from mem[64]
                       len _45857 + (32 * _34606) + -mem[64] + 96
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _45860 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45860 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45860 + 36] = _44202
                    mem[_45860 + 68] = 0
                    mem[_45860 + 100] = this.address
                    mem[_45860 + 132] = 128
                    mem[_45860 + 164] = mem[_45860]
                    mem[_45860 + 196 len ceil32(mem[_45860])] = mem[_45860 + 32 len ceil32(mem[_45860])]
                    if ceil32(mem[_45860]) > mem[_45860]:
                        mem[mem[_45860] + _45860 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45860]) + _45860 + -mem[64] + 192]
            else:
                if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                    revert with 0, 17
                if not cd[100]:
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44202, this.address
                            else:
                                _49887 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_49887 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_49887 + 36] = 0
                                mem[_49887 + 68] = _44202
                                mem[_49887 + 100] = this.address
                                mem[_49887 + 132] = 128
                                mem[_49887 + 164] = mem[_49887]
                                mem[_49887 + 196 len ceil32(mem[_49887])] = mem[_49887 + 32 len ceil32(mem[_49887])]
                                if ceil32(mem[_49887]) > mem[_49887]:
                                    mem[mem[_49887] + _49887 + 196] = 0
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_49887]) + _49887 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34606
                            mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                            return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34606
                            mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                            return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                        _49890 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49890 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49890 + 36] = _44202
                        mem[_49890 + 68] = 0
                        mem[_49890 + 100] = this.address
                        mem[_49890 + 132] = 128
                        mem[_49890 + 164] = mem[_49890]
                        mem[_49890 + 196 len ceil32(mem[_49890])] = mem[_49890 + 32 len ceil32(mem[_49890])]
                        if ceil32(mem[_49890]) > mem[_49890]:
                            mem[mem[_49890] + _49890 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44202, 0, address(this.address), 128, mem[_49890], mem[_49890 + 196 len ceil32(mem[_49890])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49890 + 32] = 32
                        mem[_49890 + 64] = _34606
                        mem[_49890 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return memory
                          from mem[64]
                           len _49890 + (32 * _34606) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44202, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34606
                            mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                            return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                        _49893 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49893 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49893 + 36] = 0
                        mem[_49893 + 68] = _44202
                        mem[_49893 + 100] = this.address
                        mem[_49893 + 132] = 128
                        mem[_49893 + 164] = mem[_49893]
                        mem[_49893 + 196 len ceil32(mem[_49893])] = mem[_49893 + 32 len ceil32(mem[_49893])]
                        if ceil32(mem[_49893]) > mem[_49893]:
                            mem[mem[_49893] + _49893 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44202, address(this.address), 128, mem[_49893], mem[_49893 + 196 len ceil32(mem[_49893])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49893 + 32] = 32
                        mem[_49893 + 64] = _34606
                        mem[_49893 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return memory
                          from mem[64]
                           len _49893 + (32 * _34606) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _49896 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49896 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49896 + 36] = _44202
                        mem[_49896 + 68] = 0
                        mem[_49896 + 100] = this.address
                        mem[_49896 + 132] = 128
                        mem[_49896 + 164] = mem[_49896]
                        mem[_49896 + 196 len ceil32(mem[_49896])] = mem[_49896 + 32 len ceil32(mem[_49896])]
                        if ceil32(mem[_49896]) > mem[_49896]:
                            mem[mem[_49896] + _49896 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49896]) + _49896 + -mem[64] + 192]
                else:
                    if not cd[100]:
                        revert with 0, 18
                    require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
                    if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                        revert with 0, 17
                    require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                    if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293] < cd[100] * uint8(cd[132]) / 100:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if 1 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[172 len 20] < mem[204 len 20]:
                        if not mem[172 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if 0 >= ('cd', 4).length:
                            revert with 0, 50
                        if mem[172 len 20] == mem[172 len 20]:
                            if not cd[164]:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44202, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64]] = 32
                                mem[mem[64] + 32] = _34606
                                mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                                return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                            _50403 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50403 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50403 + 36] = 0
                            mem[_50403 + 68] = _44202
                            mem[_50403 + 100] = this.address
                            mem[_50403 + 132] = 128
                            mem[_50403 + 164] = mem[_50403]
                            mem[_50403 + 196 len ceil32(mem[_50403])] = mem[_50403 + 32 len ceil32(mem[_50403])]
                            if ceil32(mem[_50403]) > mem[_50403]:
                                mem[mem[_50403] + _50403 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, _44202, address(this.address), 128, mem[_50403], mem[_50403 + 196 len ceil32(mem[_50403])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_50403 + 32] = 32
                            mem[_50403 + 64] = _34606
                            mem[_50403 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                            return memory
                              from mem[64]
                               len _50403 + (32 * _34606) + -mem[64] + 96
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34606
                            mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                            return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
                        _50406 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50406 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50406 + 36] = _44202
                        mem[_50406 + 68] = 0
                        mem[_50406 + 100] = this.address
                        mem[_50406 + 132] = 128
                        mem[_50406 + 164] = mem[_50406]
                        mem[_50406 + 196 len ceil32(mem[_50406])] = mem[_50406 + 32 len ceil32(mem[_50406])]
                        if ceil32(mem[_50406]) > mem[_50406]:
                            mem[mem[_50406] + _50406 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44202, 0, address(this.address), 128, mem[_50406], mem[_50406 + 196 len ceil32(mem[_50406])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_50406 + 32] = 32
                        mem[_50406 + 64] = _34606
                        mem[_50406 + 96 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
                        return memory
                          from mem[64]
                           len _50406 + (32 * _34606) + -mem[64] + 96
                    if not mem[204 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[204 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44202, this.address
                        else:
                            _50409 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50409 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50409 + 36] = 0
                            mem[_50409 + 68] = _44202
                            mem[_50409 + 100] = this.address
                            mem[_50409 + 132] = 128
                            mem[_50409 + 164] = mem[_50409]
                            mem[_50409 + 196 len ceil32(mem[_50409])] = mem[_50409 + 32 len ceil32(mem[_50409])]
                            if ceil32(mem[_50409]) > mem[_50409]:
                                mem[mem[_50409] + _50409 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50409]) + _50409 + -mem[64] + 192]
                    else:
                        if not cd[164]:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 293]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _50412 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_50412 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_50412 + 36] = _44202
                            mem[_50412 + 68] = 0
                            mem[_50412 + 100] = this.address
                            mem[_50412 + 132] = 128
                            mem[_50412 + 164] = mem[_50412]
                            mem[_50412 + 196 len ceil32(mem[_50412])] = mem[_50412 + 32 len ceil32(mem[_50412])]
                            if ceil32(mem[_50412]) > mem[_50412]:
                                mem[mem[_50412] + _50412 + 196] = 0
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_50412]) + _50412 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34606
            mem[mem[64] + 64 len 32 * _34606] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 261 len 32 * _34606]
            return Array(len=_34606, data=mem[mem[64] + 64 len 32 * _34606])
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 229] = return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'TRANSFER_FAILED'
        if not return_data.size:
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 234] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = 64
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 298] = ('cd', 4).length
            idx = 0
            s = 160
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 330
            while idx < ('cd', 4).length:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 330 len 32 * ('cd', 4).length])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 230
            require return_data.size >= 32
            _34453 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 230 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 261
            _34607 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 231 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 231
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = _34607
            require _34453 + (32 * _34607) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len ceil32(32 * _34607)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34453 + 262 len ceil32(32 * _34607)]
            if 1 >= _34607:
                revert with 0, 50
            _44203 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
            if cd[100] != 0:
                if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44203, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34607
                            mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                            return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                        _45863 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45863 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45863 + 36] = 0
                        mem[_45863 + 68] = _44203
                        mem[_45863 + 100] = this.address
                        mem[_45863 + 132] = 128
                        mem[_45863 + 164] = mem[_45863]
                        mem[_45863 + 196 len ceil32(mem[_45863])] = mem[_45863 + 32 len ceil32(mem[_45863])]
                        if ceil32(mem[_45863]) > mem[_45863]:
                            mem[mem[_45863] + _45863 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44203, address(this.address), 128, mem[_45863], mem[_45863 + 196 len ceil32(mem[_45863])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45863 + 32] = 32
                        mem[_45863 + 64] = _34607
                        mem[_45863 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                        return memory
                          from mem[64]
                           len _45863 + (32 * _34607) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34607
                        mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                        return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                    _45866 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45866 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45866 + 36] = _44203
                    mem[_45866 + 68] = 0
                    mem[_45866 + 100] = this.address
                    mem[_45866 + 132] = 128
                    mem[_45866 + 164] = mem[_45866]
                    mem[_45866 + 196 len ceil32(mem[_45866])] = mem[_45866 + 32 len ceil32(mem[_45866])]
                    if ceil32(mem[_45866]) > mem[_45866]:
                        mem[mem[_45866] + _45866 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44203, 0, address(this.address), 128, mem[_45866], mem[_45866 + 196 len ceil32(mem[_45866])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45866 + 32] = 32
                    mem[_45866 + 64] = _34607
                    mem[_45866 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return memory
                      from mem[64]
                       len _45866 + (32 * _34607) + -mem[64] + 96
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44203, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34607
                        mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                        return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                    _45869 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45869 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45869 + 36] = 0
                    mem[_45869 + 68] = _44203
                    mem[_45869 + 100] = this.address
                    mem[_45869 + 132] = 128
                    mem[_45869 + 164] = mem[_45869]
                    mem[_45869 + 196 len ceil32(mem[_45869])] = mem[_45869 + 32 len ceil32(mem[_45869])]
                    if ceil32(mem[_45869]) > mem[_45869]:
                        mem[mem[_45869] + _45869 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44203, address(this.address), 128, mem[_45869], mem[_45869 + 196 len ceil32(mem[_45869])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45869 + 32] = 32
                    mem[_45869 + 64] = _34607
                    mem[_45869 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return memory
                      from mem[64]
                       len _45869 + (32 * _34607) + -mem[64] + 96
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34607
                    mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                _45872 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45872 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45872 + 36] = _44203
                mem[_45872 + 68] = 0
                mem[_45872 + 100] = this.address
                mem[_45872 + 132] = 128
                mem[_45872 + 164] = mem[_45872]
                mem[_45872 + 196 len ceil32(mem[_45872])] = mem[_45872 + 32 len ceil32(mem[_45872])]
                if ceil32(mem[_45872]) > mem[_45872]:
                    mem[mem[_45872] + _45872 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44203, 0, address(this.address), 128, mem[_45872], mem[_45872 + 196 len ceil32(mem[_45872])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45872 + 32] = 32
                mem[_45872 + 64] = _34607
                mem[_45872 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                return memory
                  from mem[64]
                   len _45872 + (32 * _34607) + -mem[64] + 96
            if cd[100] and uint8(cd[132]) > -1 / cd[100]:
                revert with 0, 17
            if not cd[100]:
                if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                    revert with 0, 17
                require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
                if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                    revert with 0, 'INSUFFICIENT_OUT'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if 1 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[172 len 20] < mem[204 len 20]:
                    if not mem[172 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if 0 >= ('cd', 4).length:
                        revert with 0, 50
                    if mem[172 len 20] == mem[172 len 20]:
                        if not cd[164]:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44203, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34607
                            mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                            return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                        _49903 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49903 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49903 + 36] = 0
                        mem[_49903 + 68] = _44203
                        mem[_49903 + 100] = this.address
                        mem[_49903 + 132] = 128
                        mem[_49903 + 164] = mem[_49903]
                        mem[_49903 + 196 len ceil32(mem[_49903])] = mem[_49903 + 32 len ceil32(mem[_49903])]
                        if ceil32(mem[_49903]) > mem[_49903]:
                            mem[mem[_49903] + _49903 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44203, address(this.address), 128, mem[_49903], mem[_49903 + 196 len ceil32(mem[_49903])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_49903 + 32] = 32
                        mem[_49903 + 64] = _34607
                        mem[_49903 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                        return memory
                          from mem[64]
                           len _49903 + (32 * _34607) + -mem[64] + 96
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _49906 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49906 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49906 + 36] = _44203
                        mem[_49906 + 68] = 0
                        mem[_49906 + 100] = this.address
                        mem[_49906 + 132] = 128
                        mem[_49906 + 164] = mem[_49906]
                        mem[_49906 + 196 len ceil32(mem[_49906])] = mem[_49906 + 32 len ceil32(mem[_49906])]
                        if ceil32(mem[_49906]) > mem[_49906]:
                            mem[mem[_49906] + _49906 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49906]) + _49906 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34607
                    mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44203, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34607
                        mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                        return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                    _49909 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_49909 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_49909 + 36] = 0
                    mem[_49909 + 68] = _44203
                    mem[_49909 + 100] = this.address
                    mem[_49909 + 132] = 128
                    mem[_49909 + 164] = mem[_49909]
                    mem[_49909 + 196 len ceil32(mem[_49909])] = mem[_49909 + 32 len ceil32(mem[_49909])]
                    if ceil32(mem[_49909]) > mem[_49909]:
                        mem[mem[_49909] + _49909 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44203, address(this.address), 128, mem[_49909], mem[_49909 + 196 len ceil32(mem[_49909])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_49909 + 32] = 32
                    mem[_49909 + 64] = _34607
                    mem[_49909 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return memory
                      from mem[64]
                       len _49909 + (32 * _34607) + -mem[64] + 96
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34607
                    mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                _49912 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_49912 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_49912 + 36] = _44203
                mem[_49912 + 68] = 0
                mem[_49912 + 100] = this.address
                mem[_49912 + 132] = 128
                mem[_49912 + 164] = mem[_49912]
                mem[_49912 + 196 len ceil32(mem[_49912])] = mem[_49912 + 32 len ceil32(mem[_49912])]
                if ceil32(mem[_49912]) > mem[_49912]:
                    mem[mem[_49912] + _49912 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44203, 0, address(this.address), 128, mem[_49912], mem[_49912 + 196 len ceil32(mem[_49912])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_49912 + 32] = 32
                mem[_49912 + 64] = _34607
                mem[_49912 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                return memory
                  from mem[64]
                   len _49912 + (32 * _34607) + -mem[64] + 96
            if not cd[100]:
                revert with 0, 18
            require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
            if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                revert with 0, 17
            require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
            if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                revert with 0, 'INSUFFICIENT_OUT'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if 1 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[204 len 20]:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[172 len 20] < mem[204 len 20]:
                if not mem[172 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[172 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44203, this.address
                    else:
                        _50419 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_50419 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_50419 + 36] = 0
                        mem[_50419 + 68] = _44203
                        mem[_50419 + 100] = this.address
                        mem[_50419 + 132] = 128
                        mem[_50419 + 164] = mem[_50419]
                        mem[_50419 + 196 len ceil32(mem[_50419])] = mem[_50419 + 32 len ceil32(mem[_50419])]
                        if ceil32(mem[_50419]) > mem[_50419]:
                            mem[mem[_50419] + _50419 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_50419]) + _50419 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34607
                    mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34607
                    mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                    return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
                _50422 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50422 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50422 + 36] = _44203
                mem[_50422 + 68] = 0
                mem[_50422 + 100] = this.address
                mem[_50422 + 132] = 128
                mem[_50422 + 164] = mem[_50422]
                mem[_50422 + 196 len ceil32(mem[_50422])] = mem[_50422 + 32 len ceil32(mem[_50422])]
                if ceil32(mem[_50422]) > mem[_50422]:
                    mem[mem[_50422] + _50422 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44203, 0, address(this.address), 128, mem[_50422], mem[_50422 + 196 len ceil32(mem[_50422])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_50422 + 32] = 32
                mem[_50422 + 64] = _34607
                mem[_50422 + 96 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
                return memory
                  from mem[64]
                   len _50422 + (32 * _34607) + -mem[64] + 96
            if not mem[204 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[204 len 20]:
                if not cd[164]:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44203, this.address
                else:
                    _50425 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_50425 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_50425 + 36] = 0
                    mem[_50425 + 68] = _44203
                    mem[_50425 + 100] = this.address
                    mem[_50425 + 132] = 128
                    mem[_50425 + 164] = mem[_50425]
                    mem[_50425 + 196 len ceil32(mem[_50425])] = mem[_50425 + 32 len ceil32(mem[_50425])]
                    if ceil32(mem[_50425]) > mem[_50425]:
                        mem[mem[_50425] + _50425 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_50425]) + _50425 + -mem[64] + 192]
            else:
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _50428 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_50428 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_50428 + 36] = _44203
                    mem[_50428 + 68] = 0
                    mem[_50428 + 100] = this.address
                    mem[_50428 + 132] = 128
                    mem[_50428 + 164] = mem[_50428]
                    mem[_50428 + 196 len ceil32(mem[_50428])] = mem[_50428 + 32 len ceil32(mem[_50428])]
                    if ceil32(mem[_50428]) > mem[_50428]:
                        mem[mem[_50428] + _50428 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_50428]) + _50428 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34607
            mem[mem[64] + 64 len 32 * _34607] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34607]
            return Array(len=_34607, data=mem[mem[64] + 64 len 32 * _34607])
        require return_data.size >= 32
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261] == bool(mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261])
        if not mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261]:
            revert with 0, 'TRANSFER_FAILED'
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 234] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = 64
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 298] = ('cd', 4).length
        idx = 0
        s = 160
        t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 330
        while idx < ('cd', 4).length:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(cd[36]).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 330 len 32 * ('cd', 4).length])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 230
        require return_data.size >= 32
        _34454 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 230 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 261
        _34608 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]
        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 231 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 230 len 4], ext_call.return_data[0 len 28] + 230]) + 231
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 230] = _34608
        require _34454 + (32 * _34608) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len ceil32(32 * _34608)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34454 + 262 len ceil32(32 * _34608)]
        if 1 >= _34608:
            revert with 0, 50
        _44204 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
        if cd[100] != 0:
            if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100]:
                revert with 0, 'INSUFFICIENT_OUT'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if 1 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[204 len 20]:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[172 len 20] < mem[204 len 20]:
                if not mem[172 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[172 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44204, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34608
                        mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                        return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
                    _45875 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45875 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45875 + 36] = 0
                    mem[_45875 + 68] = _44204
                    mem[_45875 + 100] = this.address
                    mem[_45875 + 132] = 128
                    mem[_45875 + 164] = mem[_45875]
                    mem[_45875 + 196 len ceil32(mem[_45875])] = mem[_45875 + 32 len ceil32(mem[_45875])]
                    if ceil32(mem[_45875]) > mem[_45875]:
                        mem[mem[_45875] + _45875 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44204, address(this.address), 128, mem[_45875], mem[_45875 + 196 len ceil32(mem[_45875])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45875 + 32] = 32
                    mem[_45875 + 64] = _34608
                    mem[_45875 + 96 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                    return memory
                      from mem[64]
                       len _45875 + (32 * _34608) + -mem[64] + 96
                if not cd[164]:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34608
                    mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                    return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
                _45878 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45878 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45878 + 36] = _44204
                mem[_45878 + 68] = 0
                mem[_45878 + 100] = this.address
                mem[_45878 + 132] = 128
                mem[_45878 + 164] = mem[_45878]
                mem[_45878 + 196 len ceil32(mem[_45878])] = mem[_45878 + 32 len ceil32(mem[_45878])]
                if ceil32(mem[_45878]) > mem[_45878]:
                    mem[mem[_45878] + _45878 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44204, 0, address(this.address), 128, mem[_45878], mem[_45878 + 196 len ceil32(mem[_45878])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45878 + 32] = 32
                mem[_45878 + 64] = _34608
                mem[_45878 + 96 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                return memory
                  from mem[64]
                   len _45878 + (32 * _34608) + -mem[64] + 96
            if not mem[204 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[204 len 20]:
                if not cd[164]:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44204, this.address
                else:
                    _45881 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45881 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45881 + 36] = 0
                    mem[_45881 + 68] = _44204
                    mem[_45881 + 100] = this.address
                    mem[_45881 + 132] = 128
                    mem[_45881 + 164] = mem[_45881]
                    mem[_45881 + 196 len ceil32(mem[_45881])] = mem[_45881 + 32 len ceil32(mem[_45881])]
                    if ceil32(mem[_45881]) > mem[_45881]:
                        mem[mem[_45881] + _45881 + 196] = 0
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45881]) + _45881 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34608
                mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
            if not cd[164]:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34608
                mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
            _45884 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45884 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45884 + 36] = _44204
            mem[_45884 + 68] = 0
            mem[_45884 + 100] = this.address
            mem[_45884 + 132] = 128
            mem[_45884 + 164] = mem[_45884]
            mem[_45884 + 196 len ceil32(mem[_45884])] = mem[_45884 + 32 len ceil32(mem[_45884])]
            if ceil32(mem[_45884]) > mem[_45884]:
                mem[mem[_45884] + _45884 + 196] = 0
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _44204, 0, address(this.address), 128, mem[_45884], mem[_45884 + 196 len ceil32(mem[_45884])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45884 + 32] = 32
            mem[_45884 + 64] = _34608
            mem[_45884 + 96 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
            return memory
              from mem[64]
               len _45884 + (32 * _34608) + -mem[64] + 96
        if cd[100] and uint8(cd[132]) > -1 / cd[100]:
            revert with 0, 17
        if not cd[100]:
            if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
                revert with 0, 17
            require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
            if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
                revert with 0, 'INSUFFICIENT_OUT'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if 1 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[204 len 20]:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[172 len 20] < mem[204 len 20]:
                if not mem[172 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[172 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44204, this.address
                    else:
                        _49919 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49919 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49919 + 36] = 0
                        mem[_49919 + 68] = _44204
                        mem[_49919 + 100] = this.address
                        mem[_49919 + 132] = 128
                        mem[_49919 + 164] = mem[_49919]
                        mem[_49919 + 196 len ceil32(mem[_49919])] = mem[_49919 + 32 len ceil32(mem[_49919])]
                        if ceil32(mem[_49919]) > mem[_49919]:
                            mem[mem[_49919] + _49919 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49919]) + _49919 + -mem[64] + 192]
                else:
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _49922 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49922 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49922 + 36] = _44204
                        mem[_49922 + 68] = 0
                        mem[_49922 + 100] = this.address
                        mem[_49922 + 132] = 128
                        mem[_49922 + 164] = mem[_49922]
                        mem[_49922 + 196 len ceil32(mem[_49922])] = mem[_49922 + 32 len ceil32(mem[_49922])]
                        if ceil32(mem[_49922]) > mem[_49922]:
                            mem[mem[_49922] + _49922 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49922]) + _49922 + -mem[64] + 192]
            else:
                if not mem[204 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if 0 >= ('cd', 4).length:
                    revert with 0, 50
                if mem[172 len 20] == mem[204 len 20]:
                    if not cd[164]:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44204, this.address
                    else:
                        _49925 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49925 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49925 + 36] = 0
                        mem[_49925 + 68] = _44204
                        mem[_49925 + 100] = this.address
                        mem[_49925 + 132] = 128
                        mem[_49925 + 164] = mem[_49925]
                        mem[_49925 + 196 len ceil32(mem[_49925])] = mem[_49925 + 32 len ceil32(mem[_49925])]
                        if ceil32(mem[_49925]) > mem[_49925]:
                            mem[mem[_49925] + _49925 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49925]) + _49925 + -mem[64] + 192]
                else:
                    if not cd[164]:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _49928 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_49928 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_49928 + 36] = _44204
                        mem[_49928 + 68] = 0
                        mem[_49928 + 100] = this.address
                        mem[_49928 + 132] = 128
                        mem[_49928 + 164] = mem[_49928]
                        mem[_49928 + 196 len ceil32(mem[_49928])] = mem[_49928 + 32 len ceil32(mem[_49928])]
                        if ceil32(mem[_49928]) > mem[_49928]:
                            mem[mem[_49928] + _49928 + 196] = 0
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_49928]) + _49928 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34608
            mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
            return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
        if not cd[100]:
            revert with 0, 18
        require cd[100] * uint8(cd[132]) / cd[100] == uint8(cd[132])
        if cd[100] * uint8(cd[132]) / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * cd[100] * uint8(cd[132]) / 100 > !(cd[100] * uint8(cd[132]) % 100):
            revert with 0, 17
        require cd[100] * uint8(cd[132]) == (100 * cd[100] * uint8(cd[132]) / 100) + (cd[100] * uint8(cd[132]) % 100)
        if mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] < cd[100] * uint8(cd[132]) / 100:
            revert with 0, 'INSUFFICIENT_OUT'
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        if 1 >= ('cd', 4).length:
            revert with 0, 50
        if mem[172 len 20] == mem[204 len 20]:
            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
        if mem[172 len 20] < mem[204 len 20]:
            if not mem[172 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if 0 >= ('cd', 4).length:
                revert with 0, 50
            if mem[172 len 20] == mem[172 len 20]:
                if not cd[164]:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44204, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34608
                    mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                    return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
                _50435 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50435 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50435 + 36] = 0
                mem[_50435 + 68] = _44204
                mem[_50435 + 100] = this.address
                mem[_50435 + 132] = 128
                mem[_50435 + 164] = mem[_50435]
                mem[_50435 + 196 len ceil32(mem[_50435])] = mem[_50435 + 32 len ceil32(mem[_50435])]
                if ceil32(mem[_50435]) > mem[_50435]:
                    mem[mem[_50435] + _50435 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _44204, address(this.address), 128, mem[_50435], mem[_50435 + 196 len ceil32(mem[_50435])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_50435 + 32] = 32
                mem[_50435 + 64] = _34608
                mem[_50435 + 96 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
                return memory
                  from mem[64]
                   len _50435 + (32 * _34608) + -mem[64] + 96
            if not cd[164]:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
            else:
                _50438 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50438 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50438 + 36] = _44204
                mem[_50438 + 68] = 0
                mem[_50438 + 100] = this.address
                mem[_50438 + 132] = 128
                mem[_50438 + 164] = mem[_50438]
                mem[_50438 + 196 len ceil32(mem[_50438])] = mem[_50438 + 32 len ceil32(mem[_50438])]
                if ceil32(mem[_50438]) > mem[_50438]:
                    mem[mem[_50438] + _50438 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_50438]) + _50438 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34608
            mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
            return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
        if not mem[204 len 20]:
            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        if mem[172 len 20] == mem[204 len 20]:
            if not cd[164]:
                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args 0, _44204, this.address
            else:
                _50441 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_50441 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_50441 + 36] = 0
                mem[_50441 + 68] = _44204
                mem[_50441 + 100] = this.address
                mem[_50441 + 132] = 128
                mem[_50441 + 164] = mem[_50441]
                mem[_50441 + 196 len ceil32(mem[_50441])] = mem[_50441 + 32 len ceil32(mem[_50441])]
                if ceil32(mem[_50441]) > mem[_50441]:
                    mem[mem[_50441] + _50441 + 196] = 0
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_50441]) + _50441 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34608
            mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
            return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
        if not cd[164]:
            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 294]
            mem[mem[64] + 36] = 0
            mem[mem[64] + 68] = this.address
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args mem[mem[64] + 4], 0, this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34608
            mem[mem[64] + 64 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
            return Array(len=_34608, data=mem[mem[64] + 64 len 32 * _34608])
        _50444 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_50444 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_50444 + 36] = _44204
        mem[_50444 + 68] = 0
        mem[_50444 + 100] = this.address
        mem[_50444 + 132] = 128
        mem[_50444 + 164] = mem[_50444]
        mem[_50444 + 196 len ceil32(mem[_50444])] = mem[_50444 + 32 len ceil32(mem[_50444])]
        if ceil32(mem[_50444]) > mem[_50444]:
            mem[mem[_50444] + _50444 + 196] = 0
        require ext_code.size(address(ext_call.return_data[0]))
        call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
             gas gas_remaining wei
            args _44204, 0, address(this.address), 128, mem[_50444], mem[_50444 + 196 len ceil32(mem[_50444])]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_50444 + 32] = 32
        mem[_50444 + 64] = _34608
        mem[_50444 + 96 len 32 * _34608] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 262 len 32 * _34608]
        return memory
          from mem[64]
           len _50444 + (32 * _34608) + -mem[64] + 96
    if uint32(call.func_hash) >> 224 != unknown_0x2e0faf48(?????):
        if uint32(call.func_hash) >> 224 != unknown_0x338b5dea(?????):
            if unknown_0x3af32abf(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                return bool(stor1[address(cd[4])])
            if uint32(call.func_hash) >> 224 != unknown_0x407a4b08(?????):
                if uint32(call.func_hash) >> 224 != unknown_0x5e4ba17c(?????):
                    require unknown_0x5e994dca(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    staticcall address(cd[4]).factory() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    return ext_call.return_data[12 len 20]
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] <= test266151307()
                require cd[4] + 35 < calldata.size
                if ('cd', 4).length > test266151307():
                    revert with 0, 65
                if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
                    revert with 0, 65
                require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                idx = cd[4] + 36
                s = 160
                while idx < cd[4] + (32 * ('cd', 4).length) + 36:
                    require cd[idx] == address(cd[idx])
                    mem[s] = cd[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                require msg.sender == owner
                if ('cd', 4).length <= 0:
                    revert with 0, 'address length is 0'
                idx = 0
                while idx < ('cd', 4).length:
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    mem[0] = mem[(32 * idx) + 172 len 20]
                    mem[32] = 1
                    stor1[mem[(32 * idx) + 172 len 20]] = 0
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    emit RemovedFromWhitelist(mem[(32 * idx) + 172 len 20]);
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
            require not msg.value
            require calldata.size - 4 >= 32
            require cd[4] <= test266151307()
            require cd[4] + 35 < calldata.size
            require ('cd', 4).length <= test266151307()
            require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
            if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                revert with 0, 17
            if 2 * ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[128] = 2 * ('cd', 4).length
            mem[64] = (64 * ('cd', 4).length) + 160
            if not uint255(('cd', 4).length):
                idx = 0
                while idx < ('cd', 4).length:
                    if idx > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                        revert with 0, 17
                    if idx >= ('cd', 4).length:
                        revert with 0, 50
                    require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                    staticcall address(cd[((32 * idx) + cd[4] + 36)]).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11917 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _12047 = mem[_11917]
                    require mem[_11917] == mem[_11917 + 18 len 14]
                    require mem[_11917 + 32] == mem[_11917 + 50 len 14]
                    require mem[_11917 + 64] == mem[_11917 + 92 len 4]
                    if 2 * idx >= mem[128]:
                        revert with 0, 50
                    if 1 > !(2 * idx):
                        revert with 0, 17
                    if (2 * idx) + 1 >= mem[128]:
                        revert with 0, 50
                    mem[(32 * (2 * idx) + 1) + 160] = mem[_11917 + 50 len 14]
                    mem[(64 * idx) + 160] = Mask(112, 0, _12047)
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 32
                _11667 = mem[128]
                mem[mem[64] + 32] = mem[128]
                mem[mem[64] + 64 len 32 * _11667] = mem[160 len 32 * _11667]
                return 32, mem[mem[64] + 32 len (32 * _11667) + 32]
            mem[160 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
            idx = 0
            while idx < ('cd', 4).length:
                if idx > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                    revert with 0, 17
                if idx >= ('cd', 4).length:
                    revert with 0, 50
                require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                staticcall address(cd[((32 * idx) + cd[4] + 36)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11918 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _12048 = mem[_11918]
                require mem[_11918] == mem[_11918 + 18 len 14]
                require mem[_11918 + 32] == mem[_11918 + 50 len 14]
                require mem[_11918 + 64] == mem[_11918 + 92 len 4]
                if 2 * idx >= mem[128]:
                    revert with 0, 50
                if 1 > !(2 * idx):
                    revert with 0, 17
                if (2 * idx) + 1 >= mem[128]:
                    revert with 0, 50
                mem[(32 * (2 * idx) + 1) + 160] = mem[_11918 + 50 len 14]
                mem[(64 * idx) + 160] = Mask(112, 0, _12048)
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            _11668 = mem[128]
            mem[mem[64] + 32] = mem[128]
            mem[mem[64] + 64 len 32 * _11668] = mem[160 len 32 * _11668]
            return 32, mem[mem[64] + 32 len (32 * _11668) + 32]
        require not msg.value
        require calldata.size - 4 >= 64
        require cd[4] == address(cd[4])
        if cd[36] <= 0:
            revert with 0, 'deposit amount should be > 0'
        mem[164] = msg.sender
        mem[196] = this.address
        mem[228] = cd[36]
        mem[128] = 100
        mem[164 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[160 len 4] = unknown_0x23b872dd(?????)
        mem[260] = 32
        mem[292] = 'SafeERC20: low-level call failed'
        if not ext_code.size(address(cd[4])):
            revert with 0, 'Address: call to non-contract'
        mem[324 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[36], 0
        mem[424] = 0
        call address(cd[4]) with:
           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[36], 0) >> 224
             gas gas_remaining wei
            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), cd[36], 0) << 544)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            require not mem[96]
        mem[356 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[356] == bool(mem[356])
            if not mem[356]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 129 < 128 or ceil32(32 * ('cd', 4).length) + 129 > test266151307():
        revert with 0, 65
    mem[128] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = cd[4] + 36
    s = 160
    while idx < cd[4] + (32 * ('cd', 4).length) + 36:
        require cd[idx] == address(cd[idx])
        mem[s] = cd[idx]
        idx = idx + 32
        s = s + 32
        continue 
    mem[0] = msg.sender
    mem[32] = 1
    if not stor1[address(msg.sender)]:
        revert with 0, 'Fuck you'
    mem[ceil32(32 * ('cd', 4).length) + 129] = 2
    mem[ceil32(32 * ('cd', 4).length) + 161 len 64] = call.data[calldata.size len 64]
    if Mask(1, 85, cd[36]) >> 85:
        if 0 >= ('cd', 4).length:
            revert with 0, 50
        mem[ceil32(32 * ('cd', 4).length) + 161] = address(mem[160] xor address(cd[36]) >> 96)
        if 1 >= ('cd', 4).length:
            revert with 0, 50
        mem[ceil32(32 * ('cd', 4).length) + 193] = address(mem[192] xor address(cd[36]) >> 96)
        if Mask(85, 0, cd[36]):
            if Mask(85, 0, cd[36]) <= 0:
                revert with 0, 'NO_IN'
            if 3 >= ('cd', 4).length:
                revert with 0, 50
            _12088 = mem[256]
            if 1 == Mask(1, 94, cd[36]) >> 94:
                if 2 >= ('cd', 4).length:
                    revert with 0, 50
                _12179 = mem[224]
                mem[ceil32(32 * ('cd', 4).length) + 261] = address(mem[224] xor address(cd[36]) >> 96)
                mem[ceil32(32 * ('cd', 4).length) + 293] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + 225] = 68
                mem[ceil32(32 * ('cd', 4).length) + 257 len 4] = unknown_0xa9059cbb(?????)
                mem[ceil32(32 * ('cd', 4).length) + 325 len 96] = 0, mem[ceil32(32 * ('cd', 4).length) + 261], cd[36] << 171, mem[ceil32(32 * ('cd', 4).length) + 325 len 28]
                mem[ceil32(32 * ('cd', 4).length) + 393] = 0
                call mem[ceil32(32 * ('cd', 4).length) + 173 len 20].mem[ceil32(32 * ('cd', 4).length) + 325 len 4] with:
                     gas gas_remaining wei
                    args mem[ceil32(32 * ('cd', 4).length) + 329 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'TRANSFER_FAILED'
                    if not mem[96]:
                        mem[ceil32(32 * ('cd', 4).length) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * ('cd', 4).length) + 329] = Mask(85, 0, cd[36])
                        mem[ceil32(32 * ('cd', 4).length) + 361] = 64
                        mem[ceil32(32 * ('cd', 4).length) + 393] = 2
                        idx = 0
                        s = ceil32(32 * ('cd', 4).length) + 161
                        t = ceil32(32 * ('cd', 4).length) + 425
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                                gas gas_remaining wei
                               args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + 425 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(32 * ('cd', 4).length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
                        require return_data.size >= 32
                        _34468 = mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139
                        require mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                        require ceil32(32 * ('cd', 4).length) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 356
                        _34622 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                        if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326 > test266151307():
                            revert with 0, 65
                        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                        require _34468 + (32 * _34622) + 32 <= return_data.size
                        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len ceil32(32 * _34622)] = mem[ceil32(32 * ('cd', 4).length) + _34468 + 357 len ceil32(32 * _34622)]
                        if 1 >= _34622:
                            revert with 0, 50
                        _44233 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                        if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] < cd[68]:
                            revert with 0, 'INSUFFICIENT_OUT'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                            if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                                if Mask(1, 93, cd[36]) >> 93 != 1:
                                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args 0, _44233, this.address
                                else:
                                    _45359 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_45359 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_45359 + 36] = 0
                                    mem[_45359 + 68] = _44233
                                    mem[_45359 + 100] = this.address
                                    mem[_45359 + 132] = 128
                                    mem[_45359 + 164] = mem[_45359]
                                    mem[_45359 + 196 len ceil32(mem[_45359])] = mem[_45359 + 32 len ceil32(mem[_45359])]
                                    if ceil32(mem[_45359]) > mem[_45359]:
                                        mem[mem[_45359] + _45359 + 196] = 0
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_45359]) + _45359 + -mem[64] + 192]
                            else:
                                if Mask(1, 93, cd[36]) >> 93 != 1:
                                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4], 0, this.address
                                else:
                                    _45362 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_45362 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_45362 + 36] = _44233
                                    mem[_45362 + 68] = 0
                                    mem[_45362 + 100] = this.address
                                    mem[_45362 + 132] = 128
                                    mem[_45362 + 164] = mem[_45362]
                                    mem[_45362 + 196 len ceil32(mem[_45362])] = mem[_45362 + 32 len ceil32(mem[_45362])]
                                    if ceil32(mem[_45362]) > mem[_45362]:
                                        mem[mem[_45362] + _45362 + 196] = 0
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_45362]) + _45362 + -mem[64] + 192]
                        else:
                            if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                                if Mask(1, 93, cd[36]) >> 93 != 1:
                                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args 0, _44233, this.address
                                else:
                                    _45365 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_45365 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_45365 + 36] = 0
                                    mem[_45365 + 68] = _44233
                                    mem[_45365 + 100] = this.address
                                    mem[_45365 + 132] = 128
                                    mem[_45365 + 164] = mem[_45365]
                                    mem[_45365 + 196 len ceil32(mem[_45365])] = mem[_45365 + 32 len ceil32(mem[_45365])]
                                    if ceil32(mem[_45365]) > mem[_45365]:
                                        mem[mem[_45365] + _45365 + 196] = 0
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_45365]) + _45365 + -mem[64] + 192]
                            else:
                                if Mask(1, 93, cd[36]) >> 93 != 1:
                                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                    mem[mem[64] + 36] = 0
                                    mem[mem[64] + 68] = this.address
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4], 0, this.address
                                else:
                                    _45368 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_45368 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_45368 + 36] = _44233
                                    mem[_45368 + 68] = 0
                                    mem[_45368 + 100] = this.address
                                    mem[_45368 + 132] = 128
                                    mem[_45368 + 164] = mem[_45368]
                                    mem[_45368 + 196 len ceil32(mem[_45368])] = mem[_45368 + 32 len ceil32(mem[_45368])]
                                    if ceil32(mem[_45368]) > mem[_45368]:
                                        mem[mem[_45368] + _45368 + 196] = 0
                                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                    call address(_12179 xor address(cd[36]) >> 96) with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_45368]) + _45368 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34622
                        mem[mem[64] + 64 len 32 * _34622] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34622]
                        return Array(len=_34622, data=mem[mem[64] + 64 len 32 * _34622])
                    require mem[96] >= 32
                    require ('cd', 4).length == bool(('cd', 4).length)
                    if not ('cd', 4).length:
                        revert with 0, 'TRANSFER_FAILED'
                    mem[ceil32(32 * ('cd', 4).length) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + 329] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + 361] = 64
                    mem[ceil32(32 * ('cd', 4).length) + 393] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + 425
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + 425 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
                    require return_data.size >= 32
                    _34469 = mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 356
                    _34623 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                    if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                    require _34469 + (32 * _34623) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len ceil32(32 * _34623)] = mem[ceil32(32 * ('cd', 4).length) + _34469 + 357 len ceil32(32 * _34623)]
                    var83002 = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * _34623) + 357
                    if 1 >= _34623:
                        revert with 0, 50
                    _44234 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] < cd[68]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44234, this.address
                            else:
                                _45371 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45371 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45371 + 36] = 0
                                mem[_45371 + 68] = _44234
                                mem[_45371 + 100] = this.address
                                mem[_45371 + 132] = 128
                                mem[_45371 + 164] = mem[_45371]
                                mem[_45371 + 196 len ceil32(mem[_45371])] = mem[_45371 + 32 len ceil32(mem[_45371])]
                                if ceil32(mem[_45371]) > mem[_45371]:
                                    mem[mem[_45371] + _45371 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45371]) + _45371 + -mem[64] + 192]
                        else:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _45374 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45374 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45374 + 36] = _44234
                                mem[_45374 + 68] = 0
                                mem[_45374 + 100] = this.address
                                mem[_45374 + 132] = 128
                                mem[_45374 + 164] = mem[_45374]
                                mem[_45374 + 196 len ceil32(mem[_45374])] = mem[_45374 + 32 len ceil32(mem[_45374])]
                                if ceil32(mem[_45374]) > mem[_45374]:
                                    mem[mem[_45374] + _45374 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45374]) + _45374 + -mem[64] + 192]
                    else:
                        if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44234, this.address
                            else:
                                _45377 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45377 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45377 + 36] = 0
                                mem[_45377 + 68] = _44234
                                mem[_45377 + 100] = this.address
                                mem[_45377 + 132] = 128
                                mem[_45377 + 164] = mem[_45377]
                                mem[_45377 + 196 len ceil32(mem[_45377])] = mem[_45377 + 32 len ceil32(mem[_45377])]
                                if ceil32(mem[_45377]) > mem[_45377]:
                                    mem[mem[_45377] + _45377 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45377]) + _45377 + -mem[64] + 192]
                        else:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _45380 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45380 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45380 + 36] = _44234
                                mem[_45380 + 68] = 0
                                mem[_45380 + 100] = this.address
                                mem[_45380 + 132] = 128
                                mem[_45380 + 164] = mem[_45380]
                                mem[_45380 + 196 len ceil32(mem[_45380])] = mem[_45380 + 32 len ceil32(mem[_45380])]
                                if ceil32(mem[_45380]) > mem[_45380]:
                                    mem[mem[_45380] + _45380 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45380]) + _45380 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34623
                    mem[mem[64] + 64 len 32 * _34623] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34623]
                    return Array(len=_34623, data=mem[mem[64] + 64 len 32 * _34623])
                mem[ceil32(32 * ('cd', 4).length) + 325] = return_data.size
                mem[ceil32(32 * ('cd', 4).length) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not return_data.size:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 330] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 362] = 64
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 394] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326
                    require return_data.size >= 32
                    _34470 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 357
                    _34624 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                    require _34470 + (32 * _34624) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len ceil32(32 * _34624)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34470 + 358 len ceil32(32 * _34624)]
                    if 1 >= _34624:
                        revert with 0, 50
                    _44235 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390] < cd[68]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44235, this.address
                            else:
                                _45383 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45383 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45383 + 36] = 0
                                mem[_45383 + 68] = _44235
                                mem[_45383 + 100] = this.address
                                mem[_45383 + 132] = 128
                                mem[_45383 + 164] = mem[_45383]
                                mem[_45383 + 196 len ceil32(mem[_45383])] = mem[_45383 + 32 len ceil32(mem[_45383])]
                                if ceil32(mem[_45383]) > mem[_45383]:
                                    mem[mem[_45383] + _45383 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45383]) + _45383 + -mem[64] + 192]
                        else:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                                mem[mem[64] + 36] = 0
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4], 0, this.address
                            else:
                                _45386 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45386 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45386 + 36] = _44235
                                mem[_45386 + 68] = 0
                                mem[_45386 + 100] = this.address
                                mem[_45386 + 132] = 128
                                mem[_45386 + 164] = mem[_45386]
                                mem[_45386 + 196 len ceil32(mem[_45386])] = mem[_45386 + 32 len ceil32(mem[_45386])]
                                if ceil32(mem[_45386]) > mem[_45386]:
                                    mem[mem[_45386] + _45386 + 196] = 0
                                require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                                call address(_12179 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45386]) + _45386 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34624
                        mem[mem[64] + 64 len 32 * _34624] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34624]
                        return Array(len=_34624, data=mem[mem[64] + 64 len 32 * _34624])
                    if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                            call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44235, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34624
                            mem[mem[64] + 64 len 32 * _34624] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34624]
                            return Array(len=_34624, data=mem[mem[64] + 64 len 32 * _34624])
                        _45389 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45389 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45389 + 36] = 0
                        mem[_45389 + 68] = _44235
                        mem[_45389 + 100] = this.address
                        mem[_45389 + 132] = 128
                        mem[_45389 + 164] = mem[_45389]
                        mem[_45389 + 196 len ceil32(mem[_45389])] = mem[_45389 + 32 len ceil32(mem[_45389])]
                        if ceil32(mem[_45389]) > mem[_45389]:
                            mem[mem[_45389] + _45389 + 196] = 0
                        require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                        call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44235, address(this.address), 128, mem[_45389], mem[_45389 + 196 len ceil32(mem[_45389])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45389 + 32] = 32
                        mem[_45389 + 64] = _34624
                        mem[_45389 + 96 len 32 * _34624] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34624]
                        return memory
                          from mem[64]
                           len _45389 + (32 * _34624) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                        call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34624
                        mem[mem[64] + 64 len 32 * _34624] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34624]
                        return Array(len=_34624, data=mem[mem[64] + 64 len 32 * _34624])
                    _45392 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45392 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45392 + 36] = _44235
                    mem[_45392 + 68] = 0
                    mem[_45392 + 100] = this.address
                    mem[_45392 + 132] = 128
                    mem[_45392 + 164] = mem[_45392]
                    mem[_45392 + 196 len ceil32(mem[_45392])] = mem[_45392 + 32 len ceil32(mem[_45392])]
                    if ceil32(mem[_45392]) > mem[_45392]:
                        mem[mem[_45392] + _45392 + 196] = 0
                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44235, 0, address(this.address), 128, mem[_45392], mem[_45392 + 196 len ceil32(mem[_45392])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45392 + 32] = 32
                    mem[_45392 + 64] = _34624
                    mem[_45392 + 96 len 32 * _34624] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34624]
                    return memory
                      from mem[64]
                       len _45392 + (32 * _34624) + -mem[64] + 96
                require return_data.size >= 32
                require mem[ceil32(32 * ('cd', 4).length) + 357] == bool(mem[ceil32(32 * ('cd', 4).length) + 357])
                if not mem[ceil32(32 * ('cd', 4).length) + 357]:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 330] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 362] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 394] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326
                require return_data.size >= 32
                _34471 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 357
                _34625 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                require _34471 + (32 * _34625) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len ceil32(32 * _34625)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34471 + 358 len ceil32(32 * _34625)]
                var83002 = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * _34625) + 358
                if 1 >= _34625:
                    revert with 0, 50
                _44236 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                            call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44236, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34625
                            mem[mem[64] + 64 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                            return Array(len=_34625, data=mem[mem[64] + 64 len 32 * _34625])
                        _45395 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45395 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45395 + 36] = 0
                        mem[_45395 + 68] = _44236
                        mem[_45395 + 100] = this.address
                        mem[_45395 + 132] = 128
                        mem[_45395 + 164] = mem[_45395]
                        mem[_45395 + 196 len ceil32(mem[_45395])] = mem[_45395 + 32 len ceil32(mem[_45395])]
                        if ceil32(mem[_45395]) > mem[_45395]:
                            mem[mem[_45395] + _45395 + 196] = 0
                        require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                        call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44236, address(this.address), 128, mem[_45395], mem[_45395 + 196 len ceil32(mem[_45395])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45395 + 32] = 32
                        mem[_45395 + 64] = _34625
                        mem[_45395 + 96 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                        return memory
                          from mem[64]
                           len _45395 + (32 * _34625) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                        call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34625
                        mem[mem[64] + 64 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                        return Array(len=_34625, data=mem[mem[64] + 64 len 32 * _34625])
                    _45398 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45398 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45398 + 36] = _44236
                    mem[_45398 + 68] = 0
                    mem[_45398 + 100] = this.address
                    mem[_45398 + 132] = 128
                    mem[_45398 + 164] = mem[_45398]
                    mem[_45398 + 196 len ceil32(mem[_45398])] = mem[_45398 + 32 len ceil32(mem[_45398])]
                    if ceil32(mem[_45398]) > mem[_45398]:
                        mem[mem[_45398] + _45398 + 196] = 0
                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44236, 0, address(this.address), 128, mem[_45398], mem[_45398 + 196 len ceil32(mem[_45398])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45398 + 32] = 32
                    mem[_45398 + 64] = _34625
                    mem[_45398 + 96 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                    return memory
                      from mem[64]
                       len _45398 + (32 * _34625) + -mem[64] + 96
                if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                        call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44236, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34625
                        mem[mem[64] + 64 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                        return Array(len=_34625, data=mem[mem[64] + 64 len 32 * _34625])
                    _45401 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45401 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45401 + 36] = 0
                    mem[_45401 + 68] = _44236
                    mem[_45401 + 100] = this.address
                    mem[_45401 + 132] = 128
                    mem[_45401 + 164] = mem[_45401]
                    mem[_45401 + 196 len ceil32(mem[_45401])] = mem[_45401 + 32 len ceil32(mem[_45401])]
                    if ceil32(mem[_45401]) > mem[_45401]:
                        mem[mem[_45401] + _45401 + 196] = 0
                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44236, address(this.address), 128, mem[_45401], mem[_45401 + 196 len ceil32(mem[_45401])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45401 + 32] = 32
                    mem[_45401 + 64] = _34625
                    mem[_45401 + 96 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                    return memory
                      from mem[64]
                       len _45401 + (32 * _34625) + -mem[64] + 96
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                    call address(_12179 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _45404 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45404 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45404 + 36] = _44236
                    mem[_45404 + 68] = 0
                    mem[_45404 + 100] = this.address
                    mem[_45404 + 132] = 128
                    mem[_45404 + 164] = mem[_45404]
                    mem[_45404 + 196 len ceil32(mem[_45404])] = mem[_45404 + 32 len ceil32(mem[_45404])]
                    if ceil32(mem[_45404]) > mem[_45404]:
                        mem[mem[_45404] + _45404 + 196] = 0
                    require ext_code.size(address(_12179 xor address(cd[36]) >> 96))
                    call address(_12179 xor address(cd[36]) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45404]) + _45404 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34625
                mem[mem[64] + 64 len 32 * _34625] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34625]
                return Array(len=_34625, data=mem[mem[64] + 64 len 32 * _34625])
            mem[ceil32(32 * ('cd', 4).length) + 229] = this.address
            mem[ceil32(32 * ('cd', 4).length) + 261] = address(_12088 xor address(cd[36]) >> 96)
            staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(_12088 xor address(cd[36]) >> 96)
            mem[ceil32(32 * ('cd', 4).length) + 225] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                if cd[68]:
                    if cd[68] <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = 160
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 421
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = this.address
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 421 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225
                    require return_data.size >= 32
                    _23374 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 256
                    _23429 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                    require _23374 + (32 * _23429) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len ceil32(32 * _23429)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23374 + 257 len ceil32(32 * _23429)]
                    var71002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _23429) + 257
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[96]
                    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225
                require return_data.size >= 32
                _23390 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 256
                _23493 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                require _23390 + (32 * _23493) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len ceil32(32 * _23493)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23390 + 257 len ceil32(32 * _23493)]
                if _23493 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _23493 < 1:
                    revert with 0, 17
                if _23493 - 1 >= _23493:
                    revert with 0, 50
                if mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                    revert with 0, 17
                if not mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                    if mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, cd[36])
                    mem[mem[64] + 36] = mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _44065 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _44333 = mem[_44065]
                    require mem[_44065] <= test266151307()
                    require _44065 + return_data.size > _44065 + mem[_44065] + 31
                    _44649 = mem[_44065 + mem[_44065]]
                    if mem[_44065 + mem[_44065]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_44065 + mem[_44065]]) + 1 < 0 or _44065 + ceil32(return_data.size) + ceil32(32 * mem[_44065 + mem[_44065]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _44065 + ceil32(return_data.size) + ceil32(32 * mem[_44065 + mem[_44065]]) + 1
                    mem[_44065 + ceil32(return_data.size)] = _44649
                    require _44333 + (32 * _44649) + 32 <= return_data.size
                    mem[_44065 + ceil32(return_data.size) + 32 len ceil32(32 * _44649)] = mem[_44065 + _44333 + 32 len ceil32(32 * _44649)]
                    mem[mem[64]] = 32
                    _54537 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                    mem[mem[64] + 64 len 32 * _54537] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 32 * _54537]
                    return 32, mem[mem[64] + 32 len (32 * _54537) + 32]
                if not mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                    revert with 0, 18
                require mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] == Mask(7, 86, cd[36]) >> 86
                if mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[(32 * _23493 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _44066 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _44334 = mem[_44066]
                require mem[_44066] <= test266151307()
                require _44066 + return_data.size > _44066 + mem[_44066] + 31
                _44650 = mem[_44066 + mem[_44066]]
                if mem[_44066 + mem[_44066]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_44066 + mem[_44066]]) + 1 < 0 or _44066 + ceil32(return_data.size) + ceil32(32 * mem[_44066 + mem[_44066]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _44066 + ceil32(return_data.size) + ceil32(32 * mem[_44066 + mem[_44066]]) + 1
                mem[_44066 + ceil32(return_data.size)] = _44650
                require _44334 + (32 * _44650) + 32 <= return_data.size
                mem[_44066 + ceil32(return_data.size) + 32 len ceil32(32 * _44650)] = mem[_44066 + _44334 + 32 len ceil32(32 * _44650)]
                mem[mem[64]] = 32
                _54538 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 64 len 32 * _54538] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 32 * _54538]
                return 32, mem[mem[64] + 32 len (32 * _54538) + 32]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = this.address
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(_12088 xor address(cd[36]) >> 96)
            staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                    gas gas_remaining wei
                   args this.address, address(_12088 xor address(cd[36]) >> 96)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = address(_12088 xor address(cd[36]) >> 96)
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 68
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261 len 28] = address(_12088 xor address(cd[36]) >> 96) << 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = 32
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357] = 'SafeERC20: low-level call failed'
            if not ext_code.size(mem[ceil32(32 * ('cd', 4).length) + 173 len 20]):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 96] = approve(address arg1, uint256 arg2), address(_12088 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
            var60001 = 96
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 0
            call mem[ceil32(32 * ('cd', 4).length) + 173 len 20] with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_12088 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_12088 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not mem[96]:
                    if cd[68]:
                        if cd[68] <= 0:
                            revert with 0, 'INVALID_AOM'
                        if 1800 > !block.timestamp:
                            revert with 0, 17
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = cd[68]
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 160
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 553] = 2
                        idx = 0
                        s = ceil32(32 * ('cd', 4).length) + 161
                        t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489] = this.address
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                        call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                        require return_data.size >= 32
                        _34404 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                        require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                        require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                        _34540 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                        if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                            revert with 0, 65
                        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                        require _34404 + (32 * _34540) + 32 <= return_data.size
                        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34540)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34404 + 421 len ceil32(32 * _34540)]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = mem[96]
                        mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                        var110001 = mem[96]
                        return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = 64
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                    require return_data.size >= 32
                    _34460 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                    _34614 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    require _34460 + (32 * _34614) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34614)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34460 + 421 len ceil32(32 * _34614)]
                    if _34614 <= 0:
                        revert with 0, 'NO_OUT_AMOUNTS'
                    if _34614 < 1:
                        revert with 0, 17
                    if _34614 - 1 >= _34614:
                        revert with 0, 50
                    _44777 = mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]
                    if mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                        revert with 0, 17
                    if not mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                        if mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                            revert with 0, 17
                        if 100 * mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                            revert with 0, 17
                        require mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                        if mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                            revert with 0, 'INVALID_AOM'
                        if 1800 > !block.timestamp:
                            revert with 0, 17
                        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = Mask(85, 0, cd[36])
                        mem[mem[64] + 36] = _44777 * Mask(7, 86, cd[36]) >> 86 / 100
                        mem[mem[64] + 68] = 160
                        mem[mem[64] + 164] = 2
                        idx = 0
                        s = ceil32(32 * ('cd', 4).length) + 161
                        t = mem[64] + 196
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[mem[64] + 100] = this.address
                        mem[mem[64] + 132] = block.timestamp + 1800
                        call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args cd[36] << 171, _44777 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _54087 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _54809 = mem[_54087]
                        require mem[_54087] <= test266151307()
                        require _54087 + return_data.size > _54087 + mem[_54087] + 31
                        _54891 = mem[_54087 + mem[_54087]]
                        if mem[_54087 + mem[_54087]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_54087 + mem[_54087]]) + 1 < 0 or _54087 + ceil32(return_data.size) + ceil32(32 * mem[_54087 + mem[_54087]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _54087 + ceil32(return_data.size) + ceil32(32 * mem[_54087 + mem[_54087]]) + 1
                        mem[_54087 + ceil32(return_data.size)] = _54891
                        require _54809 + (32 * _54891) + 32 <= return_data.size
                        mem[_54087 + ceil32(return_data.size) + 32 len ceil32(32 * _54891)] = mem[_54087 + _54809 + 32 len ceil32(32 * _54891)]
                        var159002 = _54087 + ceil32(return_data.size) + ceil32(32 * _54891) + 32
                        mem[mem[64]] = 32
                        _59337 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 64 len 32 * _59337] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59337]
                        return 32, mem[mem[64] + 32 len (32 * _59337) + 32]
                    if not mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                        revert with 0, 18
                    require mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
                    if mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _34614 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, cd[36])
                    mem[mem[64] + 36] = _44777 * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, _44777 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _54088 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _54810 = mem[_54088]
                    require mem[_54088] <= test266151307()
                    require _54088 + return_data.size > _54088 + mem[_54088] + 31
                    _54892 = mem[_54088 + mem[_54088]]
                    if mem[_54088 + mem[_54088]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_54088 + mem[_54088]]) + 1 < 0 or _54088 + ceil32(return_data.size) + ceil32(32 * mem[_54088 + mem[_54088]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _54088 + ceil32(return_data.size) + ceil32(32 * mem[_54088 + mem[_54088]]) + 1
                    mem[_54088 + ceil32(return_data.size)] = _54892
                    require _54810 + (32 * _54892) + 32 <= return_data.size
                    mem[_54088 + ceil32(return_data.size) + 32 len ceil32(32 * _54892)] = mem[_54088 + _54810 + 32 len ceil32(32 * _54892)]
                    mem[mem[64]] = 32
                    _59338 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 64 len 32 * _59338] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59338]
                    return 32, mem[mem[64] + 32 len (32 * _59338) + 32]
                require mem[96] >= 32
                require ('cd', 4).length == bool(('cd', 4).length)
                if not ('cd', 4).length:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if cd[68]:
                    if cd[68] <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 160
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 553] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489] = this.address
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                    require return_data.size >= 32
                    _34405 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                    _34541 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    require _34405 + (32 * _34541) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34541)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34405 + 421 len ceil32(32 * _34541)]
                    var110002 = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * _34541) + 421
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[96]
                    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = 64
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34461 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                _34615 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                require _34461 + (32 * _34615) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34615)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34461 + 421 len ceil32(32 * _34615)]
                if _34615 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _34615 < 1:
                    revert with 0, 17
                if _34615 - 1 >= _34615:
                    revert with 0, 50
                if mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    revert with 0, 17
                if not mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    if mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, cd[36])
                    mem[mem[64] + 36] = mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _54089 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _54811 = mem[_54089]
                    require mem[_54089] <= test266151307()
                    require _54089 + return_data.size > _54089 + mem[_54089] + 31
                    _54893 = mem[_54089 + mem[_54089]]
                    if mem[_54089 + mem[_54089]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_54089 + mem[_54089]]) + 1 < 0 or _54089 + ceil32(return_data.size) + ceil32(32 * mem[_54089 + mem[_54089]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _54089 + ceil32(return_data.size) + ceil32(32 * mem[_54089 + mem[_54089]]) + 1
                    mem[_54089 + ceil32(return_data.size)] = _54893
                    require _54811 + (32 * _54893) + 32 <= return_data.size
                    mem[_54089 + ceil32(return_data.size) + 32 len ceil32(32 * _54893)] = mem[_54089 + _54811 + 32 len ceil32(32 * _54893)]
                    mem[mem[64]] = 32
                    _59339 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 64 len 32 * _59339] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59339]
                    return 32, mem[mem[64] + 32 len (32 * _59339) + 32]
                if not mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    revert with 0, 18
                require mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
                if mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[(32 * _34615 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54090 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54812 = mem[_54090]
                require mem[_54090] <= test266151307()
                require _54090 + return_data.size > _54090 + mem[_54090] + 31
                _54894 = mem[_54090 + mem[_54090]]
                if mem[_54090 + mem[_54090]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54090 + mem[_54090]]) + 1 < 0 or _54090 + ceil32(return_data.size) + ceil32(32 * mem[_54090 + mem[_54090]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54090 + ceil32(return_data.size) + ceil32(32 * mem[_54090 + mem[_54090]]) + 1
                mem[_54090 + ceil32(return_data.size)] = _54894
                require _54812 + (32 * _54894) + 32 <= return_data.size
                mem[_54090 + ceil32(return_data.size) + 32 len ceil32(32 * _54894)] = mem[_54090 + _54812 + 32 len ceil32(32 * _54894)]
                mem[mem[64]] = 32
                _59340 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59340] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59340]
                return 32, mem[mem[64] + 32 len (32 * _59340) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if not return_data.size:
                if cd[68]:
                    if cd[68] <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    require return_data.size >= 32
                    _34406 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
                    _34542 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                    require _34406 + (32 * _34542) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34542)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34406 + 422 len ceil32(32 * _34542)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[96]
                    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                    var110001 = mem[96]
                    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                require return_data.size >= 32
                _34462 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
                _34616 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                require _34462 + (32 * _34616) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34616)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34462 + 422 len ceil32(32 * _34616)]
                if _34616 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _34616 < 1:
                    revert with 0, 17
                if _34616 - 1 >= _34616:
                    revert with 0, 50
                if mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                    revert with 0, 17
                if not mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                    if mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, cd[36])
                    mem[mem[64] + 36] = mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _54091 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _54813 = mem[_54091]
                    require mem[_54091] <= test266151307()
                    require _54091 + return_data.size > _54091 + mem[_54091] + 31
                    _54895 = mem[_54091 + mem[_54091]]
                    if mem[_54091 + mem[_54091]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_54091 + mem[_54091]]) + 1 < 0 or _54091 + ceil32(return_data.size) + ceil32(32 * mem[_54091 + mem[_54091]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _54091 + ceil32(return_data.size) + ceil32(32 * mem[_54091 + mem[_54091]]) + 1
                    mem[_54091 + ceil32(return_data.size)] = _54895
                    require _54813 + (32 * _54895) + 32 <= return_data.size
                    mem[_54091 + ceil32(return_data.size) + 32 len ceil32(32 * _54895)] = mem[_54091 + _54813 + 32 len ceil32(32 * _54895)]
                    var159002 = _54091 + ceil32(return_data.size) + ceil32(32 * _54895) + 32
                    mem[mem[64]] = 32
                    _59341 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 64 len 32 * _59341] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59341]
                    return 32, mem[mem[64] + 32 len (32 * _59341) + 32]
                if not mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                    revert with 0, 18
                require mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
                if mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _34616 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54092 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54814 = mem[_54092]
                require mem[_54092] <= test266151307()
                require _54092 + return_data.size > _54092 + mem[_54092] + 31
                _54896 = mem[_54092 + mem[_54092]]
                if mem[_54092 + mem[_54092]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54092 + mem[_54092]]) + 1 < 0 or _54092 + ceil32(return_data.size) + ceil32(32 * mem[_54092 + mem[_54092]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54092 + ceil32(return_data.size) + ceil32(32 * mem[_54092 + mem[_54092]]) + 1
                mem[_54092 + ceil32(return_data.size)] = _54896
                require _54814 + (32 * _54896) + 32 <= return_data.size
                mem[_54092 + ceil32(return_data.size) + 32 len ceil32(32 * _54896)] = mem[_54092 + _54814 + 32 len ceil32(32 * _54896)]
                mem[mem[64]] = 32
                _59342 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 64 len 32 * _59342] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59342]
                return 32, mem[mem[64] + 32 len (32 * _59342) + 32]
            require return_data.size >= 32
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421] == bool(mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421])
            if not mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
                call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                require return_data.size >= 32
                _34407 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
                _34543 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                require _34407 + (32 * _34543) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34543)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34407 + 422 len ceil32(32 * _34543)]
                var110002 = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34543) + 422
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12088 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34463 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
            _34617 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            require _34463 + (32 * _34617) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34617)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34463 + 422 len ceil32(32 * _34617)]
            if _34617 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34617 < 1:
                revert with 0, 17
            if _34617 - 1 >= _34617:
                revert with 0, 50
            if mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 17
            if not mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                if mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54093 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54815 = mem[_54093]
                require mem[_54093] <= test266151307()
                require _54093 + return_data.size > _54093 + mem[_54093] + 31
                _54897 = mem[_54093 + mem[_54093]]
                if mem[_54093 + mem[_54093]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54093 + mem[_54093]]) + 1 < 0 or _54093 + ceil32(return_data.size) + ceil32(32 * mem[_54093 + mem[_54093]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54093 + ceil32(return_data.size) + ceil32(32 * mem[_54093 + mem[_54093]]) + 1
                mem[_54093 + ceil32(return_data.size)] = _54897
                require _54815 + (32 * _54897) + 32 <= return_data.size
                mem[_54093 + ceil32(return_data.size) + 32 len ceil32(32 * _54897)] = mem[_54093 + _54815 + 32 len ceil32(32 * _54897)]
                mem[mem[64]] = 32
                _59343 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 64 len 32 * _59343] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59343]
                return 32, mem[mem[64] + 32 len (32 * _59343) + 32]
            if not mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 18
            require mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, cd[36])
            mem[mem[64] + 36] = mem[(32 * _34617 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12088 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54094 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54816 = mem[_54094]
            require mem[_54094] <= test266151307()
            require _54094 + return_data.size > _54094 + mem[_54094] + 31
            _54898 = mem[_54094 + mem[_54094]]
            if mem[_54094 + mem[_54094]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54094 + mem[_54094]]) + 1 < 0 or _54094 + ceil32(return_data.size) + ceil32(32 * mem[_54094 + mem[_54094]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54094 + ceil32(return_data.size) + ceil32(32 * mem[_54094 + mem[_54094]]) + 1
            mem[_54094 + ceil32(return_data.size)] = _54898
            require _54816 + (32 * _54898) + 32 <= return_data.size
            mem[_54094 + ceil32(return_data.size) + 32 len ceil32(32 * _54898)] = mem[_54094 + _54816 + 32 len ceil32(32 * _54898)]
            mem[mem[64]] = 32
            _59344 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59344] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59344]
            return 32, mem[mem[64] + 32 len (32 * _59344) + 32]
        mem[ceil32(32 * ('cd', 4).length) + 229] = this.address
        staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(32 * ('cd', 4).length) + 225] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0, 'NO_IN'
        if 3 >= ('cd', 4).length:
            revert with 0, 50
        _12316 = mem[256]
        if 1 == Mask(1, 94, cd[36]) >> 94:
            if 2 >= ('cd', 4).length:
                revert with 0, 50
            _12345 = mem[224]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(mem[224] xor address(cd[36]) >> 96)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 68
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 257 len 4] = unknown_0xa9059cbb(?????)
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 96] = 0, mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261], ext_call.return_data[0], mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 28]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 0
            call mem[ceil32(32 * ('cd', 4).length) + 173 len 20].mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not mem[96]:
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329] = ext_call.return_data[0]
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 361] = 64
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
                    require return_data.size >= 32
                    _34485 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 356
                    _34639 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                    require _34485 + (32 * _34639) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len ceil32(32 * _34639)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34485 + 357 len ceil32(32 * _34639)]
                    var83002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _34639) + 357
                    if 1 >= _34639:
                        revert with 0, 50
                    _44265 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] < cd[68]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                                call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44265, this.address
                            else:
                                _45455 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45455 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45455 + 36] = 0
                                mem[_45455 + 68] = _44265
                                mem[_45455 + 100] = this.address
                                mem[_45455 + 132] = 128
                                mem[_45455 + 164] = mem[_45455]
                                mem[_45455 + 196 len ceil32(mem[_45455])] = mem[_45455 + 32 len ceil32(mem[_45455])]
                                if ceil32(mem[_45455]) > mem[_45455]:
                                    mem[mem[_45455] + _45455 + 196] = 0
                                require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                                call address(_12345 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45455]) + _45455 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34639
                            mem[mem[64] + 64 len 32 * _34639] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34639]
                            return Array(len=_34639, data=mem[mem[64] + 64 len 32 * _34639])
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34639
                            mem[mem[64] + 64 len 32 * _34639] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34639]
                            return Array(len=_34639, data=mem[mem[64] + 64 len 32 * _34639])
                        _45458 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45458 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45458 + 36] = _44265
                        mem[_45458 + 68] = 0
                        mem[_45458 + 100] = this.address
                        mem[_45458 + 132] = 128
                        mem[_45458 + 164] = mem[_45458]
                        mem[_45458 + 196 len ceil32(mem[_45458])] = mem[_45458 + 32 len ceil32(mem[_45458])]
                        if ceil32(mem[_45458]) > mem[_45458]:
                            mem[mem[_45458] + _45458 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44265, 0, address(this.address), 128, mem[_45458], mem[_45458 + 196 len ceil32(mem[_45458])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45458 + 32] = 32
                        mem[_45458 + 64] = _34639
                        mem[_45458 + 96 len 32 * _34639] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34639]
                        return memory
                          from mem[64]
                           len _45458 + (32 * _34639) + -mem[64] + 96
                    if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44265, this.address
                        else:
                            _45461 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45461 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45461 + 36] = 0
                            mem[_45461 + 68] = _44265
                            mem[_45461 + 100] = this.address
                            mem[_45461 + 132] = 128
                            mem[_45461 + 164] = mem[_45461]
                            mem[_45461 + 196 len ceil32(mem[_45461])] = mem[_45461 + 32 len ceil32(mem[_45461])]
                            if ceil32(mem[_45461]) > mem[_45461]:
                                mem[mem[_45461] + _45461 + 196] = 0
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45461]) + _45461 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _45464 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45464 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45464 + 36] = _44265
                            mem[_45464 + 68] = 0
                            mem[_45464 + 100] = this.address
                            mem[_45464 + 132] = 128
                            mem[_45464 + 164] = mem[_45464]
                            mem[_45464 + 196 len ceil32(mem[_45464])] = mem[_45464 + 32 len ceil32(mem[_45464])]
                            if ceil32(mem[_45464]) > mem[_45464]:
                                mem[mem[_45464] + _45464 + 196] = 0
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45464]) + _45464 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34639
                    mem[mem[64] + 64 len 32 * _34639] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34639]
                    return Array(len=_34639, data=mem[mem[64] + 64 len 32 * _34639])
                require mem[96] >= 32
                require ('cd', 4).length == bool(('cd', 4).length)
                if not ('cd', 4).length:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 361] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
                require return_data.size >= 32
                _34486 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 356
                _34640 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                require _34486 + (32 * _34640) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len ceil32(32 * _34640)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34486 + 357 len ceil32(32 * _34640)]
                var89002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _34640) + 357
                if 1 >= _34640:
                    revert with 0, 50
                _44266 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44266, this.address
                        else:
                            _45467 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45467 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45467 + 36] = 0
                            mem[_45467 + 68] = _44266
                            mem[_45467 + 100] = this.address
                            mem[_45467 + 132] = 128
                            mem[_45467 + 164] = mem[_45467]
                            mem[_45467 + 196 len ceil32(mem[_45467])] = mem[_45467 + 32 len ceil32(mem[_45467])]
                            if ceil32(mem[_45467]) > mem[_45467]:
                                mem[mem[_45467] + _45467 + 196] = 0
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45467]) + _45467 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34640
                        mem[mem[64] + 64 len 32 * _34640] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34640]
                        return Array(len=_34640, data=mem[mem[64] + 64 len 32 * _34640])
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34640
                        mem[mem[64] + 64 len 32 * _34640] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34640]
                        return Array(len=_34640, data=mem[mem[64] + 64 len 32 * _34640])
                    _45470 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45470 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45470 + 36] = _44266
                    mem[_45470 + 68] = 0
                    mem[_45470 + 100] = this.address
                    mem[_45470 + 132] = 128
                    mem[_45470 + 164] = mem[_45470]
                    mem[_45470 + 196 len ceil32(mem[_45470])] = mem[_45470 + 32 len ceil32(mem[_45470])]
                    if ceil32(mem[_45470]) > mem[_45470]:
                        mem[mem[_45470] + _45470 + 196] = 0
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44266, 0, address(this.address), 128, mem[_45470], mem[_45470 + 196 len ceil32(mem[_45470])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45470 + 32] = 32
                    mem[_45470 + 64] = _34640
                    mem[_45470 + 96 len 32 * _34640] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34640]
                    return memory
                      from mem[64]
                       len _45470 + (32 * _34640) + -mem[64] + 96
                if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44266, this.address
                    else:
                        _45473 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45473 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45473 + 36] = 0
                        mem[_45473 + 68] = _44266
                        mem[_45473 + 100] = this.address
                        mem[_45473 + 132] = 128
                        mem[_45473 + 164] = mem[_45473]
                        mem[_45473 + 196 len ceil32(mem[_45473])] = mem[_45473 + 32 len ceil32(mem[_45473])]
                        if ceil32(mem[_45473]) > mem[_45473]:
                            mem[mem[_45473] + _45473 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45473]) + _45473 + -mem[64] + 192]
                else:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45476 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45476 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45476 + 36] = _44266
                        mem[_45476 + 68] = 0
                        mem[_45476 + 100] = this.address
                        mem[_45476 + 132] = 128
                        mem[_45476 + 164] = mem[_45476]
                        mem[_45476 + 196 len ceil32(mem[_45476])] = mem[_45476 + 32 len ceil32(mem[_45476])]
                        if ceil32(mem[_45476]) > mem[_45476]:
                            mem[mem[_45476] + _45476 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45476]) + _45476 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34640
                mem[mem[64] + 64 len 32 * _34640] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34640]
                return Array(len=_34640, data=mem[mem[64] + 64 len 32 * _34640])
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = return_data.size
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not return_data.size:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 394] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
                require return_data.size >= 32
                _34487 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 357
                _34641 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = _34641
                require _34487 + (32 * _34641) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len ceil32(32 * _34641)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + _34487 + 358 len ceil32(32 * _34641)]
                var83002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34641) + 358
                if 1 >= _34641:
                    revert with 0, 50
                _44267 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44267, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34641
                            mem[mem[64] + 64 len 32 * _34641] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34641]
                            return Array(len=_34641, data=mem[mem[64] + 64 len 32 * _34641])
                        _45479 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45479 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45479 + 36] = 0
                        mem[_45479 + 68] = _44267
                        mem[_45479 + 100] = this.address
                        mem[_45479 + 132] = 128
                        mem[_45479 + 164] = mem[_45479]
                        mem[_45479 + 196 len ceil32(mem[_45479])] = mem[_45479 + 32 len ceil32(mem[_45479])]
                        if ceil32(mem[_45479]) > mem[_45479]:
                            mem[mem[_45479] + _45479 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44267, address(this.address), 128, mem[_45479], mem[_45479 + 196 len ceil32(mem[_45479])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45479 + 32] = 32
                        mem[_45479 + 64] = _34641
                        mem[_45479 + 96 len 32 * _34641] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34641]
                        return memory
                          from mem[64]
                           len _45479 + (32 * _34641) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45482 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45482 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45482 + 36] = _44267
                        mem[_45482 + 68] = 0
                        mem[_45482 + 100] = this.address
                        mem[_45482 + 132] = 128
                        mem[_45482 + 164] = mem[_45482]
                        mem[_45482 + 196 len ceil32(mem[_45482])] = mem[_45482 + 32 len ceil32(mem[_45482])]
                        if ceil32(mem[_45482]) > mem[_45482]:
                            mem[mem[_45482] + _45482 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45482]) + _45482 + -mem[64] + 192]
                else:
                    if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                            call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44267, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34641
                            mem[mem[64] + 64 len 32 * _34641] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34641]
                            return Array(len=_34641, data=mem[mem[64] + 64 len 32 * _34641])
                        _45485 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45485 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45485 + 36] = 0
                        mem[_45485 + 68] = _44267
                        mem[_45485 + 100] = this.address
                        mem[_45485 + 132] = 128
                        mem[_45485 + 164] = mem[_45485]
                        mem[_45485 + 196 len ceil32(mem[_45485])] = mem[_45485 + 32 len ceil32(mem[_45485])]
                        if ceil32(mem[_45485]) > mem[_45485]:
                            mem[mem[_45485] + _45485 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44267, address(this.address), 128, mem[_45485], mem[_45485 + 196 len ceil32(mem[_45485])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45485 + 32] = 32
                        mem[_45485 + 64] = _34641
                        mem[_45485 + 96 len 32 * _34641] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34641]
                        return memory
                          from mem[64]
                           len _45485 + (32 * _34641) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45488 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45488 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45488 + 36] = _44267
                        mem[_45488 + 68] = 0
                        mem[_45488 + 100] = this.address
                        mem[_45488 + 132] = 128
                        mem[_45488 + 164] = mem[_45488]
                        mem[_45488 + 196 len ceil32(mem[_45488])] = mem[_45488 + 32 len ceil32(mem[_45488])]
                        if ceil32(mem[_45488]) > mem[_45488]:
                            mem[mem[_45488] + _45488 + 196] = 0
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45488]) + _45488 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34641
                mem[mem[64] + 64 len 32 * _34641] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34641]
                return Array(len=_34641, data=mem[mem[64] + 64 len 32 * _34641])
            require return_data.size >= 32
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357] == bool(mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357])
            if not mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 64
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 394] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
            require return_data.size >= 32
            _34488 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 357
            _34642 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = _34642
            require _34488 + (32 * _34642) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len ceil32(32 * _34642)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + _34488 + 358 len ceil32(32 * _34642)]
            var89002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34642) + 358
            if 1 >= _34642:
                revert with 0, 50
            _44268 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] < cd[68]:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                        call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44268, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34642
                        mem[mem[64] + 64 len 32 * _34642] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34642]
                        return Array(len=_34642, data=mem[mem[64] + 64 len 32 * _34642])
                    _45491 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45491 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45491 + 36] = 0
                    mem[_45491 + 68] = _44268
                    mem[_45491 + 100] = this.address
                    mem[_45491 + 132] = 128
                    mem[_45491 + 164] = mem[_45491]
                    mem[_45491 + 196 len ceil32(mem[_45491])] = mem[_45491 + 32 len ceil32(mem[_45491])]
                    if ceil32(mem[_45491]) > mem[_45491]:
                        mem[mem[_45491] + _45491 + 196] = 0
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44268, address(this.address), 128, mem[_45491], mem[_45491 + 196 len ceil32(mem[_45491])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45491 + 32] = 32
                    mem[_45491 + 64] = _34642
                    mem[_45491 + 96 len 32 * _34642] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34642]
                    return memory
                      from mem[64]
                       len _45491 + (32 * _34642) + -mem[64] + 96
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34642
                    mem[mem[64] + 64 len 32 * _34642] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34642]
                    return Array(len=_34642, data=mem[mem[64] + 64 len 32 * _34642])
                _45494 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45494 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45494 + 36] = _44268
                mem[_45494 + 68] = 0
                mem[_45494 + 100] = this.address
                mem[_45494 + 132] = 128
                mem[_45494 + 164] = mem[_45494]
                mem[_45494 + 196 len ceil32(mem[_45494])] = mem[_45494 + 32 len ceil32(mem[_45494])]
                if ceil32(mem[_45494]) > mem[_45494]:
                    mem[mem[_45494] + _45494 + 196] = 0
                require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44268, 0, address(this.address), 128, mem[_45494], mem[_45494 + 196 len ceil32(mem[_45494])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45494 + 32] = 32
                mem[_45494 + 64] = _34642
                mem[_45494 + 96 len 32 * _34642] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34642]
                return memory
                  from mem[64]
                   len _45494 + (32 * _34642) + -mem[64] + 96
            if not mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 205 len 20]:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44268, this.address
                else:
                    _45497 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45497 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45497 + 36] = 0
                    mem[_45497 + 68] = _44268
                    mem[_45497 + 100] = this.address
                    mem[_45497 + 132] = 128
                    mem[_45497 + 164] = mem[_45497]
                    mem[_45497 + 196 len ceil32(mem[_45497])] = mem[_45497 + 32 len ceil32(mem[_45497])]
                    if ceil32(mem[_45497]) > mem[_45497]:
                        mem[mem[_45497] + _45497 + 196] = 0
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45497]) + _45497 + -mem[64] + 192]
            else:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _45500 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45500 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45500 + 36] = _44268
                    mem[_45500 + 68] = 0
                    mem[_45500 + 100] = this.address
                    mem[_45500 + 132] = 128
                    mem[_45500 + 164] = mem[_45500]
                    mem[_45500 + 196 len ceil32(mem[_45500])] = mem[_45500 + 32 len ceil32(mem[_45500])]
                    if ceil32(mem[_45500]) > mem[_45500]:
                        mem[mem[_45500] + _45500 + 196] = 0
                    require ext_code.size(address(_12345 xor address(cd[36]) >> 96))
                    call address(_12345 xor address(cd[36]) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45500]) + _45500 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34642
            mem[mem[64] + 64 len 32 * _34642] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34642]
            return Array(len=_34642, data=mem[mem[64] + 64 len 32 * _34642])
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(_12316 xor address(cd[36]) >> 96)
        staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_12316 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 160
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225
                require return_data.size >= 32
                _23375 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256
                _23442 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
                require _23375 + (32 * _23442) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len ceil32(32 * _23442)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _23375 + 257 len ceil32(32 * _23442)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225
            require return_data.size >= 32
            _23395 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256
            _23506 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
            require _23395 + (32 * _23506) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len ceil32(32 * _23506)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _23395 + 257 len ceil32(32 * _23506)]
            if _23506 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _23506 < 1:
                revert with 0, 17
            if _23506 - 1 >= _23506:
                revert with 0, 50
            if mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
                revert with 0, 17
            if not mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
                if mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _44091 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _44359 = mem[_44091]
                require mem[_44091] <= test266151307()
                require _44091 + return_data.size > _44091 + mem[_44091] + 31
                _44675 = mem[_44091 + mem[_44091]]
                if mem[_44091 + mem[_44091]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_44091 + mem[_44091]]) + 1 < 0 or _44091 + ceil32(return_data.size) + ceil32(32 * mem[_44091 + mem[_44091]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _44091 + ceil32(return_data.size) + ceil32(32 * mem[_44091 + mem[_44091]]) + 1
                mem[_44091 + ceil32(return_data.size)] = _44675
                require _44359 + (32 * _44675) + 32 <= return_data.size
                mem[_44091 + ceil32(return_data.size) + 32 len ceil32(32 * _44675)] = mem[_44091 + _44359 + 32 len ceil32(32 * _44675)]
                mem[mem[64]] = 32
                _54603 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 64 len 32 * _54603] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 32 * _54603]
                return 32, mem[mem[64] + 32 len (32 * _54603) + 32]
            if not mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
                revert with 0, 18
            require mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _23506 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _44092 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44360 = mem[_44092]
            require mem[_44092] <= test266151307()
            require _44092 + return_data.size > _44092 + mem[_44092] + 31
            _44676 = mem[_44092 + mem[_44092]]
            if mem[_44092 + mem[_44092]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_44092 + mem[_44092]]) + 1 < 0 or _44092 + ceil32(return_data.size) + ceil32(32 * mem[_44092 + mem[_44092]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _44092 + ceil32(return_data.size) + ceil32(32 * mem[_44092 + mem[_44092]]) + 1
            mem[_44092 + ceil32(return_data.size)] = _44676
            require _44360 + (32 * _44676) + 32 <= return_data.size
            mem[_44092 + ceil32(return_data.size) + 32 len ceil32(32 * _44676)] = mem[_44092 + _44360 + 32 len ceil32(32 * _44676)]
            mem[mem[64]] = 32
            _54604 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 64 len 32 * _54604] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 32 * _54604]
            return 32, mem[mem[64] + 32 len (32 * _54604) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = this.address
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = address(_12316 xor address(cd[36]) >> 96)
        staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_12316 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261] = address(_12316 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = 68
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 28] = address(_12316 xor address(cd[36]) >> 96) << 64
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 4] = approve(address arg1, uint256 arg2)
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 325] = 32
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 357] = 'SafeERC20: low-level call failed'
        if not ext_code.size(mem[ceil32(32 * ('cd', 4).length) + 173 len 20]):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 96] = approve(address arg1, uint256 arg2), address(_12316 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 0
        call mem[ceil32(32 * ('cd', 4).length) + 173 len 20] with:
           funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_12316 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_12316 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if not mem[96]:
                if cd[68]:
                    if cd[68] <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 160
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 553] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489] = this.address
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                    call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
                    require return_data.size >= 32
                    _34413 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
                    _34550 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34550
                    require _34413 + (32 * _34550) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34550)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34413 + 421 len ceil32(32 * _34550)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[96]
                    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                    var116001 = mem[96]
                    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = 64
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34477 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
                _34631 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34631
                require _34477 + (32 * _34631) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34631)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34477 + 421 len ceil32(32 * _34631)]
                if _34631 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _34631 < 1:
                    revert with 0, 17
                if _34631 - 1 >= _34631:
                    revert with 0, 50
                if mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                    revert with 0, 17
                if not mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                    if mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    mem[mem[64] + 36] = mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _54105 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _54825 = mem[_54105]
                    require mem[_54105] <= test266151307()
                    require _54105 + return_data.size > _54105 + mem[_54105] + 31
                    _54909 = mem[_54105 + mem[_54105]]
                    if mem[_54105 + mem[_54105]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_54105 + mem[_54105]]) + 1 < 0 or _54105 + ceil32(return_data.size) + ceil32(32 * mem[_54105 + mem[_54105]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _54105 + ceil32(return_data.size) + ceil32(32 * mem[_54105 + mem[_54105]]) + 1
                    mem[_54105 + ceil32(return_data.size)] = _54909
                    require _54825 + (32 * _54909) + 32 <= return_data.size
                    mem[_54105 + ceil32(return_data.size) + 32 len ceil32(32 * _54909)] = mem[_54105 + _54825 + 32 len ceil32(32 * _54909)]
                    mem[mem[64]] = 32
                    _59353 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 64 len 32 * _59353] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59353]
                    return 32, mem[mem[64] + 32 len (32 * _59353) + 32]
                if not mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                    revert with 0, 18
                require mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
                if mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[(32 * _34631 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54106 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54826 = mem[_54106]
                require mem[_54106] <= test266151307()
                require _54106 + return_data.size > _54106 + mem[_54106] + 31
                _54910 = mem[_54106 + mem[_54106]]
                if mem[_54106 + mem[_54106]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54106 + mem[_54106]]) + 1 < 0 or _54106 + ceil32(return_data.size) + ceil32(32 * mem[_54106 + mem[_54106]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54106 + ceil32(return_data.size) + ceil32(32 * mem[_54106 + mem[_54106]]) + 1
                mem[_54106 + ceil32(return_data.size)] = _54910
                require _54826 + (32 * _54910) + 32 <= return_data.size
                mem[_54106 + ceil32(return_data.size) + 32 len ceil32(32 * _54910)] = mem[_54106 + _54826 + 32 len ceil32(32 * _54910)]
                mem[mem[64]] = 32
                _59354 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59354] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59354]
                return 32, mem[mem[64] + 32 len (32 * _59354) + 32]
            require mem[96] >= 32
            require ('cd', 4).length == bool(('cd', 4).length)
            if not ('cd', 4).length:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 160
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 553] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34414 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
                _34551 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34551
                require _34414 + (32 * _34551) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34551)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34414 + 421 len ceil32(32 * _34551)]
                var116002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * _34551) + 421
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = 64
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
            require return_data.size >= 32
            _34478 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
            _34632 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34632
            require _34478 + (32 * _34632) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34632)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34478 + 421 len ceil32(32 * _34632)]
            var114002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * _34632) + 421
            if _34632 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34632 < 1:
                revert with 0, 17
            if _34632 - 1 >= _34632:
                revert with 0, 50
            _44786 = mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]
            if mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                revert with 0, 17
            if not mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                if mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = _44786 * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], _44786 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54107 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54827 = mem[_54107]
                require mem[_54107] <= test266151307()
                require _54107 + return_data.size > _54107 + mem[_54107] + 31
                _54911 = mem[_54107 + mem[_54107]]
                if mem[_54107 + mem[_54107]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54107 + mem[_54107]]) + 1 < 0 or _54107 + ceil32(return_data.size) + ceil32(32 * mem[_54107 + mem[_54107]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54107 + ceil32(return_data.size) + ceil32(32 * mem[_54107 + mem[_54107]]) + 1
                mem[_54107 + ceil32(return_data.size)] = _54911
                require _54827 + (32 * _54911) + 32 <= return_data.size
                mem[_54107 + ceil32(return_data.size) + 32 len ceil32(32 * _54911)] = mem[_54107 + _54827 + 32 len ceil32(32 * _54911)]
                mem[mem[64]] = 32
                _59355 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59355] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59355]
                return 32, mem[mem[64] + 32 len (32 * _59355) + 32]
            if not mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                revert with 0, 18
            require mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34632 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = _44786 * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _44786 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54108 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54828 = mem[_54108]
            require mem[_54108] <= test266151307()
            require _54108 + return_data.size > _54108 + mem[_54108] + 31
            _54912 = mem[_54108 + mem[_54108]]
            if mem[_54108 + mem[_54108]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54108 + mem[_54108]]) + 1 < 0 or _54108 + ceil32(return_data.size) + ceil32(32 * mem[_54108 + mem[_54108]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54108 + ceil32(return_data.size) + ceil32(32 * mem[_54108 + mem[_54108]]) + 1
            mem[_54108 + ceil32(return_data.size)] = _54912
            require _54828 + (32 * _54912) + 32 <= return_data.size
            mem[_54108 + ceil32(return_data.size) + 32 len ceil32(32 * _54912)] = mem[_54108 + _54828 + 32 len ceil32(32 * _54912)]
            mem[mem[64]] = 32
            _59356 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 64 len 32 * _59356] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59356]
            return 32, mem[mem[64] + 32 len (32 * _59356) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if not return_data.size:
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                require return_data.size >= 32
                _34415 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
                _34552 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
                require _34415 + (32 * _34552) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34552)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34415 + 422 len ceil32(32 * _34552)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                var116001 = mem[96]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34479 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
            _34633 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            require _34479 + (32 * _34633) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34633)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34479 + 422 len ceil32(32 * _34633)]
            if _34633 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34633 < 1:
                revert with 0, 17
            if _34633 - 1 >= _34633:
                revert with 0, 50
            if mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 17
            if not mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                if mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54109 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54829 = mem[_54109]
                require mem[_54109] <= test266151307()
                require _54109 + return_data.size > _54109 + mem[_54109] + 31
                _54913 = mem[_54109 + mem[_54109]]
                if mem[_54109 + mem[_54109]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54109 + mem[_54109]]) + 1 < 0 or _54109 + ceil32(return_data.size) + ceil32(32 * mem[_54109 + mem[_54109]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54109 + ceil32(return_data.size) + ceil32(32 * mem[_54109 + mem[_54109]]) + 1
                mem[_54109 + ceil32(return_data.size)] = _54913
                require _54829 + (32 * _54913) + 32 <= return_data.size
                mem[_54109 + ceil32(return_data.size) + 32 len ceil32(32 * _54913)] = mem[_54109 + _54829 + 32 len ceil32(32 * _54913)]
                mem[mem[64]] = 32
                _59357 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 64 len 32 * _59357] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59357]
                return 32, mem[mem[64] + 32 len (32 * _59357) + 32]
            if not mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 18
            require mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _34633 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54110 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54830 = mem[_54110]
            require mem[_54110] <= test266151307()
            require _54110 + return_data.size > _54110 + mem[_54110] + 31
            _54914 = mem[_54110 + mem[_54110]]
            if mem[_54110 + mem[_54110]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54110 + mem[_54110]]) + 1 < 0 or _54110 + ceil32(return_data.size) + ceil32(32 * mem[_54110 + mem[_54110]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54110 + ceil32(return_data.size) + ceil32(32 * mem[_54110 + mem[_54110]]) + 1
            mem[_54110 + ceil32(return_data.size)] = _54914
            require _54830 + (32 * _54914) + 32 <= return_data.size
            mem[_54110 + ceil32(return_data.size) + 32 len ceil32(32 * _54914)] = mem[_54110 + _54830 + 32 len ceil32(32 * _54914)]
            mem[mem[64]] = 32
            _59358 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59358] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59358]
            return 32, mem[mem[64] + 32 len (32 * _59358) + 32]
        require return_data.size >= 32
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == bool(mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421])
        if not mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
            call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34416 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
            _34553 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            require _34416 + (32 * _34553) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34553)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34416 + 422 len ceil32(32 * _34553)]
            var116002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34553) + 422
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[96]
            mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12316 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
        require return_data.size >= 32
        _34480 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
        _34634 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        require _34480 + (32 * _34634) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34634)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34480 + 422 len ceil32(32 * _34634)]
        var114002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34634) + 422
        if _34634 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _34634 < 1:
            revert with 0, 17
        if _34634 - 1 >= _34634:
            revert with 0, 50
        if mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 17
        if not mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            if mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54111 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54831 = mem[_54111]
            require mem[_54111] <= test266151307()
            require _54111 + return_data.size > _54111 + mem[_54111] + 31
            _54915 = mem[_54111 + mem[_54111]]
            if mem[_54111 + mem[_54111]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54111 + mem[_54111]]) + 1 < 0 or _54111 + ceil32(return_data.size) + ceil32(32 * mem[_54111 + mem[_54111]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54111 + ceil32(return_data.size) + ceil32(32 * mem[_54111 + mem[_54111]]) + 1
            mem[_54111 + ceil32(return_data.size)] = _54915
            require _54831 + (32 * _54915) + 32 <= return_data.size
            mem[_54111 + ceil32(return_data.size) + 32 len ceil32(32 * _54915)] = mem[_54111 + _54831 + 32 len ceil32(32 * _54915)]
            mem[mem[64]] = 32
            _59359 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59359] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59359]
            return 32, mem[mem[64] + 32 len (32 * _59359) + 32]
        if not mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 18
        require mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
        if mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _34634 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12316 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _54112 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _54832 = mem[_54112]
        require mem[_54112] <= test266151307()
        require _54112 + return_data.size > _54112 + mem[_54112] + 31
        _54916 = mem[_54112 + mem[_54112]]
        if mem[_54112 + mem[_54112]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_54112 + mem[_54112]]) + 1 < 0 or _54112 + ceil32(return_data.size) + ceil32(32 * mem[_54112 + mem[_54112]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _54112 + ceil32(return_data.size) + ceil32(32 * mem[_54112 + mem[_54112]]) + 1
        mem[_54112 + ceil32(return_data.size)] = _54916
        require _54832 + (32 * _54916) + 32 <= return_data.size
        mem[_54112 + ceil32(return_data.size) + 32 len ceil32(32 * _54916)] = mem[_54112 + _54832 + 32 len ceil32(32 * _54916)]
        mem[mem[64]] = 32
        _59360 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 64 len 32 * _59360] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59360]
        return 32, mem[mem[64] + 32 len (32 * _59360) + 32]
    if 1 >= ('cd', 4).length:
        revert with 0, 50
    mem[ceil32(32 * ('cd', 4).length) + 161] = address(mem[192] xor address(cd[36]) >> 96)
    if 0 >= ('cd', 4).length:
        revert with 0, 50
    mem[ceil32(32 * ('cd', 4).length) + 193] = address(mem[160] xor address(cd[36]) >> 96)
    if Mask(85, 0, cd[36]):
        if Mask(85, 0, cd[36]) <= 0:
            revert with 0, 'NO_IN'
        if 3 >= ('cd', 4).length:
            revert with 0, 50
        _12091 = mem[256]
        if 1 == Mask(1, 94, cd[36]) >> 94:
            if 2 >= ('cd', 4).length:
                revert with 0, 50
            _12183 = mem[224]
            mem[ceil32(32 * ('cd', 4).length) + 261] = address(mem[224] xor address(cd[36]) >> 96)
            mem[ceil32(32 * ('cd', 4).length) + 293] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + 225] = 68
            mem[ceil32(32 * ('cd', 4).length) + 257 len 4] = unknown_0xa9059cbb(?????)
            mem[ceil32(32 * ('cd', 4).length) + 325 len 96] = 0, mem[ceil32(32 * ('cd', 4).length) + 261], cd[36] << 171, mem[ceil32(32 * ('cd', 4).length) + 325 len 28]
            mem[ceil32(32 * ('cd', 4).length) + 393] = 0
            call mem[ceil32(32 * ('cd', 4).length) + 173 len 20].mem[ceil32(32 * ('cd', 4).length) + 325 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(32 * ('cd', 4).length) + 329 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'TRANSFER_FAILED'
                if not mem[96]:
                    mem[ceil32(32 * ('cd', 4).length) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + 329] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + 361] = 64
                    mem[ceil32(32 * ('cd', 4).length) + 393] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + 425
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + 425 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
                    require return_data.size >= 32
                    _34502 = mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 356
                    _34656 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                    if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                    require _34502 + (32 * _34656) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len ceil32(32 * _34656)] = mem[ceil32(32 * ('cd', 4).length) + _34502 + 357 len ceil32(32 * _34656)]
                    if 1 >= _34656:
                        revert with 0, 50
                    _44297 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] < cd[68]:
                        revert with 0, 'INSUFFICIENT_OUT'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                            if Mask(1, 93, cd[36]) >> 93 != 1:
                                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                                mem[mem[64] + 68] = this.address
                                require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                                call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                     gas gas_remaining wei
                                    args 0, _44297, this.address
                            else:
                                _45551 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_45551 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_45551 + 36] = 0
                                mem[_45551 + 68] = _44297
                                mem[_45551 + 100] = this.address
                                mem[_45551 + 132] = 128
                                mem[_45551 + 164] = mem[_45551]
                                mem[_45551 + 196 len ceil32(mem[_45551])] = mem[_45551 + 32 len ceil32(mem[_45551])]
                                if ceil32(mem[_45551]) > mem[_45551]:
                                    mem[mem[_45551] + _45551 + 196] = 0
                                require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                                call address(_12183 xor address(cd[36]) >> 96) with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_45551]) + _45551 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34656
                            mem[mem[64] + 64 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                            return Array(len=_34656, data=mem[mem[64] + 64 len 32 * _34656])
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34656
                            mem[mem[64] + 64 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                            return Array(len=_34656, data=mem[mem[64] + 64 len 32 * _34656])
                        _45554 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45554 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45554 + 36] = _44297
                        mem[_45554 + 68] = 0
                        mem[_45554 + 100] = this.address
                        mem[_45554 + 132] = 128
                        mem[_45554 + 164] = mem[_45554]
                        mem[_45554 + 196 len ceil32(mem[_45554])] = mem[_45554 + 32 len ceil32(mem[_45554])]
                        if ceil32(mem[_45554]) > mem[_45554]:
                            mem[mem[_45554] + _45554 + 196] = 0
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args _44297, 0, address(this.address), 128, mem[_45554], mem[_45554 + 196 len ceil32(mem[_45554])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45554 + 32] = 32
                        mem[_45554 + 64] = _34656
                        mem[_45554 + 96 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                        return memory
                          from mem[64]
                           len _45554 + (32 * _34656) + -mem[64] + 96
                    if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44297, this.address
                        else:
                            _45557 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45557 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45557 + 36] = 0
                            mem[_45557 + 68] = _44297
                            mem[_45557 + 100] = this.address
                            mem[_45557 + 132] = 128
                            mem[_45557 + 164] = mem[_45557]
                            mem[_45557 + 196 len ceil32(mem[_45557])] = mem[_45557 + 32 len ceil32(mem[_45557])]
                            if ceil32(mem[_45557]) > mem[_45557]:
                                mem[mem[_45557] + _45557 + 196] = 0
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45557]) + _45557 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34656
                        mem[mem[64] + 64 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                        return Array(len=_34656, data=mem[mem[64] + 64 len 32 * _34656])
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34656
                        mem[mem[64] + 64 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                        return Array(len=_34656, data=mem[mem[64] + 64 len 32 * _34656])
                    _45560 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45560 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45560 + 36] = _44297
                    mem[_45560 + 68] = 0
                    mem[_45560 + 100] = this.address
                    mem[_45560 + 132] = 128
                    mem[_45560 + 164] = mem[_45560]
                    mem[_45560 + 196 len ceil32(mem[_45560])] = mem[_45560 + 32 len ceil32(mem[_45560])]
                    if ceil32(mem[_45560]) > mem[_45560]:
                        mem[mem[_45560] + _45560 + 196] = 0
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44297, 0, address(this.address), 128, mem[_45560], mem[_45560 + 196 len ceil32(mem[_45560])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45560 + 32] = 32
                    mem[_45560 + 64] = _34656
                    mem[_45560 + 96 len 32 * _34656] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34656]
                    return memory
                      from mem[64]
                       len _45560 + (32 * _34656) + -mem[64] + 96
                require mem[96] >= 32
                require ('cd', 4).length == bool(('cd', 4).length)
                if not ('cd', 4).length:
                    revert with 0, 'TRANSFER_FAILED'
                mem[ceil32(32 * ('cd', 4).length) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + 329] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + 361] = 64
                mem[ceil32(32 * ('cd', 4).length) + 393] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + 425
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + 425 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
                require return_data.size >= 32
                _34503 = mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 356
                _34657 = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                if mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]) + 326
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = mem[ceil32(32 * ('cd', 4).length) + mem[ceil32(32 * ('cd', 4).length) + 325 len 4], Mask(85, 0, cd[36]) << 139 + 325]
                require _34503 + (32 * _34657) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len ceil32(32 * _34657)] = mem[ceil32(32 * ('cd', 4).length) + _34503 + 357 len ceil32(32 * _34657)]
                var83002 = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(32 * _34657) + 357
                if 1 >= _34657:
                    revert with 0, 50
                _44298 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44298, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34657
                            mem[mem[64] + 64 len 32 * _34657] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34657]
                            return Array(len=_34657, data=mem[mem[64] + 64 len 32 * _34657])
                        _45563 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45563 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45563 + 36] = 0
                        mem[_45563 + 68] = _44298
                        mem[_45563 + 100] = this.address
                        mem[_45563 + 132] = 128
                        mem[_45563 + 164] = mem[_45563]
                        mem[_45563 + 196 len ceil32(mem[_45563])] = mem[_45563 + 32 len ceil32(mem[_45563])]
                        if ceil32(mem[_45563]) > mem[_45563]:
                            mem[mem[_45563] + _45563 + 196] = 0
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44298, address(this.address), 128, mem[_45563], mem[_45563 + 196 len ceil32(mem[_45563])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45563 + 32] = 32
                        mem[_45563 + 64] = _34657
                        mem[_45563 + 96 len 32 * _34657] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34657]
                        return memory
                          from mem[64]
                           len _45563 + (32 * _34657) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34657
                        mem[mem[64] + 64 len 32 * _34657] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34657]
                        return Array(len=_34657, data=mem[mem[64] + 64 len 32 * _34657])
                    _45566 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45566 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45566 + 36] = _44298
                    mem[_45566 + 68] = 0
                    mem[_45566 + 100] = this.address
                    mem[_45566 + 132] = 128
                    mem[_45566 + 164] = mem[_45566]
                    mem[_45566 + 196 len ceil32(mem[_45566])] = mem[_45566 + 32 len ceil32(mem[_45566])]
                    if ceil32(mem[_45566]) > mem[_45566]:
                        mem[mem[_45566] + _45566 + 196] = 0
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args _44298, 0, address(this.address), 128, mem[_45566], mem[_45566 + 196 len ceil32(mem[_45566])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45566 + 32] = 32
                    mem[_45566 + 64] = _34657
                    mem[_45566 + 96 len 32 * _34657] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34657]
                    return memory
                      from mem[64]
                       len _45566 + (32 * _34657) + -mem[64] + 96
                if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44298, this.address
                    else:
                        _45569 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45569 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45569 + 36] = 0
                        mem[_45569 + 68] = _44298
                        mem[_45569 + 100] = this.address
                        mem[_45569 + 132] = 128
                        mem[_45569 + 164] = mem[_45569]
                        mem[_45569 + 196 len ceil32(mem[_45569])] = mem[_45569 + 32 len ceil32(mem[_45569])]
                        if ceil32(mem[_45569]) > mem[_45569]:
                            mem[mem[_45569] + _45569 + 196] = 0
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45569]) + _45569 + -mem[64] + 192]
                else:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45572 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45572 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45572 + 36] = _44298
                        mem[_45572 + 68] = 0
                        mem[_45572 + 100] = this.address
                        mem[_45572 + 132] = 128
                        mem[_45572 + 164] = mem[_45572]
                        mem[_45572 + 196 len ceil32(mem[_45572])] = mem[_45572 + 32 len ceil32(mem[_45572])]
                        if ceil32(mem[_45572]) > mem[_45572]:
                            mem[mem[_45572] + _45572 + 196] = 0
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45572]) + _45572 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34657
                mem[mem[64] + 64 len 32 * _34657] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len 32 * _34657]
                return Array(len=_34657, data=mem[mem[64] + 64 len 32 * _34657])
            mem[ceil32(32 * ('cd', 4).length) + 325] = return_data.size
            mem[ceil32(32 * ('cd', 4).length) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not return_data.size:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 330] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 362] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 394] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326
                require return_data.size >= 32
                _34504 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 357
                _34658 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
                require _34504 + (32 * _34658) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len ceil32(32 * _34658)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34504 + 358 len ceil32(32 * _34658)]
                if 1 >= _34658:
                    revert with 0, 50
                _44299 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44299, this.address
                        else:
                            _45575 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45575 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45575 + 36] = 0
                            mem[_45575 + 68] = _44299
                            mem[_45575 + 100] = this.address
                            mem[_45575 + 132] = 128
                            mem[_45575 + 164] = mem[_45575]
                            mem[_45575 + 196 len ceil32(mem[_45575])] = mem[_45575 + 32 len ceil32(mem[_45575])]
                            if ceil32(mem[_45575]) > mem[_45575]:
                                mem[mem[_45575] + _45575 + 196] = 0
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45575]) + _45575 + -mem[64] + 192]
                    else:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                            mem[mem[64] + 36] = 0
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4], 0, this.address
                        else:
                            _45578 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_45578 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_45578 + 36] = _44299
                            mem[_45578 + 68] = 0
                            mem[_45578 + 100] = this.address
                            mem[_45578 + 132] = 128
                            mem[_45578 + 164] = mem[_45578]
                            mem[_45578 + 196 len ceil32(mem[_45578])] = mem[_45578 + 32 len ceil32(mem[_45578])]
                            if ceil32(mem[_45578]) > mem[_45578]:
                                mem[mem[_45578] + _45578 + 196] = 0
                            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                            call address(_12183 xor address(cd[36]) >> 96) with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_45578]) + _45578 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34658
                    mem[mem[64] + 64 len 32 * _34658] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34658]
                    return Array(len=_34658, data=mem[mem[64] + 64 len 32 * _34658])
                if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44299, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34658
                        mem[mem[64] + 64 len 32 * _34658] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34658]
                        return Array(len=_34658, data=mem[mem[64] + 64 len 32 * _34658])
                    _45581 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45581 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45581 + 36] = 0
                    mem[_45581 + 68] = _44299
                    mem[_45581 + 100] = this.address
                    mem[_45581 + 132] = 128
                    mem[_45581 + 164] = mem[_45581]
                    mem[_45581 + 196 len ceil32(mem[_45581])] = mem[_45581 + 32 len ceil32(mem[_45581])]
                    if ceil32(mem[_45581]) > mem[_45581]:
                        mem[mem[_45581] + _45581 + 196] = 0
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44299, address(this.address), 128, mem[_45581], mem[_45581 + 196 len ceil32(mem[_45581])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45581 + 32] = 32
                    mem[_45581 + 64] = _34658
                    mem[_45581 + 96 len 32 * _34658] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34658]
                    return memory
                      from mem[64]
                       len _45581 + (32 * _34658) + -mem[64] + 96
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34658
                    mem[mem[64] + 64 len 32 * _34658] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34658]
                    return Array(len=_34658, data=mem[mem[64] + 64 len 32 * _34658])
                _45584 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45584 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45584 + 36] = _44299
                mem[_45584 + 68] = 0
                mem[_45584 + 100] = this.address
                mem[_45584 + 132] = 128
                mem[_45584 + 164] = mem[_45584]
                mem[_45584 + 196 len ceil32(mem[_45584])] = mem[_45584 + 32 len ceil32(mem[_45584])]
                if ceil32(mem[_45584]) > mem[_45584]:
                    mem[mem[_45584] + _45584 + 196] = 0
                require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44299, 0, address(this.address), 128, mem[_45584], mem[_45584 + 196 len ceil32(mem[_45584])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45584 + 32] = 32
                mem[_45584 + 64] = _34658
                mem[_45584 + 96 len 32 * _34658] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34658]
                return memory
                  from mem[64]
                   len _45584 + (32 * _34658) + -mem[64] + 96
            require return_data.size >= 32
            require mem[ceil32(32 * ('cd', 4).length) + 357] == bool(mem[ceil32(32 * ('cd', 4).length) + 357])
            if not mem[ceil32(32 * ('cd', 4).length) + 357]:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 330] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 362] = 64
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 394] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 426 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326
            require return_data.size >= 32
            _34505 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 357
            _34659 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]) + 327
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 326 len 4], Mask(85, 0, cd[36]) << 139 + 326]
            require _34505 + (32 * _34659) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len ceil32(32 * _34659)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34505 + 358 len ceil32(32 * _34659)]
            var83002 = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + ceil32(32 * _34659) + 358
            if 1 >= _34659:
                revert with 0, 50
            _44300 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390] < cd[68]:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                        call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44300, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34659
                        mem[mem[64] + 64 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                        return Array(len=_34659, data=mem[mem[64] + 64 len 32 * _34659])
                    _45587 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45587 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45587 + 36] = 0
                    mem[_45587 + 68] = _44300
                    mem[_45587 + 100] = this.address
                    mem[_45587 + 132] = 128
                    mem[_45587 + 164] = mem[_45587]
                    mem[_45587 + 196 len ceil32(mem[_45587])] = mem[_45587 + 32 len ceil32(mem[_45587])]
                    if ceil32(mem[_45587]) > mem[_45587]:
                        mem[mem[_45587] + _45587 + 196] = 0
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44300, address(this.address), 128, mem[_45587], mem[_45587 + 196 len ceil32(mem[_45587])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45587 + 32] = 32
                    mem[_45587 + 64] = _34659
                    mem[_45587 + 96 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                    return memory
                      from mem[64]
                       len _45587 + (32 * _34659) + -mem[64] + 96
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34659
                    mem[mem[64] + 64 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                    return Array(len=_34659, data=mem[mem[64] + 64 len 32 * _34659])
                _45590 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45590 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45590 + 36] = _44300
                mem[_45590 + 68] = 0
                mem[_45590 + 100] = this.address
                mem[_45590 + 132] = 128
                mem[_45590 + 164] = mem[_45590]
                mem[_45590 + 196 len ceil32(mem[_45590])] = mem[_45590 + 32 len ceil32(mem[_45590])]
                if ceil32(mem[_45590]) > mem[_45590]:
                    mem[mem[_45590] + _45590 + 196] = 0
                require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args _44300, 0, address(this.address), 128, mem[_45590], mem[_45590 + 196 len ceil32(mem[_45590])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45590 + 32] = 32
                mem[_45590 + 64] = _34659
                mem[_45590 + 96 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                return memory
                  from mem[64]
                   len _45590 + (32 * _34659) + -mem[64] + 96
            if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44300, this.address
                else:
                    _45593 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45593 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45593 + 36] = 0
                    mem[_45593 + 68] = _44300
                    mem[_45593 + 100] = this.address
                    mem[_45593 + 132] = 128
                    mem[_45593 + 164] = mem[_45593]
                    mem[_45593 + 196 len ceil32(mem[_45593])] = mem[_45593 + 32 len ceil32(mem[_45593])]
                    if ceil32(mem[_45593]) > mem[_45593]:
                        mem[mem[_45593] + _45593 + 196] = 0
                    require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                    call address(_12183 xor address(cd[36]) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45593]) + _45593 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34659
                mem[mem[64] + 64 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                return Array(len=_34659, data=mem[mem[64] + 64 len 32 * _34659])
            if Mask(1, 93, cd[36]) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 390]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
                call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34659
                mem[mem[64] + 64 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
                return Array(len=_34659, data=mem[mem[64] + 64 len 32 * _34659])
            _45596 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45596 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45596 + 36] = _44300
            mem[_45596 + 68] = 0
            mem[_45596 + 100] = this.address
            mem[_45596 + 132] = 128
            mem[_45596 + 164] = mem[_45596]
            mem[_45596 + 196 len ceil32(mem[_45596])] = mem[_45596 + 32 len ceil32(mem[_45596])]
            if ceil32(mem[_45596]) > mem[_45596]:
                mem[mem[_45596] + _45596 + 196] = 0
            require ext_code.size(address(_12183 xor address(cd[36]) >> 96))
            call address(_12183 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _44300, 0, address(this.address), 128, mem[_45596], mem[_45596 + 196 len ceil32(mem[_45596])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45596 + 32] = 32
            mem[_45596 + 64] = _34659
            mem[_45596 + 96 len 32 * _34659] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 358 len 32 * _34659]
            return memory
              from mem[64]
               len _45596 + (32 * _34659) + -mem[64] + 96
        mem[ceil32(32 * ('cd', 4).length) + 229] = this.address
        mem[ceil32(32 * ('cd', 4).length) + 261] = address(_12091 xor address(cd[36]) >> 96)
        staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_12091 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + 225] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = 160
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 389] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 421
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = this.address
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 421 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225
                require return_data.size >= 32
                _23376 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 256
                _23455 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
                require _23376 + (32 * _23455) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len ceil32(32 * _23455)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23376 + 257 len ceil32(32 * _23455)]
                var71002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _23455) + 257
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = 64
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225
            require return_data.size >= 32
            _23400 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 256
            _23519 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]) + 226
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225 len 4], Mask(85, 0, cd[36]) << 139 + 225]
            require _23400 + (32 * _23519) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len ceil32(32 * _23519)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _23400 + 257 len ceil32(32 * _23519)]
            if _23519 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _23519 < 1:
                revert with 0, 17
            if _23519 - 1 >= _23519:
                revert with 0, 50
            if mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                revert with 0, 17
            if not mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                if mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _44117 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _44385 = mem[_44117]
                require mem[_44117] <= test266151307()
                require _44117 + return_data.size > _44117 + mem[_44117] + 31
                _44701 = mem[_44117 + mem[_44117]]
                if mem[_44117 + mem[_44117]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_44117 + mem[_44117]]) + 1 < 0 or _44117 + ceil32(return_data.size) + ceil32(32 * mem[_44117 + mem[_44117]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _44117 + ceil32(return_data.size) + ceil32(32 * mem[_44117 + mem[_44117]]) + 1
                mem[_44117 + ceil32(return_data.size)] = _44701
                require _44385 + (32 * _44701) + 32 <= return_data.size
                mem[_44117 + ceil32(return_data.size) + 32 len ceil32(32 * _44701)] = mem[_44117 + _44385 + 32 len ceil32(32 * _44701)]
                mem[mem[64]] = 32
                _54669 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
                mem[mem[64] + 64 len 32 * _54669] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 32 * _54669]
                return 32, mem[mem[64] + 32 len (32 * _54669) + 32]
            if not mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257]:
                revert with 0, 18
            require mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, cd[36])
            mem[mem[64] + 36] = mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, mem[(32 * _23519 - 1) + ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _44118 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44386 = mem[_44118]
            require mem[_44118] <= test266151307()
            require _44118 + return_data.size > _44118 + mem[_44118] + 31
            _44702 = mem[_44118 + mem[_44118]]
            if mem[_44118 + mem[_44118]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_44118 + mem[_44118]]) + 1 < 0 or _44118 + ceil32(return_data.size) + ceil32(32 * mem[_44118 + mem[_44118]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _44118 + ceil32(return_data.size) + ceil32(32 * mem[_44118 + mem[_44118]]) + 1
            mem[_44118 + ceil32(return_data.size)] = _44702
            require _44386 + (32 * _44702) + 32 <= return_data.size
            mem[_44118 + ceil32(return_data.size) + 32 len ceil32(32 * _44702)] = mem[_44118 + _44386 + 32 len ceil32(32 * _44702)]
            mem[mem[64]] = 32
            _54670 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 64 len 32 * _54670] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 32 * _54670]
            return 32, mem[mem[64] + 32 len (32 * _54670) + 32]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = this.address
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(_12091 xor address(cd[36]) >> 96)
        staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
                gas gas_remaining wei
               args this.address, address(_12091 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = address(_12091 xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 68
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261 len 28] = address(_12091 xor address(cd[36]) >> 96) << 64
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 257 len 4] = approve(address arg1, uint256 arg2)
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = 32
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357] = 'SafeERC20: low-level call failed'
        if not ext_code.size(mem[ceil32(32 * ('cd', 4).length) + 173 len 20]):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 96] = approve(address arg1, uint256 arg2), address(_12091 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
        var60001 = 96
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 0
        call mem[ceil32(32 * ('cd', 4).length) + 173 len 20] with:
           funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_12091 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_12091 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if not mem[96]:
                if cd[68]:
                    if cd[68] <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = cd[68]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 160
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 553] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489] = this.address
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                    call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                    require return_data.size >= 32
                    _34422 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                    require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                    require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                    _34560 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                    require _34422 + (32 * _34560) + 32 <= return_data.size
                    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34560)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34422 + 421 len ceil32(32 * _34560)]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[96]
                    mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                    var110001 = mem[96]
                    return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = 64
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34494 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                _34648 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                require _34494 + (32 * _34648) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34648)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34494 + 421 len ceil32(32 * _34648)]
                if _34648 <= 0:
                    revert with 0, 'NO_OUT_AMOUNTS'
                if _34648 < 1:
                    revert with 0, 17
                if _34648 - 1 >= _34648:
                    revert with 0, 50
                _44793 = mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]
                if mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    revert with 0, 17
                if not mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    if mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                        revert with 0, 17
                    if 100 * mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                        revert with 0, 17
                    require mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                    if mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                        revert with 0, 'INVALID_AOM'
                    if 1800 > !block.timestamp:
                        revert with 0, 17
                    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = Mask(85, 0, cd[36])
                    mem[mem[64] + 36] = _44793 * Mask(7, 86, cd[36]) >> 86 / 100
                    mem[mem[64] + 68] = 160
                    mem[mem[64] + 164] = 2
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 161
                    t = mem[64] + 196
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[mem[64] + 100] = this.address
                    mem[mem[64] + 132] = block.timestamp + 1800
                    call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args cd[36] << 171, _44793 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _54123 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _54841 = mem[_54123]
                    require mem[_54123] <= test266151307()
                    require _54123 + return_data.size > _54123 + mem[_54123] + 31
                    _54927 = mem[_54123 + mem[_54123]]
                    if mem[_54123 + mem[_54123]] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_54123 + mem[_54123]]) + 1 < 0 or _54123 + ceil32(return_data.size) + ceil32(32 * mem[_54123 + mem[_54123]]) + 1 > test266151307():
                        revert with 0, 65
                    mem[64] = _54123 + ceil32(return_data.size) + ceil32(32 * mem[_54123 + mem[_54123]]) + 1
                    mem[_54123 + ceil32(return_data.size)] = _54927
                    require _54841 + (32 * _54927) + 32 <= return_data.size
                    mem[_54123 + ceil32(return_data.size) + 32 len ceil32(32 * _54927)] = mem[_54123 + _54841 + 32 len ceil32(32 * _54927)]
                    var159002 = _54123 + ceil32(return_data.size) + ceil32(32 * _54927) + 32
                    mem[mem[64]] = 32
                    _59369 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 64 len 32 * _59369] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59369]
                    return 32, mem[mem[64] + 32 len (32 * _59369) + 32]
                if not mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                    revert with 0, 18
                require mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
                if mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34648 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = _44793 * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, _44793 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54124 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54842 = mem[_54124]
                require mem[_54124] <= test266151307()
                require _54124 + return_data.size > _54124 + mem[_54124] + 31
                _54928 = mem[_54124 + mem[_54124]]
                if mem[_54124 + mem[_54124]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54124 + mem[_54124]]) + 1 < 0 or _54124 + ceil32(return_data.size) + ceil32(32 * mem[_54124 + mem[_54124]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54124 + ceil32(return_data.size) + ceil32(32 * mem[_54124 + mem[_54124]]) + 1
                mem[_54124 + ceil32(return_data.size)] = _54928
                require _54842 + (32 * _54928) + 32 <= return_data.size
                mem[_54124 + ceil32(return_data.size) + 32 len ceil32(32 * _54928)] = mem[_54124 + _54842 + 32 len ceil32(32 * _54928)]
                mem[mem[64]] = 32
                _59370 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59370] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59370]
                return 32, mem[mem[64] + 32 len (32 * _59370) + 32]
            require mem[96] >= 32
            require ('cd', 4).length == bool(('cd', 4).length)
            if not ('cd', 4).length:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 160
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 553] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34423 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
                _34561 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
                require _34423 + (32 * _34561) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34561)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34423 + 421 len ceil32(32 * _34561)]
                var110002 = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * _34561) + 421
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 393] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 425] = 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 457] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 489 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389
            require return_data.size >= 32
            _34495 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 420
            _34649 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]) + 390
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389 len 4], Mask(85, 0, cd[36]) << 139 + 389]
            require _34495 + (32 * _34649) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len ceil32(32 * _34649)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _34495 + 421 len ceil32(32 * _34649)]
            if _34649 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34649 < 1:
                revert with 0, 17
            if _34649 - 1 >= _34649:
                revert with 0, 50
            _44794 = mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]
            if mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                revert with 0, 17
            if not mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                if mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = _44794 * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, _44794 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54125 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54843 = mem[_54125]
                require mem[_54125] <= test266151307()
                require _54125 + return_data.size > _54125 + mem[_54125] + 31
                _54929 = mem[_54125 + mem[_54125]]
                if mem[_54125 + mem[_54125]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54125 + mem[_54125]]) + 1 < 0 or _54125 + ceil32(return_data.size) + ceil32(32 * mem[_54125 + mem[_54125]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54125 + ceil32(return_data.size) + ceil32(32 * mem[_54125 + mem[_54125]]) + 1
                mem[_54125 + ceil32(return_data.size)] = _54929
                require _54843 + (32 * _54929) + 32 <= return_data.size
                mem[_54125 + ceil32(return_data.size) + 32 len ceil32(32 * _54929)] = mem[_54125 + _54843 + 32 len ceil32(32 * _54929)]
                mem[mem[64]] = 32
                _59371 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59371] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59371]
                return 32, mem[mem[64] + 32 len (32 * _59371) + 32]
            if not mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
                revert with 0, 18
            require mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34649 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, cd[36])
            mem[mem[64] + 36] = _44794 * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, _44794 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54126 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54844 = mem[_54126]
            require mem[_54126] <= test266151307()
            require _54126 + return_data.size > _54126 + mem[_54126] + 31
            _54930 = mem[_54126 + mem[_54126]]
            if mem[_54126 + mem[_54126]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54126 + mem[_54126]]) + 1 < 0 or _54126 + ceil32(return_data.size) + ceil32(32 * mem[_54126 + mem[_54126]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54126 + ceil32(return_data.size) + ceil32(32 * mem[_54126 + mem[_54126]]) + 1
            mem[_54126 + ceil32(return_data.size)] = _54930
            require _54844 + (32 * _54930) + 32 <= return_data.size
            mem[_54126 + ceil32(return_data.size) + 32 len ceil32(32 * _54930)] = mem[_54126 + _54844 + 32 len ceil32(32 * _54930)]
            mem[mem[64]] = 32
            _59372 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 64 len 32 * _59372] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len 32 * _59372]
            return 32, mem[mem[64] + 32 len (32 * _59372) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if not return_data.size:
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                require return_data.size >= 32
                _34424 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
                require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
                _34562 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
                require _34424 + (32 * _34562) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34562)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34424 + 422 len ceil32(32 * _34562)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                var110001 = mem[96]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34496 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
            _34650 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            require _34496 + (32 * _34650) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34650)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34496 + 422 len ceil32(32 * _34650)]
            if _34650 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34650 < 1:
                revert with 0, 17
            if _34650 - 1 >= _34650:
                revert with 0, 50
            if mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 17
            if not mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                if mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = Mask(85, 0, cd[36])
                mem[mem[64] + 36] = mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54127 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54845 = mem[_54127]
                require mem[_54127] <= test266151307()
                require _54127 + return_data.size > _54127 + mem[_54127] + 31
                _54931 = mem[_54127 + mem[_54127]]
                if mem[_54127 + mem[_54127]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54127 + mem[_54127]]) + 1 < 0 or _54127 + ceil32(return_data.size) + ceil32(32 * mem[_54127 + mem[_54127]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54127 + ceil32(return_data.size) + ceil32(32 * mem[_54127 + mem[_54127]]) + 1
                mem[_54127 + ceil32(return_data.size)] = _54931
                require _54845 + (32 * _54931) + 32 <= return_data.size
                mem[_54127 + ceil32(return_data.size) + 32 len ceil32(32 * _54931)] = mem[_54127 + _54845 + 32 len ceil32(32 * _54931)]
                var159002 = _54127 + ceil32(return_data.size) + ceil32(32 * _54931) + 32
                mem[mem[64]] = 32
                _59373 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 64 len 32 * _59373] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59373]
                return 32, mem[mem[64] + 32 len (32 * _59373) + 32]
            if not mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
                revert with 0, 18
            require mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, cd[36])
            mem[mem[64] + 36] = mem[(32 * _34650 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, mem[mem[64] + 36], Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54128 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54846 = mem[_54128]
            require mem[_54128] <= test266151307()
            require _54128 + return_data.size > _54128 + mem[_54128] + 31
            _54932 = mem[_54128 + mem[_54128]]
            if mem[_54128 + mem[_54128]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54128 + mem[_54128]]) + 1 < 0 or _54128 + ceil32(return_data.size) + ceil32(32 * mem[_54128 + mem[_54128]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54128 + ceil32(return_data.size) + ceil32(32 * mem[_54128 + mem[_54128]]) + 1
            mem[_54128 + ceil32(return_data.size)] = _54932
            require _54846 + (32 * _54932) + 32 <= return_data.size
            mem[_54128 + ceil32(return_data.size) + 32 len ceil32(32 * _54932)] = mem[_54128 + _54846 + 32 len ceil32(32 * _54932)]
            mem[mem[64]] = 32
            _59374 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59374] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59374]
            return 32, mem[mem[64] + 32 len (32 * _59374) + 32]
        require return_data.size >= 32
        require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421] == bool(mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421])
        if not mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
            call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34425 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
            _34563 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
            require _34425 + (32 * _34563) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34563)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34425 + 422 len ceil32(32 * _34563)]
            var110002 = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34563) + 422
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[96]
            mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = Mask(85, 0, cd[36])
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12091 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args cd[36] << 171, Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
        require return_data.size >= 32
        _34497 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139
        require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 421
        _34651 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
        if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]) + 391
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], Mask(85, 0, cd[36]) << 139 + 390]
        require _34497 + (32 * _34651) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34651)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + _34497 + 422 len ceil32(32 * _34651)]
        if _34651 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _34651 < 1:
            revert with 0, 17
        if _34651 - 1 >= _34651:
            revert with 0, 50
        _44796 = mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]
        if mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 17
        if not mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            if mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = Mask(85, 0, cd[36])
            mem[mem[64] + 36] = _44796 * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args cd[36] << 171, _44796 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54129 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54847 = mem[_54129]
            require mem[_54129] <= test266151307()
            require _54129 + return_data.size > _54129 + mem[_54129] + 31
            _54933 = mem[_54129 + mem[_54129]]
            if mem[_54129 + mem[_54129]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54129 + mem[_54129]]) + 1 < 0 or _54129 + ceil32(return_data.size) + ceil32(32 * mem[_54129 + mem[_54129]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54129 + ceil32(return_data.size) + ceil32(32 * mem[_54129 + mem[_54129]]) + 1
            mem[_54129 + ceil32(return_data.size)] = _54933
            require _54847 + (32 * _54933) + 32 <= return_data.size
            mem[_54129 + ceil32(return_data.size) + 32 len ceil32(32 * _54933)] = mem[_54129 + _54847 + 32 len ceil32(32 * _54933)]
            mem[mem[64]] = 32
            _59375 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59375] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59375]
            return 32, mem[mem[64] + 32 len (32 * _59375) + 32]
        if not mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 18
        require mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
        if mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _34651 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = Mask(85, 0, cd[36])
        mem[mem[64] + 36] = _44796 * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12091 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args cd[36] << 171, _44796 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _54130 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _54848 = mem[_54130]
        require mem[_54130] <= test266151307()
        require _54130 + return_data.size > _54130 + mem[_54130] + 31
        _54934 = mem[_54130 + mem[_54130]]
        if mem[_54130 + mem[_54130]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_54130 + mem[_54130]]) + 1 < 0 or _54130 + ceil32(return_data.size) + ceil32(32 * mem[_54130 + mem[_54130]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _54130 + ceil32(return_data.size) + ceil32(32 * mem[_54130 + mem[_54130]]) + 1
        mem[_54130 + ceil32(return_data.size)] = _54934
        require _54848 + (32 * _54934) + 32 <= return_data.size
        mem[_54130 + ceil32(return_data.size) + 32 len ceil32(32 * _54934)] = mem[_54130 + _54848 + 32 len ceil32(32 * _54934)]
        mem[mem[64]] = 32
        _59376 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 64 len 32 * _59376] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59376]
        return 32, mem[mem[64] + 32 len (32 * _59376) + 32]
    mem[ceil32(32 * ('cd', 4).length) + 229] = this.address
    staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(32 * ('cd', 4).length) + 225] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'NO_IN'
    if 3 >= ('cd', 4).length:
        revert with 0, 50
    _12319 = mem[256]
    if 1 == Mask(1, 94, cd[36]) >> 94:
        if 2 >= ('cd', 4).length:
            revert with 0, 50
        _12349 = mem[224]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(mem[224] xor address(cd[36]) >> 96)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 293] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = 68
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 257 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 96] = 0, mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261], ext_call.return_data[0], mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 28]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 0
        call mem[ceil32(32 * ('cd', 4).length) + 173 len 20].mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'TRANSFER_FAILED'
            if not mem[96]:
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 361] = 64
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
                require return_data.size >= 32
                _34519 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 356
                _34673 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
                require _34519 + (32 * _34673) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len ceil32(32 * _34673)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34519 + 357 len ceil32(32 * _34673)]
                var83002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _34673) + 357
                if 1 >= _34673:
                    revert with 0, 50
                _44329 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] < cd[68]:
                    revert with 0, 'INSUFFICIENT_OUT'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                    if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44329, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34673
                            mem[mem[64] + 64 len 32 * _34673] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34673]
                            return Array(len=_34673, data=mem[mem[64] + 64 len 32 * _34673])
                        _45647 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45647 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45647 + 36] = 0
                        mem[_45647 + 68] = _44329
                        mem[_45647 + 100] = this.address
                        mem[_45647 + 132] = 128
                        mem[_45647 + 164] = mem[_45647]
                        mem[_45647 + 196 len ceil32(mem[_45647])] = mem[_45647 + 32 len ceil32(mem[_45647])]
                        if ceil32(mem[_45647]) > mem[_45647]:
                            mem[mem[_45647] + _45647 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44329, address(this.address), 128, mem[_45647], mem[_45647 + 196 len ceil32(mem[_45647])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45647 + 32] = 32
                        mem[_45647 + 64] = _34673
                        mem[_45647 + 96 len 32 * _34673] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34673]
                        return memory
                          from mem[64]
                           len _45647 + (32 * _34673) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45650 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45650 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45650 + 36] = _44329
                        mem[_45650 + 68] = 0
                        mem[_45650 + 100] = this.address
                        mem[_45650 + 132] = 128
                        mem[_45650 + 164] = mem[_45650]
                        mem[_45650 + 196 len ceil32(mem[_45650])] = mem[_45650 + 32 len ceil32(mem[_45650])]
                        if ceil32(mem[_45650]) > mem[_45650]:
                            mem[mem[_45650] + _45650 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45650]) + _45650 + -mem[64] + 192]
                else:
                    if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                    if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                        if Mask(1, 93, cd[36]) >> 93 != 1:
                            mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                            mem[mem[64] + 68] = this.address
                            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args 0, _44329, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 32
                            mem[mem[64] + 32] = _34673
                            mem[mem[64] + 64 len 32 * _34673] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34673]
                            return Array(len=_34673, data=mem[mem[64] + 64 len 32 * _34673])
                        _45653 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45653 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45653 + 36] = 0
                        mem[_45653 + 68] = _44329
                        mem[_45653 + 100] = this.address
                        mem[_45653 + 132] = 128
                        mem[_45653 + 164] = mem[_45653]
                        mem[_45653 + 196 len ceil32(mem[_45653])] = mem[_45653 + 32 len ceil32(mem[_45653])]
                        if ceil32(mem[_45653]) > mem[_45653]:
                            mem[mem[_45653] + _45653 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, _44329, address(this.address), 128, mem[_45653], mem[_45653 + 196 len ceil32(mem[_45653])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_45653 + 32] = 32
                        mem[_45653 + 64] = _34673
                        mem[_45653 + 96 len 32 * _34673] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34673]
                        return memory
                          from mem[64]
                           len _45653 + (32 * _34673) + -mem[64] + 96
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45656 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45656 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45656 + 36] = _44329
                        mem[_45656 + 68] = 0
                        mem[_45656 + 100] = this.address
                        mem[_45656 + 132] = 128
                        mem[_45656 + 164] = mem[_45656]
                        mem[_45656 + 196 len ceil32(mem[_45656])] = mem[_45656 + 32 len ceil32(mem[_45656])]
                        if ceil32(mem[_45656]) > mem[_45656]:
                            mem[mem[_45656] + _45656 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45656]) + _45656 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34673
                mem[mem[64] + 64 len 32 * _34673] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34673]
                return Array(len=_34673, data=mem[mem[64] + 64 len 32 * _34673])
            require mem[96] >= 32
            require ('cd', 4).length == bool(('cd', 4).length)
            if not ('cd', 4).length:
                revert with 0, 'TRANSFER_FAILED'
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 329] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 361] = 64
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 393] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 425 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
            require return_data.size >= 32
            _34520 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 325 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 356
            _34674 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]) + 326
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325 len 4], ext_call.return_data[0 len 28] + 325]
            require _34520 + (32 * _34674) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len ceil32(32 * _34674)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _34520 + 357 len ceil32(32 * _34674)]
            var89002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * _34674) + 357
            if 1 >= _34674:
                revert with 0, 50
            _44330 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] < cd[68]:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44330, this.address
                    else:
                        _45659 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45659 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45659 + 36] = 0
                        mem[_45659 + 68] = _44330
                        mem[_45659 + 100] = this.address
                        mem[_45659 + 132] = 128
                        mem[_45659 + 164] = mem[_45659]
                        mem[_45659 + 196 len ceil32(mem[_45659])] = mem[_45659 + 32 len ceil32(mem[_45659])]
                        if ceil32(mem[_45659]) > mem[_45659]:
                            mem[mem[_45659] + _45659 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45659]) + _45659 + -mem[64] + 192]
                else:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                        mem[mem[64] + 36] = 0
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4], 0, this.address
                    else:
                        _45662 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_45662 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_45662 + 36] = _44330
                        mem[_45662 + 68] = 0
                        mem[_45662 + 100] = this.address
                        mem[_45662 + 132] = 128
                        mem[_45662 + 164] = mem[_45662]
                        mem[_45662 + 196 len ceil32(mem[_45662])] = mem[_45662 + 32 len ceil32(mem[_45662])]
                        if ceil32(mem[_45662]) > mem[_45662]:
                            mem[mem[_45662] + _45662 + 196] = 0
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96) with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_45662]) + _45662 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34674
                mem[mem[64] + 64 len 32 * _34674] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34674]
                return Array(len=_34674, data=mem[mem[64] + 64 len 32 * _34674])
            if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44330, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34674
                    mem[mem[64] + 64 len 32 * _34674] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34674]
                    return Array(len=_34674, data=mem[mem[64] + 64 len 32 * _34674])
                _45665 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45665 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45665 + 36] = 0
                mem[_45665 + 68] = _44330
                mem[_45665 + 100] = this.address
                mem[_45665 + 132] = 128
                mem[_45665 + 164] = mem[_45665]
                mem[_45665 + 196 len ceil32(mem[_45665])] = mem[_45665 + 32 len ceil32(mem[_45665])]
                if ceil32(mem[_45665]) > mem[_45665]:
                    mem[mem[_45665] + _45665 + 196] = 0
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _44330, address(this.address), 128, mem[_45665], mem[_45665 + 196 len ceil32(mem[_45665])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45665 + 32] = 32
                mem[_45665 + 64] = _34674
                mem[_45665 + 96 len 32 * _34674] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34674]
                return memory
                  from mem[64]
                   len _45665 + (32 * _34674) + -mem[64] + 96
            if Mask(1, 93, cd[36]) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34674
                mem[mem[64] + 64 len 32 * _34674] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34674]
                return Array(len=_34674, data=mem[mem[64] + 64 len 32 * _34674])
            _45668 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45668 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45668 + 36] = _44330
            mem[_45668 + 68] = 0
            mem[_45668 + 100] = this.address
            mem[_45668 + 132] = 128
            mem[_45668 + 164] = mem[_45668]
            mem[_45668 + 196 len ceil32(mem[_45668])] = mem[_45668 + 32 len ceil32(mem[_45668])]
            if ceil32(mem[_45668]) > mem[_45668]:
                mem[mem[_45668] + _45668 + 196] = 0
            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _44330, 0, address(this.address), 128, mem[_45668], mem[_45668 + 196 len ceil32(mem[_45668])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45668 + 32] = 32
            mem[_45668 + 64] = _34674
            mem[_45668 + 96 len 32 * _34674] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357 len 32 * _34674]
            return memory
              from mem[64]
               len _45668 + (32 * _34674) + -mem[64] + 96
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 325] = return_data.size
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'TRANSFER_FAILED'
        if not return_data.size:
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 64
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 394] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
            require return_data.size >= 32
            _34521 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 357
            _34675 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]
            if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = _34675
            require _34521 + (32 * _34675) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len ceil32(32 * _34675)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + _34521 + 358 len ceil32(32 * _34675)]
            var83002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34675) + 358
            if 1 >= _34675:
                revert with 0, 50
            _44331 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] < cd[68]:
                revert with 0, 'INSUFFICIENT_OUT'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                    if Mask(1, 93, cd[36]) >> 93 != 1:
                        mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                        mem[mem[64] + 68] = this.address
                        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args 0, _44331, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _34675
                        mem[mem[64] + 64 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                        return Array(len=_34675, data=mem[mem[64] + 64 len 32 * _34675])
                    _45671 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45671 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45671 + 36] = 0
                    mem[_45671 + 68] = _44331
                    mem[_45671 + 100] = this.address
                    mem[_45671 + 132] = 128
                    mem[_45671 + 164] = mem[_45671]
                    mem[_45671 + 196 len ceil32(mem[_45671])] = mem[_45671 + 32 len ceil32(mem[_45671])]
                    if ceil32(mem[_45671]) > mem[_45671]:
                        mem[mem[_45671] + _45671 + 196] = 0
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, _44331, address(this.address), 128, mem[_45671], mem[_45671 + 196 len ceil32(mem[_45671])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_45671 + 32] = 32
                    mem[_45671 + 64] = _34675
                    mem[_45671 + 96 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                    return memory
                      from mem[64]
                       len _45671 + (32 * _34675) + -mem[64] + 96
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 36] = 0
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0, this.address
                else:
                    _45674 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_45674 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_45674 + 36] = _44331
                    mem[_45674 + 68] = 0
                    mem[_45674 + 100] = this.address
                    mem[_45674 + 132] = 128
                    mem[_45674 + 164] = mem[_45674]
                    mem[_45674 + 196 len ceil32(mem[_45674])] = mem[_45674 + 32 len ceil32(mem[_45674])]
                    if ceil32(mem[_45674]) > mem[_45674]:
                        mem[mem[_45674] + _45674 + 196] = 0
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_45674]) + _45674 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34675
                mem[mem[64] + 64 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                return Array(len=_34675, data=mem[mem[64] + 64 len 32 * _34675])
            if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44331, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34675
                    mem[mem[64] + 64 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                    return Array(len=_34675, data=mem[mem[64] + 64 len 32 * _34675])
                _45677 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45677 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45677 + 36] = 0
                mem[_45677 + 68] = _44331
                mem[_45677 + 100] = this.address
                mem[_45677 + 132] = 128
                mem[_45677 + 164] = mem[_45677]
                mem[_45677 + 196 len ceil32(mem[_45677])] = mem[_45677 + 32 len ceil32(mem[_45677])]
                if ceil32(mem[_45677]) > mem[_45677]:
                    mem[mem[_45677] + _45677 + 196] = 0
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _44331, address(this.address), 128, mem[_45677], mem[_45677 + 196 len ceil32(mem[_45677])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45677 + 32] = 32
                mem[_45677 + 64] = _34675
                mem[_45677 + 96 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                return memory
                  from mem[64]
                   len _45677 + (32 * _34675) + -mem[64] + 96
            if Mask(1, 93, cd[36]) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34675
                mem[mem[64] + 64 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
                return Array(len=_34675, data=mem[mem[64] + 64 len 32 * _34675])
            _45680 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45680 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45680 + 36] = _44331
            mem[_45680 + 68] = 0
            mem[_45680 + 100] = this.address
            mem[_45680 + 132] = 128
            mem[_45680 + 164] = mem[_45680]
            mem[_45680 + 196 len ceil32(mem[_45680])] = mem[_45680 + 32 len ceil32(mem[_45680])]
            if ceil32(mem[_45680]) > mem[_45680]:
                mem[mem[_45680] + _45680 + 196] = 0
            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _44331, 0, address(this.address), 128, mem[_45680], mem[_45680 + 196 len ceil32(mem[_45680])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45680 + 32] = 32
            mem[_45680 + 64] = _34675
            mem[_45680 + 96 len 32 * _34675] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34675]
            return memory
              from mem[64]
               len _45680 + (32 * _34675) + -mem[64] + 96
        require return_data.size >= 32
        require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357] == bool(mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357])
        if not mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 357]:
            revert with 0, 'TRANSFER_FAILED'
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 330] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 362] = 64
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 394] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 426 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326
        require return_data.size >= 32
        _34522 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 326 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 357
        _34676 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]
        if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + 326 len 4], ext_call.return_data[0 len 28] + 326]) + 327
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = _34676
        require _34522 + (32 * _34676) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len ceil32(32 * _34676)] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + ceil32(return_data.size) + _34522 + 358 len ceil32(32 * _34676)]
        var89002 = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34676) + 358
        if 1 >= _34676:
            revert with 0, 50
        _44332 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] < cd[68]:
            revert with 0, 'INSUFFICIENT_OUT'
        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
            revert with 0, 'UniswapV2Library: IDENTICAL_ADDRESSES'
        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] < uint64(mem[160] xor address(cd[36]) >> 96) << 96:
            if not mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
            if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == mem[ceil32(32 * ('cd', 4).length) + 173 len 20]:
                if Mask(1, 93, cd[36]) >> 93 != 1:
                    mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                    mem[mem[64] + 68] = this.address
                    require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                    call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                         gas gas_remaining wei
                        args 0, _44332, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _34676
                    mem[mem[64] + 64 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
                    return Array(len=_34676, data=mem[mem[64] + 64 len 32 * _34676])
                _45683 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_45683 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_45683 + 36] = 0
                mem[_45683 + 68] = _44332
                mem[_45683 + 100] = this.address
                mem[_45683 + 132] = 128
                mem[_45683 + 164] = mem[_45683]
                mem[_45683 + 196 len ceil32(mem[_45683])] = mem[_45683 + 32 len ceil32(mem[_45683])]
                if ceil32(mem[_45683]) > mem[_45683]:
                    mem[mem[_45683] + _45683 + 196] = 0
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, _44332, address(this.address), 128, mem[_45683], mem[_45683 + 196 len ceil32(mem[_45683])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_45683 + 32] = 32
                mem[_45683 + 64] = _34676
                mem[_45683 + 96 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
                return memory
                  from mem[64]
                   len _45683 + (32 * _34676) + -mem[64] + 96
            if Mask(1, 93, cd[36]) >> 93 != 1:
                mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 36] = 0
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34676
                mem[mem[64] + 64 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
                return Array(len=_34676, data=mem[mem[64] + 64 len 32 * _34676])
            _45686 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45686 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45686 + 36] = _44332
            mem[_45686 + 68] = 0
            mem[_45686 + 100] = this.address
            mem[_45686 + 132] = 128
            mem[_45686 + 164] = mem[_45686]
            mem[_45686 + 196 len ceil32(mem[_45686])] = mem[_45686 + 32 len ceil32(mem[_45686])]
            if ceil32(mem[_45686]) > mem[_45686]:
                mem[mem[_45686] + _45686 + 196] = 0
            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args _44332, 0, address(this.address), 128, mem[_45686], mem[_45686 + 196 len ceil32(mem[_45686])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45686 + 32] = 32
            mem[_45686 + 64] = _34676
            mem[_45686 + 96 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
            return memory
              from mem[64]
               len _45686 + (32 * _34676) + -mem[64] + 96
        if not uint64(mem[160] xor address(cd[36]) >> 96) << 96:
            revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
        if mem[ceil32(32 * ('cd', 4).length) + 173 len 20] == uint64(mem[160] xor address(cd[36]) >> 96) << 96:
            if Mask(1, 93, cd[36]) >> 93 != 1:
                mem[mem[64] + 36] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
                mem[mem[64] + 68] = this.address
                require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
                call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args 0, _44332, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _34676
                mem[mem[64] + 64 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
                return Array(len=_34676, data=mem[mem[64] + 64 len 32 * _34676])
            _45689 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_45689 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_45689 + 36] = 0
            mem[_45689 + 68] = _44332
            mem[_45689 + 100] = this.address
            mem[_45689 + 132] = 128
            mem[_45689 + 164] = mem[_45689]
            mem[_45689 + 196 len ceil32(mem[_45689])] = mem[_45689 + 32 len ceil32(mem[_45689])]
            if ceil32(mem[_45689]) > mem[_45689]:
                mem[mem[_45689] + _45689 + 196] = 0
            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, _44332, address(this.address), 128, mem[_45689], mem[_45689 + 196 len ceil32(mem[_45689])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_45689 + 32] = 32
            mem[_45689 + 64] = _34676
            mem[_45689 + 96 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
            return memory
              from mem[64]
               len _45689 + (32 * _34676) + -mem[64] + 96
        if Mask(1, 93, cd[36]) >> 93 != 1:
            mem[mem[64] + 4] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 36] = 0
            mem[mem[64] + 68] = this.address
            require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
            call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args mem[mem[64] + 4], 0, this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _34676
            mem[mem[64] + 64 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
            return Array(len=_34676, data=mem[mem[64] + 64 len 32 * _34676])
        _45692 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_45692 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_45692 + 36] = _44332
        mem[_45692 + 68] = 0
        mem[_45692 + 100] = this.address
        mem[_45692 + 132] = 128
        mem[_45692 + 164] = mem[_45692]
        mem[_45692 + 196 len ceil32(mem[_45692])] = mem[_45692 + 32 len ceil32(mem[_45692])]
        if ceil32(mem[_45692]) > mem[_45692]:
            mem[mem[_45692] + _45692 + 196] = 0
        require ext_code.size(address(_12349 xor address(cd[36]) >> 96))
        call address(_12349 xor address(cd[36]) >> 96).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
             gas gas_remaining wei
            args _44332, 0, address(this.address), 128, mem[_45692], mem[_45692 + 196 len ceil32(mem[_45692])]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_45692 + 32] = 32
        mem[_45692 + 64] = _34676
        mem[_45692 + 96 len 32 * _34676] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 32 * _34676]
        return memory
          from mem[64]
           len _45692 + (32 * _34676) + -mem[64] + 96
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 229] = this.address
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 261] = address(_12319 xor address(cd[36]) >> 96)
    staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
            gas gas_remaining wei
           args this.address, address(_12319 xor address(cd[36]) >> 96)
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 225] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 160
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 389] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325] = this.address
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 357] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 421 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225
            require return_data.size >= 32
            _23377 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256
            _23468 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
            if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
            require _23377 + (32 * _23468) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len ceil32(32 * _23468)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _23377 + 257 len ceil32(32 * _23468)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[96]
            mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = 64
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 293] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 325 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225
        require return_data.size >= 32
        _23405 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + return_data.size + 225 > ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256
        _23532 = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
        if mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
        require _23405 + (32 * _23532) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len ceil32(32 * _23532)] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + _23405 + 257 len ceil32(32 * _23532)]
        if _23532 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _23532 < 1:
            revert with 0, 17
        if _23532 - 1 >= _23532:
            revert with 0, 50
        if mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
            revert with 0, 17
        if not mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
            if mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _44143 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _44411 = mem[_44143]
            require mem[_44143] <= test266151307()
            require _44143 + return_data.size > _44143 + mem[_44143] + 31
            _44727 = mem[_44143 + mem[_44143]]
            if mem[_44143 + mem[_44143]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_44143 + mem[_44143]]) + 1 < 0 or _44143 + ceil32(return_data.size) + ceil32(32 * mem[_44143 + mem[_44143]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _44143 + ceil32(return_data.size) + ceil32(32 * mem[_44143 + mem[_44143]]) + 1
            mem[_44143 + ceil32(return_data.size)] = _44727
            require _44411 + (32 * _44727) + 32 <= return_data.size
            mem[_44143 + ceil32(return_data.size) + 32 len ceil32(32 * _44727)] = mem[_44143 + _44411 + 32 len ceil32(32 * _44727)]
            mem[mem[64]] = 32
            _54735 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
            mem[mem[64] + 64 len 32 * _54735] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 32 * _54735]
            return 32, mem[mem[64] + 32 len (32 * _54735) + 32]
        if not mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257]:
            revert with 0, 18
        require mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] == Mask(7, 86, cd[36]) >> 86
        if mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], mem[(32 * _23532 - 1) + ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _44144 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _44412 = mem[_44144]
        require mem[_44144] <= test266151307()
        require _44144 + return_data.size > _44144 + mem[_44144] + 31
        _44728 = mem[_44144 + mem[_44144]]
        if mem[_44144 + mem[_44144]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_44144 + mem[_44144]]) + 1 < 0 or _44144 + ceil32(return_data.size) + ceil32(32 * mem[_44144 + mem[_44144]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _44144 + ceil32(return_data.size) + ceil32(32 * mem[_44144 + mem[_44144]]) + 1
        mem[_44144 + ceil32(return_data.size)] = _44728
        require _44412 + (32 * _44728) + 32 <= return_data.size
        mem[_44144 + ceil32(return_data.size) + 32 len ceil32(32 * _44728)] = mem[_44144 + _44412 + 32 len ceil32(32 * _44728)]
        mem[mem[64]] = 32
        _54736 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225]
        mem[mem[64] + 64 len 32 * _54736] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 32 * _54736]
        return 32, mem[mem[64] + 32 len (32 * _54736) + 32]
    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 229] = this.address
    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 261] = address(_12319 xor address(cd[36]) >> 96)
    staticcall mem[ceil32(32 * ('cd', 4).length) + 173 len 20].0xdd62ed3e with:
            gas gas_remaining wei
           args this.address, address(_12319 xor address(cd[36]) >> 96)
    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 225] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261] = address(_12319 xor address(cd[36]) >> 96)
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 293] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 225] = 68
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 261 len 28] = address(_12319 xor address(cd[36]) >> 96) << 64
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 257 len 4] = approve(address arg1, uint256 arg2)
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 325] = 32
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 357] = 'SafeERC20: low-level call failed'
    if not ext_code.size(mem[ceil32(32 * ('cd', 4).length) + 173 len 20]):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 96] = approve(address arg1, uint256 arg2), address(_12319 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 0
    call mem[ceil32(32 * ('cd', 4).length) + 173 len 20] with:
       funct Mask(32, 224, approve(address arg1, uint256 arg2), address(_12319 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, approve(address arg1, uint256 arg2), address(_12319 xor address(cd[36]) >> 96) << 64, 0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            revert with 0, 'SafeERC20: low-level call failed'
        if not mem[96]:
            if cd[68]:
                if cd[68] <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = cd[68]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 160
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 553] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489] = this.address
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
                call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
                require return_data.size >= 32
                _34431 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
                require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
                _34570 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
                if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34570
                require _34431 + (32 * _34570) + 32 <= return_data.size
                mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34570)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34431 + 421 len ceil32(32 * _34570)]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[96]
                mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
                var116001 = mem[96]
                return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = 64
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
            require return_data.size >= 32
            _34511 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
            _34665 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34665
            require _34511 + (32 * _34665) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34665)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34511 + 421 len ceil32(32 * _34665)]
            if _34665 <= 0:
                revert with 0, 'NO_OUT_AMOUNTS'
            if _34665 < 1:
                revert with 0, 17
            if _34665 - 1 >= _34665:
                revert with 0, 50
            _44801 = mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]
            if mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                revert with 0, 17
            if not mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                if mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                    revert with 0, 17
                if 100 * mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                    revert with 0, 17
                require mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
                if mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                    revert with 0, 'INVALID_AOM'
                if 1800 > !block.timestamp:
                    revert with 0, 17
                mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = ext_call.return_data[0]
                mem[mem[64] + 36] = _44801 * Mask(7, 86, cd[36]) >> 86 / 100
                mem[mem[64] + 68] = 160
                mem[mem[64] + 164] = 2
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 161
                t = mem[64] + 196
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 100] = this.address
                mem[mem[64] + 132] = block.timestamp + 1800
                call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], _44801 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _54141 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _54857 = mem[_54141]
                require mem[_54141] <= test266151307()
                require _54141 + return_data.size > _54141 + mem[_54141] + 31
                _54945 = mem[_54141 + mem[_54141]]
                if mem[_54141 + mem[_54141]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_54141 + mem[_54141]]) + 1 < 0 or _54141 + ceil32(return_data.size) + ceil32(32 * mem[_54141 + mem[_54141]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _54141 + ceil32(return_data.size) + ceil32(32 * mem[_54141 + mem[_54141]]) + 1
                mem[_54141 + ceil32(return_data.size)] = _54945
                require _54857 + (32 * _54945) + 32 <= return_data.size
                mem[_54141 + ceil32(return_data.size) + 32 len ceil32(32 * _54945)] = mem[_54141 + _54857 + 32 len ceil32(32 * _54945)]
                mem[mem[64]] = 32
                _59385 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
                mem[mem[64] + 64 len 32 * _59385] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59385]
                return 32, mem[mem[64] + 32 len (32 * _59385) + 32]
            if not mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
                revert with 0, 18
            require mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
            if mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34665 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = _44801 * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _44801 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54142 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54858 = mem[_54142]
            require mem[_54142] <= test266151307()
            require _54142 + return_data.size > _54142 + mem[_54142] + 31
            _54946 = mem[_54142 + mem[_54142]]
            if mem[_54142 + mem[_54142]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54142 + mem[_54142]]) + 1 < 0 or _54142 + ceil32(return_data.size) + ceil32(32 * mem[_54142 + mem[_54142]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54142 + ceil32(return_data.size) + ceil32(32 * mem[_54142 + mem[_54142]]) + 1
            mem[_54142 + ceil32(return_data.size)] = _54946
            require _54858 + (32 * _54946) + 32 <= return_data.size
            mem[_54142 + ceil32(return_data.size) + 32 len ceil32(32 * _54946)] = mem[_54142 + _54858 + 32 len ceil32(32 * _54946)]
            mem[mem[64]] = 32
            _59386 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 64 len 32 * _59386] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59386]
            return 32, mem[mem[64] + 32 len (32 * _59386) + 32]
        require mem[96] >= 32
        require ('cd', 4).length == bool(('cd', 4).length)
        if not ('cd', 4).length:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 160
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 553] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489] = this.address
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 521] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 585 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
            require return_data.size >= 32
            _34432 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
            _34571 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34571
            require _34432 + (32 * _34571) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34571)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34432 + 421 len ceil32(32 * _34571)]
            var116002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * _34571) + 421
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[96]
            mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 393] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 425] = 64
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 457] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 489 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389
        require return_data.size >= 32
        _34512 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + return_data.size + 389 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 420
        _34666 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]
        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389 len 4], ext_call.return_data[0 len 28] + 389]) + 390
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389] = _34666
        require _34512 + (32 * _34666) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len ceil32(32 * _34666)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + _34512 + 421 len ceil32(32 * _34666)]
        var114002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(32 * _34666) + 421
        if _34666 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _34666 < 1:
            revert with 0, 17
        if _34666 - 1 >= _34666:
            revert with 0, 50
        if mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
            revert with 0, 17
        if not mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
            if mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54143 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54859 = mem[_54143]
            require mem[_54143] <= test266151307()
            require _54143 + return_data.size > _54143 + mem[_54143] + 31
            _54947 = mem[_54143 + mem[_54143]]
            if mem[_54143 + mem[_54143]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54143 + mem[_54143]]) + 1 < 0 or _54143 + ceil32(return_data.size) + ceil32(32 * mem[_54143 + mem[_54143]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54143 + ceil32(return_data.size) + ceil32(32 * mem[_54143 + mem[_54143]]) + 1
            mem[_54143 + ceil32(return_data.size)] = _54947
            require _54859 + (32 * _54947) + 32 <= return_data.size
            mem[_54143 + ceil32(return_data.size) + 32 len ceil32(32 * _54947)] = mem[_54143 + _54859 + 32 len ceil32(32 * _54947)]
            mem[mem[64]] = 32
            _59387 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
            mem[mem[64] + 64 len 32 * _59387] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59387]
            return 32, mem[mem[64] + 32 len (32 * _59387) + 32]
        if not mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421]:
            revert with 0, 18
        require mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] == Mask(7, 86, cd[36]) >> 86
        if mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], mem[(32 * _34666 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421] * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _54144 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _54860 = mem[_54144]
        require mem[_54144] <= test266151307()
        require _54144 + return_data.size > _54144 + mem[_54144] + 31
        _54948 = mem[_54144 + mem[_54144]]
        if mem[_54144 + mem[_54144]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_54144 + mem[_54144]]) + 1 < 0 or _54144 + ceil32(return_data.size) + ceil32(32 * mem[_54144 + mem[_54144]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _54144 + ceil32(return_data.size) + ceil32(32 * mem[_54144 + mem[_54144]]) + 1
        mem[_54144 + ceil32(return_data.size)] = _54948
        require _54860 + (32 * _54948) + 32 <= return_data.size
        mem[_54144 + ceil32(return_data.size) + 32 len ceil32(32 * _54948)] = mem[_54144 + _54860 + 32 len ceil32(32 * _54948)]
        mem[mem[64]] = 32
        _59388 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 389]
        mem[mem[64] + 64 len 32 * _59388] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + 421 len 32 * _59388]
        return 32, mem[mem[64] + 32 len (32 * _59388) + 32]
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 389] = return_data.size
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        revert with 0, 'SafeERC20: low-level call failed'
    if not return_data.size:
        if cd[68]:
            if cd[68] <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
            require return_data.size >= 32
            _34433 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
            _34572 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
            require _34433 + (32 * _34572) + 32 <= return_data.size
            mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34572)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34433 + 422 len ceil32(32 * _34572)]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[96]
            mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
            var116001 = mem[96]
            return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
        require return_data.size >= 32
        _34513 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
        _34667 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        require _34513 + (32 * _34667) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34667)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34513 + 422 len ceil32(32 * _34667)]
        if _34667 <= 0:
            revert with 0, 'NO_OUT_AMOUNTS'
        if _34667 < 1:
            revert with 0, 17
        if _34667 - 1 >= _34667:
            revert with 0, 50
        _44803 = mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]
        if mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 17
        if not mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            if mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
                revert with 0, 17
            if 100 * mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
                revert with 0, 17
            require mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
            if mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
                revert with 0, 'INVALID_AOM'
            if 1800 > !block.timestamp:
                revert with 0, 17
            mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = ext_call.return_data[0]
            mem[mem[64] + 36] = _44803 * Mask(7, 86, cd[36]) >> 86 / 100
            mem[mem[64] + 68] = 160
            mem[mem[64] + 164] = 2
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 161
            t = mem[64] + 196
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 100] = this.address
            mem[mem[64] + 132] = block.timestamp + 1800
            call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], _44803 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _54145 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _54861 = mem[_54145]
            require mem[_54145] <= test266151307()
            require _54145 + return_data.size > _54145 + mem[_54145] + 31
            _54949 = mem[_54145 + mem[_54145]]
            if mem[_54145 + mem[_54145]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_54145 + mem[_54145]]) + 1 < 0 or _54145 + ceil32(return_data.size) + ceil32(32 * mem[_54145 + mem[_54145]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _54145 + ceil32(return_data.size) + ceil32(32 * mem[_54145 + mem[_54145]]) + 1
            mem[_54145 + ceil32(return_data.size)] = _54949
            require _54861 + (32 * _54949) + 32 <= return_data.size
            mem[_54145 + ceil32(return_data.size) + 32 len ceil32(32 * _54949)] = mem[_54145 + _54861 + 32 len ceil32(32 * _54949)]
            mem[mem[64]] = 32
            _59389 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
            mem[mem[64] + 64 len 32 * _59389] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59389]
            return 32, mem[mem[64] + 32 len (32 * _59389) + 32]
        if not mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
            revert with 0, 18
        require mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
        if mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _34667 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _44803 * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _44803 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _54146 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _54862 = mem[_54146]
        require mem[_54146] <= test266151307()
        require _54146 + return_data.size > _54146 + mem[_54146] + 31
        _54950 = mem[_54146 + mem[_54146]]
        if mem[_54146 + mem[_54146]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_54146 + mem[_54146]]) + 1 < 0 or _54146 + ceil32(return_data.size) + ceil32(32 * mem[_54146 + mem[_54146]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _54146 + ceil32(return_data.size) + ceil32(32 * mem[_54146 + mem[_54146]]) + 1
        mem[_54146 + ceil32(return_data.size)] = _54950
        require _54862 + (32 * _54950) + 32 <= return_data.size
        mem[_54146 + ceil32(return_data.size) + 32 len ceil32(32 * _54950)] = mem[_54146 + _54862 + 32 len ceil32(32 * _54950)]
        mem[mem[64]] = 32
        _59390 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 64 len 32 * _59390] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59390]
        return 32, mem[mem[64] + 32 len (32 * _59390) + 32]
    require return_data.size >= 32
    require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421] == bool(mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421])
    if not mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + 421]:
        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    if cd[68]:
        if cd[68] <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = cd[68]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 160
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = this.address
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = block.timestamp + 1800
        call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], cd[68], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 586 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
        require return_data.size >= 32
        _34434 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
        _34573 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
        require _34434 + (32 * _34573) + 32 <= return_data.size
        mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34573)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34434 + 422 len ceil32(32 * _34573)]
        var116002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34573) + 422
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[96]
        mem[mem[64] + 64 len 32 * mem[96]] = mem[128 len 32 * mem[96]]
        return 32, mem[mem[64] + 32 len (32 * mem[96]) + 32]
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = ext_call.return_data[0]
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 64
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = 2
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + 161
    t = ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    staticcall address(_12319 xor address(cd[36]) >> 96).getAmountsOut(uint256 arg1, address[] arg2) with:
            gas gas_remaining wei
           args ext_call.return_data[0], Array(len=2, data=mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
    require return_data.size >= 32
    _34514 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28]
    require mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] <= test266151307()
    require ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 390 > ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 421
    _34668 = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
    if mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]) + 391
    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 390 len 4], ext_call.return_data[0 len 28] + 390]
    require _34514 + (32 * _34668) + 32 <= return_data.size
    mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len ceil32(32 * _34668)] = mem[ceil32(32 * ('cd', 4).length) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _34514 + 422 len ceil32(32 * _34668)]
    var114002 = ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(32 * _34668) + 422
    if _34668 <= 0:
        revert with 0, 'NO_OUT_AMOUNTS'
    if _34668 < 1:
        revert with 0, 17
    if _34668 - 1 >= _34668:
        revert with 0, 50
    _44804 = mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]
    if mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] and Mask(7, 86, cd[36]) >> 86 > -1 / mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
        revert with 0, 17
    if not mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
        if mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
            revert with 0, 17
        if 100 * mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
            revert with 0, 17
        require mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
        if mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
            revert with 0, 'INVALID_AOM'
        if 1800 > !block.timestamp:
            revert with 0, 17
        mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = ext_call.return_data[0]
        mem[mem[64] + 36] = _44804 * Mask(7, 86, cd[36]) >> 86 / 100
        mem[mem[64] + 68] = 160
        mem[mem[64] + 164] = 2
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 161
        t = mem[64] + 196
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 100] = this.address
        mem[mem[64] + 132] = block.timestamp + 1800
        call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], _44804 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _54147 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _54863 = mem[_54147]
        require mem[_54147] <= test266151307()
        require _54147 + return_data.size > _54147 + mem[_54147] + 31
        _54951 = mem[_54147 + mem[_54147]]
        if mem[_54147 + mem[_54147]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_54147 + mem[_54147]]) + 1 < 0 or _54147 + ceil32(return_data.size) + ceil32(32 * mem[_54147 + mem[_54147]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _54147 + ceil32(return_data.size) + ceil32(32 * mem[_54147 + mem[_54147]]) + 1
        mem[_54147 + ceil32(return_data.size)] = _54951
        require _54863 + (32 * _54951) + 32 <= return_data.size
        mem[_54147 + ceil32(return_data.size) + 32 len ceil32(32 * _54951)] = mem[_54147 + _54863 + 32 len ceil32(32 * _54951)]
        mem[mem[64]] = 32
        _59391 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
        mem[mem[64] + 64 len 32 * _59391] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59391]
        return 32, mem[mem[64] + 32 len (32 * _59391) + 32]
    if not mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422]:
        revert with 0, 18
    require mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] == Mask(7, 86, cd[36]) >> 86
    if mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    if 100 * mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 > !(mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100):
        revert with 0, 17
    require mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 == (100 * mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100) + (mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 % 100)
    if mem[(32 * _34668 - 1) + ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] * Mask(7, 86, cd[36]) >> 86 / 100 <= 0:
        revert with 0, 'INVALID_AOM'
    if 1800 > !block.timestamp:
        revert with 0, 17
    mem[mem[64]] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = ext_call.return_data[0]
    mem[mem[64] + 36] = _44804 * Mask(7, 86, cd[36]) >> 86 / 100
    mem[mem[64] + 68] = 160
    mem[mem[64] + 164] = 2
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + 161
    t = mem[64] + 196
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 100] = this.address
    mem[mem[64] + 132] = block.timestamp + 1800
    call address(_12319 xor address(cd[36]) >> 96).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args ext_call.return_data[0], _44804 * Mask(7, 86, cd[36]) >> 86 / 100, Array(len=2, data=mem[mem[64] + 196 len 64]), address(this.address), block.timestamp + 1800
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _54148 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _54864 = mem[_54148]
    require mem[_54148] <= test266151307()
    require _54148 + return_data.size > _54148 + mem[_54148] + 31
    _54952 = mem[_54148 + mem[_54148]]
    if mem[_54148 + mem[_54148]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_54148 + mem[_54148]]) + 1 < 0 or _54148 + ceil32(return_data.size) + ceil32(32 * mem[_54148 + mem[_54148]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _54148 + ceil32(return_data.size) + ceil32(32 * mem[_54148 + mem[_54148]]) + 1
    mem[_54148 + ceil32(return_data.size)] = _54952
    require _54864 + (32 * _54952) + 32 <= return_data.size
    mem[_54148 + ceil32(return_data.size) + 32 len ceil32(32 * _54952)] = mem[_54148 + _54864 + 32 len ceil32(32 * _54952)]
    mem[mem[64]] = 32
    _59392 = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390]
    mem[mem[64] + 64 len 32 * _59392] = mem[ceil32(32 * ('cd', 4).length) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422 len 32 * _59392]
    return 32, mem[mem[64] + 32 len (32 * _59392) + 32]
}



}

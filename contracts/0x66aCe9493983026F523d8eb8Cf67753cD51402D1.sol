contract main {




// =====================  Runtime code  =====================


#
#  - deposit(address arg1, uint256 arg2, uint256 arg3)
#  - initialize(address arg1, uint256 arg2, address arg3, address arg4)
#  - withdraw(address arg1, uint256 arg2, uint256 arg3)
#  - withdrawAVAX(address arg1, uint256 arg2, uint256 arg3)
#  - _fallback()
#
address owner;
uint8 paused;
address token0Address;
address token1Address;
uint256 sub_9ddc230a;
uint256 sub_3266f45c;
address lpTokenAddress;
address masterChefAddress;
uint32 stor207;
uint256 stor207; offset 32
uint256 poolId;
address treasuryAddress;
address stor209;
uint256 sub_b1a41085;
uint256 sub_0b55d7c3;
uint256 sub_c8af9d6a;
mapping of uint256 sub_be892f00;
mapping of struct userInfo;

function sub_0b55d7c3(?) {
    return sub_0b55d7c3
}

function token0() {
    return token0Address
}

function userInfo(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userInfo[arg1].field_0, userInfo[arg1].field_256
}

function sub_3266f45c(?) {
    return sub_3266f45c
}

function poolId() {
    return poolId
}

function getUserBalance(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return userInfo[address(arg1)].field_0
}

function masterChef() {
    return masterChefAddress
}

function paused() {
    return bool(paused)
}

function lpToken() {
    return lpTokenAddress
}

function treasury() {
    return treasuryAddress
}

function owner() {
    return owner
}

function sub_9ddc230a(?) {
    return sub_9ddc230a
}

function sub_b1a41085(?) {
    return sub_b1a41085
}

function sub_be892f00(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_be892f00[address(arg1)]
}

function sub_c8af9d6a(?) {
    return sub_c8af9d6a
}

function token1() {
    return token1Address
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_a99c5da2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_0b55d7c3 = arg1
}

function setBot(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor209 = arg1
}

function setTreasury(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    treasuryAddress = arg1
}

function pauseContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpauseContract() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function setYieldFeePerc(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 3000:
        revert with 0, 'Invalid yield fee percentage'
    sub_b1a41085 = arg1
}

function getAllPool() {
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args poolId, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function getUserPendingReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
        revert with 0, 17
    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
        revert with 0, 17
    return ((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256)
}

function sub_616094a7(?) {
    mem[96] = 0xffcd426300000000000000000000000000000000000000000000000000000000
    mem[100] = poolId
    mem[132] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.pendingTokens(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args poolId, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 128
    _4 = mem[96 len 4], Mask(224, 0, stor207.field_32)
    require uint32(stor207.field_0), Mask(224, 32, this.address) >> 32 == Mask(160, 32, this.address) >> 32
    _6 = uint32(this.address), mem[164 len 28]
    require uint32(this.address), mem[164 len 28] <= test266151307()
    require uint32(this.address), mem[164 len 28] + 127 < return_data.size + 96
    _7 = mem[uint32(this.address), mem[164 len 28] + 96]
    if mem[uint32(this.address), mem[164 len 28] + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[uint32(this.address), mem[164 len 28] + 96])) + 97
    mem[ceil32(return_data.size) + 96] = _7
    require _6 + _7 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 128 len ceil32(_7)] = mem[_6 + 128 len ceil32(_7)]
    if ceil32(_7) <= _7:
        _25 = mem[192]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _31 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if _4 > !mem[_31]:
            revert with 0, 17
        mem[mem[64]] = _4 + mem[_31]
        return mem[mem[64]], _25
    mem[_7 + ceil32(return_data.size) + 128] = 0
    _26 = mem[192]
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
    staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _32 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if _4 > !mem[_32]:
        revert with 0, 17
    mem[mem[64]] = _4 + mem[_32]
    return mem[mem[64]], _26
}

function harvest() {
    require ext_code.size(masterChefAddress)
    call masterChefAddress.withdraw(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args poolId, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[132] = 0
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args 24, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[100] = this.address
    require ext_code.size(0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66)
    staticcall 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 10^16:
        mem[ceil32(return_data.size) + 100] = this.address
        require ext_code.size(token0Address)
        staticcall token0Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1065 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _1069 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = _1069
            require _1065 + (32 * _1069) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1069)] = mem[(4 * ceil32(return_data.size)) + _1065 + 224 len ceil32(32 * _1069)]
            if 1 >= _1069:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] > 25 * 10^16:
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2072 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2076 = mem[_2072]
                if mem[_2072] and sub_b1a41085 > -1 / mem[_2072]:
                    revert with 0, 17
                _2108 = mem[64]
                mem[mem[64] + 36] = treasuryAddress
                mem[mem[64] + 68] = _2076 * sub_b1a41085 / 10000
                _2117 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_2108 + 100] = 32
                mem[_2108 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _2145 = mem[_2117]
                mem[_2108 + 164 len ceil32(mem[_2117])] = mem[_2117 + 32 len ceil32(mem[_2117])]
                if ceil32(_2145) > _2145:
                    mem[_2145 + _2108 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_2108 + 168 len _2145 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), 0 == bool(uint32(this.address), 0)
                        if not uint32(this.address), 0:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_2108 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_2108 + 196] == bool(mem[_2108 + 196])
                        if not mem[_2108 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _2076 < _2076 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, _2076 - (_2076 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                        gas gas_remaining wei
                       args poolId, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _2076 - (_2076 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _2076) - (1000000000000000000 * 10^18 * _2076 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _2076) - (1000000000000000000 * 10^18 * _2076 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _2076 - (_2076 * sub_b1a41085 / 10000), _2076 * sub_b1a41085 / 10000);
        else:
            if ext_call.return_data[0] <= 10^15:
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1066 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1070 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _1070
                require _1066 + (32 * _1070) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1070)] = mem[(4 * ceil32(return_data.size)) + _1066 + 224 len ceil32(32 * _1070)]
                if 1 >= _1070:
                    revert with 0, 50
                if mem[(6 * ceil32(return_data.size)) + 256] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2073 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2077 = mem[_2073]
                    if mem[_2073] and sub_b1a41085 > -1 / mem[_2073]:
                        revert with 0, 17
                    _2109 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _2077 * sub_b1a41085 / 10000
                    _2119 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_2109 + 100] = 32
                    mem[_2109 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _2147 = mem[_2119]
                    mem[_2109 + 164 len ceil32(mem[_2119])] = mem[_2119 + 32 len ceil32(mem[_2119])]
                    if ceil32(_2147) > _2147:
                        mem[_2147 + _2109 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_2109 + 168 len _2147 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), 0 == bool(uint32(this.address), 0)
                            if not uint32(this.address), 0:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_2109 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_2109 + 196] == bool(mem[_2109 + 196])
                            if not mem[_2109 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _2077 < _2077 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, _2077 - (_2077 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _2077 - (_2077 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _2077) - (1000000000000000000 * 10^18 * _2077 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _2077) - (1000000000000000000 * 10^18 * _2077 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(ext_call.return_data[0], _2077 - (_2077 * sub_b1a41085 / 10000), _2077 * sub_b1a41085 / 10000);
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 260] = 0
                mem[(2 * ceil32(return_data.size)) + 292] = 160
                mem[(2 * ceil32(return_data.size)) + 388] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 420
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(2 * ceil32(return_data.size)) + 324] = this.address
                mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1067 = mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28]
                require mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                _1071 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225
                mem[(4 * ceil32(return_data.size)) + 224] = _1071
                require _1067 + (32 * _1071) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 256 len ceil32(32 * _1071)] = mem[(2 * ceil32(return_data.size)) + _1067 + 256 len ceil32(32 * _1071)]
                if 2 >= _1071:
                    revert with 0, 50
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2070 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2074 = mem[_2070]
                _2082 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2082]:
                    revert with 0, 50
                mem[_2082 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_2082]:
                    revert with 0, 50
                mem[_2082 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_2082 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_2082 + 100] = _2074
                mem[_2082 + 132] = 64
                mem[_2082 + 164] = mem[_2082]
                idx = 0
                s = _2082 + 32
                t = _2082 + 196
                while idx < mem[_2082]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _2082 + (32 * mem[_2082]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3033 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3037 = mem[_3033]
                require mem[_3033] <= test266151307()
                require _3033 + mem[_3033] + 31 < _3033 + return_data.size
                _3065 = mem[_3033 + mem[_3033]]
                if mem[_3033 + mem[_3033]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3033 + mem[_3033]]) + 1 < 0 or _3033 + ceil32(return_data.size) + ceil32(32 * mem[_3033 + mem[_3033]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3033 + ceil32(return_data.size) + ceil32(32 * mem[_3033 + mem[_3033]]) + 1
                mem[_3033 + ceil32(return_data.size)] = _3065
                require _3037 + (32 * _3065) + 32 <= return_data.size
                mem[_3033 + ceil32(return_data.size) + 32 len ceil32(32 * _3065)] = mem[_3033 + _3037 + 32 len ceil32(32 * _3065)]
                if 1 >= _3065:
                    revert with 0, 50
                if mem[_3033 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                         gas gas_remaining wei
                        args _2074
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3938 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3942 = mem[_3938]
                    if mem[_3938] and sub_b1a41085 > -1 / mem[_3938]:
                        revert with 0, 17
                    _3954 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _3942 * sub_b1a41085 / 10000
                    _3958 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_3954 + 100] = 32
                    mem[_3954 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _3982 = mem[_3958]
                    mem[_3954 + 164 len ceil32(mem[_3958])] = mem[_3958 + 32 len ceil32(mem[_3958])]
                    if ceil32(_3982) > _3982:
                        mem[_3982 + _3954 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_3954 + 168 len _3982 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_3954 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_3954 + 196] == bool(mem[_3954 + 196])
                            if not mem[_3954 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _3942 < _3942 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, _3942 - (_3942 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _3942 - (_3942 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3942) - (1000000000000000000 * 10^18 * _3942 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _3942) - (1000000000000000000 * 10^18 * _3942 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_2074, _3942 - (_3942 * sub_b1a41085 / 10000), _3942 * sub_b1a41085 / 10000);
    else:
        mem[ceil32(return_data.size) + 96] = 2
        mem[ceil32(return_data.size) + 128] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[ceil32(return_data.size) + 160] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        mem[ceil32(return_data.size) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 228] = 0
        mem[ceil32(return_data.size) + 260] = 160
        mem[ceil32(return_data.size) + 356] = 2
        idx = 0
        s = ceil32(return_data.size) + 128
        t = ceil32(return_data.size) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[ceil32(return_data.size) + 292] = this.address
        mem[ceil32(return_data.size) + 324] = block.timestamp
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (2 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _1068 = mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28]
        require mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 223 < ceil32(return_data.size) + return_data.size + 192
        _1072 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
        if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
            revert with 0, 65
        mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
        mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
        require _1068 + (32 * _1072) + 32 <= return_data.size
        mem[(2 * ceil32(return_data.size)) + 224 len ceil32(32 * _1072)] = mem[ceil32(return_data.size) + _1068 + 224 len ceil32(32 * _1072)]
        if 1 >= _1072:
            revert with 0, 50
        mem[mem[64] + 4] = this.address
        require ext_code.size(token0Address)
        staticcall token0Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2071 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2075 = mem[_2071]
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            mem[mem[64] + 4] = this.address
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2090 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2098 = mem[_2090]
            _2111 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            if 0 >= mem[_2111]:
                revert with 0, 50
            mem[_2111 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            if 1 >= mem[_2111]:
                revert with 0, 50
            mem[_2111 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[_2111 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[_2111 + 100] = _2098
            mem[_2111 + 132] = 64
            mem[_2111 + 164] = mem[_2111]
            idx = 0
            s = _2111 + 32
            t = _2111 + 196
            while idx < mem[_2111]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4 len _2111 + (32 * mem[_2111]) + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3034 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3038 = mem[_3034]
            require mem[_3034] <= test266151307()
            require _3034 + mem[_3034] + 31 < _3034 + return_data.size
            _3066 = mem[_3034 + mem[_3034]]
            if mem[_3034 + mem[_3034]] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[_3034 + mem[_3034]]) + 1 < 0 or _3034 + ceil32(return_data.size) + ceil32(32 * mem[_3034 + mem[_3034]]) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _3034 + ceil32(return_data.size) + ceil32(32 * mem[_3034 + mem[_3034]]) + 1
            mem[_3034 + ceil32(return_data.size)] = _3066
            require _3038 + (32 * _3066) + 32 <= return_data.size
            mem[_3034 + ceil32(return_data.size) + 32 len ceil32(32 * _3066)] = mem[_3034 + _3038 + 32 len ceil32(32 * _3066)]
            if 1 >= _3066:
                revert with 0, 50
            if mem[_3034 + ceil32(return_data.size) + 64] > 25 * 10^16:
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                     gas gas_remaining wei
                    args _2098
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3939 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3943 = mem[_3939]
                if mem[_3939] and sub_b1a41085 > -1 / mem[_3939]:
                    revert with 0, 17
                _3955 = mem[64]
                mem[mem[64] + 36] = treasuryAddress
                mem[mem[64] + 68] = _3943 * sub_b1a41085 / 10000
                _3960 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_3955 + 100] = 32
                mem[_3955 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _3984 = mem[_3960]
                mem[_3955 + 164 len ceil32(mem[_3960])] = mem[_3960 + 32 len ceil32(mem[_3960])]
                if ceil32(_3984) > _3984:
                    mem[_3984 + _3955 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_3955 + 168 len _3984 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_3955 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_3955 + 196] == bool(mem[_3955 + 196])
                        if not mem[_3955 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _3943 < _3943 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, _3943 - (_3943 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                        gas gas_remaining wei
                       args poolId, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _3943 - (_3943 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3943) - (1000000000000000000 * 10^18 * _3943 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _3943) - (1000000000000000000 * 10^18 * _3943 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(_2098, _3943 - (_3943 * sub_b1a41085 / 10000), _3943 * sub_b1a41085 / 10000);
        else:
            if mem[_2071] <= 10^15:
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2093 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2104 = mem[_2093]
                _2122 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_2122]:
                    revert with 0, 50
                mem[_2122 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_2122]:
                    revert with 0, 50
                mem[_2122 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_2122 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_2122 + 100] = _2104
                mem[_2122 + 132] = 64
                mem[_2122 + 164] = mem[_2122]
                idx = 0
                s = _2122 + 32
                t = _2122 + 196
                while idx < mem[_2122]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _2122 + (32 * mem[_2122]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3035 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3039 = mem[_3035]
                require mem[_3035] <= test266151307()
                require _3035 + mem[_3035] + 31 < _3035 + return_data.size
                _3067 = mem[_3035 + mem[_3035]]
                if mem[_3035 + mem[_3035]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3035 + mem[_3035]]) + 1 < 0 or _3035 + ceil32(return_data.size) + ceil32(32 * mem[_3035 + mem[_3035]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3035 + ceil32(return_data.size) + ceil32(32 * mem[_3035 + mem[_3035]]) + 1
                mem[_3035 + ceil32(return_data.size)] = _3067
                require _3039 + (32 * _3067) + 32 <= return_data.size
                mem[_3035 + ceil32(return_data.size) + 32 len ceil32(32 * _3067)] = mem[_3035 + _3039 + 32 len ceil32(32 * _3067)]
                if 1 >= _3067:
                    revert with 0, 50
                if mem[_3035 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                         gas gas_remaining wei
                        args _2104
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3940 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3944 = mem[_3940]
                    if mem[_3940] and sub_b1a41085 > -1 / mem[_3940]:
                        revert with 0, 17
                    _3956 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _3944 * sub_b1a41085 / 10000
                    _3962 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_3956 + 100] = 32
                    mem[_3956 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _3986 = mem[_3962]
                    mem[_3956 + 164 len ceil32(mem[_3962])] = mem[_3962 + 32 len ceil32(mem[_3962])]
                    if ceil32(_3986) > _3986:
                        mem[_3986 + _3956 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_3956 + 168 len _3986 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_3956 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_3956 + 196] == bool(mem[_3956 + 196])
                            if not mem[_3956 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _3944 < _3944 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, _3944 - (_3944 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _3944 - (_3944 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _3944) - (1000000000000000000 * 10^18 * _3944 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _3944) - (1000000000000000000 * 10^18 * _3944 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_2104, _3944 - (_3944 * sub_b1a41085 / 10000), _3944 * sub_b1a41085 / 10000);
            else:
                _2091 = mem[64]
                mem[mem[64]] = 3
                mem[64] = mem[64] + 128
                if 0 >= mem[_2091]:
                    revert with 0, 50
                mem[_2091 + 32] = token0Address
                if 1 >= mem[_2091]:
                    revert with 0, 50
                mem[_2091 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                if 2 >= mem[_2091]:
                    revert with 0, 50
                mem[_2091 + 96] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                mem[_2091 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_2091 + 132] = _2075
                mem[_2091 + 164] = 0
                mem[_2091 + 196] = 160
                mem[_2091 + 292] = mem[_2091]
                idx = 0
                s = _2091 + 32
                t = _2091 + 324
                while idx < mem[_2091]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_2091 + 228] = this.address
                mem[_2091 + 260] = block.timestamp
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                call ????????????????????????????????????????.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _2091 + (32 * mem[_2091]) + -mem[64] + 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3036 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3040 = mem[_3036]
                require mem[_3036] <= test266151307()
                require _3036 + mem[_3036] + 31 < _3036 + return_data.size
                _3068 = mem[_3036 + mem[_3036]]
                if mem[_3036 + mem[_3036]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_3036 + mem[_3036]]) + 1 < 0 or _3036 + ceil32(return_data.size) + ceil32(32 * mem[_3036 + mem[_3036]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _3036 + ceil32(return_data.size) + ceil32(32 * mem[_3036 + mem[_3036]]) + 1
                mem[_3036 + ceil32(return_data.size)] = _3068
                require _3040 + (32 * _3068) + 32 <= return_data.size
                mem[_3036 + ceil32(return_data.size) + 32 len ceil32(32 * _3068)] = mem[_3036 + _3040 + 32 len ceil32(32 * _3068)]
                if 2 >= _3068:
                    revert with 0, 50
                mem[mem[64] + 4] = this.address
                require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
                staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3937 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3941 = mem[_3937]
                _3949 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_3949]:
                    revert with 0, 50
                mem[_3949 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
                if 1 >= mem[_3949]:
                    revert with 0, 50
                mem[_3949 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[_3949 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[_3949 + 100] = _3941
                mem[_3949 + 132] = 64
                mem[_3949 + 164] = mem[_3949]
                idx = 0
                s = _3949 + 32
                t = _3949 + 196
                while idx < mem[_3949]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4 len _3949 + (32 * mem[_3949]) + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4526 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _4527 = mem[_4526]
                require mem[_4526] <= test266151307()
                require _4526 + mem[_4526] + 31 < _4526 + return_data.size
                _4564 = mem[_4526 + mem[_4526]]
                if mem[_4526 + mem[_4526]] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[_4526 + mem[_4526]]) + 1 < 0 or _4526 + ceil32(return_data.size) + ceil32(32 * mem[_4526 + mem[_4526]]) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _4526 + ceil32(return_data.size) + ceil32(32 * mem[_4526 + mem[_4526]]) + 1
                mem[_4526 + ceil32(return_data.size)] = _4564
                require _4527 + (32 * _4564) + 32 <= return_data.size
                mem[_4526 + ceil32(return_data.size) + 32 len ceil32(32 * _4564)] = mem[_4526 + _4527 + 32 len ceil32(32 * _4564)]
                if 1 >= _4564:
                    revert with 0, 50
                if mem[_4526 + ceil32(return_data.size) + 64] > 25 * 10^16:
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                         gas gas_remaining wei
                        args _3941
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
                    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5077 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5078 = mem[_5077]
                    if mem[_5077] and sub_b1a41085 > -1 / mem[_5077]:
                        revert with 0, 17
                    _5079 = mem[64]
                    mem[mem[64] + 36] = treasuryAddress
                    mem[mem[64] + 68] = _5078 * sub_b1a41085 / 10000
                    _5080 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_5079 + 100] = 32
                    mem[_5079 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _5087 = mem[_5080]
                    mem[_5079 + 164 len ceil32(mem[_5080])] = mem[_5080 + 32 len ceil32(mem[_5080])]
                    if ceil32(_5087) > _5087:
                        mem[_5087 + _5079 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_5079 + 168 len _5087 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_5079 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_5079 + 196] == bool(mem[_5079 + 196])
                            if not mem[_5079 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if _5078 < _5078 * sub_b1a41085 / 10000:
                        revert with 0, 17
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, _5078 - (_5078 * sub_b1a41085 / 10000)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(masterChefAddress)
                    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                            gas gas_remaining wei
                           args poolId, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 64
                    if _5078 - (_5078 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _5078) - (1000000000000000000 * 10^18 * _5078 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                        revert with 0, 17
                    sub_c8af9d6a += (1000000000000000000 * 10^18 * _5078) - (1000000000000000000 * 10^18 * _5078 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                    emit Harvest(_3941, _5078 - (_5078 * sub_b1a41085 / 10000), _5078 * sub_b1a41085 / 10000);
}

function claimReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(masterChefAddress)
    call masterChefAddress.withdraw(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args poolId, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[132] = 0
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args 24, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[100] = this.address
    require ext_code.size(0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66)
    staticcall 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 10^16:
        mem[ceil32(return_data.size) + 100] = this.address
        require ext_code.size(token0Address)
        staticcall token0Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _5173 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _5177 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = _5177
            require _5173 + (32 * _5177) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _5177)] = mem[(4 * ceil32(return_data.size)) + _5173 + 224 len ceil32(32 * _5177)]
            if 1 >= _5177:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] <= 25 * 10^16:
                mem[0] = arg1
                mem[32] = 214
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _11057 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        _11061 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_11057 + 100] = 32
                        mem[_11057 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        _11101 = mem[_11061]
                        mem[_11057 + 164 len ceil32(mem[_11061])] = mem[_11061 + 32 len ceil32(mem[_11061])]
                        if ceil32(_11101) > _11101:
                            mem[_11101 + _11057 + 164] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                             gas gas_remaining wei
                            args mem[_11057 + 168 len _11101 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11057 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11057 + 196] == bool(mem[_11057 + 196])
                                if not mem[_11057 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                 gas gas_remaining wei
                args ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10994 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10998 = mem[_10994]
            if mem[_10994] and sub_b1a41085 > -1 / mem[_10994]:
                revert with 0, 17
            _11030 = mem[64]
            mem[mem[64] + 36] = treasuryAddress
            mem[mem[64] + 68] = _10998 * sub_b1a41085 / 10000
            _11041 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_11030 + 100] = 32
            mem[_11030 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            _11079 = mem[_11041]
            mem[_11030 + 164 len ceil32(mem[_11041])] = mem[_11041 + 32 len ceil32(mem[_11041])]
            if ceil32(_11079) > _11079:
                mem[_11079 + _11030 + 164] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                 gas gas_remaining wei
                args mem[_11030 + 168 len _11079 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _10998 < _10998 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, _10998 - (_10998 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11030 + 200] = this.address
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                        gas gas_remaining wei
                       args poolId, this.address
                mem[_11030 + 164 len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _10998 - (_10998 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _10998) - (1000000000000000000 * 10^18 * _10998 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _10998) - (1000000000000000000 * 10^18 * _10998 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _10998 - (_10998 * sub_b1a41085 / 10000), _10998 * sub_b1a41085 / 10000);
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_11030 + ceil32(return_data.size) + 200] = arg1
                        mem[_11030 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        mem[_11030 + ceil32(return_data.size) + 164] = 68
                        mem[_11030 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                        mem[_11030 + ceil32(return_data.size) + 264] = 32
                        mem[_11030 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        mem[_11030 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                        mem[_11030 + ceil32(return_data.size) + 396] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11030 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11030 + ceil32(return_data.size) + 360] == bool(mem[_11030 + ceil32(return_data.size) + 360])
                                if not mem[_11030 + ceil32(return_data.size) + 360]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11030 + 164] = return_data.size
            mem[_11030 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[_11030 + 196] == bool(mem[_11030 + 196])
                if not mem[_11030 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _10998 < _10998 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, _10998 - (_10998 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11030 + ceil32(return_data.size) + 201] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_11030 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _10998 - (_10998 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _10998) - (1000000000000000000 * 10^18 * _10998 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _10998) - (1000000000000000000 * 10^18 * _10998 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(ext_call.return_data[0], _10998 - (_10998 * sub_b1a41085 / 10000), _10998 * sub_b1a41085 / 10000);
            if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
            if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
               funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
            mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11030 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_11030 + (4 * ceil32(return_data.size)) + 334] = 32
                mem[_11030 + (4 * ceil32(return_data.size)) + 366] = 32
                mem[_11030 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
                revert with memory
                  from _11030 + (4 * ceil32(return_data.size)) + 330
                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
            if not return_data.size:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require return_data.size >= 32
            require mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
            if mem[_11030 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11030 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_11030 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_11030 + (4 * ceil32(return_data.size)) + 366] = 42
            mem[_11030 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
            mem[_11030 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
            revert with memory
              from _11030 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
        if ext_call.return_data[0] <= 10^15:
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
            staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args ext_call.return_data[0], Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _5174 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _5178 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = _5178
            require _5174 + (32 * _5178) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _5178)] = mem[(4 * ceil32(return_data.size)) + _5174 + 224 len ceil32(32 * _5178)]
            if 1 >= _5178:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] <= 25 * 10^16:
                mem[0] = arg1
                mem[32] = 214
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _11058 = mem[64]
                        mem[mem[64] + 36] = arg1
                        mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        _11064 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_11058 + 100] = 32
                        mem[_11058 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        _11103 = mem[_11064]
                        mem[_11058 + 164 len ceil32(mem[_11064])] = mem[_11064 + 32 len ceil32(mem[_11064])]
                        if ceil32(_11103) > _11103:
                            mem[_11103 + _11058 + 164] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                             gas gas_remaining wei
                            args mem[_11058 + 168 len _11103 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11058 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11058 + 196] == bool(mem[_11058 + 196])
                                if not mem[_11058 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
                 gas gas_remaining wei
                args ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
            staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _10995 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _10999 = mem[_10995]
            if mem[_10995] and sub_b1a41085 > -1 / mem[_10995]:
                revert with 0, 17
            _11031 = mem[64]
            mem[mem[64] + 36] = treasuryAddress
            mem[mem[64] + 68] = _10999 * sub_b1a41085 / 10000
            _11045 = mem[64]
            mem[mem[64]] = 68
            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
            mem[64] = mem[64] + 164
            mem[_11031 + 100] = 32
            mem[_11031 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            _11081 = mem[_11045]
            mem[_11031 + 164 len ceil32(mem[_11045])] = mem[_11045 + 32 len ceil32(mem[_11045])]
            if ceil32(_11081) > _11081:
                mem[_11081 + _11031 + 164] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                 gas gas_remaining wei
                args mem[_11031 + 168 len _11081 - 4]
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if _10999 < _10999 * sub_b1a41085 / 10000:
                    revert with 0, 17
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, _10999 - (_10999 * sub_b1a41085 / 10000)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11031 + 200] = this.address
                require ext_code.size(masterChefAddress)
                staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                        gas gas_remaining wei
                       args poolId, this.address
                mem[_11031 + 164 len 64] = ext_call.return_data[0 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 64
                if _10999 - (_10999 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _10999) - (1000000000000000000 * 10^18 * _10999 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                    revert with 0, 17
                sub_c8af9d6a += (1000000000000000000 * 10^18 * _10999) - (1000000000000000000 * 10^18 * _10999 * sub_b1a41085 / 10000) / ext_call.return_data[0]
                emit Harvest(ext_call.return_data[0], _10999 - (_10999 * sub_b1a41085 / 10000), _10999 * sub_b1a41085 / 10000);
                if userInfo[address(arg1)].field_0:
                    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                        revert with 0, 17
                    if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_11031 + ceil32(return_data.size) + 200] = arg1
                        mem[_11031 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        mem[_11031 + ceil32(return_data.size) + 164] = 68
                        mem[_11031 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                        mem[_11031 + ceil32(return_data.size) + 264] = 32
                        mem[_11031 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                            revert with 0, 'Address: call to non-contract'
                        mem[_11031 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                        mem[_11031 + ceil32(return_data.size) + 396] = 0
                        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), 0 == bool(uint32(this.address), 0)
                                if not uint32(this.address), 0:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_11031 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_11031 + ceil32(return_data.size) + 360] == bool(mem[_11031 + ceil32(return_data.size) + 360])
                                if not mem[_11031 + ceil32(return_data.size) + 360]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                            revert with 0, 17
                        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11031 + 164] = return_data.size
            mem[_11031 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[_11031 + 196] == bool(mem[_11031 + 196])
                if not mem[_11031 + 196]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _10999 < _10999 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, _10999 - (_10999 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11031 + ceil32(return_data.size) + 201] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_11031 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _10999 - (_10999 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _10999) - (1000000000000000000 * 10^18 * _10999 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _10999) - (1000000000000000000 * 10^18 * _10999 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(ext_call.return_data[0], _10999 - (_10999 * sub_b1a41085 / 10000), _10999 * sub_b1a41085 / 10000);
            if not userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
            if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                revert with 0, 'Address: call to non-contract'
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
            call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
               funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), 0 == bool(uint32(this.address), 0)
                    if not uint32(this.address), 0:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
            mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_11031 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[_11031 + (4 * ceil32(return_data.size)) + 334] = 32
                mem[_11031 + (4 * ceil32(return_data.size)) + 366] = 32
                mem[_11031 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
                revert with memory
                  from _11031 + (4 * ceil32(return_data.size)) + 330
                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
            if not return_data.size:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            require return_data.size >= 32
            require mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
            if mem[_11031 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
            mem[_11031 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_11031 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_11031 + (4 * ceil32(return_data.size)) + 366] = 42
            mem[_11031 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
            mem[_11031 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
            revert with memory
              from _11031 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
        mem[(2 * ceil32(return_data.size)) + 96] = 3
        mem[(2 * ceil32(return_data.size)) + 128] = token0Address
        mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[(2 * ceil32(return_data.size)) + 192] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 260] = 0
        mem[(2 * ceil32(return_data.size)) + 292] = 160
        mem[(2 * ceil32(return_data.size)) + 388] = 3
        idx = 0
        s = (2 * ceil32(return_data.size)) + 128
        t = (2 * ceil32(return_data.size)) + 420
        while idx < 3:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(2 * ceil32(return_data.size)) + 324] = this.address
        mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 224
        require return_data.size >= 32
        _5175 = mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28]
        require mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
        _5179 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]
        if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225 > test266151307():
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], ext_call.return_data[0 len 28] + 224]) + 225
        mem[(4 * ceil32(return_data.size)) + 224] = _5179
        require _5175 + (32 * _5179) + 32 <= return_data.size
        mem[(4 * ceil32(return_data.size)) + 256 len ceil32(32 * _5179)] = mem[(2 * ceil32(return_data.size)) + _5175 + 256 len ceil32(32 * _5179)]
        if 2 >= _5179:
            revert with 0, 50
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _10992 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _10996 = mem[_10992]
        _11004 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11004]:
            revert with 0, 50
        mem[_11004 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11004]:
            revert with 0, 50
        mem[_11004 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11004 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11004 + 100] = _10996
        mem[_11004 + 132] = 64
        mem[_11004 + 164] = mem[_11004]
        idx = 0
        s = _11004 + 32
        t = _11004 + 196
        while idx < mem[_11004]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11004 + (32 * mem[_11004]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16823 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16827 = mem[_16823]
        require mem[_16823] <= test266151307()
        require _16823 + mem[_16823] + 31 < _16823 + return_data.size
        _16879 = mem[_16823 + mem[_16823]]
        if mem[_16823 + mem[_16823]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16823 + mem[_16823]]) + 1 < 0 or _16823 + ceil32(return_data.size) + ceil32(32 * mem[_16823 + mem[_16823]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16823 + ceil32(return_data.size) + ceil32(32 * mem[_16823 + mem[_16823]]) + 1
        mem[_16823 + ceil32(return_data.size)] = _16879
        require _16827 + (32 * _16879) + 32 <= return_data.size
        mem[_16823 + ceil32(return_data.size) + 32 len ceil32(32 * _16879)] = mem[_16823 + _16827 + 32 len ceil32(32 * _16879)]
        if 1 >= _16879:
            revert with 0, 50
        if mem[_16823 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23719 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _23723 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23719 + 100] = 32
                    mem[_23719 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _23896 = mem[_23723]
                    mem[_23719 + 164 len ceil32(mem[_23723])] = mem[_23723 + 32 len ceil32(mem[_23723])]
                    if ceil32(_23896) > _23896:
                        mem[_23896 + _23719 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23719 + 168 len _23896 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23719 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23719 + 196] == bool(mem[_23719 + 196])
                            if not mem[_23719 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
             gas gas_remaining wei
            args _10996
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22723 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _22919 = mem[_22723]
        if mem[_22723] and sub_b1a41085 > -1 / mem[_22723]:
            revert with 0, 17
        _23443 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _22919 * sub_b1a41085 / 10000
        _23513 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23443 + 100] = 32
        mem[_23443 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _23873 = mem[_23513]
        mem[_23443 + 164 len ceil32(mem[_23513])] = mem[_23513 + 32 len ceil32(mem[_23513])]
        if ceil32(_23873) > _23873:
            mem[_23873 + _23443 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23443 + 168 len _23873 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _22919 < _22919 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, _22919 - (_22919 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23443 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23443 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _22919 - (_22919 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22919) - (1000000000000000000 * 10^18 * _22919 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _22919) - (1000000000000000000 * 10^18 * _22919 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_10996, _22919 - (_22919 * sub_b1a41085 / 10000), _22919 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23443 + ceil32(return_data.size) + 200] = arg1
                    mem[_23443 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23443 + ceil32(return_data.size) + 164] = 68
                    mem[_23443 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23443 + ceil32(return_data.size) + 264] = 32
                    mem[_23443 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23443 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23443 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23443 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23443 + ceil32(return_data.size) + 360] == bool(mem[_23443 + ceil32(return_data.size) + 360])
                            if not mem[_23443 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23443 + 164] = return_data.size
        mem[_23443 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23443 + 196] == bool(mem[_23443 + 196])
            if not mem[_23443 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _22919 < _22919 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, _22919 - (_22919 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23443 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23443 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _22919 - (_22919 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22919) - (1000000000000000000 * 10^18 * _22919 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _22919) - (1000000000000000000 * 10^18 * _22919 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_10996, _22919 - (_22919 * sub_b1a41085 / 10000), _22919 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23443 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23443 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23443 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23443 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23443 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23443 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23443 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23443 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23443 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23443 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23443 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23443 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    mem[ceil32(return_data.size) + 96] = 2
    mem[ceil32(return_data.size) + 128] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    mem[ceil32(return_data.size) + 160] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    mem[ceil32(return_data.size) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 228] = 0
    mem[ceil32(return_data.size) + 260] = 160
    mem[ceil32(return_data.size) + 356] = 2
    idx = 0
    s = ceil32(return_data.size) + 128
    t = ceil32(return_data.size) + 388
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[ceil32(return_data.size) + 292] = this.address
    mem[ceil32(return_data.size) + 324] = block.timestamp
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    call ????????????????????????????????????????.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (2 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _5176 = mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28]
    require mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
    require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 223 < ceil32(return_data.size) + return_data.size + 192
    _5180 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
    if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0 or (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307():
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
    mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], ext_call.return_data[0 len 28] + 192]
    require _5176 + (32 * _5180) + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 224 len ceil32(32 * _5180)] = mem[ceil32(return_data.size) + _5176 + 224 len ceil32(32 * _5180)]
    if 1 >= _5180:
        revert with 0, 50
    mem[mem[64] + 4] = this.address
    require ext_code.size(token0Address)
    staticcall token0Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _10993 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _10997 = mem[_10993]
    if lpTokenAddress != 0xb674f93952f02f2538214d4572aa47f262e990ff:
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11012 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11020 = mem[_11012]
        _11033 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11033]:
            revert with 0, 50
        mem[_11033 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11033]:
            revert with 0, 50
        mem[_11033 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11033 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11033 + 100] = _11020
        mem[_11033 + 132] = 64
        mem[_11033 + 164] = mem[_11033]
        idx = 0
        s = _11033 + 32
        t = _11033 + 196
        while idx < mem[_11033]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11033 + (32 * mem[_11033]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16824 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16828 = mem[_16824]
        require mem[_16824] <= test266151307()
        require _16824 + mem[_16824] + 31 < _16824 + return_data.size
        _16880 = mem[_16824 + mem[_16824]]
        if mem[_16824 + mem[_16824]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16824 + mem[_16824]]) + 1 < 0 or _16824 + ceil32(return_data.size) + ceil32(32 * mem[_16824 + mem[_16824]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16824 + ceil32(return_data.size) + ceil32(32 * mem[_16824 + mem[_16824]]) + 1
        mem[_16824 + ceil32(return_data.size)] = _16880
        require _16828 + (32 * _16880) + 32 <= return_data.size
        mem[_16824 + ceil32(return_data.size) + 32 len ceil32(32 * _16880)] = mem[_16824 + _16828 + 32 len ceil32(32 * _16880)]
        if 1 >= _16880:
            revert with 0, 50
        if mem[_16824 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23720 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _23726 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23720 + 100] = 32
                    mem[_23720 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _23898 = mem[_23726]
                    mem[_23720 + 164 len ceil32(mem[_23726])] = mem[_23726 + 32 len ceil32(mem[_23726])]
                    if ceil32(_23898) > _23898:
                        mem[_23898 + _23720 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23720 + 168 len _23898 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23720 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23720 + 196] == bool(mem[_23720 + 196])
                            if not mem[_23720 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
             gas gas_remaining wei
            args _11020
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22724 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _22920 = mem[_22724]
        if mem[_22724] and sub_b1a41085 > -1 / mem[_22724]:
            revert with 0, 17
        _23444 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _22920 * sub_b1a41085 / 10000
        _23517 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23444 + 100] = 32
        mem[_23444 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _23875 = mem[_23517]
        mem[_23444 + 164 len ceil32(mem[_23517])] = mem[_23517 + 32 len ceil32(mem[_23517])]
        if ceil32(_23875) > _23875:
            mem[_23875 + _23444 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23444 + 168 len _23875 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _22920 < _22920 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, _22920 - (_22920 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23444 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23444 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _22920 - (_22920 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22920) - (1000000000000000000 * 10^18 * _22920 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _22920) - (1000000000000000000 * 10^18 * _22920 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_11020, _22920 - (_22920 * sub_b1a41085 / 10000), _22920 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23444 + ceil32(return_data.size) + 200] = arg1
                    mem[_23444 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23444 + ceil32(return_data.size) + 164] = 68
                    mem[_23444 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23444 + ceil32(return_data.size) + 264] = 32
                    mem[_23444 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23444 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23444 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23444 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23444 + ceil32(return_data.size) + 360] == bool(mem[_23444 + ceil32(return_data.size) + 360])
                            if not mem[_23444 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23444 + 164] = return_data.size
        mem[_23444 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23444 + 196] == bool(mem[_23444 + 196])
            if not mem[_23444 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _22920 < _22920 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, _22920 - (_22920 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23444 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23444 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _22920 - (_22920 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22920) - (1000000000000000000 * 10^18 * _22920 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _22920) - (1000000000000000000 * 10^18 * _22920 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_11020, _22920 - (_22920 * sub_b1a41085 / 10000), _22920 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23444 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23444 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23444 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23444 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23444 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23444 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23444 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23444 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23444 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23444 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23444 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23444 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    if mem[_10993] <= 10^15:
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
        staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _11015 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _11026 = mem[_11015]
        _11048 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        if 0 >= mem[_11048]:
            revert with 0, 50
        mem[_11048 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
        if 1 >= mem[_11048]:
            revert with 0, 50
        mem[_11048 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
        mem[_11048 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[_11048 + 100] = _11026
        mem[_11048 + 132] = 64
        mem[_11048 + 164] = mem[_11048]
        idx = 0
        s = _11048 + 32
        t = _11048 + 196
        while idx < mem[_11048]:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
        staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _11048 + (32 * mem[_11048]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _16825 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _16829 = mem[_16825]
        require mem[_16825] <= test266151307()
        require _16825 + mem[_16825] + 31 < _16825 + return_data.size
        _16881 = mem[_16825 + mem[_16825]]
        if mem[_16825 + mem[_16825]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_16825 + mem[_16825]]) + 1 < 0 or _16825 + ceil32(return_data.size) + ceil32(32 * mem[_16825 + mem[_16825]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _16825 + ceil32(return_data.size) + ceil32(32 * mem[_16825 + mem[_16825]]) + 1
        mem[_16825 + ceil32(return_data.size)] = _16881
        require _16829 + (32 * _16881) + 32 <= return_data.size
        mem[_16825 + ceil32(return_data.size) + 32 len ceil32(32 * _16881)] = mem[_16825 + _16829 + 32 len ceil32(32 * _16881)]
        if 1 >= _16881:
            revert with 0, 50
        if mem[_16825 + ceil32(return_data.size) + 64] <= 25 * 10^16:
            mem[0] = arg1
            mem[32] = 214
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23721 = mem[64]
                    mem[mem[64] + 36] = arg1
                    mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    _23729 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_23721 + 100] = 32
                    mem[_23721 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    _23900 = mem[_23729]
                    mem[_23721 + 164 len ceil32(mem[_23729])] = mem[_23729 + 32 len ceil32(mem[_23729])]
                    if ceil32(_23900) > _23900:
                        mem[_23900 + _23721 + 164] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                         gas gas_remaining wei
                        args mem[_23721 + 168 len _23900 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23721 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23721 + 196] == bool(mem[_23721 + 196])
                            if not mem[_23721 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
             gas gas_remaining wei
            args _11026
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
        staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22725 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _22921 = mem[_22725]
        if mem[_22725] and sub_b1a41085 > -1 / mem[_22725]:
            revert with 0, 17
        _23445 = mem[64]
        mem[mem[64] + 36] = treasuryAddress
        mem[mem[64] + 68] = _22921 * sub_b1a41085 / 10000
        _23521 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
        mem[64] = mem[64] + 164
        mem[_23445 + 100] = 32
        mem[_23445 + 132] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        _23877 = mem[_23521]
        mem[_23445 + 164 len ceil32(mem[_23521])] = mem[_23521 + 32 len ceil32(mem[_23521])]
        if ceil32(_23877) > _23877:
            mem[_23877 + _23445 + 164] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
             gas gas_remaining wei
            args mem[_23445 + 168 len _23877 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if _22921 < _22921 * sub_b1a41085 / 10000:
                revert with 0, 17
            require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
            call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 24, _22921 - (_22921 * sub_b1a41085 / 10000)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23445 + 200] = this.address
            require ext_code.size(masterChefAddress)
            staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                    gas gas_remaining wei
                   args poolId, this.address
            mem[_23445 + 164 len 64] = ext_call.return_data[0 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 64
            if _22921 - (_22921 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22921) - (1000000000000000000 * 10^18 * _22921 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
                revert with 0, 17
            sub_c8af9d6a += (1000000000000000000 * 10^18 * _22921) - (1000000000000000000 * 10^18 * _22921 * sub_b1a41085 / 10000) / ext_call.return_data[0]
            emit Harvest(_11026, _22921 - (_22921 * sub_b1a41085 / 10000), _22921 * sub_b1a41085 / 10000);
            if userInfo[address(arg1)].field_0:
                if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                    revert with 0, 17
                if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_23445 + ceil32(return_data.size) + 200] = arg1
                    mem[_23445 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    mem[_23445 + ceil32(return_data.size) + 164] = 68
                    mem[_23445 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                    mem[_23445 + ceil32(return_data.size) + 264] = 32
                    mem[_23445 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                        revert with 0, 'Address: call to non-contract'
                    mem[_23445 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                    mem[_23445 + ceil32(return_data.size) + 396] = 0
                    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_23445 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_23445 + ceil32(return_data.size) + 360] == bool(mem[_23445 + ceil32(return_data.size) + 360])
                            if not mem[_23445 + ceil32(return_data.size) + 360]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                        revert with 0, 17
                    sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                    emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23445 + 164] = return_data.size
        mem[_23445 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[_23445 + 196] == bool(mem[_23445 + 196])
            if not mem[_23445 + 196]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _22921 < _22921 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, _22921 - (_22921 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23445 + ceil32(return_data.size) + 201] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_23445 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _22921 - (_22921 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _22921) - (1000000000000000000 * 10^18 * _22921 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _22921) - (1000000000000000000 * 10^18 * _22921 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_11026, _22921 - (_22921 * sub_b1a41085 / 10000), _22921 * sub_b1a41085 / 10000);
        if not userInfo[address(arg1)].field_0:
        if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
            revert with 0, 17
        if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
            revert with 0, 17
        if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
        if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 'Address: insufficient balance for call'
        if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
            revert with 0, 'Address: call to non-contract'
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
        call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
           funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                require mem[128] == bool(mem[128])
                if not mem[128]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
        mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            mem[_23445 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[_23445 + (4 * ceil32(return_data.size)) + 334] = 32
            mem[_23445 + (4 * ceil32(return_data.size)) + 366] = 32
            mem[_23445 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
            revert with memory
              from _23445 + (4 * ceil32(return_data.size)) + 330
               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
        if not return_data.size:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        require return_data.size >= 32
        require mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
        if mem[_23445 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
            if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                revert with 0, 17
            sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
            emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
        mem[_23445 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_23445 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_23445 + (4 * ceil32(return_data.size)) + 366] = 42
        mem[_23445 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
        mem[_23445 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
        revert with memory
          from _23445 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
    _11013 = mem[64]
    mem[mem[64]] = 3
    mem[64] = mem[64] + 128
    if 0 >= mem[_11013]:
        revert with 0, 50
    mem[_11013 + 32] = token0Address
    if 1 >= mem[_11013]:
        revert with 0, 50
    mem[_11013 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    if 2 >= mem[_11013]:
        revert with 0, 50
    mem[_11013 + 96] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    mem[_11013 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[_11013 + 132] = _10997
    mem[_11013 + 164] = 0
    mem[_11013 + 196] = 160
    mem[_11013 + 292] = mem[_11013]
    idx = 0
    s = _11013 + 32
    t = _11013 + 324
    while idx < mem[_11013]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_11013 + 228] = this.address
    mem[_11013 + 260] = block.timestamp
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    call ????????????????????????????????????????.mem[mem[64] len 4] with:
         gas gas_remaining wei
        args mem[mem[64] + 4 len _11013 + (32 * mem[_11013]) + -mem[64] + 320]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _16826 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _16830 = mem[_16826]
    require mem[_16826] <= test266151307()
    require _16826 + mem[_16826] + 31 < _16826 + return_data.size
    _16882 = mem[_16826 + mem[_16826]]
    if mem[_16826 + mem[_16826]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_16826 + mem[_16826]]) + 1 < 0 or _16826 + ceil32(return_data.size) + ceil32(32 * mem[_16826 + mem[_16826]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _16826 + ceil32(return_data.size) + ceil32(32 * mem[_16826 + mem[_16826]]) + 1
    mem[_16826 + ceil32(return_data.size)] = _16882
    require _16830 + (32 * _16882) + 32 <= return_data.size
    mem[_16826 + ceil32(return_data.size) + 32 len ceil32(32 * _16882)] = mem[_16826 + _16830 + 32 len ceil32(32 * _16882)]
    if 2 >= _16882:
        revert with 0, 50
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd)
    staticcall 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _22658 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _22854 = mem[_22658]
    _22926 = mem[64]
    mem[mem[64]] = 2
    mem[64] = mem[64] + 96
    if 0 >= mem[_22926]:
        revert with 0, 50
    mem[_22926 + 32] = 0x6e84a6216ea6dacc71ee8e6b0a5b7322eebc0fdd
    if 1 >= mem[_22926]:
        revert with 0, 50
    mem[_22926 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
    mem[_22926 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
    mem[_22926 + 100] = _22854
    mem[_22926 + 132] = 64
    mem[_22926 + 164] = mem[_22926]
    idx = 0
    s = _22926 + 32
    t = _22926 + 196
    while idx < mem[_22926]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933)
    staticcall 0xfe00000000000000000000000060ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
            gas gas_remaining wei
           args mem[mem[64] + 4 len _22926 + (32 * mem[_22926]) + -mem[64] + 192]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _27843 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _27844 = mem[_27843]
    require mem[_27843] <= test266151307()
    require _27843 + mem[_27843] + 31 < _27843 + return_data.size
    _27917 = mem[_27843 + mem[_27843]]
    if mem[_27843 + mem[_27843]] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[_27843 + mem[_27843]]) + 1 < 0 or _27843 + ceil32(return_data.size) + ceil32(32 * mem[_27843 + mem[_27843]]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _27843 + ceil32(return_data.size) + ceil32(32 * mem[_27843 + mem[_27843]]) + 1
    mem[_27843 + ceil32(return_data.size)] = _27917
    require _27844 + (32 * _27917) + 32 <= return_data.size
    mem[_27843 + ceil32(return_data.size) + 32 len ceil32(32 * _27917)] = mem[_27843 + _27844 + 32 len ceil32(32 * _27917)]
    if 1 >= _27917:
        revert with 0, 50
    if mem[_27843 + ceil32(return_data.size) + 64] <= 25 * 10^16:
        mem[0] = arg1
        mem[32] = 214
        if userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _33281 = mem[64]
                mem[mem[64] + 36] = arg1
                mem[mem[64] + 68] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                _33282 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                mem[64] = mem[64] + 164
                mem[_33281 + 100] = 32
                mem[_33281 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                _33488 = mem[_33282]
                mem[_33281 + 164 len ceil32(mem[_33282])] = mem[_33282 + 32 len ceil32(mem[_33282])]
                if ceil32(_33488) > _33488:
                    mem[_33488 + _33281 + 164] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                     gas gas_remaining wei
                    args mem[_33281 + 168 len _33488 - 4]
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_33281 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_33281 + 196] == bool(mem[_33281 + 196])
                        if not mem[_33281 + 196]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.enter(uint256 arg1) with:
         gas gas_remaining wei
        args _22854
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[mem[64] + 4] = this.address
    require ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33)
    staticcall 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _31833 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _32122 = mem[_31833]
    if mem[_31833] and sub_b1a41085 > -1 / mem[_31833]:
        revert with 0, 17
    _32891 = mem[64]
    mem[mem[64] + 36] = treasuryAddress
    mem[mem[64] + 68] = _32122 * sub_b1a41085 / 10000
    _32990 = mem[64]
    mem[mem[64]] = 68
    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
    mem[64] = mem[64] + 164
    mem[_32891 + 100] = 32
    mem[_32891 + 132] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
        revert with 0, 'Address: call to non-contract'
    _33481 = mem[_32990]
    mem[_32891 + 164 len ceil32(mem[_32990])] = mem[_32990 + 32 len ceil32(mem[_32990])]
    if ceil32(_33481) > _33481:
        mem[_33481 + _32891 + 164] = 0
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
         gas gas_remaining wei
        args mem[_32891 + 168 len _33481 - 4]
    if not return_data.size:
        if not ext_call.success:
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            revert with 0, 'SafeERC20: low-level call failed'
        if mem[96]:
            require mem[96] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if _32122 < _32122 * sub_b1a41085 / 10000:
            revert with 0, 17
        require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
        call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
             gas gas_remaining wei
            args 24, _32122 - (_32122 * sub_b1a41085 / 10000)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_32891 + 200] = this.address
        require ext_code.size(masterChefAddress)
        staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
                gas gas_remaining wei
               args poolId, this.address
        mem[_32891 + 164 len 64] = ext_call.return_data[0 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 64
        if _32122 - (_32122 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
            revert with 0, 17
        if not ext_call.return_data[0]:
            revert with 0, 18
        if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _32122) - (1000000000000000000 * 10^18 * _32122 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
            revert with 0, 17
        sub_c8af9d6a += (1000000000000000000 * 10^18 * _32122) - (1000000000000000000 * 10^18 * _32122 * sub_b1a41085 / 10000) / ext_call.return_data[0]
        emit Harvest(_22854, _32122 - (_32122 * sub_b1a41085 / 10000), _32122 * sub_b1a41085 / 10000);
        if userInfo[address(arg1)].field_0:
            if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
                revert with 0, 17
            if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
                revert with 0, 17
            if (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
                if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
                require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
                call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_32891 + ceil32(return_data.size) + 200] = arg1
                mem[_32891 + ceil32(return_data.size) + 232] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                mem[_32891 + ceil32(return_data.size) + 164] = 68
                mem[_32891 + ceil32(return_data.size) + 196 len 4] = unknown_0xa9059cbb(?????)
                mem[_32891 + ceil32(return_data.size) + 264] = 32
                mem[_32891 + ceil32(return_data.size) + 296] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
                    revert with 0, 'Address: call to non-contract'
                mem[_32891 + ceil32(return_data.size) + 328 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
                mem[_32891 + ceil32(return_data.size) + 396] = 0
                call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
                   funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if mem[96]:
                            revert with memory
                              from 128
                               len mem[96]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if mem[96]:
                        require mem[96] >= 32
                        require mem[128] == bool(mem[128])
                        if not mem[128]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[_32891 + ceil32(return_data.size) + 360 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[_32891 + ceil32(return_data.size) + 360] == bool(mem[_32891 + ceil32(return_data.size) + 360])
                        if not mem[_32891 + ceil32(return_data.size) + 360]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
                    revert with 0, 17
                sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
                emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_32891 + 164] = return_data.size
    mem[_32891 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        revert with 0, 'SafeERC20: low-level call failed'
    if return_data.size:
        require return_data.size >= 32
        require mem[_32891 + 196] == bool(mem[_32891 + 196])
        if not mem[_32891 + 196]:
            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    if _32122 < _32122 * sub_b1a41085 / 10000:
        revert with 0, 17
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.deposit(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args 24, _32122 - (_32122 * sub_b1a41085 / 10000)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[_32891 + ceil32(return_data.size) + 201] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args poolId, this.address
    mem[_32891 + ceil32(return_data.size) + 165 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if _32122 - (_32122 * sub_b1a41085 / 10000) > 0x154484932d2e725a5bbca17a3aba173d3d5:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if sub_c8af9d6a > !((1000000000000000000 * 10^18 * _32122) - (1000000000000000000 * 10^18 * _32122 * sub_b1a41085 / 10000) / ext_call.return_data[0]):
        revert with 0, 17
    sub_c8af9d6a += (1000000000000000000 * 10^18 * _32122) - (1000000000000000000 * 10^18 * _32122 * sub_b1a41085 / 10000) / ext_call.return_data[0]
    emit Harvest(_22854, _32122 - (_32122 * sub_b1a41085 / 10000), _32122 * sub_b1a41085 / 10000);
    if not userInfo[address(arg1)].field_0:
    if userInfo[address(arg1)].field_0 and sub_c8af9d6a > -1 / userInfo[address(arg1)].field_0:
        revert with 0, 17
    if userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18 < userInfo[address(arg1)].field_256:
        revert with 0, 17
    if not (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256:
    if userInfo[address(arg1)].field_256 > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
        revert with 0, 17
    userInfo[address(arg1)].field_256 = userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18
    require ext_code.size(0xd6a4f121ca35509af06a0be99093d08462f53052)
    call 0xd6a4f121ca35509af06a0be99093d08462f53052.withdraw(uint256 arg1, uint256 arg2) with:
         gas gas_remaining wei
        args 24, (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 201] = arg1
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 233] = (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 68
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 197 len 4] = unknown_0xa9059cbb(?????)
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = 32
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33):
        revert with 0, 'Address: call to non-contract'
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 329 len 96] = 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 397] = 0
    call 0x57319d41f71e81f3c65f2a47ca4e001ebafd4f33 with:
       funct Mask(32, 224, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, 0, address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            revert with 0, 'SafeERC20: low-level call failed'
        if mem[96]:
            require mem[96] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = return_data.size
    mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 361 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        mem[_32891 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[_32891 + (4 * ceil32(return_data.size)) + 334] = 32
        mem[_32891 + (4 * ceil32(return_data.size)) + 366] = 32
        mem[_32891 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: low-level call failed'
        revert with memory
          from _32891 + (4 * ceil32(return_data.size)) + 330
           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
    if not return_data.size:
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    require return_data.size >= 32
    require mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 361] == bool(mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 361])
    if mem[_32891 + ceil32(return_data.size) + ceil32(return_data.size) + 361]:
        if sub_be892f00[address(arg1)] > !((userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256):
            revert with 0, 17
        sub_be892f00[address(arg1)] = sub_be892f00[address(arg1)] + (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256
        emit ClaimReward(address(arg1), (userInfo[address(arg1)].field_0 * sub_c8af9d6a / 1000000000000000000 * 10^18) - userInfo[address(arg1)].field_256);
    mem[_32891 + (4 * ceil32(return_data.size)) + 330] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[_32891 + (4 * ceil32(return_data.size)) + 334] = 32
    mem[_32891 + (4 * ceil32(return_data.size)) + 366] = 42
    mem[_32891 + (4 * ceil32(return_data.size)) + 398] = 'SafeERC20: ERC20 operation did n'
    mem[_32891 + (4 * ceil32(return_data.size)) + 430] = 0x6f74207375636365656400000000000000000000000000000000000000000000
    revert with memory
      from _32891 + (4 * ceil32(return_data.size)) + 330
       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
}

function sub_f2905826(?) {
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestAnswer() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'ChainLink error'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = token1Address
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = 1
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1249 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _1258 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _1258
            require _1249 + (32 * _1258) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1258)] = mem[(2 * ceil32(return_data.size)) + _1249 + 224 len ceil32(32 * _1258)]
            if 1 >= _1258:
                revert with 0, 50
            _2380 = mem[(4 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2425 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2380) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2425]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380) / mem[_2425] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380) / mem[_2425]:
                    revert with 0, 17
                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380) / mem[_2425] * ext_call.return_data[0] / 100 * 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2461 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2380 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2461]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / 10^sub_3266f45c) / mem[_2461] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / 10^sub_3266f45c) / mem[_2461]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / 10^sub_3266f45c) / mem[_2461] * ext_call.return_data[0] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3580 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2380 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3580]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / s * t) / mem[_3580] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / s * t) / mem[_3580]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2380 / s * t) / mem[_3580] * ext_call.return_data[0] / 100 * 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1248 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1257 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1257
                require _1248 + (32 * _1257) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1257)] = mem[(2 * ceil32(return_data.size)) + _1248 + 224 len ceil32(32 * _1257)]
                if 1 >= _1257:
                    revert with 0, 50
                _2379 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2424 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2379) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2424]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379) / mem[_2424] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379) / mem[_2424]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379) / mem[_2424] * ext_call.return_data[0] / 100 * 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2460 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2379 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2460]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / 10^sub_3266f45c) / mem[_2460] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / 10^sub_3266f45c) / mem[_2460]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / 10^sub_3266f45c) / mem[_2460] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3579 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2379 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3579]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / s * t) / mem[_3579] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / s * t) / mem[_3579]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2379 / s * t) / mem[_3579] * ext_call.return_data[0] / 100 * 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = s * t
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (2 * ceil32(return_data.size)) + 128
                v = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2386 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _2389 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _2389
                require _2386 + (32 * _2389) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2389)] = mem[(2 * ceil32(return_data.size)) + _2386 + 224 len ceil32(32 * _2389)]
                if 1 >= _2389:
                    revert with 0, 50
                _3470 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3618 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3470) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3618]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470) / mem[_3618] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470) / mem[_3618]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470) / mem[_3618] * ext_call.return_data[0] / 100 * 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3660 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3470 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3660]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / 10^sub_3266f45c) / mem[_3660] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / 10^sub_3266f45c) / mem[_3660]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / 10^sub_3266f45c) / mem[_3660] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4556 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3470 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4556]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / s * t) / mem[_4556] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / s * t) / mem[_4556]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3470 / s * t) / mem[_4556] * ext_call.return_data[0] / 100 * 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1246 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1255 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1255
                require _1246 + (32 * _1255) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1255)] = mem[(2 * ceil32(return_data.size)) + _1246 + 224 len ceil32(32 * _1255)]
                if 1 >= _1255:
                    revert with 0, 50
                _2377 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2423 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2377) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2423]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377) / mem[_2423] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377) / mem[_2423]:
                        revert with 0, 17
                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377) / mem[_2423] * ext_call.return_data[0] / 100 * 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2459 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2377 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2459]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / 10^sub_9ddc230a) / mem[_2459] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / 10^sub_9ddc230a) / mem[_2459]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / 10^sub_9ddc230a) / mem[_2459] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3578 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2377 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3578]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / s * t) / mem[_3578] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / s * t) / mem[_3578]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2377 / s * t) / mem[_3578] * ext_call.return_data[0] / 100 * 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1245 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1254 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1254
                    require _1245 + (32 * _1254) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1254)] = mem[(2 * ceil32(return_data.size)) + _1245 + 224 len ceil32(32 * _1254)]
                    if 1 >= _1254:
                        revert with 0, 50
                    _2376 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2422 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2376) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2422]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376) / mem[_2422] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376) / mem[_2422]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376) / mem[_2422] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2458 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2376 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2458]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / 10^sub_9ddc230a) / mem[_2458] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / 10^sub_9ddc230a) / mem[_2458]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / 10^sub_9ddc230a) / mem[_2458] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3577 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2376 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3577]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / s * t) / mem[_3577] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / s * t) / mem[_3577]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2376 / s * t) / mem[_3577] * ext_call.return_data[0] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2385 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2388 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2388
                    require _2385 + (32 * _2388) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2388)] = mem[(2 * ceil32(return_data.size)) + _2385 + 224 len ceil32(32 * _2388)]
                    if 1 >= _2388:
                        revert with 0, 50
                    _3469 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3617 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3469) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3617]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469) / mem[_3617] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469) / mem[_3617]:
                            revert with 0, 17
                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469) / mem[_3617] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3659 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3469 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3659]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / 10^sub_9ddc230a) / mem[_3659] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / 10^sub_9ddc230a) / mem[_3659]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / 10^sub_9ddc230a) / mem[_3659] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4555 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3469 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4555]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / s * t) / mem[_4555] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / s * t) / mem[_4555]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3469 / s * t) / mem[_4555] * ext_call.return_data[0] / 100 * 10^18
        else:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1243 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1252 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1252
                require _1243 + (32 * _1252) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1252)] = mem[(2 * ceil32(return_data.size)) + _1243 + 224 len ceil32(32 * _1252)]
                if 1 >= _1252:
                    revert with 0, 50
                _2374 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2428 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2428]:
                            revert with 0, 50
                        mem[_2428 + 32] = token1Address
                        if 1 >= mem[_2428]:
                            revert with 0, 50
                        mem[_2428 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2428 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2428 + 100] = 1
                        mem[_2428 + 132] = 64
                        mem[_2428 + 164] = mem[_2428]
                        idx = 0
                        s = _2428 + 32
                        t = _2428 + 196
                        while idx < mem[_2428]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2428 + (32 * mem[_2428]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3486 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3506 = mem[_3486]
                        require mem[_3486] <= test266151307()
                        require _3486 + mem[_3486] + 31 < _3486 + return_data.size
                        _3518 = mem[_3486 + mem[_3486]]
                        if mem[_3486 + mem[_3486]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3486 + mem[_3486]]) + 1 < 0 or _3486 + ceil32(return_data.size) + ceil32(32 * mem[_3486 + mem[_3486]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3486 + ceil32(return_data.size) + ceil32(32 * mem[_3486 + mem[_3486]]) + 1
                        mem[_3486 + ceil32(return_data.size)] = _3518
                        require _3506 + (32 * _3518) + 32 <= return_data.size
                        mem[_3486 + ceil32(return_data.size) + 32 len ceil32(32 * _3518)] = mem[_3486 + _3506 + 32 len ceil32(32 * _3518)]
                        if 1 >= _3518:
                            revert with 0, 50
                        _4434 = mem[_3486 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4606 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4434) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4606]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4606] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4606]:
                                revert with 0, 17
                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434) / mem[_4606] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4652 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4652]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4652] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4652]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / 10^sub_3266f45c) / mem[_4652] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3486 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3486 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5248 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5248]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5248] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5248]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4434 / s * t) / mem[_5248] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2469 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2469]:
                                revert with 0, 50
                            mem[_2469 + 32] = token1Address
                            if 1 >= mem[_2469]:
                                revert with 0, 50
                            mem[_2469 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2469 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2469 + 100] = 10^sub_3266f45c
                            mem[_2469 + 132] = 64
                            mem[_2469 + 164] = mem[_2469]
                            idx = 0
                            s = _2469 + 32
                            t = _2469 + 196
                            while idx < mem[_2469]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2469 + (32 * mem[_2469]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3485 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3505 = mem[_3485]
                            require mem[_3485] <= test266151307()
                            require _3485 + mem[_3485] + 31 < _3485 + return_data.size
                            _3517 = mem[_3485 + mem[_3485]]
                            if mem[_3485 + mem[_3485]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3485 + mem[_3485]]) + 1 < 0 or _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1
                            mem[_3485 + ceil32(return_data.size)] = _3517
                            require _3505 + (32 * _3517) + 32 <= return_data.size
                            mem[_3485 + ceil32(return_data.size) + 32 len ceil32(32 * _3517)] = mem[_3485 + _3505 + 32 len ceil32(32 * _3517)]
                            if 1 >= _3517:
                                revert with 0, 50
                            _4433 = mem[_3485 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4605 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4433) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4605]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4605] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4605]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4605] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4651 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4651]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4651] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4651]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4651] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5247 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5247]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5247] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5247]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5247] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3493 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3493]:
                                revert with 0, 50
                            mem[_3493 + 32] = token1Address
                            if 1 >= mem[_3493]:
                                revert with 0, 50
                            mem[_3493 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3493 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3493 + 100] = s * t
                            mem[_3493 + 132] = 64
                            mem[_3493 + 164] = mem[_3493]
                            idx = 0
                            s = _3493 + 32
                            t = _3493 + 196
                            while idx < mem[_3493]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3493 + (32 * mem[_3493]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4454 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4478 = mem[_4454]
                            require mem[_4454] <= test266151307()
                            require _4454 + mem[_4454] + 31 < _4454 + return_data.size
                            _4494 = mem[_4454 + mem[_4454]]
                            if mem[_4454 + mem[_4454]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4454 + mem[_4454]]) + 1 < 0 or _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1
                            mem[_4454 + ceil32(return_data.size)] = _4494
                            require _4478 + (32 * _4494) + 32 <= return_data.size
                            mem[_4454 + ceil32(return_data.size) + 32 len ceil32(32 * _4494)] = mem[_4454 + _4478 + 32 len ceil32(32 * _4494)]
                            if 1 >= _4494:
                                revert with 0, 50
                            _5178 = mem[_4454 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5300 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _5178) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5300]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5300] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5300]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5300] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5349 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5349]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5349] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5349]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5349] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5688 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5688]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / s * t) / mem[_5688] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / s * t) / mem[_5688]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / s * t) / mem[_5688] * ext_call.return_data[0] / 100 * 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2467 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2467]:
                                revert with 0, 50
                            mem[_2467 + 32] = token1Address
                            if 1 >= mem[_2467]:
                                revert with 0, 50
                            mem[_2467 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2467 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2467 + 100] = 1
                            mem[_2467 + 132] = 64
                            mem[_2467 + 164] = mem[_2467]
                            idx = 0
                            s = _2467 + 32
                            t = _2467 + 196
                            while idx < mem[_2467]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2467 + (32 * mem[_2467]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3482 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3503 = mem[_3482]
                            require mem[_3482] <= test266151307()
                            require _3482 + mem[_3482] + 31 < _3482 + return_data.size
                            _3515 = mem[_3482 + mem[_3482]]
                            if mem[_3482 + mem[_3482]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3482 + mem[_3482]]) + 1 < 0 or _3482 + ceil32(return_data.size) + ceil32(32 * mem[_3482 + mem[_3482]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3482 + ceil32(return_data.size) + ceil32(32 * mem[_3482 + mem[_3482]]) + 1
                            mem[_3482 + ceil32(return_data.size)] = _3515
                            require _3503 + (32 * _3515) + 32 <= return_data.size
                            mem[_3482 + ceil32(return_data.size) + 32 len ceil32(32 * _3515)] = mem[_3482 + _3503 + 32 len ceil32(32 * _3515)]
                            if 1 >= _3515:
                                revert with 0, 50
                            _4431 = mem[_3482 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4604 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4604]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4604] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4604]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431) / mem[_4604] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4650 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4650]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4650] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4650]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / 10^sub_3266f45c) / mem[_4650] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3482 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3482 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5246 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5246]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5246] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5246]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4431 / s * t) / mem[_5246] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2529 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2529]:
                                    revert with 0, 50
                                mem[_2529 + 32] = token1Address
                                if 1 >= mem[_2529]:
                                    revert with 0, 50
                                mem[_2529 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2529 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2529 + 100] = 10^sub_3266f45c
                                mem[_2529 + 132] = 64
                                mem[_2529 + 164] = mem[_2529]
                                idx = 0
                                s = _2529 + 32
                                t = _2529 + 196
                                while idx < mem[_2529]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2529 + (32 * mem[_2529]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3481 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3502 = mem[_3481]
                                require mem[_3481] <= test266151307()
                                require _3481 + mem[_3481] + 31 < _3481 + return_data.size
                                _3514 = mem[_3481 + mem[_3481]]
                                if mem[_3481 + mem[_3481]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3481 + mem[_3481]]) + 1 < 0 or _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1
                                mem[_3481 + ceil32(return_data.size)] = _3514
                                require _3502 + (32 * _3514) + 32 <= return_data.size
                                mem[_3481 + ceil32(return_data.size) + 32 len ceil32(32 * _3514)] = mem[_3481 + _3502 + 32 len ceil32(32 * _3514)]
                                if 1 >= _3514:
                                    revert with 0, 50
                                _4430 = mem[_3481 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4603 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4603]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4603] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4603]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4603] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4649 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4649]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4649] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4649]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4649] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5245 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5245]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5245] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5245]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5245] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3491 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3491]:
                                    revert with 0, 50
                                mem[_3491 + 32] = token1Address
                                if 1 >= mem[_3491]:
                                    revert with 0, 50
                                mem[_3491 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3491 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3491 + 100] = s * t
                                mem[_3491 + 132] = 64
                                mem[_3491 + 164] = mem[_3491]
                                idx = 0
                                s = _3491 + 32
                                t = _3491 + 196
                                while idx < mem[_3491]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3491 + (32 * mem[_3491]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4453 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4477 = mem[_4453]
                                require mem[_4453] <= test266151307()
                                require _4453 + mem[_4453] + 31 < _4453 + return_data.size
                                _4493 = mem[_4453 + mem[_4453]]
                                if mem[_4453 + mem[_4453]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4453 + mem[_4453]]) + 1 < 0 or _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1
                                mem[_4453 + ceil32(return_data.size)] = _4493
                                require _4477 + (32 * _4493) + 32 <= return_data.size
                                mem[_4453 + ceil32(return_data.size) + 32 len ceil32(32 * _4493)] = mem[_4453 + _4477 + 32 len ceil32(32 * _4493)]
                                if 1 >= _4493:
                                    revert with 0, 50
                                _5177 = mem[_4453 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5299 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5177) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5299]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5299] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5299]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5299] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5348 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5348]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5348] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5348]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5348] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5687 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5177 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5687]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / s * t) / mem[_5687] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / s * t) / mem[_5687]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / s * t) / mem[_5687] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3587 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3587]:
                                revert with 0, 50
                            mem[_3587 + 32] = token1Address
                            if 1 >= mem[_3587]:
                                revert with 0, 50
                            mem[_3587 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3587 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3587 + 100] = 1
                            mem[_3587 + 132] = 64
                            mem[_3587 + 164] = mem[_3587]
                            idx = 0
                            u = _3587 + 32
                            v = _3587 + 196
                            while idx < mem[_3587]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3587 + (32 * mem[_3587]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4452 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4476 = mem[_4452]
                            require mem[_4452] <= test266151307()
                            require _4452 + mem[_4452] + 31 < _4452 + return_data.size
                            _4492 = mem[_4452 + mem[_4452]]
                            if mem[_4452 + mem[_4452]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4452 + mem[_4452]]) + 1 < 0 or _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1
                            mem[_4452 + ceil32(return_data.size)] = _4492
                            require _4476 + (32 * _4492) + 32 <= return_data.size
                            mem[_4452 + ceil32(return_data.size) + 32 len ceil32(32 * _4492)] = mem[_4452 + _4476 + 32 len ceil32(32 * _4492)]
                            if 1 >= _4492:
                                revert with 0, 50
                            _5176 = mem[_4452 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5298 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5176) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5298]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5298] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5298]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176) / mem[_5298] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5347 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5347]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5347] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5347]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / 10^sub_3266f45c) / mem[_5347] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5686 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5176 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5686]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / u * v) / mem[_5686] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / u * v) / mem[_5686]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5176 / u * v) / mem[_5686] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3631 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3631]:
                                    revert with 0, 50
                                mem[_3631 + 32] = token1Address
                                if 1 >= mem[_3631]:
                                    revert with 0, 50
                                mem[_3631 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3631 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3631 + 100] = 10^sub_3266f45c
                                mem[_3631 + 132] = 64
                                mem[_3631 + 164] = mem[_3631]
                                idx = 0
                                u = _3631 + 32
                                v = _3631 + 196
                                while idx < mem[_3631]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3631 + (32 * mem[_3631]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4451 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4475 = mem[_4451]
                                require mem[_4451] <= test266151307()
                                require _4451 + mem[_4451] + 31 < _4451 + return_data.size
                                _4491 = mem[_4451 + mem[_4451]]
                                if mem[_4451 + mem[_4451]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4451 + mem[_4451]]) + 1 < 0 or _4451 + ceil32(return_data.size) + ceil32(32 * mem[_4451 + mem[_4451]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4451 + ceil32(return_data.size) + ceil32(32 * mem[_4451 + mem[_4451]]) + 1
                                mem[_4451 + ceil32(return_data.size)] = _4491
                                require _4475 + (32 * _4491) + 32 <= return_data.size
                                mem[_4451 + ceil32(return_data.size) + 32 len ceil32(32 * _4491)] = mem[_4451 + _4475 + 32 len ceil32(32 * _4491)]
                                if 1 >= _4491:
                                    revert with 0, 50
                                _5175 = mem[_4451 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4451 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4451 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5297 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5175) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5297]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5297] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5297]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5297] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4451 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4451 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5346 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5346]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5346] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5346]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5346] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4451 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4451 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5685 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5685]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / u * v) / mem[_5685] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / u * v) / mem[_5685]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / u * v) / mem[_5685] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4461 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4461]:
                                    revert with 0, 50
                                mem[_4461 + 32] = token1Address
                                if 1 >= mem[_4461]:
                                    revert with 0, 50
                                mem[_4461 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4461 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4461 + 100] = u * v
                                mem[_4461 + 132] = 64
                                mem[_4461 + 164] = mem[_4461]
                                idx = 0
                                u = _4461 + 32
                                v = _4461 + 196
                                while idx < mem[_4461]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4461 + (32 * mem[_4461]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5186 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5195 = mem[_5186]
                                require mem[_5186] <= test266151307()
                                require _5186 + mem[_5186] + 31 < _5186 + return_data.size
                                _5202 = mem[_5186 + mem[_5186]]
                                if mem[_5186 + mem[_5186]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5186 + mem[_5186]]) + 1 < 0 or _5186 + ceil32(return_data.size) + ceil32(32 * mem[_5186 + mem[_5186]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5186 + ceil32(return_data.size) + ceil32(32 * mem[_5186 + mem[_5186]]) + 1
                                mem[_5186 + ceil32(return_data.size)] = _5202
                                require _5195 + (32 * _5202) + 32 <= return_data.size
                                mem[_5186 + ceil32(return_data.size) + 32 len ceil32(32 * _5202)] = mem[_5186 + _5195 + 32 len ceil32(32 * _5202)]
                                if 1 >= _5202:
                                    revert with 0, 50
                                _5646 = mem[_5186 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5186 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5186 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5719 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5719]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5719] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5719]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5719] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5186 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5186 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5743]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5743] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5743]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5743] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5186 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5186 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5872 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5872]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_5872] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_5872]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2374 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_5872] * ext_call.return_data[0] / 100 * 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1242 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1251 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1251
                    require _1242 + (32 * _1251) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1251)] = mem[(2 * ceil32(return_data.size)) + _1242 + 224 len ceil32(32 * _1251)]
                    if 1 >= _1251:
                        revert with 0, 50
                    _2373 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2426 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2426]:
                                revert with 0, 50
                            mem[_2426 + 32] = token1Address
                            if 1 >= mem[_2426]:
                                revert with 0, 50
                            mem[_2426 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2426 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2426 + 100] = 1
                            mem[_2426 + 132] = 64
                            mem[_2426 + 164] = mem[_2426]
                            idx = 0
                            s = _2426 + 32
                            t = _2426 + 196
                            while idx < mem[_2426]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2426 + (32 * mem[_2426]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3478 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3500 = mem[_3478]
                            require mem[_3478] <= test266151307()
                            require _3478 + mem[_3478] + 31 < _3478 + return_data.size
                            _3512 = mem[_3478 + mem[_3478]]
                            if mem[_3478 + mem[_3478]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3478 + mem[_3478]]) + 1 < 0 or _3478 + ceil32(return_data.size) + ceil32(32 * mem[_3478 + mem[_3478]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3478 + ceil32(return_data.size) + ceil32(32 * mem[_3478 + mem[_3478]]) + 1
                            mem[_3478 + ceil32(return_data.size)] = _3512
                            require _3500 + (32 * _3512) + 32 <= return_data.size
                            mem[_3478 + ceil32(return_data.size) + 32 len ceil32(32 * _3512)] = mem[_3478 + _3500 + 32 len ceil32(32 * _3512)]
                            if 1 >= _3512:
                                revert with 0, 50
                            _4426 = mem[_3478 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3478 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3478 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4601 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4426) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4601]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426) / mem[_4601] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426) / mem[_4601]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426) / mem[_4601] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3478 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3478 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4648 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4426 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4648]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / 10^sub_3266f45c) / mem[_4648] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / 10^sub_3266f45c) / mem[_4648]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / 10^sub_3266f45c) / mem[_4648] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3478 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3478 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5243 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4426 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5243]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / s * t) / mem[_5243] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / s * t) / mem[_5243]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4426 / s * t) / mem[_5243] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2464 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2464]:
                                    revert with 0, 50
                                mem[_2464 + 32] = token1Address
                                if 1 >= mem[_2464]:
                                    revert with 0, 50
                                mem[_2464 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2464 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2464 + 100] = 10^sub_3266f45c
                                mem[_2464 + 132] = 64
                                mem[_2464 + 164] = mem[_2464]
                                idx = 0
                                s = _2464 + 32
                                t = _2464 + 196
                                while idx < mem[_2464]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2464 + (32 * mem[_2464]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3477 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3499 = mem[_3477]
                                require mem[_3477] <= test266151307()
                                require _3477 + mem[_3477] + 31 < _3477 + return_data.size
                                _3511 = mem[_3477 + mem[_3477]]
                                if mem[_3477 + mem[_3477]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3477 + mem[_3477]]) + 1 < 0 or _3477 + ceil32(return_data.size) + ceil32(32 * mem[_3477 + mem[_3477]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3477 + ceil32(return_data.size) + ceil32(32 * mem[_3477 + mem[_3477]]) + 1
                                mem[_3477 + ceil32(return_data.size)] = _3511
                                require _3499 + (32 * _3511) + 32 <= return_data.size
                                mem[_3477 + ceil32(return_data.size) + 32 len ceil32(32 * _3511)] = mem[_3477 + _3499 + 32 len ceil32(32 * _3511)]
                                if 1 >= _3511:
                                    revert with 0, 50
                                _4425 = mem[_3477 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3477 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3477 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4600 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4425) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4600]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425) / mem[_4600] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425) / mem[_4600]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425) / mem[_4600] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3477 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3477 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4647 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4425 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4647]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / 10^sub_3266f45c) / mem[_4647] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / 10^sub_3266f45c) / mem[_4647]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / 10^sub_3266f45c) / mem[_4647] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3477 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3477 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5242 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _4425 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5242]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / s * t) / mem[_5242] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / s * t) / mem[_5242]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4425 / s * t) / mem[_5242] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3489 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3489]:
                                    revert with 0, 50
                                mem[_3489 + 32] = token1Address
                                if 1 >= mem[_3489]:
                                    revert with 0, 50
                                mem[_3489 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3489 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3489 + 100] = s * t
                                mem[_3489 + 132] = 64
                                mem[_3489 + 164] = mem[_3489]
                                idx = 0
                                s = _3489 + 32
                                t = _3489 + 196
                                while idx < mem[_3489]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3489 + (32 * mem[_3489]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4448 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4473 = mem[_4448]
                                require mem[_4448] <= test266151307()
                                require _4448 + mem[_4448] + 31 < _4448 + return_data.size
                                _4489 = mem[_4448 + mem[_4448]]
                                if mem[_4448 + mem[_4448]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4448 + mem[_4448]]) + 1 < 0 or _4448 + ceil32(return_data.size) + ceil32(32 * mem[_4448 + mem[_4448]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4448 + ceil32(return_data.size) + ceil32(32 * mem[_4448 + mem[_4448]]) + 1
                                mem[_4448 + ceil32(return_data.size)] = _4489
                                require _4473 + (32 * _4489) + 32 <= return_data.size
                                mem[_4448 + ceil32(return_data.size) + 32 len ceil32(32 * _4489)] = mem[_4448 + _4473 + 32 len ceil32(32 * _4489)]
                                if 1 >= _4489:
                                    revert with 0, 50
                                _5173 = mem[_4448 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5296 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _5173) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5296]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5296] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5296]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173) / mem[_5296] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5345 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5345]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5345] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5345]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / 10^sub_3266f45c) / mem[_5345] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5684 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373) + (Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5684]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5684] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5684]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5173 / s * t) / mem[_5684] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2462 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2462]:
                                    revert with 0, 50
                                mem[_2462 + 32] = token1Address
                                if 1 >= mem[_2462]:
                                    revert with 0, 50
                                mem[_2462 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2462 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2462 + 100] = 1
                                mem[_2462 + 132] = 64
                                mem[_2462 + 164] = mem[_2462]
                                idx = 0
                                s = _2462 + 32
                                t = _2462 + 196
                                while idx < mem[_2462]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2462 + (32 * mem[_2462]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3474 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3497 = mem[_3474]
                                require mem[_3474] <= test266151307()
                                require _3474 + mem[_3474] + 31 < _3474 + return_data.size
                                _3509 = mem[_3474 + mem[_3474]]
                                if mem[_3474 + mem[_3474]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3474 + mem[_3474]]) + 1 < 0 or _3474 + ceil32(return_data.size) + ceil32(32 * mem[_3474 + mem[_3474]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3474 + ceil32(return_data.size) + ceil32(32 * mem[_3474 + mem[_3474]]) + 1
                                mem[_3474 + ceil32(return_data.size)] = _3509
                                require _3497 + (32 * _3509) + 32 <= return_data.size
                                mem[_3474 + ceil32(return_data.size) + 32 len ceil32(32 * _3509)] = mem[_3474 + _3497 + 32 len ceil32(32 * _3509)]
                                if 1 >= _3509:
                                    revert with 0, 50
                                _4423 = mem[_3474 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3474 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3474 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4599 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4423) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4599]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423) / mem[_4599] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423) / mem[_4599]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423) / mem[_4599] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3474 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3474 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4646 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4423 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4646]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / 10^sub_3266f45c) / mem[_4646] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / 10^sub_3266f45c) / mem[_4646]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / 10^sub_3266f45c) / mem[_4646] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3474 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3474 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5241 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4423 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5241]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / s * t) / mem[_5241] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / s * t) / mem[_5241]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4423 / s * t) / mem[_5241] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2523 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2523]:
                                        revert with 0, 50
                                    mem[_2523 + 32] = token1Address
                                    if 1 >= mem[_2523]:
                                        revert with 0, 50
                                    mem[_2523 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2523 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2523 + 100] = 10^sub_3266f45c
                                    mem[_2523 + 132] = 64
                                    mem[_2523 + 164] = mem[_2523]
                                    idx = 0
                                    s = _2523 + 32
                                    t = _2523 + 196
                                    while idx < mem[_2523]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2523 + (32 * mem[_2523]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3473 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3496 = mem[_3473]
                                    require mem[_3473] <= test266151307()
                                    require _3473 + mem[_3473] + 31 < _3473 + return_data.size
                                    _3508 = mem[_3473 + mem[_3473]]
                                    if mem[_3473 + mem[_3473]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3473 + mem[_3473]]) + 1 < 0 or _3473 + ceil32(return_data.size) + ceil32(32 * mem[_3473 + mem[_3473]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3473 + ceil32(return_data.size) + ceil32(32 * mem[_3473 + mem[_3473]]) + 1
                                    mem[_3473 + ceil32(return_data.size)] = _3508
                                    require _3496 + (32 * _3508) + 32 <= return_data.size
                                    mem[_3473 + ceil32(return_data.size) + 32 len ceil32(32 * _3508)] = mem[_3473 + _3496 + 32 len ceil32(32 * _3508)]
                                    if 1 >= _3508:
                                        revert with 0, 50
                                    _4422 = mem[_3473 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3473 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3473 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4598 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4422) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4598]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422) / mem[_4598] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422) / mem[_4598]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422) / mem[_4598] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3473 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3473 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4645 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4422 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_4645]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / 10^sub_3266f45c) / mem[_4645] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / 10^sub_3266f45c) / mem[_4645]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / 10^sub_3266f45c) / mem[_4645] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3473 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3473 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5240 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4422 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5240]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / s * t) / mem[_5240] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / s * t) / mem[_5240]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4422 / s * t) / mem[_5240] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3487 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3487]:
                                        revert with 0, 50
                                    mem[_3487 + 32] = token1Address
                                    if 1 >= mem[_3487]:
                                        revert with 0, 50
                                    mem[_3487 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3487 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3487 + 100] = s * t
                                    mem[_3487 + 132] = 64
                                    mem[_3487 + 164] = mem[_3487]
                                    idx = 0
                                    s = _3487 + 32
                                    t = _3487 + 196
                                    while idx < mem[_3487]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3487 + (32 * mem[_3487]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4447 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4472 = mem[_4447]
                                    require mem[_4447] <= test266151307()
                                    require _4447 + mem[_4447] + 31 < _4447 + return_data.size
                                    _4488 = mem[_4447 + mem[_4447]]
                                    if mem[_4447 + mem[_4447]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4447 + mem[_4447]]) + 1 < 0 or _4447 + ceil32(return_data.size) + ceil32(32 * mem[_4447 + mem[_4447]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4447 + ceil32(return_data.size) + ceil32(32 * mem[_4447 + mem[_4447]]) + 1
                                    mem[_4447 + ceil32(return_data.size)] = _4488
                                    require _4472 + (32 * _4488) + 32 <= return_data.size
                                    mem[_4447 + ceil32(return_data.size) + 32 len ceil32(32 * _4488)] = mem[_4447 + _4472 + 32 len ceil32(32 * _4488)]
                                    if 1 >= _4488:
                                        revert with 0, 50
                                    _5172 = mem[_4447 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4447 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4447 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5295 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5295]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5295] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5295]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5295] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4447 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4447 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5344 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5344]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5344] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5344]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5344] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4447 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4447 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5683 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5683]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5683] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5683]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5683] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3581 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3581]:
                                    revert with 0, 50
                                mem[_3581 + 32] = token1Address
                                if 1 >= mem[_3581]:
                                    revert with 0, 50
                                mem[_3581 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3581 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3581 + 100] = 1
                                mem[_3581 + 132] = 64
                                mem[_3581 + 164] = mem[_3581]
                                idx = 0
                                u = _3581 + 32
                                v = _3581 + 196
                                while idx < mem[_3581]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3581 + (32 * mem[_3581]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4446 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4471 = mem[_4446]
                                require mem[_4446] <= test266151307()
                                require _4446 + mem[_4446] + 31 < _4446 + return_data.size
                                _4487 = mem[_4446 + mem[_4446]]
                                if mem[_4446 + mem[_4446]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4446 + mem[_4446]]) + 1 < 0 or _4446 + ceil32(return_data.size) + ceil32(32 * mem[_4446 + mem[_4446]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4446 + ceil32(return_data.size) + ceil32(32 * mem[_4446 + mem[_4446]]) + 1
                                mem[_4446 + ceil32(return_data.size)] = _4487
                                require _4471 + (32 * _4487) + 32 <= return_data.size
                                mem[_4446 + ceil32(return_data.size) + 32 len ceil32(32 * _4487)] = mem[_4446 + _4471 + 32 len ceil32(32 * _4487)]
                                if 1 >= _4487:
                                    revert with 0, 50
                                _5171 = mem[_4446 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5294 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5171) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5294]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5294] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5294]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5294] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5343 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5343]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5343] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5343]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5343] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4446 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4446 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5682 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5171 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5682]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / u * v) / mem[_5682] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / u * v) / mem[_5682]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / u * v) / mem[_5682] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3626 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3626]:
                                        revert with 0, 50
                                    mem[_3626 + 32] = token1Address
                                    if 1 >= mem[_3626]:
                                        revert with 0, 50
                                    mem[_3626 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3626 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3626 + 100] = 10^sub_3266f45c
                                    mem[_3626 + 132] = 64
                                    mem[_3626 + 164] = mem[_3626]
                                    idx = 0
                                    u = _3626 + 32
                                    v = _3626 + 196
                                    while idx < mem[_3626]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3626 + (32 * mem[_3626]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4445 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4470 = mem[_4445]
                                    require mem[_4445] <= test266151307()
                                    require _4445 + mem[_4445] + 31 < _4445 + return_data.size
                                    _4486 = mem[_4445 + mem[_4445]]
                                    if mem[_4445 + mem[_4445]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4445 + mem[_4445]]) + 1 < 0 or _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1
                                    mem[_4445 + ceil32(return_data.size)] = _4486
                                    require _4470 + (32 * _4486) + 32 <= return_data.size
                                    mem[_4445 + ceil32(return_data.size) + 32 len ceil32(32 * _4486)] = mem[_4445 + _4470 + 32 len ceil32(32 * _4486)]
                                    if 1 >= _4486:
                                        revert with 0, 50
                                    _5170 = mem[_4445 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5293 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5170) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5293]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170) / mem[_5293] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170) / mem[_5293]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170) / mem[_5293] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5342 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5170 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5342]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / 10^sub_3266f45c) / mem[_5342] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / 10^sub_3266f45c) / mem[_5342]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / 10^sub_3266f45c) / mem[_5342] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5681 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5170 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5681]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / u * v) / mem[_5681] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / u * v) / mem[_5681]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5170 / u * v) / mem[_5681] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4459 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4459]:
                                        revert with 0, 50
                                    mem[_4459 + 32] = token1Address
                                    if 1 >= mem[_4459]:
                                        revert with 0, 50
                                    mem[_4459 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4459 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4459 + 100] = u * v
                                    mem[_4459 + 132] = 64
                                    mem[_4459 + 164] = mem[_4459]
                                    idx = 0
                                    u = _4459 + 32
                                    v = _4459 + 196
                                    while idx < mem[_4459]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4459 + (32 * mem[_4459]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5185 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5194 = mem[_5185]
                                    require mem[_5185] <= test266151307()
                                    require _5185 + mem[_5185] + 31 < _5185 + return_data.size
                                    _5201 = mem[_5185 + mem[_5185]]
                                    if mem[_5185 + mem[_5185]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5185 + mem[_5185]]) + 1 < 0 or _5185 + ceil32(return_data.size) + ceil32(32 * mem[_5185 + mem[_5185]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5185 + ceil32(return_data.size) + ceil32(32 * mem[_5185 + mem[_5185]]) + 1
                                    mem[_5185 + ceil32(return_data.size)] = _5201
                                    require _5194 + (32 * _5201) + 32 <= return_data.size
                                    mem[_5185 + ceil32(return_data.size) + 32 len ceil32(32 * _5201)] = mem[_5185 + _5194 + 32 len ceil32(32 * _5201)]
                                    if 1 >= _5201:
                                        revert with 0, 50
                                    _5645 = mem[_5185 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5185 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5185 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5718 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5645) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5718]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645) / mem[_5718] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645) / mem[_5718]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645) / mem[_5718] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5185 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5185 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5742 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5645 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5742]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / 10^sub_3266f45c) / mem[_5742] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / 10^sub_3266f45c) / mem[_5742]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / 10^sub_3266f45c) / mem[_5742] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5185 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5185 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5871 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5645 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5871]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / u * v) / mem[_5871] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / u * v) / mem[_5871]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2373 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5645 / u * v) / mem[_5871] * ext_call.return_data[0] / 100 * 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2384 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2387 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2387
                    require _2384 + (32 * _2387) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2387)] = mem[(2 * ceil32(return_data.size)) + _2384 + 224 len ceil32(32 * _2387)]
                    if 1 >= _2387:
                        revert with 0, 50
                    _3460 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3619 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3619]:
                                revert with 0, 50
                            mem[_3619 + 32] = token1Address
                            if 1 >= mem[_3619]:
                                revert with 0, 50
                            mem[_3619 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3619 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3619 + 100] = 1
                            mem[_3619 + 132] = 64
                            mem[_3619 + 164] = mem[_3619]
                            idx = 0
                            s = _3619 + 32
                            t = _3619 + 196
                            while idx < mem[_3619]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3619 + (32 * mem[_3619]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4442 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4468 = mem[_4442]
                            require mem[_4442] <= test266151307()
                            require _4442 + mem[_4442] + 31 < _4442 + return_data.size
                            _4484 = mem[_4442 + mem[_4442]]
                            if mem[_4442 + mem[_4442]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4442 + mem[_4442]]) + 1 < 0 or _4442 + ceil32(return_data.size) + ceil32(32 * mem[_4442 + mem[_4442]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4442 + ceil32(return_data.size) + ceil32(32 * mem[_4442 + mem[_4442]]) + 1
                            mem[_4442 + ceil32(return_data.size)] = _4484
                            require _4468 + (32 * _4484) + 32 <= return_data.size
                            mem[_4442 + ceil32(return_data.size) + 32 len ceil32(32 * _4484)] = mem[_4442 + _4468 + 32 len ceil32(32 * _4484)]
                            if 1 >= _4484:
                                revert with 0, 50
                            _5168 = mem[_4442 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4442 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4442 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5292 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5168) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5292]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168) / mem[_5292] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168) / mem[_5292]:
                                    revert with 0, 17
                                mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168) / mem[_5292] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4442 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4442 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5341 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5168 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5341]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / 10^sub_3266f45c) / mem[_5341] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / 10^sub_3266f45c) / mem[_5341]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / 10^sub_3266f45c) / mem[_5341] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4442 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4442 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5680 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5168 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5680]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / s * t) / mem[_5680] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / s * t) / mem[_5680]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5168 / s * t) / mem[_5680] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3663 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3663]:
                                    revert with 0, 50
                                mem[_3663 + 32] = token1Address
                                if 1 >= mem[_3663]:
                                    revert with 0, 50
                                mem[_3663 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3663 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3663 + 100] = 10^sub_3266f45c
                                mem[_3663 + 132] = 64
                                mem[_3663 + 164] = mem[_3663]
                                idx = 0
                                s = _3663 + 32
                                t = _3663 + 196
                                while idx < mem[_3663]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3663 + (32 * mem[_3663]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4441 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4467 = mem[_4441]
                                require mem[_4441] <= test266151307()
                                require _4441 + mem[_4441] + 31 < _4441 + return_data.size
                                _4483 = mem[_4441 + mem[_4441]]
                                if mem[_4441 + mem[_4441]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4441 + mem[_4441]]) + 1 < 0 or _4441 + ceil32(return_data.size) + ceil32(32 * mem[_4441 + mem[_4441]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4441 + ceil32(return_data.size) + ceil32(32 * mem[_4441 + mem[_4441]]) + 1
                                mem[_4441 + ceil32(return_data.size)] = _4483
                                require _4467 + (32 * _4483) + 32 <= return_data.size
                                mem[_4441 + ceil32(return_data.size) + 32 len ceil32(32 * _4483)] = mem[_4441 + _4467 + 32 len ceil32(32 * _4483)]
                                if 1 >= _4483:
                                    revert with 0, 50
                                _5167 = mem[_4441 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4441 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4441 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5291 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5167) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5291]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167) / mem[_5291] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167) / mem[_5291]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167) / mem[_5291] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4441 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4441 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5340 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5167 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5340]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / 10^sub_3266f45c) / mem[_5340] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / 10^sub_3266f45c) / mem[_5340]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / 10^sub_3266f45c) / mem[_5340] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4441 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4441 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5679 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5167 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5679]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / s * t) / mem[_5679] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / s * t) / mem[_5679]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5167 / s * t) / mem[_5679] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4457 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4457]:
                                    revert with 0, 50
                                mem[_4457 + 32] = token1Address
                                if 1 >= mem[_4457]:
                                    revert with 0, 50
                                mem[_4457 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4457 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4457 + 100] = s * t
                                mem[_4457 + 132] = 64
                                mem[_4457 + 164] = mem[_4457]
                                idx = 0
                                s = _4457 + 32
                                t = _4457 + 196
                                while idx < mem[_4457]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4457 + (32 * mem[_4457]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5184 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5193 = mem[_5184]
                                require mem[_5184] <= test266151307()
                                require _5184 + mem[_5184] + 31 < _5184 + return_data.size
                                _5200 = mem[_5184 + mem[_5184]]
                                if mem[_5184 + mem[_5184]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5184 + mem[_5184]]) + 1 < 0 or _5184 + ceil32(return_data.size) + ceil32(32 * mem[_5184 + mem[_5184]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5184 + ceil32(return_data.size) + ceil32(32 * mem[_5184 + mem[_5184]]) + 1
                                mem[_5184 + ceil32(return_data.size)] = _5200
                                require _5193 + (32 * _5200) + 32 <= return_data.size
                                mem[_5184 + ceil32(return_data.size) + 32 len ceil32(32 * _5200)] = mem[_5184 + _5193 + 32 len ceil32(32 * _5200)]
                                if 1 >= _5200:
                                    revert with 0, 50
                                _5644 = mem[_5184 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5184 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5184 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5717 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5644) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5717]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5717] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5717]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5717] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5184 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5184 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5741 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5741]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5741] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5741]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5741] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5184 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5184 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5870 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5870]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_5870] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_5870]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_5870] * ext_call.return_data[0] / 100 * 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3661 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3661]:
                                    revert with 0, 50
                                mem[_3661 + 32] = token1Address
                                if 1 >= mem[_3661]:
                                    revert with 0, 50
                                mem[_3661 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3661 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3661 + 100] = 1
                                mem[_3661 + 132] = 64
                                mem[_3661 + 164] = mem[_3661]
                                idx = 0
                                s = _3661 + 32
                                t = _3661 + 196
                                while idx < mem[_3661]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3661 + (32 * mem[_3661]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4438 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4465 = mem[_4438]
                                require mem[_4438] <= test266151307()
                                require _4438 + mem[_4438] + 31 < _4438 + return_data.size
                                _4481 = mem[_4438 + mem[_4438]]
                                if mem[_4438 + mem[_4438]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4438 + mem[_4438]]) + 1 < 0 or _4438 + ceil32(return_data.size) + ceil32(32 * mem[_4438 + mem[_4438]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4438 + ceil32(return_data.size) + ceil32(32 * mem[_4438 + mem[_4438]]) + 1
                                mem[_4438 + ceil32(return_data.size)] = _4481
                                require _4465 + (32 * _4481) + 32 <= return_data.size
                                mem[_4438 + ceil32(return_data.size) + 32 len ceil32(32 * _4481)] = mem[_4438 + _4465 + 32 len ceil32(32 * _4481)]
                                if 1 >= _4481:
                                    revert with 0, 50
                                _5165 = mem[_4438 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4438 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4438 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5290 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5165) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5290]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165) / mem[_5290] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165) / mem[_5290]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165) / mem[_5290] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4438 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4438 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5339 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5165 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5339]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / 10^sub_3266f45c) / mem[_5339] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / 10^sub_3266f45c) / mem[_5339]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / 10^sub_3266f45c) / mem[_5339] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4438 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4438 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5678 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5165 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5678]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / s * t) / mem[_5678] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / s * t) / mem[_5678]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5165 / s * t) / mem[_5678] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3721 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3721]:
                                        revert with 0, 50
                                    mem[_3721 + 32] = token1Address
                                    if 1 >= mem[_3721]:
                                        revert with 0, 50
                                    mem[_3721 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3721 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3721 + 100] = 10^sub_3266f45c
                                    mem[_3721 + 132] = 64
                                    mem[_3721 + 164] = mem[_3721]
                                    idx = 0
                                    s = _3721 + 32
                                    t = _3721 + 196
                                    while idx < mem[_3721]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3721 + (32 * mem[_3721]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4437 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4464 = mem[_4437]
                                    require mem[_4437] <= test266151307()
                                    require _4437 + mem[_4437] + 31 < _4437 + return_data.size
                                    _4480 = mem[_4437 + mem[_4437]]
                                    if mem[_4437 + mem[_4437]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4437 + mem[_4437]]) + 1 < 0 or _4437 + ceil32(return_data.size) + ceil32(32 * mem[_4437 + mem[_4437]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4437 + ceil32(return_data.size) + ceil32(32 * mem[_4437 + mem[_4437]]) + 1
                                    mem[_4437 + ceil32(return_data.size)] = _4480
                                    require _4464 + (32 * _4480) + 32 <= return_data.size
                                    mem[_4437 + ceil32(return_data.size) + 32 len ceil32(32 * _4480)] = mem[_4437 + _4464 + 32 len ceil32(32 * _4480)]
                                    if 1 >= _4480:
                                        revert with 0, 50
                                    _5164 = mem[_4437 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4437 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4437 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5289 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5164) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5289]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164) / mem[_5289] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164) / mem[_5289]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164) / mem[_5289] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4437 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4437 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5338 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5164 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5338]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / 10^sub_3266f45c) / mem[_5338] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / 10^sub_3266f45c) / mem[_5338]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / 10^sub_3266f45c) / mem[_5338] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4437 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4437 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5677 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5164 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5677]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / s * t) / mem[_5677] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / s * t) / mem[_5677]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5164 / s * t) / mem[_5677] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4455 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4455]:
                                        revert with 0, 50
                                    mem[_4455 + 32] = token1Address
                                    if 1 >= mem[_4455]:
                                        revert with 0, 50
                                    mem[_4455 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4455 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4455 + 100] = s * t
                                    mem[_4455 + 132] = 64
                                    mem[_4455 + 164] = mem[_4455]
                                    idx = 0
                                    s = _4455 + 32
                                    t = _4455 + 196
                                    while idx < mem[_4455]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4455 + (32 * mem[_4455]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5183 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5192 = mem[_5183]
                                    require mem[_5183] <= test266151307()
                                    require _5183 + mem[_5183] + 31 < _5183 + return_data.size
                                    _5199 = mem[_5183 + mem[_5183]]
                                    if mem[_5183 + mem[_5183]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5183 + mem[_5183]]) + 1 < 0 or _5183 + ceil32(return_data.size) + ceil32(32 * mem[_5183 + mem[_5183]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5183 + ceil32(return_data.size) + ceil32(32 * mem[_5183 + mem[_5183]]) + 1
                                    mem[_5183 + ceil32(return_data.size)] = _5199
                                    require _5192 + (32 * _5199) + 32 <= return_data.size
                                    mem[_5183 + ceil32(return_data.size) + 32 len ceil32(32 * _5199)] = mem[_5183 + _5192 + 32 len ceil32(32 * _5199)]
                                    if 1 >= _5199:
                                        revert with 0, 50
                                    _5643 = mem[_5183 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5183 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5716 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5716]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5716] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5716]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5716] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5183 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5740 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5740]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5740] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5740]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5740] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5183 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5869 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5869]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_5869] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_5869]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_5869] * ext_call.return_data[0] / 100 * 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4557 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4557]:
                                    revert with 0, 50
                                mem[_4557 + 32] = token1Address
                                if 1 >= mem[_4557]:
                                    revert with 0, 50
                                mem[_4557 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4557 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4557 + 100] = 1
                                mem[_4557 + 132] = 64
                                mem[_4557 + 164] = mem[_4557]
                                idx = 0
                                u = _4557 + 32
                                v = _4557 + 196
                                while idx < mem[_4557]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4557 + (32 * mem[_4557]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5182 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5191 = mem[_5182]
                                require mem[_5182] <= test266151307()
                                require _5182 + mem[_5182] + 31 < _5182 + return_data.size
                                _5198 = mem[_5182 + mem[_5182]]
                                if mem[_5182 + mem[_5182]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5182 + mem[_5182]]) + 1 < 0 or _5182 + ceil32(return_data.size) + ceil32(32 * mem[_5182 + mem[_5182]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5182 + ceil32(return_data.size) + ceil32(32 * mem[_5182 + mem[_5182]]) + 1
                                mem[_5182 + ceil32(return_data.size)] = _5198
                                require _5191 + (32 * _5198) + 32 <= return_data.size
                                mem[_5182 + ceil32(return_data.size) + 32 len ceil32(32 * _5198)] = mem[_5182 + _5191 + 32 len ceil32(32 * _5198)]
                                if 1 >= _5198:
                                    revert with 0, 50
                                _5642 = mem[_5182 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5182 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5182 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5715 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5715]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5715] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5715]:
                                        revert with 0, 17
                                    mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5715] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5182 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5182 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5739 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5739]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5739] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5739]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5739] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5182 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5182 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5868 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5868]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_5868] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_5868]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_5868] * ext_call.return_data[0] / 100 * 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4609 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4609]:
                                        revert with 0, 50
                                    mem[_4609 + 32] = token1Address
                                    if 1 >= mem[_4609]:
                                        revert with 0, 50
                                    mem[_4609 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4609 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4609 + 100] = 10^sub_3266f45c
                                    mem[_4609 + 132] = 64
                                    mem[_4609 + 164] = mem[_4609]
                                    idx = 0
                                    u = _4609 + 32
                                    v = _4609 + 196
                                    while idx < mem[_4609]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4609 + (32 * mem[_4609]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5181 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5190 = mem[_5181]
                                    require mem[_5181] <= test266151307()
                                    require _5181 + mem[_5181] + 31 < _5181 + return_data.size
                                    _5197 = mem[_5181 + mem[_5181]]
                                    if mem[_5181 + mem[_5181]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5181 + mem[_5181]]) + 1 < 0 or _5181 + ceil32(return_data.size) + ceil32(32 * mem[_5181 + mem[_5181]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5181 + ceil32(return_data.size) + ceil32(32 * mem[_5181 + mem[_5181]]) + 1
                                    mem[_5181 + ceil32(return_data.size)] = _5197
                                    require _5190 + (32 * _5197) + 32 <= return_data.size
                                    mem[_5181 + ceil32(return_data.size) + 32 len ceil32(32 * _5197)] = mem[_5181 + _5190 + 32 len ceil32(32 * _5197)]
                                    if 1 >= _5197:
                                        revert with 0, 50
                                    _5641 = mem[_5181 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5181 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5181 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5714 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5714]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5714] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5714]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5714] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5181 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5181 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5738 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5738]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5738] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5738]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5738] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5181 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5181 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5867 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5867]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_5867] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_5867]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_5867] * ext_call.return_data[0] / 100 * 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5187 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5187]:
                                        revert with 0, 50
                                    mem[_5187 + 32] = token1Address
                                    if 1 >= mem[_5187]:
                                        revert with 0, 50
                                    mem[_5187 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5187 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5187 + 100] = u * v
                                    mem[_5187 + 132] = 64
                                    mem[_5187 + 164] = mem[_5187]
                                    idx = 0
                                    u = _5187 + 32
                                    v = _5187 + 196
                                    while idx < mem[_5187]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5187 + (32 * mem[_5187]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5647 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5648 = mem[_5647]
                                    require mem[_5647] <= test266151307()
                                    require _5647 + mem[_5647] + 31 < _5647 + return_data.size
                                    _5649 = mem[_5647 + mem[_5647]]
                                    if mem[_5647 + mem[_5647]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5647 + mem[_5647]]) + 1 < 0 or _5647 + ceil32(return_data.size) + ceil32(32 * mem[_5647 + mem[_5647]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5647 + ceil32(return_data.size) + ceil32(32 * mem[_5647 + mem[_5647]]) + 1
                                    mem[_5647 + ceil32(return_data.size)] = _5649
                                    require _5648 + (32 * _5649) + 32 <= return_data.size
                                    mem[_5647 + ceil32(return_data.size) + 32 len ceil32(32 * _5649)] = mem[_5647 + _5648 + 32 len ceil32(32 * _5649)]
                                    if 1 >= _5649:
                                        revert with 0, 50
                                    _5854 = mem[_5647 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5647 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5647 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5881 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5854) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5881]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854) / mem[_5881] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854) / mem[_5881]:
                                            revert with 0, 17
                                        mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854) / mem[_5881] * ext_call.return_data[0] / 100 * 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5647 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5647 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5885 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5854 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5885]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / 10^sub_3266f45c) / mem[_5885] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / 10^sub_3266f45c) / mem[_5885]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / 10^sub_3266f45c) / mem[_5885] * ext_call.return_data[0] / 100 * 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5647 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5647 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5911 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5854 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5911]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / u * v) / mem[_5911] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / u * v) / mem[_5911]:
                                                revert with 0, 17
                                            mem[mem[64]] = (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3460 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5854 / u * v) / mem[_5911] * ext_call.return_data[0] / 100 * 10^18
    return memory
      from mem[64]
       len 32
}

function getAllPoolInUSD() {
    mem[132] = this.address
    require ext_code.size(masterChefAddress)
    staticcall masterChefAddress.userInfo(uint256 arg1, address arg2) with:
            gas gas_remaining wei
           args poolId, this.address
    mem[96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if not ext_call.return_data[0]:
        return 0
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestAnswer() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'ChainLink error'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = token1Address
            mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = 1
            mem[(4 * ceil32(return_data.size)) + 228] = 64
            mem[(4 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1256 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _1265 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = _1265
            require _1256 + (32 * _1265) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1265)] = mem[(4 * ceil32(return_data.size)) + _1256 + 224 len ceil32(32 * _1265)]
            if 1 >= _1265:
                revert with 0, 50
            _2387 = mem[(6 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2432 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2432]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432]:
                    revert with 0, 17
                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387) / mem[_2432] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2468 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2468]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / 10^sub_3266f45c) / mem[_2468] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3587 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3587]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2387 / s * t) / mem[_3587] * ext_call.return_data[0] / 100 * 10^18 / 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token1Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1255 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1264 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _1264
                require _1255 + (32 * _1264) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1264)] = mem[(4 * ceil32(return_data.size)) + _1255 + 224 len ceil32(32 * _1264)]
                if 1 >= _1264:
                    revert with 0, 50
                _2386 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2431 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2386) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2431]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386) / mem[_2431] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386) / mem[_2431]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386) / mem[_2431] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386) / mem[_2431] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2467 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2386 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2467]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / 10^sub_3266f45c) / mem[_2467] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / 10^sub_3266f45c) / mem[_2467]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / 10^sub_3266f45c) / mem[_2467] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / 10^sub_3266f45c) / mem[_2467] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3586 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2386 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3586]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / s * t) / mem[_3586] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / s * t) / mem[_3586]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / s * t) / mem[_3586] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2386 / s * t) / mem[_3586] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token1Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = s * t
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (4 * ceil32(return_data.size)) + 128
                v = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2393 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2396 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _2396
                require _2393 + (32 * _2396) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2396)] = mem[(4 * ceil32(return_data.size)) + _2393 + 224 len ceil32(32 * _2396)]
                if 1 >= _2396:
                    revert with 0, 50
                _3477 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3625 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3477) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3625]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477) / mem[_3625] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477) / mem[_3625]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477) / mem[_3625] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477) / mem[_3625] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3667 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3477 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3667]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / 10^sub_3266f45c) / mem[_3667] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / 10^sub_3266f45c) / mem[_3667]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / 10^sub_3266f45c) / mem[_3667] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / 10^sub_3266f45c) / mem[_3667] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4563 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3477 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4563]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / s * t) / mem[_4563] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / s * t) / mem[_4563]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / s * t) / mem[_4563] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3477 / s * t) / mem[_4563] * ext_call.return_data[0] / 100 * 10^18 / 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 1
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1253 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1262 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _1262
                require _1253 + (32 * _1262) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1262)] = mem[(4 * ceil32(return_data.size)) + _1253 + 224 len ceil32(32 * _1262)]
                if 1 >= _1262:
                    revert with 0, 50
                _2384 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2430 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2430]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430]:
                        revert with 0, 17
                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384) / mem[_2430] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2466 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2466]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / 10^sub_9ddc230a) / mem[_2466] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3585 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3585]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2384 / s * t) / mem[_3585] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1252 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _1261 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1261
                    require _1252 + (32 * _1261) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1261)] = mem[(4 * ceil32(return_data.size)) + _1252 + 224 len ceil32(32 * _1261)]
                    if 1 >= _1261:
                        revert with 0, 50
                    _2383 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2429 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2383) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2429]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383) / mem[_2429] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383) / mem[_2429]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383) / mem[_2429] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383) / mem[_2429] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2465 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2383 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2465]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / 10^sub_9ddc230a) / mem[_2465] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / 10^sub_9ddc230a) / mem[_2465]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / 10^sub_9ddc230a) / mem[_2465] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / 10^sub_9ddc230a) / mem[_2465] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3584 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2383 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3584]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / s * t) / mem[_3584] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / s * t) / mem[_3584]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / s * t) / mem[_3584] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2383 / s * t) / mem[_3584] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = s * t
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (4 * ceil32(return_data.size)) + 128
                    v = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2392 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2395 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _2395
                    require _2392 + (32 * _2395) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2395)] = mem[(4 * ceil32(return_data.size)) + _2392 + 224 len ceil32(32 * _2395)]
                    if 1 >= _2395:
                        revert with 0, 50
                    _3476 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3624 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3476) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3624]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476) / mem[_3624] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476) / mem[_3624]:
                            revert with 0, 17
                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476) / mem[_3624] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476) / mem[_3624] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3666 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3476 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3666]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / 10^sub_9ddc230a) / mem[_3666] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / 10^sub_9ddc230a) / mem[_3666]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / 10^sub_9ddc230a) / mem[_3666] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / 10^sub_9ddc230a) / mem[_3666] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(6 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4562 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3476 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4562]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / s * t) / mem[_4562] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / s * t) / mem[_4562]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / s * t) / mem[_4562] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3476 / s * t) / mem[_4562] * ext_call.return_data[0] / 100 * 10^18 / 10^18
        else:
            if not sub_9ddc230a:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 1
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1250 = mem[(4 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1259 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _1259
                require _1250 + (32 * _1259) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1259)] = mem[(4 * ceil32(return_data.size)) + _1250 + 224 len ceil32(32 * _1259)]
                if 1 >= _1259:
                    revert with 0, 50
                _2381 = mem[(6 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2435 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2435]:
                            revert with 0, 50
                        mem[_2435 + 32] = token1Address
                        if 1 >= mem[_2435]:
                            revert with 0, 50
                        mem[_2435 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2435 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2435 + 100] = 1
                        mem[_2435 + 132] = 64
                        mem[_2435 + 164] = mem[_2435]
                        idx = 0
                        s = _2435 + 32
                        t = _2435 + 196
                        while idx < mem[_2435]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2435 + (32 * mem[_2435]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3493 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3513 = mem[_3493]
                        require mem[_3493] <= test266151307()
                        require _3493 + mem[_3493] + 31 < _3493 + return_data.size
                        _3525 = mem[_3493 + mem[_3493]]
                        if mem[_3493 + mem[_3493]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3493 + mem[_3493]]) + 1 < 0 or _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3493 + ceil32(return_data.size) + ceil32(32 * mem[_3493 + mem[_3493]]) + 1
                        mem[_3493 + ceil32(return_data.size)] = _3525
                        require _3513 + (32 * _3525) + 32 <= return_data.size
                        mem[_3493 + ceil32(return_data.size) + 32 len ceil32(32 * _3525)] = mem[_3493 + _3513 + 32 len ceil32(32 * _3525)]
                        if 1 >= _3525:
                            revert with 0, 50
                        _4441 = mem[_3493 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4613 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4441) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4613]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613]:
                                revert with 0, 17
                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441) / mem[_4613] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4659 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4659]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / 10^sub_3266f45c) / mem[_4659] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3493 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3493 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5255 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5255]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4441 / s * t) / mem[_5255] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2476 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2476]:
                                revert with 0, 50
                            mem[_2476 + 32] = token1Address
                            if 1 >= mem[_2476]:
                                revert with 0, 50
                            mem[_2476 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2476 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2476 + 100] = 10^sub_3266f45c
                            mem[_2476 + 132] = 64
                            mem[_2476 + 164] = mem[_2476]
                            idx = 0
                            s = _2476 + 32
                            t = _2476 + 196
                            while idx < mem[_2476]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2476 + (32 * mem[_2476]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3492 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3512 = mem[_3492]
                            require mem[_3492] <= test266151307()
                            require _3492 + mem[_3492] + 31 < _3492 + return_data.size
                            _3524 = mem[_3492 + mem[_3492]]
                            if mem[_3492 + mem[_3492]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3492 + mem[_3492]]) + 1 < 0 or _3492 + ceil32(return_data.size) + ceil32(32 * mem[_3492 + mem[_3492]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3492 + ceil32(return_data.size) + ceil32(32 * mem[_3492 + mem[_3492]]) + 1
                            mem[_3492 + ceil32(return_data.size)] = _3524
                            require _3512 + (32 * _3524) + 32 <= return_data.size
                            mem[_3492 + ceil32(return_data.size) + 32 len ceil32(32 * _3524)] = mem[_3492 + _3512 + 32 len ceil32(32 * _3524)]
                            if 1 >= _3524:
                                revert with 0, 50
                            _4440 = mem[_3492 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4612 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4440) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4612]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4612] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4612]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4612] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440) / mem[_4612] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4658 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4658]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4658] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4658]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4658] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / 10^sub_3266f45c) / mem[_4658] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3492 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3492 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5254 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5254]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5254] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5254]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5254] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4440 / s * t) / mem[_5254] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3500 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3500]:
                                revert with 0, 50
                            mem[_3500 + 32] = token1Address
                            if 1 >= mem[_3500]:
                                revert with 0, 50
                            mem[_3500 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3500 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3500 + 100] = s * t
                            mem[_3500 + 132] = 64
                            mem[_3500 + 164] = mem[_3500]
                            idx = 0
                            s = _3500 + 32
                            t = _3500 + 196
                            while idx < mem[_3500]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3500 + (32 * mem[_3500]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4461 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4485 = mem[_4461]
                            require mem[_4461] <= test266151307()
                            require _4461 + mem[_4461] + 31 < _4461 + return_data.size
                            _4501 = mem[_4461 + mem[_4461]]
                            if mem[_4461 + mem[_4461]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4461 + mem[_4461]]) + 1 < 0 or _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4461 + ceil32(return_data.size) + ceil32(32 * mem[_4461 + mem[_4461]]) + 1
                            mem[_4461 + ceil32(return_data.size)] = _4501
                            require _4485 + (32 * _4501) + 32 <= return_data.size
                            mem[_4461 + ceil32(return_data.size) + 32 len ceil32(32 * _4501)] = mem[_4461 + _4485 + 32 len ceil32(32 * _4501)]
                            if 1 >= _4501:
                                revert with 0, 50
                            _5185 = mem[_4461 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5307 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5185) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5307]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185) / mem[_5307] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5356 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5356]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / 10^sub_3266f45c) / mem[_5356] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4461 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4461 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5695 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381) + (Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5695]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5185 / s * t) / mem[_5695] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2474 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2474]:
                                revert with 0, 50
                            mem[_2474 + 32] = token1Address
                            if 1 >= mem[_2474]:
                                revert with 0, 50
                            mem[_2474 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2474 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2474 + 100] = 1
                            mem[_2474 + 132] = 64
                            mem[_2474 + 164] = mem[_2474]
                            idx = 0
                            s = _2474 + 32
                            t = _2474 + 196
                            while idx < mem[_2474]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2474 + (32 * mem[_2474]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3489 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3510 = mem[_3489]
                            require mem[_3489] <= test266151307()
                            require _3489 + mem[_3489] + 31 < _3489 + return_data.size
                            _3522 = mem[_3489 + mem[_3489]]
                            if mem[_3489 + mem[_3489]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3489 + mem[_3489]]) + 1 < 0 or _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3489 + ceil32(return_data.size) + ceil32(32 * mem[_3489 + mem[_3489]]) + 1
                            mem[_3489 + ceil32(return_data.size)] = _3522
                            require _3510 + (32 * _3522) + 32 <= return_data.size
                            mem[_3489 + ceil32(return_data.size) + 32 len ceil32(32 * _3522)] = mem[_3489 + _3510 + 32 len ceil32(32 * _3522)]
                            if 1 >= _3522:
                                revert with 0, 50
                            _4438 = mem[_3489 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4611 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4611]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438) / mem[_4611] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4657 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4657]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / 10^sub_3266f45c) / mem[_4657] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3489 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3489 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5253 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5253]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4438 / s * t) / mem[_5253] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2536 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2536]:
                                    revert with 0, 50
                                mem[_2536 + 32] = token1Address
                                if 1 >= mem[_2536]:
                                    revert with 0, 50
                                mem[_2536 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2536 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2536 + 100] = 10^sub_3266f45c
                                mem[_2536 + 132] = 64
                                mem[_2536 + 164] = mem[_2536]
                                idx = 0
                                s = _2536 + 32
                                t = _2536 + 196
                                while idx < mem[_2536]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2536 + (32 * mem[_2536]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3488 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3509 = mem[_3488]
                                require mem[_3488] <= test266151307()
                                require _3488 + mem[_3488] + 31 < _3488 + return_data.size
                                _3521 = mem[_3488 + mem[_3488]]
                                if mem[_3488 + mem[_3488]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3488 + mem[_3488]]) + 1 < 0 or _3488 + ceil32(return_data.size) + ceil32(32 * mem[_3488 + mem[_3488]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3488 + ceil32(return_data.size) + ceil32(32 * mem[_3488 + mem[_3488]]) + 1
                                mem[_3488 + ceil32(return_data.size)] = _3521
                                require _3509 + (32 * _3521) + 32 <= return_data.size
                                mem[_3488 + ceil32(return_data.size) + 32 len ceil32(32 * _3521)] = mem[_3488 + _3509 + 32 len ceil32(32 * _3521)]
                                if 1 >= _3521:
                                    revert with 0, 50
                                _4437 = mem[_3488 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4610 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4610]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4610] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4610]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4610] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437) / mem[_4610] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4656 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4656]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4656] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4656]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4656] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / 10^sub_3266f45c) / mem[_4656] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3488 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3488 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5252 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5252]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5252] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5252]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5252] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4437 / s * t) / mem[_5252] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3498 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3498]:
                                    revert with 0, 50
                                mem[_3498 + 32] = token1Address
                                if 1 >= mem[_3498]:
                                    revert with 0, 50
                                mem[_3498 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3498 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3498 + 100] = s * t
                                mem[_3498 + 132] = 64
                                mem[_3498 + 164] = mem[_3498]
                                idx = 0
                                s = _3498 + 32
                                t = _3498 + 196
                                while idx < mem[_3498]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3498 + (32 * mem[_3498]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4460 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4484 = mem[_4460]
                                require mem[_4460] <= test266151307()
                                require _4460 + mem[_4460] + 31 < _4460 + return_data.size
                                _4500 = mem[_4460 + mem[_4460]]
                                if mem[_4460 + mem[_4460]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4460 + mem[_4460]]) + 1 < 0 or _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4460 + ceil32(return_data.size) + ceil32(32 * mem[_4460 + mem[_4460]]) + 1
                                mem[_4460 + ceil32(return_data.size)] = _4500
                                require _4484 + (32 * _4500) + 32 <= return_data.size
                                mem[_4460 + ceil32(return_data.size) + 32 len ceil32(32 * _4500)] = mem[_4460 + _4484 + 32 len ceil32(32 * _4500)]
                                if 1 >= _4500:
                                    revert with 0, 50
                                _5184 = mem[_4460 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5306 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5184) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5306]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184) / mem[_5306] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5355 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5355]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / 10^sub_3266f45c) / mem[_5355] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4460 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4460 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5694 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5184 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5694]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / s * t) / mem[_5694] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / s * t) / mem[_5694]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / s * t) / mem[_5694] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5184 / s * t) / mem[_5694] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3594 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3594]:
                                revert with 0, 50
                            mem[_3594 + 32] = token1Address
                            if 1 >= mem[_3594]:
                                revert with 0, 50
                            mem[_3594 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3594 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3594 + 100] = 1
                            mem[_3594 + 132] = 64
                            mem[_3594 + 164] = mem[_3594]
                            idx = 0
                            u = _3594 + 32
                            v = _3594 + 196
                            while idx < mem[_3594]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3594 + (32 * mem[_3594]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4459 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4483 = mem[_4459]
                            require mem[_4459] <= test266151307()
                            require _4459 + mem[_4459] + 31 < _4459 + return_data.size
                            _4499 = mem[_4459 + mem[_4459]]
                            if mem[_4459 + mem[_4459]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4459 + mem[_4459]]) + 1 < 0 or _4459 + ceil32(return_data.size) + ceil32(32 * mem[_4459 + mem[_4459]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4459 + ceil32(return_data.size) + ceil32(32 * mem[_4459 + mem[_4459]]) + 1
                            mem[_4459 + ceil32(return_data.size)] = _4499
                            require _4483 + (32 * _4499) + 32 <= return_data.size
                            mem[_4459 + ceil32(return_data.size) + 32 len ceil32(32 * _4499)] = mem[_4459 + _4483 + 32 len ceil32(32 * _4499)]
                            if 1 >= _4499:
                                revert with 0, 50
                            _5183 = mem[_4459 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5305 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5305]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183) / mem[_5305] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5354 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5354]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / 10^sub_3266f45c) / mem[_5354] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4459 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4459 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5693 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5693]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5183 / u * v) / mem[_5693] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3638 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3638]:
                                    revert with 0, 50
                                mem[_3638 + 32] = token1Address
                                if 1 >= mem[_3638]:
                                    revert with 0, 50
                                mem[_3638 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3638 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3638 + 100] = 10^sub_3266f45c
                                mem[_3638 + 132] = 64
                                mem[_3638 + 164] = mem[_3638]
                                idx = 0
                                u = _3638 + 32
                                v = _3638 + 196
                                while idx < mem[_3638]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3638 + (32 * mem[_3638]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4458 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4482 = mem[_4458]
                                require mem[_4458] <= test266151307()
                                require _4458 + mem[_4458] + 31 < _4458 + return_data.size
                                _4498 = mem[_4458 + mem[_4458]]
                                if mem[_4458 + mem[_4458]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4458 + mem[_4458]]) + 1 < 0 or _4458 + ceil32(return_data.size) + ceil32(32 * mem[_4458 + mem[_4458]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4458 + ceil32(return_data.size) + ceil32(32 * mem[_4458 + mem[_4458]]) + 1
                                mem[_4458 + ceil32(return_data.size)] = _4498
                                require _4482 + (32 * _4498) + 32 <= return_data.size
                                mem[_4458 + ceil32(return_data.size) + 32 len ceil32(32 * _4498)] = mem[_4458 + _4482 + 32 len ceil32(32 * _4498)]
                                if 1 >= _4498:
                                    revert with 0, 50
                                _5182 = mem[_4458 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4458 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4458 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5304 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5182) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5304]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5304] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5304]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5304] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182) / mem[_5304] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4458 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4458 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5353 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5353]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5353] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5353]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5353] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / 10^sub_3266f45c) / mem[_5353] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4458 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4458 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5692 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5182 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5692]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / u * v) / mem[_5692] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / u * v) / mem[_5692]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / u * v) / mem[_5692] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5182 / u * v) / mem[_5692] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4468 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4468]:
                                    revert with 0, 50
                                mem[_4468 + 32] = token1Address
                                if 1 >= mem[_4468]:
                                    revert with 0, 50
                                mem[_4468 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4468 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4468 + 100] = u * v
                                mem[_4468 + 132] = 64
                                mem[_4468 + 164] = mem[_4468]
                                idx = 0
                                u = _4468 + 32
                                v = _4468 + 196
                                while idx < mem[_4468]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4468 + (32 * mem[_4468]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5193 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5202 = mem[_5193]
                                require mem[_5193] <= test266151307()
                                require _5193 + mem[_5193] + 31 < _5193 + return_data.size
                                _5209 = mem[_5193 + mem[_5193]]
                                if mem[_5193 + mem[_5193]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5193 + mem[_5193]]) + 1 < 0 or _5193 + ceil32(return_data.size) + ceil32(32 * mem[_5193 + mem[_5193]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5193 + ceil32(return_data.size) + ceil32(32 * mem[_5193 + mem[_5193]]) + 1
                                mem[_5193 + ceil32(return_data.size)] = _5209
                                require _5202 + (32 * _5209) + 32 <= return_data.size
                                mem[_5193 + ceil32(return_data.size) + 32 len ceil32(32 * _5209)] = mem[_5193 + _5202 + 32 len ceil32(32 * _5209)]
                                if 1 >= _5209:
                                    revert with 0, 50
                                _5653 = mem[_5193 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5726 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5726]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653) / mem[_5726] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5750 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5750]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / 10^sub_3266f45c) / mem[_5750] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5193 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5193 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5879 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5879]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2381 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5653 / u * v) / mem[_5879] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1249 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _1258 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1258
                    require _1249 + (32 * _1258) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _1258)] = mem[(4 * ceil32(return_data.size)) + _1249 + 224 len ceil32(32 * _1258)]
                    if 1 >= _1258:
                        revert with 0, 50
                    _2380 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2433 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2433]:
                                revert with 0, 50
                            mem[_2433 + 32] = token1Address
                            if 1 >= mem[_2433]:
                                revert with 0, 50
                            mem[_2433 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2433 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2433 + 100] = 1
                            mem[_2433 + 132] = 64
                            mem[_2433 + 164] = mem[_2433]
                            idx = 0
                            s = _2433 + 32
                            t = _2433 + 196
                            while idx < mem[_2433]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2433 + (32 * mem[_2433]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3485 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3507 = mem[_3485]
                            require mem[_3485] <= test266151307()
                            require _3485 + mem[_3485] + 31 < _3485 + return_data.size
                            _3519 = mem[_3485 + mem[_3485]]
                            if mem[_3485 + mem[_3485]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3485 + mem[_3485]]) + 1 < 0 or _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3485 + ceil32(return_data.size) + ceil32(32 * mem[_3485 + mem[_3485]]) + 1
                            mem[_3485 + ceil32(return_data.size)] = _3519
                            require _3507 + (32 * _3519) + 32 <= return_data.size
                            mem[_3485 + ceil32(return_data.size) + 32 len ceil32(32 * _3519)] = mem[_3485 + _3507 + 32 len ceil32(32 * _3519)]
                            if 1 >= _3519:
                                revert with 0, 50
                            _4433 = mem[_3485 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4608 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4433) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4608]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433) / mem[_4608] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4655 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4655]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / 10^sub_3266f45c) / mem[_4655] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3485 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3485 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5250 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5250]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4433 / s * t) / mem[_5250] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2471 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2471]:
                                    revert with 0, 50
                                mem[_2471 + 32] = token1Address
                                if 1 >= mem[_2471]:
                                    revert with 0, 50
                                mem[_2471 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2471 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2471 + 100] = 10^sub_3266f45c
                                mem[_2471 + 132] = 64
                                mem[_2471 + 164] = mem[_2471]
                                idx = 0
                                s = _2471 + 32
                                t = _2471 + 196
                                while idx < mem[_2471]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2471 + (32 * mem[_2471]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3484 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3506 = mem[_3484]
                                require mem[_3484] <= test266151307()
                                require _3484 + mem[_3484] + 31 < _3484 + return_data.size
                                _3518 = mem[_3484 + mem[_3484]]
                                if mem[_3484 + mem[_3484]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3484 + mem[_3484]]) + 1 < 0 or _3484 + ceil32(return_data.size) + ceil32(32 * mem[_3484 + mem[_3484]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3484 + ceil32(return_data.size) + ceil32(32 * mem[_3484 + mem[_3484]]) + 1
                                mem[_3484 + ceil32(return_data.size)] = _3518
                                require _3506 + (32 * _3518) + 32 <= return_data.size
                                mem[_3484 + ceil32(return_data.size) + 32 len ceil32(32 * _3518)] = mem[_3484 + _3506 + 32 len ceil32(32 * _3518)]
                                if 1 >= _3518:
                                    revert with 0, 50
                                _4432 = mem[_3484 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3484 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3484 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4607 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4432) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4607]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432) / mem[_4607] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432) / mem[_4607]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432) / mem[_4607] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432) / mem[_4607] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3484 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3484 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4654 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4432 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4654]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / 10^sub_3266f45c) / mem[_4654] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / 10^sub_3266f45c) / mem[_4654]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / 10^sub_3266f45c) / mem[_4654] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / 10^sub_3266f45c) / mem[_4654] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3484 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3484 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5249 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _4432 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5249]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / s * t) / mem[_5249] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / s * t) / mem[_5249]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / s * t) / mem[_5249] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4432 / s * t) / mem[_5249] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3496 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3496]:
                                    revert with 0, 50
                                mem[_3496 + 32] = token1Address
                                if 1 >= mem[_3496]:
                                    revert with 0, 50
                                mem[_3496 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3496 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3496 + 100] = s * t
                                mem[_3496 + 132] = 64
                                mem[_3496 + 164] = mem[_3496]
                                idx = 0
                                s = _3496 + 32
                                t = _3496 + 196
                                while idx < mem[_3496]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3496 + (32 * mem[_3496]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4455 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4480 = mem[_4455]
                                require mem[_4455] <= test266151307()
                                require _4455 + mem[_4455] + 31 < _4455 + return_data.size
                                _4496 = mem[_4455 + mem[_4455]]
                                if mem[_4455 + mem[_4455]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4455 + mem[_4455]]) + 1 < 0 or _4455 + ceil32(return_data.size) + ceil32(32 * mem[_4455 + mem[_4455]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4455 + ceil32(return_data.size) + ceil32(32 * mem[_4455 + mem[_4455]]) + 1
                                mem[_4455 + ceil32(return_data.size)] = _4496
                                require _4480 + (32 * _4496) + 32 <= return_data.size
                                mem[_4455 + ceil32(return_data.size) + 32 len ceil32(32 * _4496)] = mem[_4455 + _4480 + 32 len ceil32(32 * _4496)]
                                if 1 >= _4496:
                                    revert with 0, 50
                                _5180 = mem[_4455 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5303 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _5180) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5303]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180) / mem[_5303] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5352 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5352]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / 10^sub_3266f45c) / mem[_5352] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4455 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4455 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5691 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380) + (Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5691]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5180 / s * t) / mem[_5691] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2469 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2469]:
                                    revert with 0, 50
                                mem[_2469 + 32] = token1Address
                                if 1 >= mem[_2469]:
                                    revert with 0, 50
                                mem[_2469 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2469 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2469 + 100] = 1
                                mem[_2469 + 132] = 64
                                mem[_2469 + 164] = mem[_2469]
                                idx = 0
                                s = _2469 + 32
                                t = _2469 + 196
                                while idx < mem[_2469]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2469 + (32 * mem[_2469]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3481 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3504 = mem[_3481]
                                require mem[_3481] <= test266151307()
                                require _3481 + mem[_3481] + 31 < _3481 + return_data.size
                                _3516 = mem[_3481 + mem[_3481]]
                                if mem[_3481 + mem[_3481]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3481 + mem[_3481]]) + 1 < 0 or _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3481 + ceil32(return_data.size) + ceil32(32 * mem[_3481 + mem[_3481]]) + 1
                                mem[_3481 + ceil32(return_data.size)] = _3516
                                require _3504 + (32 * _3516) + 32 <= return_data.size
                                mem[_3481 + ceil32(return_data.size) + 32 len ceil32(32 * _3516)] = mem[_3481 + _3504 + 32 len ceil32(32 * _3516)]
                                if 1 >= _3516:
                                    revert with 0, 50
                                _4430 = mem[_3481 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4606 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4606]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430) / mem[_4606] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4653 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4653]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / 10^sub_3266f45c) / mem[_4653] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3481 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3481 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5248 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5248]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4430 / s * t) / mem[_5248] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2530 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2530]:
                                        revert with 0, 50
                                    mem[_2530 + 32] = token1Address
                                    if 1 >= mem[_2530]:
                                        revert with 0, 50
                                    mem[_2530 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2530 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2530 + 100] = 10^sub_3266f45c
                                    mem[_2530 + 132] = 64
                                    mem[_2530 + 164] = mem[_2530]
                                    idx = 0
                                    s = _2530 + 32
                                    t = _2530 + 196
                                    while idx < mem[_2530]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2530 + (32 * mem[_2530]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3480 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3503 = mem[_3480]
                                    require mem[_3480] <= test266151307()
                                    require _3480 + mem[_3480] + 31 < _3480 + return_data.size
                                    _3515 = mem[_3480 + mem[_3480]]
                                    if mem[_3480 + mem[_3480]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3480 + mem[_3480]]) + 1 < 0 or _3480 + ceil32(return_data.size) + ceil32(32 * mem[_3480 + mem[_3480]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3480 + ceil32(return_data.size) + ceil32(32 * mem[_3480 + mem[_3480]]) + 1
                                    mem[_3480 + ceil32(return_data.size)] = _3515
                                    require _3503 + (32 * _3515) + 32 <= return_data.size
                                    mem[_3480 + ceil32(return_data.size) + 32 len ceil32(32 * _3515)] = mem[_3480 + _3503 + 32 len ceil32(32 * _3515)]
                                    if 1 >= _3515:
                                        revert with 0, 50
                                    _4429 = mem[_3480 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3480 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3480 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4605 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4429) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4605]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429) / mem[_4605] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429) / mem[_4605]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429) / mem[_4605] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429) / mem[_4605] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3480 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3480 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4652 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4429 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_4652]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / 10^sub_3266f45c) / mem[_4652] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / 10^sub_3266f45c) / mem[_4652]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / 10^sub_3266f45c) / mem[_4652] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / 10^sub_3266f45c) / mem[_4652] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3480 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3480 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5247 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4429 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5247]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / s * t) / mem[_5247] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / s * t) / mem[_5247]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / s * t) / mem[_5247] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4429 / s * t) / mem[_5247] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3494 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3494]:
                                        revert with 0, 50
                                    mem[_3494 + 32] = token1Address
                                    if 1 >= mem[_3494]:
                                        revert with 0, 50
                                    mem[_3494 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3494 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3494 + 100] = s * t
                                    mem[_3494 + 132] = 64
                                    mem[_3494 + 164] = mem[_3494]
                                    idx = 0
                                    s = _3494 + 32
                                    t = _3494 + 196
                                    while idx < mem[_3494]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3494 + (32 * mem[_3494]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4454 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4479 = mem[_4454]
                                    require mem[_4454] <= test266151307()
                                    require _4454 + mem[_4454] + 31 < _4454 + return_data.size
                                    _4495 = mem[_4454 + mem[_4454]]
                                    if mem[_4454 + mem[_4454]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4454 + mem[_4454]]) + 1 < 0 or _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4454 + ceil32(return_data.size) + ceil32(32 * mem[_4454 + mem[_4454]]) + 1
                                    mem[_4454 + ceil32(return_data.size)] = _4495
                                    require _4479 + (32 * _4495) + 32 <= return_data.size
                                    mem[_4454 + ceil32(return_data.size) + 32 len ceil32(32 * _4495)] = mem[_4454 + _4479 + 32 len ceil32(32 * _4495)]
                                    if 1 >= _4495:
                                        revert with 0, 50
                                    _5179 = mem[_4454 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5302 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5302]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179) / mem[_5302] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5351 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5351]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / 10^sub_3266f45c) / mem[_5351] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4454 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4454 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5690 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5690]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5690] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5690]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5690] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5179 / s * t) / mem[_5690] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3588 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3588]:
                                    revert with 0, 50
                                mem[_3588 + 32] = token1Address
                                if 1 >= mem[_3588]:
                                    revert with 0, 50
                                mem[_3588 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3588 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3588 + 100] = 1
                                mem[_3588 + 132] = 64
                                mem[_3588 + 164] = mem[_3588]
                                idx = 0
                                u = _3588 + 32
                                v = _3588 + 196
                                while idx < mem[_3588]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3588 + (32 * mem[_3588]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4453 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4478 = mem[_4453]
                                require mem[_4453] <= test266151307()
                                require _4453 + mem[_4453] + 31 < _4453 + return_data.size
                                _4494 = mem[_4453 + mem[_4453]]
                                if mem[_4453 + mem[_4453]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4453 + mem[_4453]]) + 1 < 0 or _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4453 + ceil32(return_data.size) + ceil32(32 * mem[_4453 + mem[_4453]]) + 1
                                mem[_4453 + ceil32(return_data.size)] = _4494
                                require _4478 + (32 * _4494) + 32 <= return_data.size
                                mem[_4453 + ceil32(return_data.size) + 32 len ceil32(32 * _4494)] = mem[_4453 + _4478 + 32 len ceil32(32 * _4494)]
                                if 1 >= _4494:
                                    revert with 0, 50
                                _5178 = mem[_4453 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5301 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5301]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178) / mem[_5301] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5350 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5350]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / 10^sub_3266f45c) / mem[_5350] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4453 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4453 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5689 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5689]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5178 / u * v) / mem[_5689] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3633 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3633]:
                                        revert with 0, 50
                                    mem[_3633 + 32] = token1Address
                                    if 1 >= mem[_3633]:
                                        revert with 0, 50
                                    mem[_3633 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3633 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3633 + 100] = 10^sub_3266f45c
                                    mem[_3633 + 132] = 64
                                    mem[_3633 + 164] = mem[_3633]
                                    idx = 0
                                    u = _3633 + 32
                                    v = _3633 + 196
                                    while idx < mem[_3633]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3633 + (32 * mem[_3633]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4452 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4477 = mem[_4452]
                                    require mem[_4452] <= test266151307()
                                    require _4452 + mem[_4452] + 31 < _4452 + return_data.size
                                    _4493 = mem[_4452 + mem[_4452]]
                                    if mem[_4452 + mem[_4452]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4452 + mem[_4452]]) + 1 < 0 or _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4452 + ceil32(return_data.size) + ceil32(32 * mem[_4452 + mem[_4452]]) + 1
                                    mem[_4452 + ceil32(return_data.size)] = _4493
                                    require _4477 + (32 * _4493) + 32 <= return_data.size
                                    mem[_4452 + ceil32(return_data.size) + 32 len ceil32(32 * _4493)] = mem[_4452 + _4477 + 32 len ceil32(32 * _4493)]
                                    if 1 >= _4493:
                                        revert with 0, 50
                                    _5177 = mem[_4452 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5300 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5177) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5300]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5300] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5300]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5300] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177) / mem[_5300] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5349 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5349]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5349] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5349]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5349] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / 10^sub_3266f45c) / mem[_5349] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4452 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4452 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5688 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5177 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5688]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / u * v) / mem[_5688] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / u * v) / mem[_5688]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / u * v) / mem[_5688] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5177 / u * v) / mem[_5688] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4466 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4466]:
                                        revert with 0, 50
                                    mem[_4466 + 32] = token1Address
                                    if 1 >= mem[_4466]:
                                        revert with 0, 50
                                    mem[_4466 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4466 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4466 + 100] = u * v
                                    mem[_4466 + 132] = 64
                                    mem[_4466 + 164] = mem[_4466]
                                    idx = 0
                                    u = _4466 + 32
                                    v = _4466 + 196
                                    while idx < mem[_4466]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4466 + (32 * mem[_4466]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5192 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5201 = mem[_5192]
                                    require mem[_5192] <= test266151307()
                                    require _5192 + mem[_5192] + 31 < _5192 + return_data.size
                                    _5208 = mem[_5192 + mem[_5192]]
                                    if mem[_5192 + mem[_5192]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5192 + mem[_5192]]) + 1 < 0 or _5192 + ceil32(return_data.size) + ceil32(32 * mem[_5192 + mem[_5192]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5192 + ceil32(return_data.size) + ceil32(32 * mem[_5192 + mem[_5192]]) + 1
                                    mem[_5192 + ceil32(return_data.size)] = _5208
                                    require _5201 + (32 * _5208) + 32 <= return_data.size
                                    mem[_5192 + ceil32(return_data.size) + 32 len ceil32(32 * _5208)] = mem[_5192 + _5201 + 32 len ceil32(32 * _5208)]
                                    if 1 >= _5208:
                                        revert with 0, 50
                                    _5652 = mem[_5192 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5652) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5725]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652) / mem[_5725] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5749 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5749]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / 10^sub_3266f45c) / mem[_5749] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5192 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5192 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5878 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5652 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5878]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / u * v) / mem[_5878] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / u * v) / mem[_5878]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / u * v) / mem[_5878] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2380 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5652 / u * v) / mem[_5878] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(4 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = s * t
                    mem[(4 * ceil32(return_data.size)) + 228] = 64
                    mem[(4 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (4 * ceil32(return_data.size)) + 128
                    v = (4 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2391 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2394 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _2394
                    require _2391 + (32 * _2394) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len ceil32(32 * _2394)] = mem[(4 * ceil32(return_data.size)) + _2391 + 224 len ceil32(32 * _2394)]
                    if 1 >= _2394:
                        revert with 0, 50
                    _3467 = mem[(6 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3626 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3626]:
                                revert with 0, 50
                            mem[_3626 + 32] = token1Address
                            if 1 >= mem[_3626]:
                                revert with 0, 50
                            mem[_3626 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3626 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3626 + 100] = 1
                            mem[_3626 + 132] = 64
                            mem[_3626 + 164] = mem[_3626]
                            idx = 0
                            s = _3626 + 32
                            t = _3626 + 196
                            while idx < mem[_3626]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3626 + (32 * mem[_3626]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4449 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4475 = mem[_4449]
                            require mem[_4449] <= test266151307()
                            require _4449 + mem[_4449] + 31 < _4449 + return_data.size
                            _4491 = mem[_4449 + mem[_4449]]
                            if mem[_4449 + mem[_4449]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4449 + mem[_4449]]) + 1 < 0 or _4449 + ceil32(return_data.size) + ceil32(32 * mem[_4449 + mem[_4449]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4449 + ceil32(return_data.size) + ceil32(32 * mem[_4449 + mem[_4449]]) + 1
                            mem[_4449 + ceil32(return_data.size)] = _4491
                            require _4475 + (32 * _4491) + 32 <= return_data.size
                            mem[_4449 + ceil32(return_data.size) + 32 len ceil32(32 * _4491)] = mem[_4449 + _4475 + 32 len ceil32(32 * _4491)]
                            if 1 >= _4491:
                                revert with 0, 50
                            _5175 = mem[_4449 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5299 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5175) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5299]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299]:
                                    revert with 0, 17
                                if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175) / mem[_5299] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5348 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5348]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / 10^sub_3266f45c) / mem[_5348] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4449 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4449 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5687 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5687]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5175 / s * t) / mem[_5687] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3670 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3670]:
                                    revert with 0, 50
                                mem[_3670 + 32] = token1Address
                                if 1 >= mem[_3670]:
                                    revert with 0, 50
                                mem[_3670 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3670 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3670 + 100] = 10^sub_3266f45c
                                mem[_3670 + 132] = 64
                                mem[_3670 + 164] = mem[_3670]
                                idx = 0
                                s = _3670 + 32
                                t = _3670 + 196
                                while idx < mem[_3670]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3670 + (32 * mem[_3670]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4448 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4474 = mem[_4448]
                                require mem[_4448] <= test266151307()
                                require _4448 + mem[_4448] + 31 < _4448 + return_data.size
                                _4490 = mem[_4448 + mem[_4448]]
                                if mem[_4448 + mem[_4448]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4448 + mem[_4448]]) + 1 < 0 or _4448 + ceil32(return_data.size) + ceil32(32 * mem[_4448 + mem[_4448]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4448 + ceil32(return_data.size) + ceil32(32 * mem[_4448 + mem[_4448]]) + 1
                                mem[_4448 + ceil32(return_data.size)] = _4490
                                require _4474 + (32 * _4490) + 32 <= return_data.size
                                mem[_4448 + ceil32(return_data.size) + 32 len ceil32(32 * _4490)] = mem[_4448 + _4474 + 32 len ceil32(32 * _4490)]
                                if 1 >= _4490:
                                    revert with 0, 50
                                _5174 = mem[_4448 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5298 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5174) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5298]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174) / mem[_5298] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174) / mem[_5298]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174) / mem[_5298] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174) / mem[_5298] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5347 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5174 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5347]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / 10^sub_3266f45c) / mem[_5347] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / 10^sub_3266f45c) / mem[_5347]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / 10^sub_3266f45c) / mem[_5347] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / 10^sub_3266f45c) / mem[_5347] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4448 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4448 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5686 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5174 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5686]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / s * t) / mem[_5686] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / s * t) / mem[_5686]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / s * t) / mem[_5686] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5174 / s * t) / mem[_5686] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4464 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4464]:
                                    revert with 0, 50
                                mem[_4464 + 32] = token1Address
                                if 1 >= mem[_4464]:
                                    revert with 0, 50
                                mem[_4464 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4464 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4464 + 100] = s * t
                                mem[_4464 + 132] = 64
                                mem[_4464 + 164] = mem[_4464]
                                idx = 0
                                s = _4464 + 32
                                t = _4464 + 196
                                while idx < mem[_4464]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4464 + (32 * mem[_4464]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5191 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5200 = mem[_5191]
                                require mem[_5191] <= test266151307()
                                require _5191 + mem[_5191] + 31 < _5191 + return_data.size
                                _5207 = mem[_5191 + mem[_5191]]
                                if mem[_5191 + mem[_5191]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5191 + mem[_5191]]) + 1 < 0 or _5191 + ceil32(return_data.size) + ceil32(32 * mem[_5191 + mem[_5191]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5191 + ceil32(return_data.size) + ceil32(32 * mem[_5191 + mem[_5191]]) + 1
                                mem[_5191 + ceil32(return_data.size)] = _5207
                                require _5200 + (32 * _5207) + 32 <= return_data.size
                                mem[_5191 + ceil32(return_data.size) + 32 len ceil32(32 * _5207)] = mem[_5191 + _5200 + 32 len ceil32(32 * _5207)]
                                if 1 >= _5207:
                                    revert with 0, 50
                                _5651 = mem[_5191 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5724 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5651) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5724]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651) / mem[_5724] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5748 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5748]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / 10^sub_3266f45c) / mem[_5748] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5191 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5191 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5877 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467) + (Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5877]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5651 / s * t) / mem[_5877] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3668 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3668]:
                                    revert with 0, 50
                                mem[_3668 + 32] = token1Address
                                if 1 >= mem[_3668]:
                                    revert with 0, 50
                                mem[_3668 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3668 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3668 + 100] = 1
                                mem[_3668 + 132] = 64
                                mem[_3668 + 164] = mem[_3668]
                                idx = 0
                                s = _3668 + 32
                                t = _3668 + 196
                                while idx < mem[_3668]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3668 + (32 * mem[_3668]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4445 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4472 = mem[_4445]
                                require mem[_4445] <= test266151307()
                                require _4445 + mem[_4445] + 31 < _4445 + return_data.size
                                _4488 = mem[_4445 + mem[_4445]]
                                if mem[_4445 + mem[_4445]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4445 + mem[_4445]]) + 1 < 0 or _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4445 + ceil32(return_data.size) + ceil32(32 * mem[_4445 + mem[_4445]]) + 1
                                mem[_4445 + ceil32(return_data.size)] = _4488
                                require _4472 + (32 * _4488) + 32 <= return_data.size
                                mem[_4445 + ceil32(return_data.size) + 32 len ceil32(32 * _4488)] = mem[_4445 + _4472 + 32 len ceil32(32 * _4488)]
                                if 1 >= _4488:
                                    revert with 0, 50
                                _5172 = mem[_4445 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5297 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5297]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172) / mem[_5297] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5346 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5346]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / 10^sub_3266f45c) / mem[_5346] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4445 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4445 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5685 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5685]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5172 / s * t) / mem[_5685] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3728 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3728]:
                                        revert with 0, 50
                                    mem[_3728 + 32] = token1Address
                                    if 1 >= mem[_3728]:
                                        revert with 0, 50
                                    mem[_3728 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3728 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3728 + 100] = 10^sub_3266f45c
                                    mem[_3728 + 132] = 64
                                    mem[_3728 + 164] = mem[_3728]
                                    idx = 0
                                    s = _3728 + 32
                                    t = _3728 + 196
                                    while idx < mem[_3728]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3728 + (32 * mem[_3728]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4444 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4471 = mem[_4444]
                                    require mem[_4444] <= test266151307()
                                    require _4444 + mem[_4444] + 31 < _4444 + return_data.size
                                    _4487 = mem[_4444 + mem[_4444]]
                                    if mem[_4444 + mem[_4444]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4444 + mem[_4444]]) + 1 < 0 or _4444 + ceil32(return_data.size) + ceil32(32 * mem[_4444 + mem[_4444]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4444 + ceil32(return_data.size) + ceil32(32 * mem[_4444 + mem[_4444]]) + 1
                                    mem[_4444 + ceil32(return_data.size)] = _4487
                                    require _4471 + (32 * _4487) + 32 <= return_data.size
                                    mem[_4444 + ceil32(return_data.size) + 32 len ceil32(32 * _4487)] = mem[_4444 + _4471 + 32 len ceil32(32 * _4487)]
                                    if 1 >= _4487:
                                        revert with 0, 50
                                    _5171 = mem[_4444 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4444 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4444 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5296 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5171) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5296]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5296] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5296]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5296] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171) / mem[_5296] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4444 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4444 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5345 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5345]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5345] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5345]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5345] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / 10^sub_3266f45c) / mem[_5345] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4444 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4444 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5684 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5171 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5684]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / s * t) / mem[_5684] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / s * t) / mem[_5684]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / s * t) / mem[_5684] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5171 / s * t) / mem[_5684] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4462 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4462]:
                                        revert with 0, 50
                                    mem[_4462 + 32] = token1Address
                                    if 1 >= mem[_4462]:
                                        revert with 0, 50
                                    mem[_4462 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4462 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4462 + 100] = s * t
                                    mem[_4462 + 132] = 64
                                    mem[_4462 + 164] = mem[_4462]
                                    idx = 0
                                    s = _4462 + 32
                                    t = _4462 + 196
                                    while idx < mem[_4462]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4462 + (32 * mem[_4462]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5190 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5199 = mem[_5190]
                                    require mem[_5190] <= test266151307()
                                    require _5190 + mem[_5190] + 31 < _5190 + return_data.size
                                    _5206 = mem[_5190 + mem[_5190]]
                                    if mem[_5190 + mem[_5190]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5190 + mem[_5190]]) + 1 < 0 or _5190 + ceil32(return_data.size) + ceil32(32 * mem[_5190 + mem[_5190]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5190 + ceil32(return_data.size) + ceil32(32 * mem[_5190 + mem[_5190]]) + 1
                                    mem[_5190 + ceil32(return_data.size)] = _5206
                                    require _5199 + (32 * _5206) + 32 <= return_data.size
                                    mem[_5190 + ceil32(return_data.size) + 32 len ceil32(32 * _5206)] = mem[_5190 + _5199 + 32 len ceil32(32 * _5206)]
                                    if 1 >= _5206:
                                        revert with 0, 50
                                    _5650 = mem[_5190 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5723 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5650) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5723]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650) / mem[_5723] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5747 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5747]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / 10^sub_3266f45c) / mem[_5747] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5190 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5190 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5876 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5650 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5876]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / s * t) / mem[_5876] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / s * t) / mem[_5876]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / s * t) / mem[_5876] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5650 / s * t) / mem[_5876] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(6 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4564 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4564]:
                                    revert with 0, 50
                                mem[_4564 + 32] = token1Address
                                if 1 >= mem[_4564]:
                                    revert with 0, 50
                                mem[_4564 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4564 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4564 + 100] = 1
                                mem[_4564 + 132] = 64
                                mem[_4564 + 164] = mem[_4564]
                                idx = 0
                                u = _4564 + 32
                                v = _4564 + 196
                                while idx < mem[_4564]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4564 + (32 * mem[_4564]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5189 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5198 = mem[_5189]
                                require mem[_5189] <= test266151307()
                                require _5189 + mem[_5189] + 31 < _5189 + return_data.size
                                _5205 = mem[_5189 + mem[_5189]]
                                if mem[_5189 + mem[_5189]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5189 + mem[_5189]]) + 1 < 0 or _5189 + ceil32(return_data.size) + ceil32(32 * mem[_5189 + mem[_5189]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5189 + ceil32(return_data.size) + ceil32(32 * mem[_5189 + mem[_5189]]) + 1
                                mem[_5189 + ceil32(return_data.size)] = _5205
                                require _5198 + (32 * _5205) + 32 <= return_data.size
                                mem[_5189 + ceil32(return_data.size) + 32 len ceil32(32 * _5205)] = mem[_5189 + _5198 + 32 len ceil32(32 * _5205)]
                                if 1 >= _5205:
                                    revert with 0, 50
                                _5649 = mem[_5189 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5722 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5722]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722]:
                                        revert with 0, 17
                                    if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5722] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5746 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5746]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5746] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5189 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5189 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5875 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5875]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / u * v) / mem[_5875] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4616 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4616]:
                                        revert with 0, 50
                                    mem[_4616 + 32] = token1Address
                                    if 1 >= mem[_4616]:
                                        revert with 0, 50
                                    mem[_4616 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4616 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4616 + 100] = 10^sub_3266f45c
                                    mem[_4616 + 132] = 64
                                    mem[_4616 + 164] = mem[_4616]
                                    idx = 0
                                    u = _4616 + 32
                                    v = _4616 + 196
                                    while idx < mem[_4616]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4616 + (32 * mem[_4616]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5188 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5197 = mem[_5188]
                                    require mem[_5188] <= test266151307()
                                    require _5188 + mem[_5188] + 31 < _5188 + return_data.size
                                    _5204 = mem[_5188 + mem[_5188]]
                                    if mem[_5188 + mem[_5188]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5188 + mem[_5188]]) + 1 < 0 or _5188 + ceil32(return_data.size) + ceil32(32 * mem[_5188 + mem[_5188]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5188 + ceil32(return_data.size) + ceil32(32 * mem[_5188 + mem[_5188]]) + 1
                                    mem[_5188 + ceil32(return_data.size)] = _5204
                                    require _5197 + (32 * _5204) + 32 <= return_data.size
                                    mem[_5188 + ceil32(return_data.size) + 32 len ceil32(32 * _5204)] = mem[_5188 + _5197 + 32 len ceil32(32 * _5204)]
                                    if 1 >= _5204:
                                        revert with 0, 50
                                    _5648 = mem[_5188 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5188 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5188 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5721 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5648) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5721]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5721] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5721]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5721] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5721] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5188 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5188 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5745]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5745] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5745]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5745] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5745] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5188 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5188 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5874 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5648 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5874]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / u * v) / mem[_5874] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / u * v) / mem[_5874]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / u * v) / mem[_5874] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / u * v) / mem[_5874] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5194 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5194]:
                                        revert with 0, 50
                                    mem[_5194 + 32] = token1Address
                                    if 1 >= mem[_5194]:
                                        revert with 0, 50
                                    mem[_5194 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5194 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5194 + 100] = u * v
                                    mem[_5194 + 132] = 64
                                    mem[_5194 + 164] = mem[_5194]
                                    idx = 0
                                    u = _5194 + 32
                                    v = _5194 + 196
                                    while idx < mem[_5194]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5194 + (32 * mem[_5194]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5654 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5655 = mem[_5654]
                                    require mem[_5654] <= test266151307()
                                    require _5654 + mem[_5654] + 31 < _5654 + return_data.size
                                    _5656 = mem[_5654 + mem[_5654]]
                                    if mem[_5654 + mem[_5654]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5654 + mem[_5654]]) + 1 < 0 or _5654 + ceil32(return_data.size) + ceil32(32 * mem[_5654 + mem[_5654]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5654 + ceil32(return_data.size) + ceil32(32 * mem[_5654 + mem[_5654]]) + 1
                                    mem[_5654 + ceil32(return_data.size)] = _5656
                                    require _5655 + (32 * _5656) + 32 <= return_data.size
                                    mem[_5654 + ceil32(return_data.size) + 32 len ceil32(32 * _5656)] = mem[_5654 + _5655 + 32 len ceil32(32 * _5656)]
                                    if 1 >= _5656:
                                        revert with 0, 50
                                    _5861 = mem[_5654 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5888 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5861) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5888]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861) / mem[_5888] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861) / mem[_5888]:
                                            revert with 0, 17
                                        if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861) / mem[_5888] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861) / mem[_5888] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5892 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5861 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5892]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / 10^sub_3266f45c) / mem[_5892] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / 10^sub_3266f45c) / mem[_5892]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / 10^sub_3266f45c) / mem[_5892] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / 10^sub_3266f45c) / mem[_5892] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5918 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5861 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5918]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / u * v) / mem[_5918] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / u * v) / mem[_5918]:
                                                revert with 0, 17
                                            if ext_call.return_data[0] and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / u * v) / mem[_5918] * ext_call.return_data[0] / 100 * 10^18 > -1 / ext_call.return_data[0]:
                                                revert with 0, 17
                                            mem[mem[64]] = ext_call.return_data[0] * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3467 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5861 / u * v) / mem[_5918] * ext_call.return_data[0] / 100 * 10^18 / 10^18
    return memory
      from mem[64]
       len 32
}

function sub_ba633017(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(0xa77230d17318075983913bc2145db16c7366156)
    staticcall 0xa77230d17318075983913bc2145db16c7366156.latestAnswer() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'ChainLink error'
    require ext_code.size(lpTokenAddress)
    staticcall lpTokenAddress.getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token0Address:
        if not sub_3266f45c:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = token1Address
            mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = 1
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _1348 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _1357 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = _1357
            require _1348 + (32 * _1357) + 32 <= return_data.size
            mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1357)] = mem[(2 * ceil32(return_data.size)) + _1348 + 224 len ceil32(32 * _1357)]
            if 1 >= _1357:
                revert with 0, 50
            _2578 = mem[(4 * ceil32(return_data.size)) + 256]
            if not sub_3266f45c:
                if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                    revert with 0, 17
                require ext_code.size(lpTokenAddress)
                staticcall lpTokenAddress.0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2623 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2578) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not mem[_2623]:
                    revert with 0, 18
                if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578) / mem[_2623] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578) / mem[_2623]:
                    revert with 0, 17
                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578) / mem[_2623] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                    revert with 0, 17
                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578) / mem[_2623] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not 10^sub_3266f45c:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2659 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2578 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2659]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / 10^sub_3266f45c) / mem[_2659] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / 10^sub_3266f45c) / mem[_2659]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / 10^sub_3266f45c) / mem[_2659] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / 10^sub_3266f45c) / mem[_2659] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_3266f45c
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if not s * t:
                        revert with 0, 18
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3877 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2578 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3877]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / s * t) / mem[_3877] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / s * t) / mem[_3877]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / s * t) / mem[_3877] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2578 / s * t) / mem[_3877] * ext_call.return_data[0] / 100 * 10^18 / 10^18
        else:
            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_3266f45c
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 10^sub_3266f45c, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1347 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1356 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_3266f45c) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1356
                require _1347 + (32 * _1356) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1356)] = mem[(2 * ceil32(return_data.size)) + _1347 + 224 len ceil32(32 * _1356)]
                if 1 >= _1356:
                    revert with 0, 50
                _2577 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2622 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2577) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2622]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577) / mem[_2622] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577) / mem[_2622]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577) / mem[_2622] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577) / mem[_2622] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2658 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2577 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2658]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / 10^sub_3266f45c) / mem[_2658] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / 10^sub_3266f45c) / mem[_2658]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / 10^sub_3266f45c) / mem[_2658] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / 10^sub_3266f45c) / mem[_2658] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3876 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _2577 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3876]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / s * t) / mem[_3876] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / s * t) / mem[_3876]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / s * t) / mem[_3876] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _2577 / s * t) / mem[_3876] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                s = 10
                t = 1
                idx = sub_3266f45c
                while idx > 1:
                    if s > -1 / s:
                        revert with 0, 17
                    if not bool(idx):
                        s = s * s
                        t = t
                        idx = uint255(idx) * 0.5
                        continue 
                    s = s * s
                    t = s * t
                    idx = uint255(idx) * 0.5
                    continue 
                if t > -1 / s:
                    revert with 0, 17
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token1Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = s * t
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                u = (2 * ceil32(return_data.size)) + 128
                v = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[v] = mem[u + 12 len 20]
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2584 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _2587 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _2587
                require _2584 + (32 * _2587) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2587)] = mem[(2 * ceil32(return_data.size)) + _2584 + 224 len ceil32(32 * _2587)]
                if 1 >= _2587:
                    revert with 0, 50
                _3767 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_3266f45c:
                    if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3915 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3767) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_3915]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767) / mem[_3915] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767) / mem[_3915]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767) / mem[_3915] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767) / mem[_3915] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not 10^sub_3266f45c:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_3266f45c):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3957 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3767 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3957]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / 10^sub_3266f45c) / mem[_3957] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / 10^sub_3266f45c) / mem[_3957]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / 10^sub_3266f45c) / mem[_3957] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / 10^sub_3266f45c) / mem[_3957] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_3266f45c
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[0]) > !(Mask(112, 0, ext_call.return_data[32]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4944 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[0]) + (Mask(112, 0, ext_call.return_data[32]) * _3767 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_4944]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / s * t) / mem[_4944] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / s * t) / mem[_4944]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / s * t) / mem[_4944] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0])) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _3767 / s * t) / mem[_4944] * ext_call.return_data[0] / 100 * 10^18 / 10^18
    else:
        if 0xd4000000000000000000000000b31f66aa3c1e785363f0875a1b74e27b85fd66 == token1Address:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1345 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1354 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1354
                require _1345 + (32 * _1354) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1354)] = mem[(2 * ceil32(return_data.size)) + _1345 + 224 len ceil32(32 * _1354)]
                if 1 >= _1354:
                    revert with 0, 50
                _2575 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                        revert with 0, 17
                    require ext_code.size(lpTokenAddress)
                    staticcall lpTokenAddress.0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2621 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2575) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not mem[_2621]:
                        revert with 0, 18
                    if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575) / mem[_2621] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575) / mem[_2621]:
                        revert with 0, 17
                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575) / mem[_2621] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                        revert with 0, 17
                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575) / mem[_2621] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2657 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2575 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2657]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / 10^sub_9ddc230a) / mem[_2657] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / 10^sub_9ddc230a) / mem[_2657]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / 10^sub_9ddc230a) / mem[_2657] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / 10^sub_9ddc230a) / mem[_2657] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3875 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2575 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3875]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / s * t) / mem[_3875] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / s * t) / mem[_3875]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / s * t) / mem[_3875] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2575 / s * t) / mem[_3875] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1344 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1353 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1353
                    require _1344 + (32 * _1353) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1353)] = mem[(2 * ceil32(return_data.size)) + _1344 + 224 len ceil32(32 * _1353)]
                    if 1 >= _1353:
                        revert with 0, 50
                    _2574 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2574) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_2620]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574) / mem[_2620] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574) / mem[_2620]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574) / mem[_2620] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574) / mem[_2620] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2656 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2574 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_2656]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / 10^sub_9ddc230a) / mem[_2656] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / 10^sub_9ddc230a) / mem[_2656]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / 10^sub_9ddc230a) / mem[_2656] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / 10^sub_9ddc230a) / mem[_2656] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3874 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _2574 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3874]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / s * t) / mem[_3874] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / s * t) / mem[_3874]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / s * t) / mem[_3874] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2574 / s * t) / mem[_3874] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2583 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2586 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2586
                    require _2583 + (32 * _2586) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2586)] = mem[(2 * ceil32(return_data.size)) + _2583 + 224 len ceil32(32 * _2586)]
                    if 1 >= _2586:
                        revert with 0, 50
                    _3766 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256]):
                            revert with 0, 17
                        require ext_code.size(lpTokenAddress)
                        staticcall lpTokenAddress.0x18160ddd with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3914 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3766) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not mem[_3914]:
                            revert with 0, 18
                        if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766) / mem[_3914] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766) / mem[_3914]:
                            revert with 0, 17
                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766) / mem[_3914] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                            revert with 0, 17
                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766) / mem[_3914] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / 10^sub_9ddc230a):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3956 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3766 / 10^sub_9ddc230a) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_3956]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / 10^sub_9ddc230a) / mem[_3956] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / 10^sub_9ddc230a) / mem[_3956]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / 10^sub_9ddc230a) / mem[_3956] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / 10^sub_9ddc230a) / mem[_3956] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if Mask(112, 0, ext_call.return_data[32]) > !(Mask(112, 0, ext_call.return_data[0]) * mem[(4 * ceil32(return_data.size)) + 256] / s * t):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4943 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if Mask(112, 0, ext_call.return_data[32]) + (Mask(112, 0, ext_call.return_data[0]) * _3766 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4943]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / s * t) / mem[_4943] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / s * t) / mem[_4943]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / s * t) / mem[_4943] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[32])) + (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3766 / s * t) / mem[_4943] * ext_call.return_data[0] / 100 * 10^18 / 10^18
        else:
            if not sub_9ddc230a:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = 1
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args 1, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1342 = mem[(2 * ceil32(return_data.size)) + 192 len 4], 0
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1351 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], 0 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = _1351
                require _1342 + (32 * _1351) + 32 <= return_data.size
                mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1351)] = mem[(2 * ceil32(return_data.size)) + _1342 + 224 len ceil32(32 * _1351)]
                if 1 >= _1351:
                    revert with 0, 50
                _2572 = mem[(4 * ceil32(return_data.size)) + 256]
                if not sub_9ddc230a:
                    if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_3266f45c:
                        _2626 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_2626]:
                            revert with 0, 50
                        mem[_2626 + 32] = token1Address
                        if 1 >= mem[_2626]:
                            revert with 0, 50
                        mem[_2626 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                        mem[_2626 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_2626 + 100] = 1
                        mem[_2626 + 132] = 64
                        mem[_2626 + 164] = mem[_2626]
                        idx = 0
                        s = _2626 + 32
                        t = _2626 + 196
                        while idx < mem[_2626]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                        staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _2626 + (32 * mem[_2626]) + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3783 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3803 = mem[_3783]
                        require mem[_3783] <= test266151307()
                        require _3783 + mem[_3783] + 31 < _3783 + return_data.size
                        _3815 = mem[_3783 + mem[_3783]]
                        if mem[_3783 + mem[_3783]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_3783 + mem[_3783]]) + 1 < 0 or _3783 + ceil32(return_data.size) + ceil32(32 * mem[_3783 + mem[_3783]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _3783 + ceil32(return_data.size) + ceil32(32 * mem[_3783 + mem[_3783]]) + 1
                        mem[_3783 + ceil32(return_data.size)] = _3815
                        require _3803 + (32 * _3815) + 32 <= return_data.size
                        mem[_3783 + ceil32(return_data.size) + 32 len ceil32(32 * _3815)] = mem[_3783 + _3803 + 32 len ceil32(32 * _3815)]
                        if 1 >= _3815:
                            revert with 0, 50
                        _4822 = mem[_3783 + ceil32(return_data.size) + 64]
                        if not sub_3266f45c:
                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64]):
                                revert with 0, 17
                            require ext_code.size(lpTokenAddress)
                            staticcall lpTokenAddress.0x18160ddd with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4994 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4822) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not mem[_4994]:
                                revert with 0, 18
                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4994] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4994]:
                                revert with 0, 17
                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4994] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                revert with 0, 17
                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822) / mem[_4994] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not 10^sub_3266f45c:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5040 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5040]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5040] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5040]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5040] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / 10^sub_3266f45c) / mem[_5040] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3783 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if not s * t:
                                    revert with 0, 18
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3783 + ceil32(return_data.size) + 64] / s * t):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5719 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5719]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5719] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5719]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5719] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4822 / s * t) / mem[_5719] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                            _2667 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2667]:
                                revert with 0, 50
                            mem[_2667 + 32] = token1Address
                            if 1 >= mem[_2667]:
                                revert with 0, 50
                            mem[_2667 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2667 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2667 + 100] = 10^sub_3266f45c
                            mem[_2667 + 132] = 64
                            mem[_2667 + 164] = mem[_2667]
                            idx = 0
                            s = _2667 + 32
                            t = _2667 + 196
                            while idx < mem[_2667]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2667 + (32 * mem[_2667]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3782 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3802 = mem[_3782]
                            require mem[_3782] <= test266151307()
                            require _3782 + mem[_3782] + 31 < _3782 + return_data.size
                            _3814 = mem[_3782 + mem[_3782]]
                            if mem[_3782 + mem[_3782]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3782 + mem[_3782]]) + 1 < 0 or _3782 + ceil32(return_data.size) + ceil32(32 * mem[_3782 + mem[_3782]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3782 + ceil32(return_data.size) + ceil32(32 * mem[_3782 + mem[_3782]]) + 1
                            mem[_3782 + ceil32(return_data.size)] = _3814
                            require _3802 + (32 * _3814) + 32 <= return_data.size
                            mem[_3782 + ceil32(return_data.size) + 32 len ceil32(32 * _3814)] = mem[_3782 + _3802 + 32 len ceil32(32 * _3814)]
                            if 1 >= _3814:
                                revert with 0, 50
                            _4821 = mem[_3782 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4993 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4821) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4993]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4993] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4993]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4993] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821) / mem[_4993] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5039 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5039]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5039] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5039]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5039] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / 10^sub_3266f45c) / mem[_5039] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3782 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3782 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5718 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5718]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5718] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5718]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5718] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4821 / s * t) / mem[_5718] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_3266f45c
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            _3790 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3790]:
                                revert with 0, 50
                            mem[_3790 + 32] = token1Address
                            if 1 >= mem[_3790]:
                                revert with 0, 50
                            mem[_3790 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3790 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3790 + 100] = s * t
                            mem[_3790 + 132] = 64
                            mem[_3790 + 164] = mem[_3790]
                            idx = 0
                            s = _3790 + 32
                            t = _3790 + 196
                            while idx < mem[_3790]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3790 + (32 * mem[_3790]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4842 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4866 = mem[_4842]
                            require mem[_4842] <= test266151307()
                            require _4842 + mem[_4842] + 31 < _4842 + return_data.size
                            _4882 = mem[_4842 + mem[_4842]]
                            if mem[_4842 + mem[_4842]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4842 + mem[_4842]]) + 1 < 0 or _4842 + ceil32(return_data.size) + ceil32(32 * mem[_4842 + mem[_4842]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4842 + ceil32(return_data.size) + ceil32(32 * mem[_4842 + mem[_4842]]) + 1
                            mem[_4842 + ceil32(return_data.size)] = _4882
                            require _4866 + (32 * _4882) + 32 <= return_data.size
                            mem[_4842 + ceil32(return_data.size) + 32 len ceil32(32 * _4882)] = mem[_4842 + _4866 + 32 len ceil32(32 * _4882)]
                            if 1 >= _4882:
                                revert with 0, 50
                            _5649 = mem[_4842 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5771 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _5649) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5771]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5771] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5771]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5771] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649) / mem[_5771] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5820 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5820]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5820] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5820]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5820] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / 10^sub_3266f45c) / mem[_5820] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4842 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4842 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6224 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572) + (Mask(112, 0, ext_call.return_data[32]) * _5649 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6224]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / s * t) / mem[_6224] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / s * t) / mem[_6224]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / s * t) / mem[_6224] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5649 / s * t) / mem[_6224] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not 10^sub_9ddc230a:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _2665 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2665]:
                                revert with 0, 50
                            mem[_2665 + 32] = token1Address
                            if 1 >= mem[_2665]:
                                revert with 0, 50
                            mem[_2665 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2665 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2665 + 100] = 1
                            mem[_2665 + 132] = 64
                            mem[_2665 + 164] = mem[_2665]
                            idx = 0
                            s = _2665 + 32
                            t = _2665 + 196
                            while idx < mem[_2665]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2665 + (32 * mem[_2665]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3779 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3800 = mem[_3779]
                            require mem[_3779] <= test266151307()
                            require _3779 + mem[_3779] + 31 < _3779 + return_data.size
                            _3812 = mem[_3779 + mem[_3779]]
                            if mem[_3779 + mem[_3779]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3779 + mem[_3779]]) + 1 < 0 or _3779 + ceil32(return_data.size) + ceil32(32 * mem[_3779 + mem[_3779]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3779 + ceil32(return_data.size) + ceil32(32 * mem[_3779 + mem[_3779]]) + 1
                            mem[_3779 + ceil32(return_data.size)] = _3812
                            require _3800 + (32 * _3812) + 32 <= return_data.size
                            mem[_3779 + ceil32(return_data.size) + 32 len ceil32(32 * _3812)] = mem[_3779 + _3800 + 32 len ceil32(32 * _3812)]
                            if 1 >= _3812:
                                revert with 0, 50
                            _4819 = mem[_3779 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4992 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4992]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4992] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4992]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4992] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819) / mem[_4992] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5038 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5038]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5038] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5038]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5038] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / 10^sub_3266f45c) / mem[_5038] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3779 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3779 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5717 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5717]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5717] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5717]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5717] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4819 / s * t) / mem[_5717] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2727 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2727]:
                                    revert with 0, 50
                                mem[_2727 + 32] = token1Address
                                if 1 >= mem[_2727]:
                                    revert with 0, 50
                                mem[_2727 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2727 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2727 + 100] = 10^sub_3266f45c
                                mem[_2727 + 132] = 64
                                mem[_2727 + 164] = mem[_2727]
                                idx = 0
                                s = _2727 + 32
                                t = _2727 + 196
                                while idx < mem[_2727]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2727 + (32 * mem[_2727]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3778 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3799 = mem[_3778]
                                require mem[_3778] <= test266151307()
                                require _3778 + mem[_3778] + 31 < _3778 + return_data.size
                                _3811 = mem[_3778 + mem[_3778]]
                                if mem[_3778 + mem[_3778]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3778 + mem[_3778]]) + 1 < 0 or _3778 + ceil32(return_data.size) + ceil32(32 * mem[_3778 + mem[_3778]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3778 + ceil32(return_data.size) + ceil32(32 * mem[_3778 + mem[_3778]]) + 1
                                mem[_3778 + ceil32(return_data.size)] = _3811
                                require _3799 + (32 * _3811) + 32 <= return_data.size
                                mem[_3778 + ceil32(return_data.size) + 32 len ceil32(32 * _3811)] = mem[_3778 + _3799 + 32 len ceil32(32 * _3811)]
                                if 1 >= _3811:
                                    revert with 0, 50
                                _4818 = mem[_3778 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4991 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4991]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4991] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4991]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4991] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818) / mem[_4991] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5037 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5037]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5037] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5037]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5037] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / 10^sub_3266f45c) / mem[_5037] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3778 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3778 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5716 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5716]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5716] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5716]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5716] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4818 / s * t) / mem[_5716] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3788 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3788]:
                                    revert with 0, 50
                                mem[_3788 + 32] = token1Address
                                if 1 >= mem[_3788]:
                                    revert with 0, 50
                                mem[_3788 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3788 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3788 + 100] = s * t
                                mem[_3788 + 132] = 64
                                mem[_3788 + 164] = mem[_3788]
                                idx = 0
                                s = _3788 + 32
                                t = _3788 + 196
                                while idx < mem[_3788]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3788 + (32 * mem[_3788]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4841 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4865 = mem[_4841]
                                require mem[_4841] <= test266151307()
                                require _4841 + mem[_4841] + 31 < _4841 + return_data.size
                                _4881 = mem[_4841 + mem[_4841]]
                                if mem[_4841 + mem[_4841]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4841 + mem[_4841]]) + 1 < 0 or _4841 + ceil32(return_data.size) + ceil32(32 * mem[_4841 + mem[_4841]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4841 + ceil32(return_data.size) + ceil32(32 * mem[_4841 + mem[_4841]]) + 1
                                mem[_4841 + ceil32(return_data.size)] = _4881
                                require _4865 + (32 * _4881) + 32 <= return_data.size
                                mem[_4841 + ceil32(return_data.size) + 32 len ceil32(32 * _4881)] = mem[_4841 + _4865 + 32 len ceil32(32 * _4881)]
                                if 1 >= _4881:
                                    revert with 0, 50
                                _5648 = mem[_4841 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5770 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5648) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5770]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5770] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5770]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5770] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648) / mem[_5770] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5819 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5819]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5819] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5819]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5819] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / 10^sub_3266f45c) / mem[_5819] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4841 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4841 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6223 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5648 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6223]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / s * t) / mem[_6223] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / s * t) / mem[_6223]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / s * t) / mem[_6223] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5648 / s * t) / mem[_6223] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        s = 10
                        t = 1
                        idx = sub_9ddc230a
                        while idx > 1:
                            if s > -1 / s:
                                revert with 0, 17
                            if not bool(idx):
                                s = s * s
                                t = t
                                idx = uint255(idx) * 0.5
                                continue 
                            s = s * s
                            t = s * t
                            idx = uint255(idx) * 0.5
                            continue 
                        if t > -1 / s:
                            revert with 0, 17
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not s * t:
                            revert with 0, 18
                        if not sub_3266f45c:
                            _3884 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3884]:
                                revert with 0, 50
                            mem[_3884 + 32] = token1Address
                            if 1 >= mem[_3884]:
                                revert with 0, 50
                            mem[_3884 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3884 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3884 + 100] = 1
                            mem[_3884 + 132] = 64
                            mem[_3884 + 164] = mem[_3884]
                            idx = 0
                            u = _3884 + 32
                            v = _3884 + 196
                            while idx < mem[_3884]:
                                mem[v] = mem[u + 12 len 20]
                                idx = idx + 1
                                u = u + 32
                                v = v + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3884 + (32 * mem[_3884]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4840 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4864 = mem[_4840]
                            require mem[_4840] <= test266151307()
                            require _4840 + mem[_4840] + 31 < _4840 + return_data.size
                            _4880 = mem[_4840 + mem[_4840]]
                            if mem[_4840 + mem[_4840]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4840 + mem[_4840]]) + 1 < 0 or _4840 + ceil32(return_data.size) + ceil32(32 * mem[_4840 + mem[_4840]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4840 + ceil32(return_data.size) + ceil32(32 * mem[_4840 + mem[_4840]]) + 1
                            mem[_4840 + ceil32(return_data.size)] = _4880
                            require _4864 + (32 * _4880) + 32 <= return_data.size
                            mem[_4840 + ceil32(return_data.size) + 32 len ceil32(32 * _4880)] = mem[_4840 + _4864 + 32 len ceil32(32 * _4880)]
                            if 1 >= _4880:
                                revert with 0, 50
                            _5647 = mem[_4840 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4840 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4840 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5769 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5647) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5769]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5769] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5769]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5769] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647) / mem[_5769] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4840 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4840 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5818 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5818]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5818] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5818]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5818] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / 10^sub_3266f45c) / mem[_5818] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4840 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not u * v:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4840 + ceil32(return_data.size) + 64] / u * v):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6222 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5647 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6222]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / u * v) / mem[_6222] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / u * v) / mem[_6222]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / u * v) / mem[_6222] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5647 / u * v) / mem[_6222] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3928 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3928]:
                                    revert with 0, 50
                                mem[_3928 + 32] = token1Address
                                if 1 >= mem[_3928]:
                                    revert with 0, 50
                                mem[_3928 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3928 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3928 + 100] = 10^sub_3266f45c
                                mem[_3928 + 132] = 64
                                mem[_3928 + 164] = mem[_3928]
                                idx = 0
                                u = _3928 + 32
                                v = _3928 + 196
                                while idx < mem[_3928]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3928 + (32 * mem[_3928]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4839 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4863 = mem[_4839]
                                require mem[_4839] <= test266151307()
                                require _4839 + mem[_4839] + 31 < _4839 + return_data.size
                                _4879 = mem[_4839 + mem[_4839]]
                                if mem[_4839 + mem[_4839]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4839 + mem[_4839]]) + 1 < 0 or _4839 + ceil32(return_data.size) + ceil32(32 * mem[_4839 + mem[_4839]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4839 + ceil32(return_data.size) + ceil32(32 * mem[_4839 + mem[_4839]]) + 1
                                mem[_4839 + ceil32(return_data.size)] = _4879
                                require _4863 + (32 * _4879) + 32 <= return_data.size
                                mem[_4839 + ceil32(return_data.size) + 32 len ceil32(32 * _4879)] = mem[_4839 + _4863 + 32 len ceil32(32 * _4879)]
                                if 1 >= _4879:
                                    revert with 0, 50
                                _5646 = mem[_4839 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4839 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4839 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5768 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5768]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5768] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5768]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5768] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646) / mem[_5768] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4839 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4839 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5817 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5817]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5817] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5817]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5817] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / 10^sub_3266f45c) / mem[_5817] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4839 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4839 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6221 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6221]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_6221] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_6221]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_6221] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5646 / u * v) / mem[_6221] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                u = 10
                                v = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if u > -1 / u:
                                        revert with 0, 17
                                    if not bool(idx):
                                        u = u * u
                                        v = v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    u = u * u
                                    v = u * v
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if v > -1 / u:
                                    revert with 0, 17
                                _4849 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4849]:
                                    revert with 0, 50
                                mem[_4849 + 32] = token1Address
                                if 1 >= mem[_4849]:
                                    revert with 0, 50
                                mem[_4849 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4849 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4849 + 100] = u * v
                                mem[_4849 + 132] = 64
                                mem[_4849 + 164] = mem[_4849]
                                idx = 0
                                u = _4849 + 32
                                v = _4849 + 196
                                while idx < mem[_4849]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4849 + (32 * mem[_4849]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5657 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5666 = mem[_5657]
                                require mem[_5657] <= test266151307()
                                require _5657 + mem[_5657] + 31 < _5657 + return_data.size
                                _5673 = mem[_5657 + mem[_5657]]
                                if mem[_5657 + mem[_5657]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5657 + mem[_5657]]) + 1 < 0 or _5657 + ceil32(return_data.size) + ceil32(32 * mem[_5657 + mem[_5657]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5657 + ceil32(return_data.size) + ceil32(32 * mem[_5657 + mem[_5657]]) + 1
                                mem[_5657 + ceil32(return_data.size)] = _5673
                                require _5666 + (32 * _5673) + 32 <= return_data.size
                                mem[_5657 + ceil32(return_data.size) + 32 len ceil32(32 * _5673)] = mem[_5657 + _5666 + 32 len ceil32(32 * _5673)]
                                if 1 >= _5673:
                                    revert with 0, 50
                                _6182 = mem[_5657 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5657 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5657 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6255 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6182) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6255]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182) / mem[_6255] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182) / mem[_6255]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182) / mem[_6255] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182) / mem[_6255] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5657 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5657 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6279 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6182 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6279]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / 10^sub_3266f45c) / mem[_6279] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / 10^sub_3266f45c) / mem[_6279]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / 10^sub_3266f45c) / mem[_6279] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / 10^sub_3266f45c) / mem[_6279] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5657 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5657 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6441 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6182 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6441]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / u * v) / mem[_6441] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / u * v) / mem[_6441]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / u * v) / mem[_6441] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2572 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6182 / u * v) / mem[_6441] * ext_call.return_data[0] / 100 * 10^18 / 10^18
            else:
                if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = 10^sub_9ddc230a
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    s = (2 * ceil32(return_data.size)) + 128
                    t = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args 10^sub_9ddc230a, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1341 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _1350 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^sub_9ddc230a) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _1350
                    require _1341 + (32 * _1350) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _1350)] = mem[(2 * ceil32(return_data.size)) + _1341 + 224 len ceil32(32 * _1350)]
                    if 1 >= _1350:
                        revert with 0, 50
                    _2571 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _2624 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_2624]:
                                revert with 0, 50
                            mem[_2624 + 32] = token1Address
                            if 1 >= mem[_2624]:
                                revert with 0, 50
                            mem[_2624 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_2624 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_2624 + 100] = 1
                            mem[_2624 + 132] = 64
                            mem[_2624 + 164] = mem[_2624]
                            idx = 0
                            s = _2624 + 32
                            t = _2624 + 196
                            while idx < mem[_2624]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _2624 + (32 * mem[_2624]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3775 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3797 = mem[_3775]
                            require mem[_3775] <= test266151307()
                            require _3775 + mem[_3775] + 31 < _3775 + return_data.size
                            _3809 = mem[_3775 + mem[_3775]]
                            if mem[_3775 + mem[_3775]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_3775 + mem[_3775]]) + 1 < 0 or _3775 + ceil32(return_data.size) + ceil32(32 * mem[_3775 + mem[_3775]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _3775 + ceil32(return_data.size) + ceil32(32 * mem[_3775 + mem[_3775]]) + 1
                            mem[_3775 + ceil32(return_data.size)] = _3809
                            require _3797 + (32 * _3809) + 32 <= return_data.size
                            mem[_3775 + ceil32(return_data.size) + 32 len ceil32(32 * _3809)] = mem[_3775 + _3797 + 32 len ceil32(32 * _3809)]
                            if 1 >= _3809:
                                revert with 0, 50
                            _4814 = mem[_3775 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_3775 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3775 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4989 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4814) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_4989]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814) / mem[_4989] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814) / mem[_4989]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814) / mem[_4989] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814) / mem[_4989] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3775 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3775 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5036 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4814 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5036]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / 10^sub_3266f45c) / mem[_5036] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / 10^sub_3266f45c) / mem[_5036]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / 10^sub_3266f45c) / mem[_5036] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / 10^sub_3266f45c) / mem[_5036] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3775 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3775 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5714 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4814 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5714]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / s * t) / mem[_5714] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / s * t) / mem[_5714]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / s * t) / mem[_5714] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4814 / s * t) / mem[_5714] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _2662 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2662]:
                                    revert with 0, 50
                                mem[_2662 + 32] = token1Address
                                if 1 >= mem[_2662]:
                                    revert with 0, 50
                                mem[_2662 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2662 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2662 + 100] = 10^sub_3266f45c
                                mem[_2662 + 132] = 64
                                mem[_2662 + 164] = mem[_2662]
                                idx = 0
                                s = _2662 + 32
                                t = _2662 + 196
                                while idx < mem[_2662]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2662 + (32 * mem[_2662]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3774 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3796 = mem[_3774]
                                require mem[_3774] <= test266151307()
                                require _3774 + mem[_3774] + 31 < _3774 + return_data.size
                                _3808 = mem[_3774 + mem[_3774]]
                                if mem[_3774 + mem[_3774]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3774 + mem[_3774]]) + 1 < 0 or _3774 + ceil32(return_data.size) + ceil32(32 * mem[_3774 + mem[_3774]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3774 + ceil32(return_data.size) + ceil32(32 * mem[_3774 + mem[_3774]]) + 1
                                mem[_3774 + ceil32(return_data.size)] = _3808
                                require _3796 + (32 * _3808) + 32 <= return_data.size
                                mem[_3774 + ceil32(return_data.size) + 32 len ceil32(32 * _3808)] = mem[_3774 + _3796 + 32 len ceil32(32 * _3808)]
                                if 1 >= _3808:
                                    revert with 0, 50
                                _4813 = mem[_3774 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3774 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3774 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4988 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4813) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4988]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813) / mem[_4988] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813) / mem[_4988]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813) / mem[_4988] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813) / mem[_4988] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3774 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3774 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5035 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4813 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5035]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / 10^sub_3266f45c) / mem[_5035] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / 10^sub_3266f45c) / mem[_5035]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / 10^sub_3266f45c) / mem[_5035] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / 10^sub_3266f45c) / mem[_5035] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3774 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3774 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5713 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _4813 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5713]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / s * t) / mem[_5713] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / s * t) / mem[_5713]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / s * t) / mem[_5713] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4813 / s * t) / mem[_5713] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _3786 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3786]:
                                    revert with 0, 50
                                mem[_3786 + 32] = token1Address
                                if 1 >= mem[_3786]:
                                    revert with 0, 50
                                mem[_3786 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3786 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3786 + 100] = s * t
                                mem[_3786 + 132] = 64
                                mem[_3786 + 164] = mem[_3786]
                                idx = 0
                                s = _3786 + 32
                                t = _3786 + 196
                                while idx < mem[_3786]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3786 + (32 * mem[_3786]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4836 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4861 = mem[_4836]
                                require mem[_4836] <= test266151307()
                                require _4836 + mem[_4836] + 31 < _4836 + return_data.size
                                _4877 = mem[_4836 + mem[_4836]]
                                if mem[_4836 + mem[_4836]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4836 + mem[_4836]]) + 1 < 0 or _4836 + ceil32(return_data.size) + ceil32(32 * mem[_4836 + mem[_4836]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4836 + ceil32(return_data.size) + ceil32(32 * mem[_4836 + mem[_4836]]) + 1
                                mem[_4836 + ceil32(return_data.size)] = _4877
                                require _4861 + (32 * _4877) + 32 <= return_data.size
                                mem[_4836 + ceil32(return_data.size) + 32 len ceil32(32 * _4877)] = mem[_4836 + _4861 + 32 len ceil32(32 * _4877)]
                                if 1 >= _4877:
                                    revert with 0, 50
                                _5644 = mem[_4836 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4836 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4836 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5767 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _5644) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5767]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5767] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5767]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5767] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644) / mem[_5767] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4836 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4836 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5816 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5816]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5816] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5816]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5816] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / 10^sub_3266f45c) / mem[_5816] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4836 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4836 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6220 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571) + (Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6220]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6220] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6220]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6220] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5644 / s * t) / mem[_6220] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _2660 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_2660]:
                                    revert with 0, 50
                                mem[_2660 + 32] = token1Address
                                if 1 >= mem[_2660]:
                                    revert with 0, 50
                                mem[_2660 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_2660 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_2660 + 100] = 1
                                mem[_2660 + 132] = 64
                                mem[_2660 + 164] = mem[_2660]
                                idx = 0
                                s = _2660 + 32
                                t = _2660 + 196
                                while idx < mem[_2660]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _2660 + (32 * mem[_2660]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3771 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _3794 = mem[_3771]
                                require mem[_3771] <= test266151307()
                                require _3771 + mem[_3771] + 31 < _3771 + return_data.size
                                _3806 = mem[_3771 + mem[_3771]]
                                if mem[_3771 + mem[_3771]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_3771 + mem[_3771]]) + 1 < 0 or _3771 + ceil32(return_data.size) + ceil32(32 * mem[_3771 + mem[_3771]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _3771 + ceil32(return_data.size) + ceil32(32 * mem[_3771 + mem[_3771]]) + 1
                                mem[_3771 + ceil32(return_data.size)] = _3806
                                require _3794 + (32 * _3806) + 32 <= return_data.size
                                mem[_3771 + ceil32(return_data.size) + 32 len ceil32(32 * _3806)] = mem[_3771 + _3794 + 32 len ceil32(32 * _3806)]
                                if 1 >= _3806:
                                    revert with 0, 50
                                _4811 = mem[_3771 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_3771 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3771 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4987 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4811) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_4987]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811) / mem[_4987] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811) / mem[_4987]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811) / mem[_4987] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811) / mem[_4987] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3771 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3771 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5034 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4811 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5034]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / 10^sub_3266f45c) / mem[_5034] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / 10^sub_3266f45c) / mem[_5034]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / 10^sub_3266f45c) / mem[_5034] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / 10^sub_3266f45c) / mem[_5034] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3771 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3771 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5712 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4811 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5712]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / s * t) / mem[_5712] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / s * t) / mem[_5712]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / s * t) / mem[_5712] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4811 / s * t) / mem[_5712] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _2721 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_2721]:
                                        revert with 0, 50
                                    mem[_2721 + 32] = token1Address
                                    if 1 >= mem[_2721]:
                                        revert with 0, 50
                                    mem[_2721 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_2721 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_2721 + 100] = 10^sub_3266f45c
                                    mem[_2721 + 132] = 64
                                    mem[_2721 + 164] = mem[_2721]
                                    idx = 0
                                    s = _2721 + 32
                                    t = _2721 + 196
                                    while idx < mem[_2721]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _2721 + (32 * mem[_2721]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3770 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _3793 = mem[_3770]
                                    require mem[_3770] <= test266151307()
                                    require _3770 + mem[_3770] + 31 < _3770 + return_data.size
                                    _3805 = mem[_3770 + mem[_3770]]
                                    if mem[_3770 + mem[_3770]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_3770 + mem[_3770]]) + 1 < 0 or _3770 + ceil32(return_data.size) + ceil32(32 * mem[_3770 + mem[_3770]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _3770 + ceil32(return_data.size) + ceil32(32 * mem[_3770 + mem[_3770]]) + 1
                                    mem[_3770 + ceil32(return_data.size)] = _3805
                                    require _3793 + (32 * _3805) + 32 <= return_data.size
                                    mem[_3770 + ceil32(return_data.size) + 32 len ceil32(32 * _3805)] = mem[_3770 + _3793 + 32 len ceil32(32 * _3805)]
                                    if 1 >= _3805:
                                        revert with 0, 50
                                    _4810 = mem[_3770 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_3770 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3770 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _4986 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4810) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_4986]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810) / mem[_4986] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810) / mem[_4986]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810) / mem[_4986] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810) / mem[_4986] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3770 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3770 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5033 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4810 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5033]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / 10^sub_3266f45c) / mem[_5033] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / 10^sub_3266f45c) / mem[_5033]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / 10^sub_3266f45c) / mem[_5033] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / 10^sub_3266f45c) / mem[_5033] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_3770 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_3770 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5711 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _4810 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5711]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / s * t) / mem[_5711] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / s * t) / mem[_5711]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / s * t) / mem[_5711] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _4810 / s * t) / mem[_5711] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _3784 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3784]:
                                        revert with 0, 50
                                    mem[_3784 + 32] = token1Address
                                    if 1 >= mem[_3784]:
                                        revert with 0, 50
                                    mem[_3784 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3784 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3784 + 100] = s * t
                                    mem[_3784 + 132] = 64
                                    mem[_3784 + 164] = mem[_3784]
                                    idx = 0
                                    s = _3784 + 32
                                    t = _3784 + 196
                                    while idx < mem[_3784]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3784 + (32 * mem[_3784]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4835 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4860 = mem[_4835]
                                    require mem[_4835] <= test266151307()
                                    require _4835 + mem[_4835] + 31 < _4835 + return_data.size
                                    _4876 = mem[_4835 + mem[_4835]]
                                    if mem[_4835 + mem[_4835]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4835 + mem[_4835]]) + 1 < 0 or _4835 + ceil32(return_data.size) + ceil32(32 * mem[_4835 + mem[_4835]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4835 + ceil32(return_data.size) + ceil32(32 * mem[_4835 + mem[_4835]]) + 1
                                    mem[_4835 + ceil32(return_data.size)] = _4876
                                    require _4860 + (32 * _4876) + 32 <= return_data.size
                                    mem[_4835 + ceil32(return_data.size) + 32 len ceil32(32 * _4876)] = mem[_4835 + _4860 + 32 len ceil32(32 * _4876)]
                                    if 1 >= _4876:
                                        revert with 0, 50
                                    _5643 = mem[_4835 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4835 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4835 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5766 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5766]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5766] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5766]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5766] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643) / mem[_5766] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4835 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4835 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5815 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5815]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5815] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5815]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5815] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / 10^sub_3266f45c) / mem[_5815] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4835 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4835 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6219 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6219]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6219] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6219]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6219] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5643 / s * t) / mem[_6219] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3878 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3878]:
                                    revert with 0, 50
                                mem[_3878 + 32] = token1Address
                                if 1 >= mem[_3878]:
                                    revert with 0, 50
                                mem[_3878 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3878 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3878 + 100] = 1
                                mem[_3878 + 132] = 64
                                mem[_3878 + 164] = mem[_3878]
                                idx = 0
                                u = _3878 + 32
                                v = _3878 + 196
                                while idx < mem[_3878]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3878 + (32 * mem[_3878]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4834 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4859 = mem[_4834]
                                require mem[_4834] <= test266151307()
                                require _4834 + mem[_4834] + 31 < _4834 + return_data.size
                                _4875 = mem[_4834 + mem[_4834]]
                                if mem[_4834 + mem[_4834]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4834 + mem[_4834]]) + 1 < 0 or _4834 + ceil32(return_data.size) + ceil32(32 * mem[_4834 + mem[_4834]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4834 + ceil32(return_data.size) + ceil32(32 * mem[_4834 + mem[_4834]]) + 1
                                mem[_4834 + ceil32(return_data.size)] = _4875
                                require _4859 + (32 * _4875) + 32 <= return_data.size
                                mem[_4834 + ceil32(return_data.size) + 32 len ceil32(32 * _4875)] = mem[_4834 + _4859 + 32 len ceil32(32 * _4875)]
                                if 1 >= _4875:
                                    revert with 0, 50
                                _5642 = mem[_4834 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5765 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5765]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5765] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5765]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5765] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642) / mem[_5765] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5814 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5814]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5814] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5814]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5814] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / 10^sub_3266f45c) / mem[_5814] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4834 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4834 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6218 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6218]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_6218] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_6218]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_6218] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5642 / u * v) / mem[_6218] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _3923 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_3923]:
                                        revert with 0, 50
                                    mem[_3923 + 32] = token1Address
                                    if 1 >= mem[_3923]:
                                        revert with 0, 50
                                    mem[_3923 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_3923 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3923 + 100] = 10^sub_3266f45c
                                    mem[_3923 + 132] = 64
                                    mem[_3923 + 164] = mem[_3923]
                                    idx = 0
                                    u = _3923 + 32
                                    v = _3923 + 196
                                    while idx < mem[_3923]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3923 + (32 * mem[_3923]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4833 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4858 = mem[_4833]
                                    require mem[_4833] <= test266151307()
                                    require _4833 + mem[_4833] + 31 < _4833 + return_data.size
                                    _4874 = mem[_4833 + mem[_4833]]
                                    if mem[_4833 + mem[_4833]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4833 + mem[_4833]]) + 1 < 0 or _4833 + ceil32(return_data.size) + ceil32(32 * mem[_4833 + mem[_4833]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4833 + ceil32(return_data.size) + ceil32(32 * mem[_4833 + mem[_4833]]) + 1
                                    mem[_4833 + ceil32(return_data.size)] = _4874
                                    require _4858 + (32 * _4874) + 32 <= return_data.size
                                    mem[_4833 + ceil32(return_data.size) + 32 len ceil32(32 * _4874)] = mem[_4833 + _4858 + 32 len ceil32(32 * _4874)]
                                    if 1 >= _4874:
                                        revert with 0, 50
                                    _5641 = mem[_4833 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5764 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5764]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5764] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5764]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5764] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641) / mem[_5764] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5813 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5813]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5813] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5813]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5813] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / 10^sub_3266f45c) / mem[_5813] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4833 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4833 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6217 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6217]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_6217] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_6217]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_6217] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5641 / u * v) / mem[_6217] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _4847 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4847]:
                                        revert with 0, 50
                                    mem[_4847 + 32] = token1Address
                                    if 1 >= mem[_4847]:
                                        revert with 0, 50
                                    mem[_4847 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4847 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4847 + 100] = u * v
                                    mem[_4847 + 132] = 64
                                    mem[_4847 + 164] = mem[_4847]
                                    idx = 0
                                    u = _4847 + 32
                                    v = _4847 + 196
                                    while idx < mem[_4847]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4847 + (32 * mem[_4847]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5656 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5665 = mem[_5656]
                                    require mem[_5656] <= test266151307()
                                    require _5656 + mem[_5656] + 31 < _5656 + return_data.size
                                    _5672 = mem[_5656 + mem[_5656]]
                                    if mem[_5656 + mem[_5656]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5656 + mem[_5656]]) + 1 < 0 or _5656 + ceil32(return_data.size) + ceil32(32 * mem[_5656 + mem[_5656]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5656 + ceil32(return_data.size) + ceil32(32 * mem[_5656 + mem[_5656]]) + 1
                                    mem[_5656 + ceil32(return_data.size)] = _5672
                                    require _5665 + (32 * _5672) + 32 <= return_data.size
                                    mem[_5656 + ceil32(return_data.size) + 32 len ceil32(32 * _5672)] = mem[_5656 + _5665 + 32 len ceil32(32 * _5672)]
                                    if 1 >= _5672:
                                        revert with 0, 50
                                    _6181 = mem[_5656 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5656 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5656 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6254 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6181) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6254]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181) / mem[_6254] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181) / mem[_6254]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181) / mem[_6254] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181) / mem[_6254] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5656 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5656 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6278 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6181 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6278]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / 10^sub_3266f45c) / mem[_6278] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / 10^sub_3266f45c) / mem[_6278]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / 10^sub_3266f45c) / mem[_6278] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / 10^sub_3266f45c) / mem[_6278] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5656 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5656 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6440 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6181 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6440]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / u * v) / mem[_6440] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / u * v) / mem[_6440]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / u * v) / mem[_6440] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _2571 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6181 / u * v) / mem[_6440] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                else:
                    s = 10
                    t = 1
                    idx = sub_9ddc230a
                    while idx > 1:
                        if s > -1 / s:
                            revert with 0, 17
                        if not bool(idx):
                            s = s * s
                            t = t
                            idx = uint255(idx) * 0.5
                            continue 
                        s = s * s
                        t = s * t
                        idx = uint255(idx) * 0.5
                        continue 
                    if t > -1 / s:
                        revert with 0, 17
                    mem[(2 * ceil32(return_data.size)) + 96] = 2
                    mem[(2 * ceil32(return_data.size)) + 128] = token0Address
                    mem[(2 * ceil32(return_data.size)) + 160] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                    mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(2 * ceil32(return_data.size)) + 196] = s * t
                    mem[(2 * ceil32(return_data.size)) + 228] = 64
                    mem[(2 * ceil32(return_data.size)) + 260] = 2
                    idx = 0
                    u = (2 * ceil32(return_data.size)) + 128
                    v = (2 * ceil32(return_data.size)) + 292
                    while idx < 2:
                        mem[v] = mem[u + 12 len 20]
                        idx = idx + 1
                        u = u + 32
                        v = v + 32
                        continue 
                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.getAmountsOut(uint256 arg1, address[] arg2) with:
                            gas gas_remaining wei
                           args s * t, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2582 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32
                    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 <= test266151307()
                    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                    _2585 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]
                    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, s * t) >> 32 + 192]) + 193
                    mem[(4 * ceil32(return_data.size)) + 192] = _2585
                    require _2582 + (32 * _2585) + 32 <= return_data.size
                    mem[(4 * ceil32(return_data.size)) + 224 len ceil32(32 * _2585)] = mem[(2 * ceil32(return_data.size)) + _2582 + 224 len ceil32(32 * _2585)]
                    if 1 >= _2585:
                        revert with 0, 50
                    _3757 = mem[(4 * ceil32(return_data.size)) + 256]
                    if not sub_9ddc230a:
                        if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 17
                        if not sub_3266f45c:
                            _3916 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_3916]:
                                revert with 0, 50
                            mem[_3916 + 32] = token1Address
                            if 1 >= mem[_3916]:
                                revert with 0, 50
                            mem[_3916 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                            mem[_3916 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_3916 + 100] = 1
                            mem[_3916 + 132] = 64
                            mem[_3916 + 164] = mem[_3916]
                            idx = 0
                            s = _3916 + 32
                            t = _3916 + 196
                            while idx < mem[_3916]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _3916 + (32 * mem[_3916]) + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _4830 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _4856 = mem[_4830]
                            require mem[_4830] <= test266151307()
                            require _4830 + mem[_4830] + 31 < _4830 + return_data.size
                            _4872 = mem[_4830 + mem[_4830]]
                            if mem[_4830 + mem[_4830]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_4830 + mem[_4830]]) + 1 < 0 or _4830 + ceil32(return_data.size) + ceil32(32 * mem[_4830 + mem[_4830]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _4830 + ceil32(return_data.size) + ceil32(32 * mem[_4830 + mem[_4830]]) + 1
                            mem[_4830 + ceil32(return_data.size)] = _4872
                            require _4856 + (32 * _4872) + 32 <= return_data.size
                            mem[_4830 + ceil32(return_data.size) + 32 len ceil32(32 * _4872)] = mem[_4830 + _4856 + 32 len ceil32(32 * _4872)]
                            if 1 >= _4872:
                                revert with 0, 50
                            _5639 = mem[_4830 + ceil32(return_data.size) + 64]
                            if not sub_3266f45c:
                                if Mask(112, 0, ext_call.return_data[32]) and mem[_4830 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 17
                                if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4830 + ceil32(return_data.size) + 64]):
                                    revert with 0, 17
                                require ext_code.size(lpTokenAddress)
                                staticcall lpTokenAddress.0x18160ddd with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5763 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5639) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                    revert with 0, 17
                                if not mem[_5763]:
                                    revert with 0, 18
                                if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639) / mem[_5763] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639) / mem[_5763]:
                                    revert with 0, 17
                                if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639) / mem[_5763] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                    revert with 0, 17
                                mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639) / mem[_5763] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4830 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not 10^sub_3266f45c:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4830 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5812 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5639 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5812]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / 10^sub_3266f45c) / mem[_5812] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / 10^sub_3266f45c) / mem[_5812]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / 10^sub_3266f45c) / mem[_5812] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / 10^sub_3266f45c) / mem[_5812] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4830 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if not s * t:
                                        revert with 0, 18
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4830 + ceil32(return_data.size) + 64] / s * t):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6216 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5639 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6216]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / s * t) / mem[_6216] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / s * t) / mem[_6216]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / s * t) / mem[_6216] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5639 / s * t) / mem[_6216] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                _3960 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3960]:
                                    revert with 0, 50
                                mem[_3960 + 32] = token1Address
                                if 1 >= mem[_3960]:
                                    revert with 0, 50
                                mem[_3960 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3960 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3960 + 100] = 10^sub_3266f45c
                                mem[_3960 + 132] = 64
                                mem[_3960 + 164] = mem[_3960]
                                idx = 0
                                s = _3960 + 32
                                t = _3960 + 196
                                while idx < mem[_3960]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3960 + (32 * mem[_3960]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4829 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4855 = mem[_4829]
                                require mem[_4829] <= test266151307()
                                require _4829 + mem[_4829] + 31 < _4829 + return_data.size
                                _4871 = mem[_4829 + mem[_4829]]
                                if mem[_4829 + mem[_4829]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4829 + mem[_4829]]) + 1 < 0 or _4829 + ceil32(return_data.size) + ceil32(32 * mem[_4829 + mem[_4829]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4829 + ceil32(return_data.size) + ceil32(32 * mem[_4829 + mem[_4829]]) + 1
                                mem[_4829 + ceil32(return_data.size)] = _4871
                                require _4855 + (32 * _4871) + 32 <= return_data.size
                                mem[_4829 + ceil32(return_data.size) + 32 len ceil32(32 * _4871)] = mem[_4829 + _4855 + 32 len ceil32(32 * _4871)]
                                if 1 >= _4871:
                                    revert with 0, 50
                                _5638 = mem[_4829 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4829 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4829 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5762 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5638) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5762]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638) / mem[_5762] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638) / mem[_5762]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638) / mem[_5762] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638) / mem[_5762] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4829 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4829 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5811 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5638 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5811]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / 10^sub_3266f45c) / mem[_5811] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / 10^sub_3266f45c) / mem[_5811]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / 10^sub_3266f45c) / mem[_5811] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / 10^sub_3266f45c) / mem[_5811] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4829 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4829 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6215 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _5638 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6215]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / s * t) / mem[_6215] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / s * t) / mem[_6215]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / s * t) / mem[_6215] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5638 / s * t) / mem[_6215] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                s = 10
                                t = 1
                                idx = sub_3266f45c
                                while idx > 1:
                                    if s > -1 / s:
                                        revert with 0, 17
                                    if not bool(idx):
                                        s = s * s
                                        t = t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    s = s * s
                                    t = s * t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                if t > -1 / s:
                                    revert with 0, 17
                                _4845 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4845]:
                                    revert with 0, 50
                                mem[_4845 + 32] = token1Address
                                if 1 >= mem[_4845]:
                                    revert with 0, 50
                                mem[_4845 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4845 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4845 + 100] = s * t
                                mem[_4845 + 132] = 64
                                mem[_4845 + 164] = mem[_4845]
                                idx = 0
                                s = _4845 + 32
                                t = _4845 + 196
                                while idx < mem[_4845]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4845 + (32 * mem[_4845]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5655 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5664 = mem[_5655]
                                require mem[_5655] <= test266151307()
                                require _5655 + mem[_5655] + 31 < _5655 + return_data.size
                                _5671 = mem[_5655 + mem[_5655]]
                                if mem[_5655 + mem[_5655]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5655 + mem[_5655]]) + 1 < 0 or _5655 + ceil32(return_data.size) + ceil32(32 * mem[_5655 + mem[_5655]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5655 + ceil32(return_data.size) + ceil32(32 * mem[_5655 + mem[_5655]]) + 1
                                mem[_5655 + ceil32(return_data.size)] = _5671
                                require _5664 + (32 * _5671) + 32 <= return_data.size
                                mem[_5655 + ceil32(return_data.size) + 32 len ceil32(32 * _5671)] = mem[_5655 + _5664 + 32 len ceil32(32 * _5671)]
                                if 1 >= _5671:
                                    revert with 0, 50
                                _6180 = mem[_5655 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6253 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _6180) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6253]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180) / mem[_6253] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180) / mem[_6253]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180) / mem[_6253] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180) / mem[_6253] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6277 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _6180 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6277]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / 10^sub_3266f45c) / mem[_6277] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / 10^sub_3266f45c) / mem[_6277]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / 10^sub_3266f45c) / mem[_6277] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / 10^sub_3266f45c) / mem[_6277] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5655 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5655 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6439 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757) + (Mask(112, 0, ext_call.return_data[32]) * _6180 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6439]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / s * t) / mem[_6439] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / s * t) / mem[_6439]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / s * t) / mem[_6439] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6180 / s * t) / mem[_6439] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                    else:
                        if bool(bool(sub_9ddc230a < 78)) or bool(bool(sub_9ddc230a < 32)):
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not 10^sub_9ddc230a:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _3958 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_3958]:
                                    revert with 0, 50
                                mem[_3958 + 32] = token1Address
                                if 1 >= mem[_3958]:
                                    revert with 0, 50
                                mem[_3958 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_3958 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3958 + 100] = 1
                                mem[_3958 + 132] = 64
                                mem[_3958 + 164] = mem[_3958]
                                idx = 0
                                s = _3958 + 32
                                t = _3958 + 196
                                while idx < mem[_3958]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3958 + (32 * mem[_3958]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4826 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4853 = mem[_4826]
                                require mem[_4826] <= test266151307()
                                require _4826 + mem[_4826] + 31 < _4826 + return_data.size
                                _4869 = mem[_4826 + mem[_4826]]
                                if mem[_4826 + mem[_4826]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_4826 + mem[_4826]]) + 1 < 0 or _4826 + ceil32(return_data.size) + ceil32(32 * mem[_4826 + mem[_4826]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _4826 + ceil32(return_data.size) + ceil32(32 * mem[_4826 + mem[_4826]]) + 1
                                mem[_4826 + ceil32(return_data.size)] = _4869
                                require _4853 + (32 * _4869) + 32 <= return_data.size
                                mem[_4826 + ceil32(return_data.size) + 32 len ceil32(32 * _4869)] = mem[_4826 + _4853 + 32 len ceil32(32 * _4869)]
                                if 1 >= _4869:
                                    revert with 0, 50
                                _5636 = mem[_4826 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_4826 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4826 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5761 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5636) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_5761]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636) / mem[_5761] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636) / mem[_5761]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636) / mem[_5761] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636) / mem[_5761] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4826 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4826 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5810 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5636 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5810]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / 10^sub_3266f45c) / mem[_5810] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / 10^sub_3266f45c) / mem[_5810]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / 10^sub_3266f45c) / mem[_5810] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / 10^sub_3266f45c) / mem[_5810] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        s = 10
                                        t = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if s > -1 / s:
                                                revert with 0, 17
                                            if not bool(idx):
                                                s = s * s
                                                t = t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            s = s * s
                                            t = s * t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if t > -1 / s:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4826 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not s * t:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4826 + ceil32(return_data.size) + 64] / s * t):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6214 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5636 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6214]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / s * t) / mem[_6214] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / s * t) / mem[_6214]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / s * t) / mem[_6214] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5636 / s * t) / mem[_6214] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4018 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4018]:
                                        revert with 0, 50
                                    mem[_4018 + 32] = token1Address
                                    if 1 >= mem[_4018]:
                                        revert with 0, 50
                                    mem[_4018 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4018 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4018 + 100] = 10^sub_3266f45c
                                    mem[_4018 + 132] = 64
                                    mem[_4018 + 164] = mem[_4018]
                                    idx = 0
                                    s = _4018 + 32
                                    t = _4018 + 196
                                    while idx < mem[_4018]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4018 + (32 * mem[_4018]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4825 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _4852 = mem[_4825]
                                    require mem[_4825] <= test266151307()
                                    require _4825 + mem[_4825] + 31 < _4825 + return_data.size
                                    _4868 = mem[_4825 + mem[_4825]]
                                    if mem[_4825 + mem[_4825]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_4825 + mem[_4825]]) + 1 < 0 or _4825 + ceil32(return_data.size) + ceil32(32 * mem[_4825 + mem[_4825]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _4825 + ceil32(return_data.size) + ceil32(32 * mem[_4825 + mem[_4825]]) + 1
                                    mem[_4825 + ceil32(return_data.size)] = _4868
                                    require _4852 + (32 * _4868) + 32 <= return_data.size
                                    mem[_4825 + ceil32(return_data.size) + 32 len ceil32(32 * _4868)] = mem[_4825 + _4852 + 32 len ceil32(32 * _4868)]
                                    if 1 >= _4868:
                                        revert with 0, 50
                                    _5635 = mem[_4825 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_4825 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4825 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5760 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5635) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_5760]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635) / mem[_5760] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635) / mem[_5760]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635) / mem[_5760] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635) / mem[_5760] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4825 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4825 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5809 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5635 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_5809]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / 10^sub_3266f45c) / mem[_5809] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / 10^sub_3266f45c) / mem[_5809]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / 10^sub_3266f45c) / mem[_5809] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / 10^sub_3266f45c) / mem[_5809] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_4825 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_4825 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6213 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _5635 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6213]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / s * t) / mem[_6213] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / s * t) / mem[_6213]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / s * t) / mem[_6213] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _5635 / s * t) / mem[_6213] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    s = 10
                                    t = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if s > -1 / s:
                                            revert with 0, 17
                                        if not bool(idx):
                                            s = s * s
                                            t = t
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        s = s * s
                                        t = s * t
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if t > -1 / s:
                                        revert with 0, 17
                                    _4843 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4843]:
                                        revert with 0, 50
                                    mem[_4843 + 32] = token1Address
                                    if 1 >= mem[_4843]:
                                        revert with 0, 50
                                    mem[_4843 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4843 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4843 + 100] = s * t
                                    mem[_4843 + 132] = 64
                                    mem[_4843 + 164] = mem[_4843]
                                    idx = 0
                                    s = _4843 + 32
                                    t = _4843 + 196
                                    while idx < mem[_4843]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4843 + (32 * mem[_4843]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5654 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5663 = mem[_5654]
                                    require mem[_5654] <= test266151307()
                                    require _5654 + mem[_5654] + 31 < _5654 + return_data.size
                                    _5670 = mem[_5654 + mem[_5654]]
                                    if mem[_5654 + mem[_5654]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5654 + mem[_5654]]) + 1 < 0 or _5654 + ceil32(return_data.size) + ceil32(32 * mem[_5654 + mem[_5654]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5654 + ceil32(return_data.size) + ceil32(32 * mem[_5654 + mem[_5654]]) + 1
                                    mem[_5654 + ceil32(return_data.size)] = _5670
                                    require _5663 + (32 * _5670) + 32 <= return_data.size
                                    mem[_5654 + ceil32(return_data.size) + 32 len ceil32(32 * _5670)] = mem[_5654 + _5663 + 32 len ceil32(32 * _5670)]
                                    if 1 >= _5670:
                                        revert with 0, 50
                                    _6179 = mem[_5654 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6252 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6179) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6252]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179) / mem[_6252] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179) / mem[_6252]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179) / mem[_6252] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179) / mem[_6252] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6276 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6179 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6276]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / 10^sub_3266f45c) / mem[_6276] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / 10^sub_3266f45c) / mem[_6276]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / 10^sub_3266f45c) / mem[_6276] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / 10^sub_3266f45c) / mem[_6276] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            s = 10
                                            t = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if s > -1 / s:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    s = s * s
                                                    t = t
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                s = s * s
                                                t = s * t
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if t > -1 / s:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5654 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not s * t:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5654 + ceil32(return_data.size) + 64] / s * t):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6438 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (Mask(112, 0, ext_call.return_data[32]) * _6179 / s * t) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6438]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / s * t) / mem[_6438] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / s * t) / mem[_6438]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / s * t) / mem[_6438] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / 10^sub_9ddc230a) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6179 / s * t) / mem[_6438] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                        else:
                            s = 10
                            t = 1
                            idx = sub_9ddc230a
                            while idx > 1:
                                if s > -1 / s:
                                    revert with 0, 17
                                if not bool(idx):
                                    s = s * s
                                    t = t
                                    idx = uint255(idx) * 0.5
                                    continue 
                                s = s * s
                                t = s * t
                                idx = uint255(idx) * 0.5
                                continue 
                            if t > -1 / s:
                                revert with 0, 17
                            if Mask(112, 0, ext_call.return_data[0]) and mem[(4 * ceil32(return_data.size)) + 256] > -1 / Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 17
                            if not s * t:
                                revert with 0, 18
                            if not sub_3266f45c:
                                _4945 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_4945]:
                                    revert with 0, 50
                                mem[_4945 + 32] = token1Address
                                if 1 >= mem[_4945]:
                                    revert with 0, 50
                                mem[_4945 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                mem[_4945 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_4945 + 100] = 1
                                mem[_4945 + 132] = 64
                                mem[_4945 + 164] = mem[_4945]
                                idx = 0
                                u = _4945 + 32
                                v = _4945 + 196
                                while idx < mem[_4945]:
                                    mem[v] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    u = u + 32
                                    v = v + 32
                                    continue 
                                require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _4945 + (32 * mem[_4945]) + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5653 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5662 = mem[_5653]
                                require mem[_5653] <= test266151307()
                                require _5653 + mem[_5653] + 31 < _5653 + return_data.size
                                _5669 = mem[_5653 + mem[_5653]]
                                if mem[_5653 + mem[_5653]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_5653 + mem[_5653]]) + 1 < 0 or _5653 + ceil32(return_data.size) + ceil32(32 * mem[_5653 + mem[_5653]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _5653 + ceil32(return_data.size) + ceil32(32 * mem[_5653 + mem[_5653]]) + 1
                                mem[_5653 + ceil32(return_data.size)] = _5669
                                require _5662 + (32 * _5669) + 32 <= return_data.size
                                mem[_5653 + ceil32(return_data.size) + 32 len ceil32(32 * _5669)] = mem[_5653 + _5662 + 32 len ceil32(32 * _5669)]
                                if 1 >= _5669:
                                    revert with 0, 50
                                _6178 = mem[_5653 + ceil32(return_data.size) + 64]
                                if not sub_3266f45c:
                                    if Mask(112, 0, ext_call.return_data[32]) and mem[_5653 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 17
                                    if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5653 + ceil32(return_data.size) + 64]):
                                        revert with 0, 17
                                    require ext_code.size(lpTokenAddress)
                                    staticcall lpTokenAddress.0x18160ddd with:
                                            gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6251 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6178) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                        revert with 0, 17
                                    if not mem[_6251]:
                                        revert with 0, 18
                                    if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178) / mem[_6251] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178) / mem[_6251]:
                                        revert with 0, 17
                                    if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178) / mem[_6251] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                        revert with 0, 17
                                    mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178) / mem[_6251] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5653 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not 10^sub_3266f45c:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5653 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6275 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6178 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6275]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / 10^sub_3266f45c) / mem[_6275] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / 10^sub_3266f45c) / mem[_6275]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / 10^sub_3266f45c) / mem[_6275] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / 10^sub_3266f45c) / mem[_6275] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        u = 10
                                        v = 1
                                        idx = sub_3266f45c
                                        while idx > 1:
                                            if u > -1 / u:
                                                revert with 0, 17
                                            if not bool(idx):
                                                u = u * u
                                                v = v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            u = u * u
                                            v = u * v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        if v > -1 / u:
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5653 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if not u * v:
                                            revert with 0, 18
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5653 + ceil32(return_data.size) + 64] / u * v):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6437 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6178 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6437]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / u * v) / mem[_6437] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / u * v) / mem[_6437]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / u * v) / mem[_6437] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6178 / u * v) / mem[_6437] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                            else:
                                if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                    _4997 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_4997]:
                                        revert with 0, 50
                                    mem[_4997 + 32] = token1Address
                                    if 1 >= mem[_4997]:
                                        revert with 0, 50
                                    mem[_4997 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_4997 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_4997 + 100] = 10^sub_3266f45c
                                    mem[_4997 + 132] = 64
                                    mem[_4997 + 164] = mem[_4997]
                                    idx = 0
                                    u = _4997 + 32
                                    v = _4997 + 196
                                    while idx < mem[_4997]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _4997 + (32 * mem[_4997]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5652 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5661 = mem[_5652]
                                    require mem[_5652] <= test266151307()
                                    require _5652 + mem[_5652] + 31 < _5652 + return_data.size
                                    _5668 = mem[_5652 + mem[_5652]]
                                    if mem[_5652 + mem[_5652]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_5652 + mem[_5652]]) + 1 < 0 or _5652 + ceil32(return_data.size) + ceil32(32 * mem[_5652 + mem[_5652]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _5652 + ceil32(return_data.size) + ceil32(32 * mem[_5652 + mem[_5652]]) + 1
                                    mem[_5652 + ceil32(return_data.size)] = _5668
                                    require _5661 + (32 * _5668) + 32 <= return_data.size
                                    mem[_5652 + ceil32(return_data.size) + 32 len ceil32(32 * _5668)] = mem[_5652 + _5661 + 32 len ceil32(32 * _5668)]
                                    if 1 >= _5668:
                                        revert with 0, 50
                                    _6177 = mem[_5652 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_5652 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5652 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6250 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6177) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6250]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177) / mem[_6250] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177) / mem[_6250]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177) / mem[_6250] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177) / mem[_6250] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5652 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5652 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6274 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6177 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6274]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / 10^sub_3266f45c) / mem[_6274] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / 10^sub_3266f45c) / mem[_6274]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / 10^sub_3266f45c) / mem[_6274] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / 10^sub_3266f45c) / mem[_6274] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_5652 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_5652 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6436 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6177 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6436]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / u * v) / mem[_6436] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / u * v) / mem[_6436]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / u * v) / mem[_6436] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6177 / u * v) / mem[_6436] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                else:
                                    u = 10
                                    v = 1
                                    idx = sub_3266f45c
                                    while idx > 1:
                                        if u > -1 / u:
                                            revert with 0, 17
                                        if not bool(idx):
                                            u = u * u
                                            v = v
                                            idx = uint255(idx) * 0.5
                                            continue 
                                        u = u * u
                                        v = u * v
                                        idx = uint255(idx) * 0.5
                                        continue 
                                    if v > -1 / u:
                                        revert with 0, 17
                                    _5658 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_5658]:
                                        revert with 0, 50
                                    mem[_5658 + 32] = token1Address
                                    if 1 >= mem[_5658]:
                                        revert with 0, 50
                                    mem[_5658 + 64] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66
                                    mem[_5658 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_5658 + 100] = u * v
                                    mem[_5658 + 132] = 64
                                    mem[_5658 + 164] = mem[_5658]
                                    idx = 0
                                    u = _5658 + 32
                                    v = _5658 + 196
                                    while idx < mem[_5658]:
                                        mem[v] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        u = u + 32
                                        v = v + 32
                                        continue 
                                    require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933)
                                    staticcall 0x60ae616a2155ee3d9a68541ba4544862310933.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _5658 + (32 * mem[_5658]) + -mem[64] + 192]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6183 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6184 = mem[_6183]
                                    require mem[_6183] <= test266151307()
                                    require _6183 + mem[_6183] + 31 < _6183 + return_data.size
                                    _6185 = mem[_6183 + mem[_6183]]
                                    if mem[_6183 + mem[_6183]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_6183 + mem[_6183]]) + 1 < 0 or _6183 + ceil32(return_data.size) + ceil32(32 * mem[_6183 + mem[_6183]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _6183 + ceil32(return_data.size) + ceil32(32 * mem[_6183 + mem[_6183]]) + 1
                                    mem[_6183 + ceil32(return_data.size)] = _6185
                                    require _6184 + (32 * _6185) + 32 <= return_data.size
                                    mem[_6183 + ceil32(return_data.size) + 32 len ceil32(32 * _6185)] = mem[_6183 + _6184 + 32 len ceil32(32 * _6185)]
                                    if 1 >= _6185:
                                        revert with 0, 50
                                    _6423 = mem[_6183 + ceil32(return_data.size) + 64]
                                    if not sub_3266f45c:
                                        if Mask(112, 0, ext_call.return_data[32]) and mem[_6183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                            revert with 0, 17
                                        if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6183 + ceil32(return_data.size) + 64]):
                                            revert with 0, 17
                                        require ext_code.size(lpTokenAddress)
                                        staticcall lpTokenAddress.0x18160ddd with:
                                                gas gas_remaining wei
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _6450 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6423) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                            revert with 0, 17
                                        if not mem[_6450]:
                                            revert with 0, 18
                                        if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423) / mem[_6450] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423) / mem[_6450]:
                                            revert with 0, 17
                                        if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423) / mem[_6450] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                            revert with 0, 17
                                        mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423) / mem[_6450] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                    else:
                                        if bool(bool(sub_3266f45c < 78)) or bool(bool(sub_3266f45c < 32)):
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_6183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not 10^sub_3266f45c:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6183 + ceil32(return_data.size) + 64] / 10^sub_3266f45c):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6454 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6423 / 10^sub_3266f45c) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6454]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / 10^sub_3266f45c) / mem[_6454] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / 10^sub_3266f45c) / mem[_6454]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / 10^sub_3266f45c) / mem[_6454] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / 10^sub_3266f45c) / mem[_6454] * ext_call.return_data[0] / 100 * 10^18 / 10^18
                                        else:
                                            u = 10
                                            v = 1
                                            idx = sub_3266f45c
                                            while idx > 1:
                                                if u > -1 / u:
                                                    revert with 0, 17
                                                if not bool(idx):
                                                    u = u * u
                                                    v = v
                                                    idx = uint255(idx) * 0.5
                                                    continue 
                                                u = u * u
                                                v = u * v
                                                idx = uint255(idx) * 0.5
                                                continue 
                                            if v > -1 / u:
                                                revert with 0, 17
                                            if Mask(112, 0, ext_call.return_data[32]) and mem[_6183 + ceil32(return_data.size) + 64] > -1 / Mask(112, 0, ext_call.return_data[32]):
                                                revert with 0, 17
                                            if not u * v:
                                                revert with 0, 18
                                            if Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t > !(Mask(112, 0, ext_call.return_data[32]) * mem[_6183 + ceil32(return_data.size) + 64] / u * v):
                                                revert with 0, 17
                                            require ext_code.size(lpTokenAddress)
                                            staticcall lpTokenAddress.0x18160ddd with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _6489 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if (Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (Mask(112, 0, ext_call.return_data[32]) * _6423 / u * v) > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                                revert with 0, 17
                                            if not mem[_6489]:
                                                revert with 0, 18
                                            if (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / u * v) / mem[_6489] and ext_call.return_data[0] > -1 / (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / u * v) / mem[_6489]:
                                                revert with 0, 17
                                            if userInfo[address(arg1)].field_0 and (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / u * v) / mem[_6489] * ext_call.return_data[0] / 100 * 10^18 > -1 / userInfo[address(arg1)].field_0:
                                                revert with 0, 17
                                            mem[mem[64]] = userInfo[address(arg1)].field_0 * (10^18 * Mask(112, 0, ext_call.return_data[0]) * _3757 / s * t) + (10^18 * Mask(112, 0, ext_call.return_data[32]) * _6423 / u * v) / mem[_6489] * ext_call.return_data[0] / 100 * 10^18 / 10^18
    return memory
      from mem[64]
       len 32
}



}

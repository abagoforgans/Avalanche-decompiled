contract main {




// =====================  Runtime code  =====================


#
#  - sub_0a40ec89(?)
#  - sub_179a3410(?)
#  - sub_39e04734(?)
#  - _getNodesRewardAvailable(address arg1)
#  - sub_5c71eea6(?)
#  - _cashoutNodeReward(address arg1, uint256 arg2)
#  - sub_863b9293(?)
#  - _getRewardAmountOf(address arg1, uint256 arg2)
#  - sub_d73203ae(?)
#
array of uint256 stor1;
array of struct stor4;
uint256 nodePrice;
uint256 rewardPerNode;
uint256 claimTime;
address gateKeeperAddress;
address tokenAddress;
uint256 totalNodesCreated;
uint256 totalRewardStaked;
uint256 sub_a2a7b0f2;
uint256 sub_666c8c6d;
uint256 sub_54d9454d;
uint256 gracePeriod;

function claimTime() payable {
    return claimTime
}

function gateKeeper() payable {
    return gateKeeperAddress
}

function sub_54d9454d(?) payable {
    return sub_54d9454d
}

function rewardPerNode() payable {
    return rewardPerNode
}

function sub_666c8c6d(?) payable {
    return sub_666c8c6d
}

function totalRewardStaked() payable {
    return totalRewardStaked
}

function gracePeriod() payable {
    return gracePeriod
}

function sub_a2a7b0f2(?) payable {
    return sub_a2a7b0f2
}

function totalNodesCreated() payable {
    return totalNodesCreated
}

function nodePrice() payable {
    return nodePrice
}

function token() payable {
    return tokenAddress
}

function _fallback() payable {
    revert
}

function sub_60c18276(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    gracePeriod = arg1
}

function sub_111543f8(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    sub_54d9454d = arg1
}

function sub_96ee03af(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    sub_a2a7b0f2 = arg1
}

function sub_efe342ef(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    sub_666c8c6d = arg1
}

function _changeNodePrice(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    nodePrice = arg1
}

function _changeClaimTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    claimTime = arg1
}

function _changeRewardPerNode(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    rewardPerNode = arg1
}

function setToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    tokenAddress = arg1
}

function _getNodeNumberOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
    delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return delegate.return_data[0]
}

function _isNodeOwner(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
    delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (delegate.return_data[0] > 0)
}

function sub_48031c5d(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    idx = 0
    s = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
            revert with 0, 17
        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d > !gracePeriod:
            revert with 0, 17
        if block.timestamp >= stor4[address(arg1)][idx].field_768 + sub_666c8c6d + gracePeriod:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    return s
}

function sub_811ebbec(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    if not stor4[address(arg1)].field_0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    55,
                    0xfe434153484f5554204552524f523a20596f7520646f6e27742068617665206e,
                    0x64657320746f2070617920696e737572616e6365206f66000000000000000000
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
            revert with 0, 17
        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d > !gracePeriod:
            revert with 0, 17
        if block.timestamp <= stor4[address(arg1)][idx].field_768 + sub_666c8c6d + gracePeriod:
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if stor4[address(arg1)][idx].field_1024 > !sub_54d9454d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 4)
            if block.timestamp >= stor4[address(arg1)][idx].field_1024 + sub_54d9454d:
                stor4[address(arg1)][idx].field_1024 = block.timestamp
            else:
                if stor4[address(arg1)][idx].field_1024 > !sub_54d9454d:
                    revert with 0, 17
                stor4[address(arg1)][idx].field_1024 += sub_54d9454d
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function createNode(address arg1, string arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    mem[0] = arg1
    mem[32] = 4
    if stor4[address(arg1)].field_0 >= sub_a2a7b0f2:
        revert with 0, 'You reached Max Nodes limit!'
    mem[64] = ceil32(ceil32(arg2.length)) + 161
    mem[ceil32(ceil32(arg2.length)) + 97] = 1
    mem[ceil32(ceil32(arg2.length)) + 129] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 0
    while idx < arg2.length:
        if idx >= arg2.length:
            revert with 0, 50
        if Mask(8, 248, mem[idx + 128]):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if idx != -1:
            revert with 0, '# is not allowed!'
        if stor4[address(arg1)].field_0:
            if stor4[address(arg1)].field_0 < 1:
                revert with 0, 17
            if stor4[address(arg1)].field_0 - 1 >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 >= block.timestamp:
                revert with 0, 'You have already a node with the current timestamp!'
        stor4[address(arg1)].field_0++
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0):
            if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5 < 32:
                revert with 0, 34
            if not arg2.length:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + ((uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            else:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = (2 * arg2.length) + 1
                s = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                idx = 128
                while arg2.length + 128 > idx:
                    stor[s] = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (Mask(251, 0, arg2.length + 31) >> 5)
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + ((uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 < 32:
                revert with 0, 34
            if not arg2.length:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            else:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = (2 * arg2.length) + 1
                s = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                idx = 128
                while arg2.length + 128 > idx:
                    stor[s] = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (Mask(251, 0, arg2.length + 31) >> 5)
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_256 = block.timestamp
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_512 = block.timestamp
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_768 = block.timestamp
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_1024 = 0
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_1280 = 0
        require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
        delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0xbc2b405c with:
             gas gas_remaining wei
            args 0, address(arg1), stor4[address(arg1)].field_0
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        if totalNodesCreated == -1:
            revert with 0, 17
        totalNodesCreated++
    if stor4[address(arg1)].field_0:
        if stor4[address(arg1)].field_0 < 1:
            revert with 0, 17
        if stor4[address(arg1)].field_0 - 1 >= stor4[address(arg1)].field_0:
            revert with 0, 50
        if stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 >= block.timestamp:
            revert with 0, 'You have already a node with the current timestamp!'
    stor4[address(arg1)].field_0++
    if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0):
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            stor4[address(arg1)][stor4[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
            idx = 0
            while (uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32 > idx:
                stor4[address(arg1)][(6 * stor4[address(arg1)].field_0) + idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            stor4[address(arg1)][stor4[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
            idx = 0
            while stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32 > idx:
                stor4[address(arg1)][(6 * stor4[address(arg1)].field_0) + idx].field_0 = 0
                idx = idx + 1
                continue 
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_256 = block.timestamp
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_512 = block.timestamp
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_768 = block.timestamp
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_1024 = 0
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_1280 = 0
    require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
    delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0xbc2b405c with:
         gas gas_remaining wei
        args 0, address(arg1), stor4[address(arg1)].field_0
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    if totalNodesCreated == -1:
        revert with 0, 17
    totalNodesCreated++
}

function sub_068cc69d(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
    mem[0] = address(arg1)
    mem[32] = 4
    if stor4[address(arg1)].field_0 >= sub_a2a7b0f2:
        revert with 0, 'You reached Max Nodes limit!'
    if arg2.length <= 3:
        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
    if arg2.length >= 32:
        revert with 0, 'NODE CREATION: NAME SIZE INVALID'
    mem[64] = ceil32(ceil32(arg2.length)) + 161
    mem[ceil32(ceil32(arg2.length)) + 97] = 1
    mem[ceil32(ceil32(arg2.length)) + 129] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 0
    while idx < arg2.length:
        if idx >= arg2.length:
            revert with 0, 50
        if Mask(8, 248, mem[idx + 128]):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if idx != -1:
            revert with 0, '# is not allowed!'
        if stor4[address(arg1)].field_0:
            if stor4[address(arg1)].field_0 < 1:
                revert with 0, 17
            if stor4[address(arg1)].field_0 - 1 >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 >= arg3:
                revert with 0, 'You have already a node with the current timestamp!'
        stor4[address(arg1)].field_0++
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0):
            if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5 < 32:
                revert with 0, 34
            if not arg2.length:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + ((uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            else:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = (2 * arg2.length) + 1
                s = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                idx = 128
                while arg2.length + 128 > idx:
                    stor[s] = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (Mask(251, 0, arg2.length + 31) >> 5)
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + ((uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
        else:
            if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 < 32:
                revert with 0, 34
            if not arg2.length:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            else:
                stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = (2 * arg2.length) + 1
                s = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0))
                idx = 128
                while arg2.length + 128 > idx:
                    stor[s] = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (Mask(251, 0, arg2.length + 31) >> 5)
                while sha3(sha3(sha3(address(arg1), 4)) + (6 * stor4[address(arg1)].field_0)) + (stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32) > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_256 = arg3
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_512 = arg3
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_768 = arg3
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_1024 = 0
        stor4[address(arg1)][stor4[address(arg1)].field_0].field_1280 = 0
        require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
        delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0xbc2b405c with:
             gas gas_remaining wei
            args 0, address(arg1), stor4[address(arg1)].field_0
        if not delegate.return_code:
            revert with ext_call.return_data[0 len return_data.size]
        if totalNodesCreated == -1:
            revert with 0, 17
        totalNodesCreated++
    if stor4[address(arg1)].field_0:
        if stor4[address(arg1)].field_0 < 1:
            revert with 0, 17
        if stor4[address(arg1)].field_0 - 1 >= stor4[address(arg1)].field_0:
            revert with 0, 50
        if stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 >= arg3:
            revert with 0, 'You have already a node with the current timestamp!'
    stor4[address(arg1)].field_0++
    if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0):
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            stor4[address(arg1)][stor4[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
            idx = 0
            while (uint255(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) * 0.5) + 31 / 32 > idx:
                stor4[address(arg1)][(6 * stor4[address(arg1)].field_0) + idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor4[address(arg1)][stor4[address(arg1)].field_0].field_0) == stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            stor4[address(arg1)][stor4[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor4[address(arg1)][stor4[address(arg1)].field_0].field_0 = 0
            idx = 0
            while stor4[address(arg1)][stor4[address(arg1)].field_0].field_1 % 128 + 31 / 32 > idx:
                stor4[address(arg1)][(6 * stor4[address(arg1)].field_0) + idx].field_0 = 0
                idx = idx + 1
                continue 
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_256 = arg3
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_512 = arg3
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_768 = arg3
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_1024 = 0
    stor4[address(arg1)][stor4[address(arg1)].field_0].field_1280 = 0
    require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
    delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0xbc2b405c with:
         gas gas_remaining wei
        args 0, address(arg1), stor4[address(arg1)].field_0
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    if totalNodesCreated == -1:
        revert with 0, 17
    totalNodesCreated++
}

function _getNodesNames(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[100] = 0
    mem[132] = arg1
    require ext_code.size(0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4)
    delegate 0x8d5bfe55500c3f2e5b813f8237c7cbe87f8b29f4.0x732a2ccf with:
         gas gas_remaining wei
        args 0, arg1
    mem[96] = delegate.return_data[0]
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if delegate.return_data[0] <= 0:
        revert with 0, 'GET NAMES: NO NODE OWNER'
    mem[0] = arg1
    mem[32] = 4
    mem[64] = ceil32(return_data.size) + (32 * stor4[address(arg1)].field_0) + 128
    mem[ceil32(return_data.size) + 96] = stor4[address(arg1)].field_0
    s = ceil32(return_data.size) + 128
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _56 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _62 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_62] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_62 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_62 + 32] = stor4[address(arg1)][idx].field_0
                        t = _62 + 32
                        u = sha3(mem[0])
                        while _62 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_56] = _62
                mem[_56 + 32] = stor4[address(arg1)][idx].field_256
                mem[_56 + 64] = stor4[address(arg1)][idx].field_512
                mem[_56 + 96] = stor4[address(arg1)][idx].field_768
                mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            if not stor4[address(arg1)][idx].field_1 % 128:
                mem[_56] = _62
                mem[_56 + 32] = stor4[address(arg1)][idx].field_256
                mem[_56 + 64] = stor4[address(arg1)][idx].field_512
                mem[_56 + 96] = stor4[address(arg1)][idx].field_768
                mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_62 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_56] = _62
                mem[_56 + 32] = stor4[address(arg1)][idx].field_256
                mem[_56 + 64] = stor4[address(arg1)][idx].field_512
                mem[_56 + 96] = stor4[address(arg1)][idx].field_768
                mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_62 + 32] = stor4[address(arg1)][idx].field_0
            t = _62 + 32
            u = sha3(mem[0])
            while _62 + stor4[address(arg1)][u].field_1 % 128 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_56] = _62
            mem[_56 + 32] = stor4[address(arg1)][u].field_256
            mem[_56 + 64] = stor4[address(arg1)][u].field_512
            mem[_56 + 96] = stor4[address(arg1)][u].field_768
            mem[_56 + 128] = stor4[address(arg1)][u].field_1024
            mem[_56 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _56
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        _64 = mem[64]
        mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
        mem[_64] = stor4[address(arg1)][idx].field_1 % 128
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                mem[_56] = _64
                mem[_56 + 32] = stor4[address(arg1)][idx].field_256
                mem[_56 + 64] = stor4[address(arg1)][idx].field_512
                mem[_56 + 96] = stor4[address(arg1)][idx].field_768
                mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                mem[_64 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_56] = _64
                mem[_56 + 32] = stor4[address(arg1)][idx].field_256
                mem[_56 + 64] = stor4[address(arg1)][idx].field_512
                mem[_56 + 96] = stor4[address(arg1)][idx].field_768
                mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _56
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_64 + 32] = stor4[address(arg1)][idx].field_0
            t = _64 + 32
            u = sha3(mem[0])
            while _64 + (uint255(stor4[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_56] = _64
            mem[_56 + 32] = stor4[address(arg1)][u].field_256
            mem[_56 + 64] = stor4[address(arg1)][u].field_512
            mem[_56 + 96] = stor4[address(arg1)][u].field_768
            mem[_56 + 128] = stor4[address(arg1)][u].field_1024
            mem[_56 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _56
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        if stor4[address(arg1)][idx].field_1 % 128:
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_64 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
            else:
                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                mem[_64 + 32] = stor4[address(arg1)][idx].field_0
                t = _64 + 32
                u = sha3(mem[0])
                while _64 + stor4[address(arg1)][idx].field_1 % 128 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_56] = _64
        mem[_56 + 32] = stor4[address(arg1)][idx].field_256
        mem[_56 + 64] = stor4[address(arg1)][idx].field_512
        mem[_56 + 96] = stor4[address(arg1)][idx].field_768
        mem[_56 + 128] = stor4[address(arg1)][idx].field_1024
        mem[_56 + 160] = stor4[address(arg1)][idx].field_1280
        mem[s] = _56
        s = s + 32
        idx = idx + 1
        continue 
    _54 = mem[ceil32(return_data.size) + 96]
    _57 = mem[64]
    mem[64] = mem[64] + 192
    mem[_57] = 96
    mem[_57 + 32] = 0
    mem[_57 + 64] = 0
    mem[_57 + 96] = 0
    mem[_57 + 128] = 0
    mem[_57 + 160] = 0
    if 0 >= mem[ceil32(return_data.size) + 96]:
        revert with 0, 50
    _60 = mem[mem[ceil32(return_data.size) + 128]]
    _61 = mem[64]
    mem[64] = mem[64] + 64
    mem[_61] = 1
    mem[_61 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _60
    t = _57
    while idx < _54:
        if idx >= mem[ceil32(return_data.size) + 96]:
            revert with 0, 50
        _101 = mem[(32 * idx) + ceil32(return_data.size) + 128]
        _102 = mem[mem[(32 * idx) + ceil32(return_data.size) + 128]]
        _103 = mem[64]
        _105 = mem[s]
        t = 0
        while t < _105:
            mem[t + _103 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_105) <= _105:
            _132 = mem[_61]
            s = 0
            while s < _132:
                mem[s + _103 + _105 + 32] = mem[s + _61 + 32]
                s = s + 32
                continue 
            if ceil32(_132) <= _132:
                _156 = mem[_102]
                s = 0
                while s < _156:
                    mem[s + _103 + _105 + _132 + 32] = mem[s + _102 + 32]
                    s = s + 32
                    continue 
                if ceil32(_156) <= _156:
                    _176 = mem[64]
                    mem[mem[64]] = _156 + _103 + _105 + _132 - mem[64]
                    mem[64] = _156 + _103 + _105 + _132 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _176
                    t = _101
                    continue 
                mem[_156 + _103 + _105 + _132 + 32] = 0
                _177 = mem[64]
                mem[mem[64]] = _156 + _103 + _105 + _132 - mem[64]
                mem[64] = _156 + _103 + _105 + _132 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _177
                t = _101
                continue 
            mem[_132 + _103 + _105 + 32] = 0
            _157 = mem[_102]
            s = 0
            while s < _157:
                mem[s + _103 + _105 + _132 + 32] = mem[s + _102 + 32]
                s = s + 32
                continue 
            if ceil32(_157) <= _157:
                _178 = mem[64]
                mem[mem[64]] = _157 + _103 + _105 + _132 - mem[64]
                mem[64] = _157 + _103 + _105 + _132 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _178
                t = _101
                continue 
            mem[_157 + _103 + _105 + _132 + 32] = 0
            _179 = mem[64]
            mem[mem[64]] = _157 + _103 + _105 + _132 - mem[64]
            mem[64] = _157 + _103 + _105 + _132 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _179
            t = _101
            continue 
        mem[_105 + _103 + 32] = 0
        _133 = mem[_61]
        s = 0
        while s < _133:
            mem[s + _103 + _105 + 32] = mem[s + _61 + 32]
            s = s + 32
            continue 
        if ceil32(_133) <= _133:
            _158 = mem[_102]
            s = 0
            while s < _158:
                mem[s + _103 + _105 + _133 + 32] = mem[s + _102 + 32]
                s = s + 32
                continue 
            if ceil32(_158) <= _158:
                _180 = mem[64]
                mem[mem[64]] = _158 + _103 + _105 + _133 - mem[64]
                mem[64] = _158 + _103 + _105 + _133 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _180
                t = _101
                continue 
            mem[_158 + _103 + _105 + _133 + 32] = 0
            _181 = mem[64]
            mem[mem[64]] = _158 + _103 + _105 + _133 - mem[64]
            mem[64] = _158 + _103 + _105 + _133 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _181
            t = _101
            continue 
        mem[_133 + _103 + _105 + 32] = 0
        _159 = mem[_102]
        s = 0
        while s < _159:
            mem[s + _103 + _105 + _133 + 32] = mem[s + _102 + 32]
            s = s + 32
            continue 
        if ceil32(_159) <= _159:
            _182 = mem[64]
            mem[mem[64]] = _159 + _103 + _105 + _133 - mem[64]
            mem[64] = _159 + _103 + _105 + _133 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _182
            t = _101
            continue 
        mem[_159 + _103 + _105 + _133 + 32] = 0
        _183 = mem[64]
        mem[mem[64]] = _159 + _103 + _105 + _133 - mem[64]
        mem[64] = _159 + _103 + _105 + _133 + 32
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = _183
        t = _101
        continue 
    mem[mem[64]] = 32
    _104 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_104)] = mem[s + 32 len ceil32(_104)]
    if ceil32(_104) > _104:
        mem[_104 + mem[64] + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_104) + 32]
}

function sub_216cc0e6(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 4
    mem[64] = (32 * stor4[address(arg1)].field_0) + 128
    mem[96] = stor4[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _52 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _57 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_57] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_57 + 32] = stor4[address(arg1)][idx].field_0
                        t = _57 + 32
                        u = sha3(mem[0])
                        while _57 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            if not stor4[address(arg1)][idx].field_1 % 128:
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_57 + 32] = stor4[address(arg1)][idx].field_0
            t = _57 + 32
            u = sha3(mem[0])
            while _57 + stor4[address(arg1)][u].field_1 % 128 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _57
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        _59 = mem[64]
        mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
        mem[_59] = stor4[address(arg1)][idx].field_1 % 128
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_59 + 32] = stor4[address(arg1)][idx].field_0
            t = _59 + 32
            u = sha3(mem[0])
            while _59 + (uint255(stor4[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _59
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        if stor4[address(arg1)][idx].field_1 % 128:
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
            else:
                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                mem[_59 + 32] = stor4[address(arg1)][idx].field_0
                t = _59 + 32
                u = sha3(mem[0])
                while _59 + stor4[address(arg1)][idx].field_1 % 128 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_52] = _59
        mem[_52 + 32] = stor4[address(arg1)][idx].field_256
        mem[_52 + 64] = stor4[address(arg1)][idx].field_512
        mem[_52 + 96] = stor4[address(arg1)][idx].field_768
        mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
        mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
        mem[s] = _52
        s = s + 32
        idx = idx + 1
        continue 
    _50 = mem[96]
    _53 = mem[64]
    mem[64] = mem[64] + 192
    mem[_53] = 96
    mem[_53 + 32] = 0
    mem[_53 + 64] = 0
    mem[_53 + 96] = 0
    mem[_53 + 128] = 0
    mem[_53 + 160] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _56 = mem[mem[128] + 96]
    if not mem[mem[128] + 96]:
        _58 = mem[64]
        mem[64] = mem[64] + 64
        mem[_58] = 1
        mem[_58 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _60 = mem[64]
        mem[64] = mem[64] + 64
        mem[_60] = 1
        mem[_60 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _58
        t = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _100 = mem[(32 * idx) + 128]
            _101 = mem[mem[(32 * idx) + 128] + 96]
            if not mem[mem[(32 * idx) + 128] + 96]:
                _103 = mem[64]
                mem[64] = mem[64] + 64
                mem[_103] = 1
                mem[_103 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _104 = mem[64]
                _107 = mem[s]
                t = 0
                while t < _107:
                    mem[t + _104 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_107) <= _107:
                    _203 = mem[_60]
                    s = 0
                    while s < _203:
                        mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_203) <= _203:
                        _355 = mem[_103]
                        s = 0
                        while s < _355:
                            mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_355) <= _355:
                            _493 = mem[64]
                            mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                            mem[64] = _355 + _104 + _107 + _203 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _493
                            t = _100
                            continue 
                        mem[_355 + _104 + _107 + _203 + 32] = 0
                        _494 = mem[64]
                        mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                        mem[64] = _355 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _494
                        t = _100
                        continue 
                    mem[_203 + _104 + _107 + 32] = 0
                    _356 = mem[_103]
                    s = 0
                    while s < _356:
                        mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_356) <= _356:
                        _495 = mem[64]
                        mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                        mem[64] = _356 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _495
                        t = _100
                        continue 
                    mem[_356 + _104 + _107 + _203 + 32] = 0
                    _496 = mem[64]
                    mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                    mem[64] = _356 + _104 + _107 + _203 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _496
                    t = _100
                    continue 
                mem[_107 + _104 + 32] = 0
                _204 = mem[_60]
                s = 0
                while s < _204:
                    mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_204) <= _204:
                    _357 = mem[_103]
                    s = 0
                    while s < _357:
                        mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_357) <= _357:
                        _497 = mem[64]
                        mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                        mem[64] = _357 + _104 + _107 + _204 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _497
                        t = _100
                        continue 
                    mem[_357 + _104 + _107 + _204 + 32] = 0
                    _498 = mem[64]
                    mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                    mem[64] = _357 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _498
                    t = _100
                    continue 
                mem[_204 + _104 + _107 + 32] = 0
                _358 = mem[_103]
                s = 0
                while s < _358:
                    mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                    s = s + 32
                    continue 
                if ceil32(_358) <= _358:
                    _499 = mem[64]
                    mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                    mem[64] = _358 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _499
                    t = _100
                    continue 
                mem[_358 + _104 + _107 + _204 + 32] = 0
                _500 = mem[64]
                mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                mem[64] = _358 + _104 + _107 + _204 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _500
                t = _100
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 96]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _202 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _101
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_202]:
                        revert with 0, 50
                    mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _349 = mem[64]
                _353 = mem[s]
                t = 0
                while t < _353:
                    mem[t + _349 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_353) <= _353:
                    _485 = mem[_60]
                    s = 0
                    while s < _485:
                        mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_485) <= _485:
                        _693 = mem[_202]
                        s = 0
                        while s < _693:
                            mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_693) <= _693:
                            _881 = mem[64]
                            mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                            mem[64] = _693 + _349 + _353 + _485 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _881
                            t = _100
                            continue 
                        mem[_693 + _349 + _353 + _485 + 32] = 0
                        _882 = mem[64]
                        mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                        mem[64] = _693 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _882
                        t = _100
                        continue 
                    mem[_485 + _349 + _353 + 32] = 0
                    _694 = mem[_202]
                    s = 0
                    while s < _694:
                        mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_694) <= _694:
                        _883 = mem[64]
                        mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                        mem[64] = _694 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _100
                        continue 
                    mem[_694 + _349 + _353 + _485 + 32] = 0
                    _884 = mem[64]
                    mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                    mem[64] = _694 + _349 + _353 + _485 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _100
                    continue 
                mem[_353 + _349 + 32] = 0
                _486 = mem[_60]
                s = 0
                while s < _486:
                    mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_486) <= _486:
                    _695 = mem[_202]
                    s = 0
                    while s < _695:
                        mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_695) <= _695:
                        _885 = mem[64]
                        mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                        mem[64] = _695 + _349 + _353 + _486 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _885
                        t = _100
                        continue 
                    mem[_695 + _349 + _353 + _486 + 32] = 0
                    _886 = mem[64]
                    mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                    mem[64] = _695 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _886
                    t = _100
                    continue 
                mem[_486 + _349 + _353 + 32] = 0
                _696 = mem[_202]
                s = 0
                while s < _696:
                    mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                    s = s + 32
                    continue 
                if ceil32(_696) <= _696:
                    _887 = mem[64]
                    mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                    mem[64] = _696 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _887
                    t = _100
                    continue 
                mem[_696 + _349 + _353 + _486 + 32] = 0
                _888 = mem[64]
                mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                mem[64] = _696 + _349 + _353 + _486 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _888
                t = _100
                continue 
            mem[_202 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _101
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_202]:
                    revert with 0, 50
                mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _350 = mem[64]
            _354 = mem[s]
            t = 0
            while t < _354:
                mem[t + _350 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_354) <= _354:
                _487 = mem[_60]
                s = 0
                while s < _487:
                    mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_487) <= _487:
                    _697 = mem[_202]
                    idx = 0
                    while idx < _697:
                        mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _889 = mem[64]
                        mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                        mem[64] = _697 + _350 + _354 + _487 + 32
                        if ceil32(_487) == -1:
                            revert with 0, 17
                        s = ceil32(_487) + 1
                        s = _889
                        t = _100
                        continue 
                    mem[_697 + _350 + _354 + _487 + 32] = 0
                    _890 = mem[64]
                    mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                    mem[64] = _697 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _890
                    t = _100
                    continue 
                mem[_487 + _350 + _354 + 32] = 0
                _698 = mem[_202]
                idx = 0
                while idx < _698:
                    mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_698) <= _698:
                    _891 = mem[64]
                    mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                    mem[64] = _698 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _891
                    t = _100
                    continue 
                mem[_698 + _350 + _354 + _487 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                mem[64] = _698 + _350 + _354 + _487 + 32
                if ceil32(_487) == -1:
                    revert with 0, 17
                s = ceil32(_487) + 1
                s = _892
                t = _100
                continue 
            mem[_354 + _350 + 32] = 0
            _488 = mem[_60]
            s = 0
            while s < _488:
                mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                s = s + 32
                continue 
            if ceil32(_488) <= _488:
                _699 = mem[_202]
                idx = 0
                while idx < _699:
                    mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_699) <= _699:
                    _893 = mem[64]
                    mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                    mem[64] = _699 + _350 + _354 + _488 + 32
                    if ceil32(_488) == -1:
                        revert with 0, 17
                    s = ceil32(_488) + 1
                    s = _893
                    t = _100
                    continue 
                mem[_699 + _350 + _354 + _488 + 32] = 0
                _894 = mem[64]
                mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                mem[64] = _699 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _894
                t = _100
                continue 
            mem[_488 + _350 + _354 + 32] = 0
            _700 = mem[_202]
            idx = 0
            while idx < _700:
                mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                idx = idx + 32
                continue 
            if ceil32(_700) <= _700:
                _895 = mem[64]
                mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
                mem[64] = _700 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _895
                t = _100
                continue 
            mem[_700 + _350 + _354 + _488 + 32] = 0
            _896 = mem[64]
            mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
            mem[64] = _700 + _350 + _354 + _488 + 32
            if ceil32(_488) == -1:
                revert with 0, 17
            s = ceil32(_488) + 1
            s = _896
            t = _100
            continue 
        _99 = mem[64]
        mem[mem[64]] = 32
        _102 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_102)] = mem[s + 32 len ceil32(_102)]
        if ceil32(_102) <= _102:
            return 32, mem[mem[64] + 32 len ceil32(_102) + 32]
        mem[_102 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_102) + _99 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 96]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _98 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _56
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_98]:
                revert with 0, 50
            mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 1
        mem[_200 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _98
        u = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _344 = mem[(32 * idx) + 128]
            _345 = mem[mem[(32 * idx) + 128] + 96]
            if not mem[mem[(32 * idx) + 128] + 96]:
                _359 = mem[64]
                mem[64] = mem[64] + 64
                mem[_359] = 1
                mem[_359 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _361 = mem[64]
                _364 = mem[s]
                u = 0
                while u < _364:
                    mem[u + _361 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_364) <= _364:
                    _481 = mem[_200]
                    s = 0
                    while s < _481:
                        mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_481) <= _481:
                        _683 = mem[_359]
                        s = 0
                        while s < _683:
                            mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_683) <= _683:
                            _865 = mem[64]
                            mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                            mem[64] = _683 + _361 + _364 + _481 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _865
                            u = _344
                            continue 
                        mem[_683 + _361 + _364 + _481 + 32] = 0
                        _866 = mem[64]
                        mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                        mem[64] = _683 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _866
                        u = _344
                        continue 
                    mem[_481 + _361 + _364 + 32] = 0
                    _684 = mem[_359]
                    s = 0
                    while s < _684:
                        mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_684) <= _684:
                        _867 = mem[64]
                        mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                        mem[64] = _684 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _867
                        u = _344
                        continue 
                    mem[_684 + _361 + _364 + _481 + 32] = 0
                    _868 = mem[64]
                    mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                    mem[64] = _684 + _361 + _364 + _481 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _868
                    u = _344
                    continue 
                mem[_364 + _361 + 32] = 0
                _482 = mem[_200]
                s = 0
                while s < _482:
                    mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_482) <= _482:
                    _685 = mem[_359]
                    s = 0
                    while s < _685:
                        mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_685) <= _685:
                        _869 = mem[64]
                        mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                        mem[64] = _685 + _361 + _364 + _482 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _869
                        u = _344
                        continue 
                    mem[_685 + _361 + _364 + _482 + 32] = 0
                    _870 = mem[64]
                    mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                    mem[64] = _685 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _870
                    u = _344
                    continue 
                mem[_482 + _361 + _364 + 32] = 0
                _686 = mem[_359]
                s = 0
                while s < _686:
                    mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                    s = s + 32
                    continue 
                if ceil32(_686) <= _686:
                    _871 = mem[64]
                    mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                    mem[64] = _686 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _871
                    u = _344
                    continue 
                mem[_686 + _361 + _364 + _482 + 32] = 0
                _872 = mem[64]
                mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                mem[64] = _686 + _361 + _364 + _482 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _872
                u = _344
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 96]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _479 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _345
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_479]:
                        revert with 0, 50
                    mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _677 = mem[64]
                _681 = mem[s]
                t = 0
                while t < _681:
                    mem[t + _677 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_681) <= _681:
                    _857 = mem[_200]
                    s = 0
                    while s < _857:
                        mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_857) <= _857:
                        _977 = mem[_479]
                        s = 0
                        while s < _977:
                            mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_977) <= _977:
                            _1057 = mem[64]
                            mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                            mem[64] = _977 + _677 + _681 + _857 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1057
                            u = _344
                            continue 
                        mem[_977 + _677 + _681 + _857 + 32] = 0
                        _1058 = mem[64]
                        mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                        mem[64] = _977 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1058
                        u = _344
                        continue 
                    mem[_857 + _677 + _681 + 32] = 0
                    _978 = mem[_479]
                    s = 0
                    while s < _978:
                        mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_978) <= _978:
                        _1059 = mem[64]
                        mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                        mem[64] = _978 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1059
                        u = _344
                        continue 
                    mem[_978 + _677 + _681 + _857 + 32] = 0
                    _1060 = mem[64]
                    mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                    mem[64] = _978 + _677 + _681 + _857 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1060
                    u = _344
                    continue 
                mem[_681 + _677 + 32] = 0
                _858 = mem[_200]
                s = 0
                while s < _858:
                    mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_858) <= _858:
                    _979 = mem[_479]
                    s = 0
                    while s < _979:
                        mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_979) <= _979:
                        _1061 = mem[64]
                        mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                        mem[64] = _979 + _677 + _681 + _858 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1061
                        u = _344
                        continue 
                    mem[_979 + _677 + _681 + _858 + 32] = 0
                    _1062 = mem[64]
                    mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                    mem[64] = _979 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1062
                    u = _344
                    continue 
                mem[_858 + _677 + _681 + 32] = 0
                _980 = mem[_479]
                s = 0
                while s < _980:
                    mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                    s = s + 32
                    continue 
                if ceil32(_980) <= _980:
                    _1063 = mem[64]
                    mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                    mem[64] = _980 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1063
                    u = _344
                    continue 
                mem[_980 + _677 + _681 + _858 + 32] = 0
                _1064 = mem[64]
                mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                mem[64] = _980 + _677 + _681 + _858 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1064
                u = _344
                continue 
            mem[_479 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _345
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_479]:
                    revert with 0, 50
                mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _678 = mem[64]
            _682 = mem[s]
            t = 0
            while t < _682:
                mem[t + _678 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_682) <= _682:
                _859 = mem[_200]
                s = 0
                while s < _859:
                    mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_859) <= _859:
                    _981 = mem[_479]
                    idx = 0
                    while idx < _981:
                        mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_981) <= _981:
                        _1065 = mem[64]
                        mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                        mem[64] = _981 + _678 + _682 + _859 + 32
                        if ceil32(_859) == -1:
                            revert with 0, 17
                        s = ceil32(_859) + 1
                        s = _1065
                        u = _344
                        continue 
                    mem[_981 + _678 + _682 + _859 + 32] = 0
                    _1066 = mem[64]
                    mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                    mem[64] = _981 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1066
                    u = _344
                    continue 
                mem[_859 + _678 + _682 + 32] = 0
                _982 = mem[_479]
                idx = 0
                while idx < _982:
                    mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_982) <= _982:
                    _1067 = mem[64]
                    mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                    mem[64] = _982 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1067
                    u = _344
                    continue 
                mem[_982 + _678 + _682 + _859 + 32] = 0
                _1068 = mem[64]
                mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                mem[64] = _982 + _678 + _682 + _859 + 32
                if ceil32(_859) == -1:
                    revert with 0, 17
                s = ceil32(_859) + 1
                s = _1068
                u = _344
                continue 
            mem[_682 + _678 + 32] = 0
            _860 = mem[_200]
            s = 0
            while s < _860:
                mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                s = s + 32
                continue 
            if ceil32(_860) <= _860:
                _983 = mem[_479]
                idx = 0
                while idx < _983:
                    mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_983) <= _983:
                    _1069 = mem[64]
                    mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                    mem[64] = _983 + _678 + _682 + _860 + 32
                    if ceil32(_860) == -1:
                        revert with 0, 17
                    s = ceil32(_860) + 1
                    s = _1069
                    u = _344
                    continue 
                mem[_983 + _678 + _682 + _860 + 32] = 0
                _1070 = mem[64]
                mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                mem[64] = _983 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1070
                u = _344
                continue 
            mem[_860 + _678 + _682 + 32] = 0
            _984 = mem[_479]
            idx = 0
            while idx < _984:
                mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                idx = idx + 32
                continue 
            if ceil32(_984) <= _984:
                _1071 = mem[64]
                mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
                mem[64] = _984 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1071
                u = _344
                continue 
            mem[_984 + _678 + _682 + _860 + 32] = 0
            _1072 = mem[64]
            mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
            mem[64] = _984 + _678 + _682 + _860 + 32
            if ceil32(_860) == -1:
                revert with 0, 17
            s = ceil32(_860) + 1
            s = _1072
            u = _344
            continue 
        mem[mem[64]] = 32
        _351 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_351)] = mem[s + 32 len ceil32(_351)]
        if ceil32(_351) > _351:
            mem[_351 + mem[64] + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_351) + 32]
    mem[_98 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _56
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_98]:
            revert with 0, 50
        mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _201 = mem[64]
    mem[64] = mem[64] + 64
    mem[_201] = 1
    mem[_201 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _98
    u = _53
    while idx < _50:
        if idx >= mem[96]:
            revert with 0, 50
        _347 = mem[(32 * idx) + 128]
        _348 = mem[mem[(32 * idx) + 128] + 96]
        if not mem[mem[(32 * idx) + 128] + 96]:
            _360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_360] = 1
            mem[_360 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _362 = mem[64]
            _366 = mem[s]
            u = 0
            while u < _366:
                mem[u + _362 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_366) <= _366:
                _483 = mem[_201]
                s = 0
                while s < _483:
                    mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_483) <= _483:
                    _689 = mem[_360]
                    s = 0
                    while s < _689:
                        mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_689) <= _689:
                        _873 = mem[64]
                        mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                        mem[64] = _689 + _362 + _366 + _483 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _873
                        u = _347
                        continue 
                    mem[_689 + _362 + _366 + _483 + 32] = 0
                    _874 = mem[64]
                    mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                    mem[64] = _689 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _874
                    u = _347
                    continue 
                mem[_483 + _362 + _366 + 32] = 0
                _690 = mem[_360]
                s = 0
                while s < _690:
                    mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_690) <= _690:
                    _875 = mem[64]
                    mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                    mem[64] = _690 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _875
                    u = _347
                    continue 
                mem[_690 + _362 + _366 + _483 + 32] = 0
                _876 = mem[64]
                mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                mem[64] = _690 + _362 + _366 + _483 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _876
                u = _347
                continue 
            mem[_366 + _362 + 32] = 0
            _484 = mem[_201]
            s = 0
            while s < _484:
                mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_484) <= _484:
                _691 = mem[_360]
                s = 0
                while s < _691:
                    mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_691) <= _691:
                    _877 = mem[64]
                    mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                    mem[64] = _691 + _362 + _366 + _484 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    u = _347
                    continue 
                mem[_691 + _362 + _366 + _484 + 32] = 0
                _878 = mem[64]
                mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                mem[64] = _691 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                u = _347
                continue 
            mem[_484 + _362 + _366 + 32] = 0
            _692 = mem[_360]
            s = 0
            while s < _692:
                mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                s = s + 32
                continue 
            if ceil32(_692) <= _692:
                _879 = mem[64]
                mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
                mem[64] = _692 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _879
                u = _347
                continue 
            mem[_692 + _362 + _366 + _484 + 32] = 0
            _880 = mem[64]
            mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
            mem[64] = _692 + _362 + _366 + _484 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _880
            u = _347
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 96]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _480 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _348
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_480]:
                    revert with 0, 50
                mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _679 = mem[64]
            _687 = mem[s]
            t = 0
            while t < _687:
                mem[t + _679 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_687) <= _687:
                _861 = mem[_201]
                s = 0
                while s < _861:
                    mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_861) <= _861:
                    _985 = mem[_480]
                    s = 0
                    while s < _985:
                        mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1073 = mem[64]
                        mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                        mem[64] = _985 + _679 + _687 + _861 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1073
                        u = _347
                        continue 
                    mem[_985 + _679 + _687 + _861 + 32] = 0
                    _1074 = mem[64]
                    mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                    mem[64] = _985 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1074
                    u = _347
                    continue 
                mem[_861 + _679 + _687 + 32] = 0
                _986 = mem[_480]
                s = 0
                while s < _986:
                    mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1075 = mem[64]
                    mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                    mem[64] = _986 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    u = _347
                    continue 
                mem[_986 + _679 + _687 + _861 + 32] = 0
                _1076 = mem[64]
                mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                mem[64] = _986 + _679 + _687 + _861 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                u = _347
                continue 
            mem[_687 + _679 + 32] = 0
            _862 = mem[_201]
            s = 0
            while s < _862:
                mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_862) <= _862:
                _987 = mem[_480]
                s = 0
                while s < _987:
                    mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_987) <= _987:
                    _1077 = mem[64]
                    mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                    mem[64] = _987 + _679 + _687 + _862 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1077
                    u = _347
                    continue 
                mem[_987 + _679 + _687 + _862 + 32] = 0
                _1078 = mem[64]
                mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                mem[64] = _987 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1078
                u = _347
                continue 
            mem[_862 + _679 + _687 + 32] = 0
            _988 = mem[_480]
            s = 0
            while s < _988:
                mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                s = s + 32
                continue 
            if ceil32(_988) <= _988:
                _1079 = mem[64]
                mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
                mem[64] = _988 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1079
                u = _347
                continue 
            mem[_988 + _679 + _687 + _862 + 32] = 0
            _1080 = mem[64]
            mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
            mem[64] = _988 + _679 + _687 + _862 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1080
            u = _347
            continue 
        mem[_480 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _348
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_480]:
                revert with 0, 50
            mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _680 = mem[64]
        _688 = mem[s]
        t = 0
        while t < _688:
            mem[t + _680 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_688) <= _688:
            _863 = mem[_201]
            s = 0
            while s < _863:
                mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_863) <= _863:
                _989 = mem[_480]
                idx = 0
                while idx < _989:
                    mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1081 = mem[64]
                    mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                    mem[64] = _989 + _680 + _688 + _863 + 32
                    if ceil32(_863) == -1:
                        revert with 0, 17
                    s = ceil32(_863) + 1
                    s = _1081
                    u = _347
                    continue 
                mem[_989 + _680 + _688 + _863 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                mem[64] = _989 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1082
                u = _347
                continue 
            mem[_863 + _680 + _688 + 32] = 0
            _990 = mem[_480]
            idx = 0
            while idx < _990:
                mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_990) <= _990:
                _1083 = mem[64]
                mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
                mem[64] = _990 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1083
                u = _347
                continue 
            mem[_990 + _680 + _688 + _863 + 32] = 0
            _1084 = mem[64]
            mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
            mem[64] = _990 + _680 + _688 + _863 + 32
            if ceil32(_863) == -1:
                revert with 0, 17
            s = ceil32(_863) + 1
            s = _1084
            u = _347
            continue 
        mem[_688 + _680 + 32] = 0
        _864 = mem[_201]
        s = 0
        while s < _864:
            mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
            s = s + 32
            continue 
        if ceil32(_864) <= _864:
            _991 = mem[_480]
            idx = 0
            while idx < _991:
                mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_991) <= _991:
                _1085 = mem[64]
                mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
                mem[64] = _991 + _680 + _688 + _864 + 32
                if ceil32(_864) == -1:
                    revert with 0, 17
                s = ceil32(_864) + 1
                s = _1085
                u = _347
                continue 
            mem[_991 + _680 + _688 + _864 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
            mem[64] = _991 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1086
            u = _347
            continue 
        mem[_864 + _680 + _688 + 32] = 0
        _992 = mem[_480]
        idx = 0
        while idx < _992:
            mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
            idx = idx + 32
            continue 
        if ceil32(_992) <= _992:
            _1087 = mem[64]
            mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
            mem[64] = _992 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1087
            u = _347
            continue 
        mem[_992 + _680 + _688 + _864 + 32] = 0
        _1088 = mem[64]
        mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
        mem[64] = _992 + _680 + _688 + _864 + 32
        if ceil32(_864) == -1:
            revert with 0, 17
        s = ceil32(_864) + 1
        s = _1088
        u = _347
        continue 
    mem[mem[64]] = 32
    _352 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_352)] = mem[s + 32 len ceil32(_352)]
    if ceil32(_352) > _352:
        mem[_352 + mem[64] + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_352) + 32]
}

function _getNodesCreationTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 4
    mem[64] = (32 * stor4[address(arg1)].field_0) + 128
    mem[96] = stor4[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _52 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _57 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_57] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_57 + 32] = stor4[address(arg1)][idx].field_0
                        t = _57 + 32
                        u = sha3(mem[0])
                        while _57 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            if not stor4[address(arg1)][idx].field_1 % 128:
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_57 + 32] = stor4[address(arg1)][idx].field_0
            t = _57 + 32
            u = sha3(mem[0])
            while _57 + stor4[address(arg1)][u].field_1 % 128 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _57
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        _59 = mem[64]
        mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
        mem[_59] = stor4[address(arg1)][idx].field_1 % 128
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_59 + 32] = stor4[address(arg1)][idx].field_0
            t = _59 + 32
            u = sha3(mem[0])
            while _59 + (uint255(stor4[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _59
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        if stor4[address(arg1)][idx].field_1 % 128:
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
            else:
                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                mem[_59 + 32] = stor4[address(arg1)][idx].field_0
                t = _59 + 32
                u = sha3(mem[0])
                while _59 + stor4[address(arg1)][idx].field_1 % 128 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_52] = _59
        mem[_52 + 32] = stor4[address(arg1)][idx].field_256
        mem[_52 + 64] = stor4[address(arg1)][idx].field_512
        mem[_52 + 96] = stor4[address(arg1)][idx].field_768
        mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
        mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
        mem[s] = _52
        s = s + 32
        idx = idx + 1
        continue 
    _50 = mem[96]
    _53 = mem[64]
    mem[64] = mem[64] + 192
    mem[_53] = 96
    mem[_53 + 32] = 0
    mem[_53 + 64] = 0
    mem[_53 + 96] = 0
    mem[_53 + 128] = 0
    mem[_53 + 160] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _56 = mem[mem[128] + 32]
    if not mem[mem[128] + 32]:
        _58 = mem[64]
        mem[64] = mem[64] + 64
        mem[_58] = 1
        mem[_58 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _60 = mem[64]
        mem[64] = mem[64] + 64
        mem[_60] = 1
        mem[_60 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _58
        t = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _100 = mem[(32 * idx) + 128]
            _101 = mem[mem[(32 * idx) + 128] + 32]
            if not mem[mem[(32 * idx) + 128] + 32]:
                _103 = mem[64]
                mem[64] = mem[64] + 64
                mem[_103] = 1
                mem[_103 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _104 = mem[64]
                _107 = mem[s]
                t = 0
                while t < _107:
                    mem[t + _104 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_107) <= _107:
                    _203 = mem[_60]
                    s = 0
                    while s < _203:
                        mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_203) <= _203:
                        _355 = mem[_103]
                        s = 0
                        while s < _355:
                            mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_355) <= _355:
                            _493 = mem[64]
                            mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                            mem[64] = _355 + _104 + _107 + _203 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _493
                            t = _100
                            continue 
                        mem[_355 + _104 + _107 + _203 + 32] = 0
                        _494 = mem[64]
                        mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                        mem[64] = _355 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _494
                        t = _100
                        continue 
                    mem[_203 + _104 + _107 + 32] = 0
                    _356 = mem[_103]
                    s = 0
                    while s < _356:
                        mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_356) <= _356:
                        _495 = mem[64]
                        mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                        mem[64] = _356 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _495
                        t = _100
                        continue 
                    mem[_356 + _104 + _107 + _203 + 32] = 0
                    _496 = mem[64]
                    mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                    mem[64] = _356 + _104 + _107 + _203 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _496
                    t = _100
                    continue 
                mem[_107 + _104 + 32] = 0
                _204 = mem[_60]
                s = 0
                while s < _204:
                    mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_204) <= _204:
                    _357 = mem[_103]
                    s = 0
                    while s < _357:
                        mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_357) <= _357:
                        _497 = mem[64]
                        mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                        mem[64] = _357 + _104 + _107 + _204 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _497
                        t = _100
                        continue 
                    mem[_357 + _104 + _107 + _204 + 32] = 0
                    _498 = mem[64]
                    mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                    mem[64] = _357 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _498
                    t = _100
                    continue 
                mem[_204 + _104 + _107 + 32] = 0
                _358 = mem[_103]
                s = 0
                while s < _358:
                    mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                    s = s + 32
                    continue 
                if ceil32(_358) <= _358:
                    _499 = mem[64]
                    mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                    mem[64] = _358 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _499
                    t = _100
                    continue 
                mem[_358 + _104 + _107 + _204 + 32] = 0
                _500 = mem[64]
                mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                mem[64] = _358 + _104 + _107 + _204 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _500
                t = _100
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 32]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _202 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _101
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_202]:
                        revert with 0, 50
                    mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _349 = mem[64]
                _353 = mem[s]
                t = 0
                while t < _353:
                    mem[t + _349 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_353) <= _353:
                    _485 = mem[_60]
                    s = 0
                    while s < _485:
                        mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_485) <= _485:
                        _693 = mem[_202]
                        s = 0
                        while s < _693:
                            mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_693) <= _693:
                            _881 = mem[64]
                            mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                            mem[64] = _693 + _349 + _353 + _485 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _881
                            t = _100
                            continue 
                        mem[_693 + _349 + _353 + _485 + 32] = 0
                        _882 = mem[64]
                        mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                        mem[64] = _693 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _882
                        t = _100
                        continue 
                    mem[_485 + _349 + _353 + 32] = 0
                    _694 = mem[_202]
                    s = 0
                    while s < _694:
                        mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_694) <= _694:
                        _883 = mem[64]
                        mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                        mem[64] = _694 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _100
                        continue 
                    mem[_694 + _349 + _353 + _485 + 32] = 0
                    _884 = mem[64]
                    mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                    mem[64] = _694 + _349 + _353 + _485 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _100
                    continue 
                mem[_353 + _349 + 32] = 0
                _486 = mem[_60]
                s = 0
                while s < _486:
                    mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_486) <= _486:
                    _695 = mem[_202]
                    s = 0
                    while s < _695:
                        mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_695) <= _695:
                        _885 = mem[64]
                        mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                        mem[64] = _695 + _349 + _353 + _486 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _885
                        t = _100
                        continue 
                    mem[_695 + _349 + _353 + _486 + 32] = 0
                    _886 = mem[64]
                    mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                    mem[64] = _695 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _886
                    t = _100
                    continue 
                mem[_486 + _349 + _353 + 32] = 0
                _696 = mem[_202]
                s = 0
                while s < _696:
                    mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                    s = s + 32
                    continue 
                if ceil32(_696) <= _696:
                    _887 = mem[64]
                    mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                    mem[64] = _696 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _887
                    t = _100
                    continue 
                mem[_696 + _349 + _353 + _486 + 32] = 0
                _888 = mem[64]
                mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                mem[64] = _696 + _349 + _353 + _486 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _888
                t = _100
                continue 
            mem[_202 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _101
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_202]:
                    revert with 0, 50
                mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _350 = mem[64]
            _354 = mem[s]
            t = 0
            while t < _354:
                mem[t + _350 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_354) <= _354:
                _487 = mem[_60]
                s = 0
                while s < _487:
                    mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_487) <= _487:
                    _697 = mem[_202]
                    idx = 0
                    while idx < _697:
                        mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _889 = mem[64]
                        mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                        mem[64] = _697 + _350 + _354 + _487 + 32
                        if ceil32(_487) == -1:
                            revert with 0, 17
                        s = ceil32(_487) + 1
                        s = _889
                        t = _100
                        continue 
                    mem[_697 + _350 + _354 + _487 + 32] = 0
                    _890 = mem[64]
                    mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                    mem[64] = _697 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _890
                    t = _100
                    continue 
                mem[_487 + _350 + _354 + 32] = 0
                _698 = mem[_202]
                idx = 0
                while idx < _698:
                    mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_698) <= _698:
                    _891 = mem[64]
                    mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                    mem[64] = _698 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _891
                    t = _100
                    continue 
                mem[_698 + _350 + _354 + _487 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                mem[64] = _698 + _350 + _354 + _487 + 32
                if ceil32(_487) == -1:
                    revert with 0, 17
                s = ceil32(_487) + 1
                s = _892
                t = _100
                continue 
            mem[_354 + _350 + 32] = 0
            _488 = mem[_60]
            s = 0
            while s < _488:
                mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                s = s + 32
                continue 
            if ceil32(_488) <= _488:
                _699 = mem[_202]
                idx = 0
                while idx < _699:
                    mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_699) <= _699:
                    _893 = mem[64]
                    mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                    mem[64] = _699 + _350 + _354 + _488 + 32
                    if ceil32(_488) == -1:
                        revert with 0, 17
                    s = ceil32(_488) + 1
                    s = _893
                    t = _100
                    continue 
                mem[_699 + _350 + _354 + _488 + 32] = 0
                _894 = mem[64]
                mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                mem[64] = _699 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _894
                t = _100
                continue 
            mem[_488 + _350 + _354 + 32] = 0
            _700 = mem[_202]
            idx = 0
            while idx < _700:
                mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                idx = idx + 32
                continue 
            if ceil32(_700) <= _700:
                _895 = mem[64]
                mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
                mem[64] = _700 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _895
                t = _100
                continue 
            mem[_700 + _350 + _354 + _488 + 32] = 0
            _896 = mem[64]
            mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
            mem[64] = _700 + _350 + _354 + _488 + 32
            if ceil32(_488) == -1:
                revert with 0, 17
            s = ceil32(_488) + 1
            s = _896
            t = _100
            continue 
        _99 = mem[64]
        mem[mem[64]] = 32
        _102 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_102)] = mem[s + 32 len ceil32(_102)]
        if ceil32(_102) <= _102:
            return 32, mem[mem[64] + 32 len ceil32(_102) + 32]
        mem[_102 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_102) + _99 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 32]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _98 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _56
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_98]:
                revert with 0, 50
            mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 1
        mem[_200 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _98
        u = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _344 = mem[(32 * idx) + 128]
            _345 = mem[mem[(32 * idx) + 128] + 32]
            if not mem[mem[(32 * idx) + 128] + 32]:
                _359 = mem[64]
                mem[64] = mem[64] + 64
                mem[_359] = 1
                mem[_359 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _361 = mem[64]
                _364 = mem[s]
                u = 0
                while u < _364:
                    mem[u + _361 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_364) <= _364:
                    _481 = mem[_200]
                    s = 0
                    while s < _481:
                        mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_481) <= _481:
                        _683 = mem[_359]
                        s = 0
                        while s < _683:
                            mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_683) <= _683:
                            _865 = mem[64]
                            mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                            mem[64] = _683 + _361 + _364 + _481 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _865
                            u = _344
                            continue 
                        mem[_683 + _361 + _364 + _481 + 32] = 0
                        _866 = mem[64]
                        mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                        mem[64] = _683 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _866
                        u = _344
                        continue 
                    mem[_481 + _361 + _364 + 32] = 0
                    _684 = mem[_359]
                    s = 0
                    while s < _684:
                        mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_684) <= _684:
                        _867 = mem[64]
                        mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                        mem[64] = _684 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _867
                        u = _344
                        continue 
                    mem[_684 + _361 + _364 + _481 + 32] = 0
                    _868 = mem[64]
                    mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                    mem[64] = _684 + _361 + _364 + _481 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _868
                    u = _344
                    continue 
                mem[_364 + _361 + 32] = 0
                _482 = mem[_200]
                s = 0
                while s < _482:
                    mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_482) <= _482:
                    _685 = mem[_359]
                    s = 0
                    while s < _685:
                        mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_685) <= _685:
                        _869 = mem[64]
                        mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                        mem[64] = _685 + _361 + _364 + _482 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _869
                        u = _344
                        continue 
                    mem[_685 + _361 + _364 + _482 + 32] = 0
                    _870 = mem[64]
                    mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                    mem[64] = _685 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _870
                    u = _344
                    continue 
                mem[_482 + _361 + _364 + 32] = 0
                _686 = mem[_359]
                s = 0
                while s < _686:
                    mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                    s = s + 32
                    continue 
                if ceil32(_686) <= _686:
                    _871 = mem[64]
                    mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                    mem[64] = _686 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _871
                    u = _344
                    continue 
                mem[_686 + _361 + _364 + _482 + 32] = 0
                _872 = mem[64]
                mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                mem[64] = _686 + _361 + _364 + _482 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _872
                u = _344
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 32]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _479 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _345
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_479]:
                        revert with 0, 50
                    mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _677 = mem[64]
                _681 = mem[s]
                t = 0
                while t < _681:
                    mem[t + _677 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_681) <= _681:
                    _857 = mem[_200]
                    s = 0
                    while s < _857:
                        mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_857) <= _857:
                        _977 = mem[_479]
                        s = 0
                        while s < _977:
                            mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_977) <= _977:
                            _1057 = mem[64]
                            mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                            mem[64] = _977 + _677 + _681 + _857 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1057
                            u = _344
                            continue 
                        mem[_977 + _677 + _681 + _857 + 32] = 0
                        _1058 = mem[64]
                        mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                        mem[64] = _977 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1058
                        u = _344
                        continue 
                    mem[_857 + _677 + _681 + 32] = 0
                    _978 = mem[_479]
                    s = 0
                    while s < _978:
                        mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_978) <= _978:
                        _1059 = mem[64]
                        mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                        mem[64] = _978 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1059
                        u = _344
                        continue 
                    mem[_978 + _677 + _681 + _857 + 32] = 0
                    _1060 = mem[64]
                    mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                    mem[64] = _978 + _677 + _681 + _857 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1060
                    u = _344
                    continue 
                mem[_681 + _677 + 32] = 0
                _858 = mem[_200]
                s = 0
                while s < _858:
                    mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_858) <= _858:
                    _979 = mem[_479]
                    s = 0
                    while s < _979:
                        mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_979) <= _979:
                        _1061 = mem[64]
                        mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                        mem[64] = _979 + _677 + _681 + _858 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1061
                        u = _344
                        continue 
                    mem[_979 + _677 + _681 + _858 + 32] = 0
                    _1062 = mem[64]
                    mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                    mem[64] = _979 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1062
                    u = _344
                    continue 
                mem[_858 + _677 + _681 + 32] = 0
                _980 = mem[_479]
                s = 0
                while s < _980:
                    mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                    s = s + 32
                    continue 
                if ceil32(_980) <= _980:
                    _1063 = mem[64]
                    mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                    mem[64] = _980 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1063
                    u = _344
                    continue 
                mem[_980 + _677 + _681 + _858 + 32] = 0
                _1064 = mem[64]
                mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                mem[64] = _980 + _677 + _681 + _858 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1064
                u = _344
                continue 
            mem[_479 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _345
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_479]:
                    revert with 0, 50
                mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _678 = mem[64]
            _682 = mem[s]
            t = 0
            while t < _682:
                mem[t + _678 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_682) <= _682:
                _859 = mem[_200]
                s = 0
                while s < _859:
                    mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_859) <= _859:
                    _981 = mem[_479]
                    idx = 0
                    while idx < _981:
                        mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_981) <= _981:
                        _1065 = mem[64]
                        mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                        mem[64] = _981 + _678 + _682 + _859 + 32
                        if ceil32(_859) == -1:
                            revert with 0, 17
                        s = ceil32(_859) + 1
                        s = _1065
                        u = _344
                        continue 
                    mem[_981 + _678 + _682 + _859 + 32] = 0
                    _1066 = mem[64]
                    mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                    mem[64] = _981 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1066
                    u = _344
                    continue 
                mem[_859 + _678 + _682 + 32] = 0
                _982 = mem[_479]
                idx = 0
                while idx < _982:
                    mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_982) <= _982:
                    _1067 = mem[64]
                    mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                    mem[64] = _982 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1067
                    u = _344
                    continue 
                mem[_982 + _678 + _682 + _859 + 32] = 0
                _1068 = mem[64]
                mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                mem[64] = _982 + _678 + _682 + _859 + 32
                if ceil32(_859) == -1:
                    revert with 0, 17
                s = ceil32(_859) + 1
                s = _1068
                u = _344
                continue 
            mem[_682 + _678 + 32] = 0
            _860 = mem[_200]
            s = 0
            while s < _860:
                mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                s = s + 32
                continue 
            if ceil32(_860) <= _860:
                _983 = mem[_479]
                idx = 0
                while idx < _983:
                    mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_983) <= _983:
                    _1069 = mem[64]
                    mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                    mem[64] = _983 + _678 + _682 + _860 + 32
                    if ceil32(_860) == -1:
                        revert with 0, 17
                    s = ceil32(_860) + 1
                    s = _1069
                    u = _344
                    continue 
                mem[_983 + _678 + _682 + _860 + 32] = 0
                _1070 = mem[64]
                mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                mem[64] = _983 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1070
                u = _344
                continue 
            mem[_860 + _678 + _682 + 32] = 0
            _984 = mem[_479]
            idx = 0
            while idx < _984:
                mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                idx = idx + 32
                continue 
            if ceil32(_984) <= _984:
                _1071 = mem[64]
                mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
                mem[64] = _984 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1071
                u = _344
                continue 
            mem[_984 + _678 + _682 + _860 + 32] = 0
            _1072 = mem[64]
            mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
            mem[64] = _984 + _678 + _682 + _860 + 32
            if ceil32(_860) == -1:
                revert with 0, 17
            s = ceil32(_860) + 1
            s = _1072
            u = _344
            continue 
        mem[mem[64]] = 32
        _351 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_351)] = mem[s + 32 len ceil32(_351)]
        if ceil32(_351) > _351:
            mem[_351 + mem[64] + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_351) + 32]
    mem[_98 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _56
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_98]:
            revert with 0, 50
        mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _201 = mem[64]
    mem[64] = mem[64] + 64
    mem[_201] = 1
    mem[_201 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _98
    u = _53
    while idx < _50:
        if idx >= mem[96]:
            revert with 0, 50
        _347 = mem[(32 * idx) + 128]
        _348 = mem[mem[(32 * idx) + 128] + 32]
        if not mem[mem[(32 * idx) + 128] + 32]:
            _360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_360] = 1
            mem[_360 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _362 = mem[64]
            _366 = mem[s]
            u = 0
            while u < _366:
                mem[u + _362 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_366) <= _366:
                _483 = mem[_201]
                s = 0
                while s < _483:
                    mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_483) <= _483:
                    _689 = mem[_360]
                    s = 0
                    while s < _689:
                        mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_689) <= _689:
                        _873 = mem[64]
                        mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                        mem[64] = _689 + _362 + _366 + _483 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _873
                        u = _347
                        continue 
                    mem[_689 + _362 + _366 + _483 + 32] = 0
                    _874 = mem[64]
                    mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                    mem[64] = _689 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _874
                    u = _347
                    continue 
                mem[_483 + _362 + _366 + 32] = 0
                _690 = mem[_360]
                s = 0
                while s < _690:
                    mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_690) <= _690:
                    _875 = mem[64]
                    mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                    mem[64] = _690 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _875
                    u = _347
                    continue 
                mem[_690 + _362 + _366 + _483 + 32] = 0
                _876 = mem[64]
                mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                mem[64] = _690 + _362 + _366 + _483 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _876
                u = _347
                continue 
            mem[_366 + _362 + 32] = 0
            _484 = mem[_201]
            s = 0
            while s < _484:
                mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_484) <= _484:
                _691 = mem[_360]
                s = 0
                while s < _691:
                    mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_691) <= _691:
                    _877 = mem[64]
                    mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                    mem[64] = _691 + _362 + _366 + _484 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    u = _347
                    continue 
                mem[_691 + _362 + _366 + _484 + 32] = 0
                _878 = mem[64]
                mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                mem[64] = _691 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                u = _347
                continue 
            mem[_484 + _362 + _366 + 32] = 0
            _692 = mem[_360]
            s = 0
            while s < _692:
                mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                s = s + 32
                continue 
            if ceil32(_692) <= _692:
                _879 = mem[64]
                mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
                mem[64] = _692 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _879
                u = _347
                continue 
            mem[_692 + _362 + _366 + _484 + 32] = 0
            _880 = mem[64]
            mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
            mem[64] = _692 + _362 + _366 + _484 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _880
            u = _347
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 32]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _480 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _348
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_480]:
                    revert with 0, 50
                mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _679 = mem[64]
            _687 = mem[s]
            t = 0
            while t < _687:
                mem[t + _679 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_687) <= _687:
                _861 = mem[_201]
                s = 0
                while s < _861:
                    mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_861) <= _861:
                    _985 = mem[_480]
                    s = 0
                    while s < _985:
                        mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1073 = mem[64]
                        mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                        mem[64] = _985 + _679 + _687 + _861 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1073
                        u = _347
                        continue 
                    mem[_985 + _679 + _687 + _861 + 32] = 0
                    _1074 = mem[64]
                    mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                    mem[64] = _985 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1074
                    u = _347
                    continue 
                mem[_861 + _679 + _687 + 32] = 0
                _986 = mem[_480]
                s = 0
                while s < _986:
                    mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1075 = mem[64]
                    mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                    mem[64] = _986 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    u = _347
                    continue 
                mem[_986 + _679 + _687 + _861 + 32] = 0
                _1076 = mem[64]
                mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                mem[64] = _986 + _679 + _687 + _861 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                u = _347
                continue 
            mem[_687 + _679 + 32] = 0
            _862 = mem[_201]
            s = 0
            while s < _862:
                mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_862) <= _862:
                _987 = mem[_480]
                s = 0
                while s < _987:
                    mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_987) <= _987:
                    _1077 = mem[64]
                    mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                    mem[64] = _987 + _679 + _687 + _862 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1077
                    u = _347
                    continue 
                mem[_987 + _679 + _687 + _862 + 32] = 0
                _1078 = mem[64]
                mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                mem[64] = _987 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1078
                u = _347
                continue 
            mem[_862 + _679 + _687 + 32] = 0
            _988 = mem[_480]
            s = 0
            while s < _988:
                mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                s = s + 32
                continue 
            if ceil32(_988) <= _988:
                _1079 = mem[64]
                mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
                mem[64] = _988 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1079
                u = _347
                continue 
            mem[_988 + _679 + _687 + _862 + 32] = 0
            _1080 = mem[64]
            mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
            mem[64] = _988 + _679 + _687 + _862 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1080
            u = _347
            continue 
        mem[_480 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _348
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_480]:
                revert with 0, 50
            mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _680 = mem[64]
        _688 = mem[s]
        t = 0
        while t < _688:
            mem[t + _680 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_688) <= _688:
            _863 = mem[_201]
            s = 0
            while s < _863:
                mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_863) <= _863:
                _989 = mem[_480]
                idx = 0
                while idx < _989:
                    mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1081 = mem[64]
                    mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                    mem[64] = _989 + _680 + _688 + _863 + 32
                    if ceil32(_863) == -1:
                        revert with 0, 17
                    s = ceil32(_863) + 1
                    s = _1081
                    u = _347
                    continue 
                mem[_989 + _680 + _688 + _863 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                mem[64] = _989 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1082
                u = _347
                continue 
            mem[_863 + _680 + _688 + 32] = 0
            _990 = mem[_480]
            idx = 0
            while idx < _990:
                mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_990) <= _990:
                _1083 = mem[64]
                mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
                mem[64] = _990 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1083
                u = _347
                continue 
            mem[_990 + _680 + _688 + _863 + 32] = 0
            _1084 = mem[64]
            mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
            mem[64] = _990 + _680 + _688 + _863 + 32
            if ceil32(_863) == -1:
                revert with 0, 17
            s = ceil32(_863) + 1
            s = _1084
            u = _347
            continue 
        mem[_688 + _680 + 32] = 0
        _864 = mem[_201]
        s = 0
        while s < _864:
            mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
            s = s + 32
            continue 
        if ceil32(_864) <= _864:
            _991 = mem[_480]
            idx = 0
            while idx < _991:
                mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_991) <= _991:
                _1085 = mem[64]
                mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
                mem[64] = _991 + _680 + _688 + _864 + 32
                if ceil32(_864) == -1:
                    revert with 0, 17
                s = ceil32(_864) + 1
                s = _1085
                u = _347
                continue 
            mem[_991 + _680 + _688 + _864 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
            mem[64] = _991 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1086
            u = _347
            continue 
        mem[_864 + _680 + _688 + 32] = 0
        _992 = mem[_480]
        idx = 0
        while idx < _992:
            mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
            idx = idx + 32
            continue 
        if ceil32(_992) <= _992:
            _1087 = mem[64]
            mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
            mem[64] = _992 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1087
            u = _347
            continue 
        mem[_992 + _680 + _688 + _864 + 32] = 0
        _1088 = mem[64]
        mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
        mem[64] = _992 + _680 + _688 + _864 + 32
        if ceil32(_864) == -1:
            revert with 0, 17
        s = ceil32(_864) + 1
        s = _1088
        u = _347
        continue 
    mem[mem[64]] = 32
    _352 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_352)] = mem[s + 32 len ceil32(_352)]
    if ceil32(_352) > _352:
        mem[_352 + mem[64] + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_352) + 32]
}

function _getNodesLastClaimTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 4
    mem[64] = (32 * stor4[address(arg1)].field_0) + 128
    mem[96] = stor4[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _52 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _57 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_57] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_57 + 32] = stor4[address(arg1)][idx].field_0
                        t = _57 + 32
                        u = sha3(mem[0])
                        while _57 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            if not stor4[address(arg1)][idx].field_1 % 128:
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_57 + 32] = stor4[address(arg1)][idx].field_0
            t = _57 + 32
            u = sha3(mem[0])
            while _57 + stor4[address(arg1)][u].field_1 % 128 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _57
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        _59 = mem[64]
        mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
        mem[_59] = stor4[address(arg1)][idx].field_1 % 128
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_59 + 32] = stor4[address(arg1)][idx].field_0
            t = _59 + 32
            u = sha3(mem[0])
            while _59 + (uint255(stor4[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _59
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        if stor4[address(arg1)][idx].field_1 % 128:
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
            else:
                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                mem[_59 + 32] = stor4[address(arg1)][idx].field_0
                t = _59 + 32
                u = sha3(mem[0])
                while _59 + stor4[address(arg1)][idx].field_1 % 128 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_52] = _59
        mem[_52 + 32] = stor4[address(arg1)][idx].field_256
        mem[_52 + 64] = stor4[address(arg1)][idx].field_512
        mem[_52 + 96] = stor4[address(arg1)][idx].field_768
        mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
        mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
        mem[s] = _52
        s = s + 32
        idx = idx + 1
        continue 
    _50 = mem[96]
    _53 = mem[64]
    mem[64] = mem[64] + 192
    mem[_53] = 96
    mem[_53 + 32] = 0
    mem[_53 + 64] = 0
    mem[_53 + 96] = 0
    mem[_53 + 128] = 0
    mem[_53 + 160] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _56 = mem[mem[128] + 64]
    if not mem[mem[128] + 64]:
        _58 = mem[64]
        mem[64] = mem[64] + 64
        mem[_58] = 1
        mem[_58 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _60 = mem[64]
        mem[64] = mem[64] + 64
        mem[_60] = 1
        mem[_60 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _58
        t = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _100 = mem[(32 * idx) + 128]
            _101 = mem[mem[(32 * idx) + 128] + 64]
            if not mem[mem[(32 * idx) + 128] + 64]:
                _103 = mem[64]
                mem[64] = mem[64] + 64
                mem[_103] = 1
                mem[_103 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _104 = mem[64]
                _107 = mem[s]
                t = 0
                while t < _107:
                    mem[t + _104 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_107) <= _107:
                    _203 = mem[_60]
                    s = 0
                    while s < _203:
                        mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_203) <= _203:
                        _355 = mem[_103]
                        s = 0
                        while s < _355:
                            mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_355) <= _355:
                            _493 = mem[64]
                            mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                            mem[64] = _355 + _104 + _107 + _203 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _493
                            t = _100
                            continue 
                        mem[_355 + _104 + _107 + _203 + 32] = 0
                        _494 = mem[64]
                        mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                        mem[64] = _355 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _494
                        t = _100
                        continue 
                    mem[_203 + _104 + _107 + 32] = 0
                    _356 = mem[_103]
                    s = 0
                    while s < _356:
                        mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_356) <= _356:
                        _495 = mem[64]
                        mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                        mem[64] = _356 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _495
                        t = _100
                        continue 
                    mem[_356 + _104 + _107 + _203 + 32] = 0
                    _496 = mem[64]
                    mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                    mem[64] = _356 + _104 + _107 + _203 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _496
                    t = _100
                    continue 
                mem[_107 + _104 + 32] = 0
                _204 = mem[_60]
                s = 0
                while s < _204:
                    mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_204) <= _204:
                    _357 = mem[_103]
                    s = 0
                    while s < _357:
                        mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_357) <= _357:
                        _497 = mem[64]
                        mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                        mem[64] = _357 + _104 + _107 + _204 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _497
                        t = _100
                        continue 
                    mem[_357 + _104 + _107 + _204 + 32] = 0
                    _498 = mem[64]
                    mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                    mem[64] = _357 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _498
                    t = _100
                    continue 
                mem[_204 + _104 + _107 + 32] = 0
                _358 = mem[_103]
                s = 0
                while s < _358:
                    mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                    s = s + 32
                    continue 
                if ceil32(_358) <= _358:
                    _499 = mem[64]
                    mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                    mem[64] = _358 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _499
                    t = _100
                    continue 
                mem[_358 + _104 + _107 + _204 + 32] = 0
                _500 = mem[64]
                mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                mem[64] = _358 + _104 + _107 + _204 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _500
                t = _100
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 64]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _202 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _101
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_202]:
                        revert with 0, 50
                    mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _349 = mem[64]
                _353 = mem[s]
                t = 0
                while t < _353:
                    mem[t + _349 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_353) <= _353:
                    _485 = mem[_60]
                    s = 0
                    while s < _485:
                        mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_485) <= _485:
                        _693 = mem[_202]
                        s = 0
                        while s < _693:
                            mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_693) <= _693:
                            _881 = mem[64]
                            mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                            mem[64] = _693 + _349 + _353 + _485 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _881
                            t = _100
                            continue 
                        mem[_693 + _349 + _353 + _485 + 32] = 0
                        _882 = mem[64]
                        mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                        mem[64] = _693 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _882
                        t = _100
                        continue 
                    mem[_485 + _349 + _353 + 32] = 0
                    _694 = mem[_202]
                    s = 0
                    while s < _694:
                        mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_694) <= _694:
                        _883 = mem[64]
                        mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                        mem[64] = _694 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _100
                        continue 
                    mem[_694 + _349 + _353 + _485 + 32] = 0
                    _884 = mem[64]
                    mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                    mem[64] = _694 + _349 + _353 + _485 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _100
                    continue 
                mem[_353 + _349 + 32] = 0
                _486 = mem[_60]
                s = 0
                while s < _486:
                    mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_486) <= _486:
                    _695 = mem[_202]
                    s = 0
                    while s < _695:
                        mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_695) <= _695:
                        _885 = mem[64]
                        mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                        mem[64] = _695 + _349 + _353 + _486 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _885
                        t = _100
                        continue 
                    mem[_695 + _349 + _353 + _486 + 32] = 0
                    _886 = mem[64]
                    mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                    mem[64] = _695 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _886
                    t = _100
                    continue 
                mem[_486 + _349 + _353 + 32] = 0
                _696 = mem[_202]
                s = 0
                while s < _696:
                    mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                    s = s + 32
                    continue 
                if ceil32(_696) <= _696:
                    _887 = mem[64]
                    mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                    mem[64] = _696 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _887
                    t = _100
                    continue 
                mem[_696 + _349 + _353 + _486 + 32] = 0
                _888 = mem[64]
                mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                mem[64] = _696 + _349 + _353 + _486 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _888
                t = _100
                continue 
            mem[_202 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _101
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_202]:
                    revert with 0, 50
                mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _350 = mem[64]
            _354 = mem[s]
            t = 0
            while t < _354:
                mem[t + _350 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_354) <= _354:
                _487 = mem[_60]
                s = 0
                while s < _487:
                    mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_487) <= _487:
                    _697 = mem[_202]
                    idx = 0
                    while idx < _697:
                        mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _889 = mem[64]
                        mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                        mem[64] = _697 + _350 + _354 + _487 + 32
                        if ceil32(_487) == -1:
                            revert with 0, 17
                        s = ceil32(_487) + 1
                        s = _889
                        t = _100
                        continue 
                    mem[_697 + _350 + _354 + _487 + 32] = 0
                    _890 = mem[64]
                    mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                    mem[64] = _697 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _890
                    t = _100
                    continue 
                mem[_487 + _350 + _354 + 32] = 0
                _698 = mem[_202]
                idx = 0
                while idx < _698:
                    mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_698) <= _698:
                    _891 = mem[64]
                    mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                    mem[64] = _698 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _891
                    t = _100
                    continue 
                mem[_698 + _350 + _354 + _487 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                mem[64] = _698 + _350 + _354 + _487 + 32
                if ceil32(_487) == -1:
                    revert with 0, 17
                s = ceil32(_487) + 1
                s = _892
                t = _100
                continue 
            mem[_354 + _350 + 32] = 0
            _488 = mem[_60]
            s = 0
            while s < _488:
                mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                s = s + 32
                continue 
            if ceil32(_488) <= _488:
                _699 = mem[_202]
                idx = 0
                while idx < _699:
                    mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_699) <= _699:
                    _893 = mem[64]
                    mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                    mem[64] = _699 + _350 + _354 + _488 + 32
                    if ceil32(_488) == -1:
                        revert with 0, 17
                    s = ceil32(_488) + 1
                    s = _893
                    t = _100
                    continue 
                mem[_699 + _350 + _354 + _488 + 32] = 0
                _894 = mem[64]
                mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                mem[64] = _699 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _894
                t = _100
                continue 
            mem[_488 + _350 + _354 + 32] = 0
            _700 = mem[_202]
            idx = 0
            while idx < _700:
                mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                idx = idx + 32
                continue 
            if ceil32(_700) <= _700:
                _895 = mem[64]
                mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
                mem[64] = _700 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _895
                t = _100
                continue 
            mem[_700 + _350 + _354 + _488 + 32] = 0
            _896 = mem[64]
            mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
            mem[64] = _700 + _350 + _354 + _488 + 32
            if ceil32(_488) == -1:
                revert with 0, 17
            s = ceil32(_488) + 1
            s = _896
            t = _100
            continue 
        _99 = mem[64]
        mem[mem[64]] = 32
        _102 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_102)] = mem[s + 32 len ceil32(_102)]
        if ceil32(_102) <= _102:
            return 32, mem[mem[64] + 32 len ceil32(_102) + 32]
        mem[_102 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_102) + _99 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 64]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _98 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _56
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_98]:
                revert with 0, 50
            mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 1
        mem[_200 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _98
        u = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _344 = mem[(32 * idx) + 128]
            _345 = mem[mem[(32 * idx) + 128] + 64]
            if not mem[mem[(32 * idx) + 128] + 64]:
                _359 = mem[64]
                mem[64] = mem[64] + 64
                mem[_359] = 1
                mem[_359 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _361 = mem[64]
                _364 = mem[s]
                u = 0
                while u < _364:
                    mem[u + _361 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_364) <= _364:
                    _481 = mem[_200]
                    s = 0
                    while s < _481:
                        mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_481) <= _481:
                        _683 = mem[_359]
                        s = 0
                        while s < _683:
                            mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_683) <= _683:
                            _865 = mem[64]
                            mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                            mem[64] = _683 + _361 + _364 + _481 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _865
                            u = _344
                            continue 
                        mem[_683 + _361 + _364 + _481 + 32] = 0
                        _866 = mem[64]
                        mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                        mem[64] = _683 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _866
                        u = _344
                        continue 
                    mem[_481 + _361 + _364 + 32] = 0
                    _684 = mem[_359]
                    s = 0
                    while s < _684:
                        mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_684) <= _684:
                        _867 = mem[64]
                        mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                        mem[64] = _684 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _867
                        u = _344
                        continue 
                    mem[_684 + _361 + _364 + _481 + 32] = 0
                    _868 = mem[64]
                    mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                    mem[64] = _684 + _361 + _364 + _481 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _868
                    u = _344
                    continue 
                mem[_364 + _361 + 32] = 0
                _482 = mem[_200]
                s = 0
                while s < _482:
                    mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_482) <= _482:
                    _685 = mem[_359]
                    s = 0
                    while s < _685:
                        mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_685) <= _685:
                        _869 = mem[64]
                        mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                        mem[64] = _685 + _361 + _364 + _482 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _869
                        u = _344
                        continue 
                    mem[_685 + _361 + _364 + _482 + 32] = 0
                    _870 = mem[64]
                    mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                    mem[64] = _685 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _870
                    u = _344
                    continue 
                mem[_482 + _361 + _364 + 32] = 0
                _686 = mem[_359]
                s = 0
                while s < _686:
                    mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                    s = s + 32
                    continue 
                if ceil32(_686) <= _686:
                    _871 = mem[64]
                    mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                    mem[64] = _686 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _871
                    u = _344
                    continue 
                mem[_686 + _361 + _364 + _482 + 32] = 0
                _872 = mem[64]
                mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                mem[64] = _686 + _361 + _364 + _482 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _872
                u = _344
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 64]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _479 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _345
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_479]:
                        revert with 0, 50
                    mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _677 = mem[64]
                _681 = mem[s]
                t = 0
                while t < _681:
                    mem[t + _677 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_681) <= _681:
                    _857 = mem[_200]
                    s = 0
                    while s < _857:
                        mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_857) <= _857:
                        _977 = mem[_479]
                        s = 0
                        while s < _977:
                            mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_977) <= _977:
                            _1057 = mem[64]
                            mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                            mem[64] = _977 + _677 + _681 + _857 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1057
                            u = _344
                            continue 
                        mem[_977 + _677 + _681 + _857 + 32] = 0
                        _1058 = mem[64]
                        mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                        mem[64] = _977 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1058
                        u = _344
                        continue 
                    mem[_857 + _677 + _681 + 32] = 0
                    _978 = mem[_479]
                    s = 0
                    while s < _978:
                        mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_978) <= _978:
                        _1059 = mem[64]
                        mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                        mem[64] = _978 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1059
                        u = _344
                        continue 
                    mem[_978 + _677 + _681 + _857 + 32] = 0
                    _1060 = mem[64]
                    mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                    mem[64] = _978 + _677 + _681 + _857 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1060
                    u = _344
                    continue 
                mem[_681 + _677 + 32] = 0
                _858 = mem[_200]
                s = 0
                while s < _858:
                    mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_858) <= _858:
                    _979 = mem[_479]
                    s = 0
                    while s < _979:
                        mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_979) <= _979:
                        _1061 = mem[64]
                        mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                        mem[64] = _979 + _677 + _681 + _858 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1061
                        u = _344
                        continue 
                    mem[_979 + _677 + _681 + _858 + 32] = 0
                    _1062 = mem[64]
                    mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                    mem[64] = _979 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1062
                    u = _344
                    continue 
                mem[_858 + _677 + _681 + 32] = 0
                _980 = mem[_479]
                s = 0
                while s < _980:
                    mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                    s = s + 32
                    continue 
                if ceil32(_980) <= _980:
                    _1063 = mem[64]
                    mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                    mem[64] = _980 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1063
                    u = _344
                    continue 
                mem[_980 + _677 + _681 + _858 + 32] = 0
                _1064 = mem[64]
                mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                mem[64] = _980 + _677 + _681 + _858 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1064
                u = _344
                continue 
            mem[_479 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _345
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_479]:
                    revert with 0, 50
                mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _678 = mem[64]
            _682 = mem[s]
            t = 0
            while t < _682:
                mem[t + _678 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_682) <= _682:
                _859 = mem[_200]
                s = 0
                while s < _859:
                    mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_859) <= _859:
                    _981 = mem[_479]
                    idx = 0
                    while idx < _981:
                        mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_981) <= _981:
                        _1065 = mem[64]
                        mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                        mem[64] = _981 + _678 + _682 + _859 + 32
                        if ceil32(_859) == -1:
                            revert with 0, 17
                        s = ceil32(_859) + 1
                        s = _1065
                        u = _344
                        continue 
                    mem[_981 + _678 + _682 + _859 + 32] = 0
                    _1066 = mem[64]
                    mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                    mem[64] = _981 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1066
                    u = _344
                    continue 
                mem[_859 + _678 + _682 + 32] = 0
                _982 = mem[_479]
                idx = 0
                while idx < _982:
                    mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_982) <= _982:
                    _1067 = mem[64]
                    mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                    mem[64] = _982 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1067
                    u = _344
                    continue 
                mem[_982 + _678 + _682 + _859 + 32] = 0
                _1068 = mem[64]
                mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                mem[64] = _982 + _678 + _682 + _859 + 32
                if ceil32(_859) == -1:
                    revert with 0, 17
                s = ceil32(_859) + 1
                s = _1068
                u = _344
                continue 
            mem[_682 + _678 + 32] = 0
            _860 = mem[_200]
            s = 0
            while s < _860:
                mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                s = s + 32
                continue 
            if ceil32(_860) <= _860:
                _983 = mem[_479]
                idx = 0
                while idx < _983:
                    mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_983) <= _983:
                    _1069 = mem[64]
                    mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                    mem[64] = _983 + _678 + _682 + _860 + 32
                    if ceil32(_860) == -1:
                        revert with 0, 17
                    s = ceil32(_860) + 1
                    s = _1069
                    u = _344
                    continue 
                mem[_983 + _678 + _682 + _860 + 32] = 0
                _1070 = mem[64]
                mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                mem[64] = _983 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1070
                u = _344
                continue 
            mem[_860 + _678 + _682 + 32] = 0
            _984 = mem[_479]
            idx = 0
            while idx < _984:
                mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                idx = idx + 32
                continue 
            if ceil32(_984) <= _984:
                _1071 = mem[64]
                mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
                mem[64] = _984 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1071
                u = _344
                continue 
            mem[_984 + _678 + _682 + _860 + 32] = 0
            _1072 = mem[64]
            mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
            mem[64] = _984 + _678 + _682 + _860 + 32
            if ceil32(_860) == -1:
                revert with 0, 17
            s = ceil32(_860) + 1
            s = _1072
            u = _344
            continue 
        mem[mem[64]] = 32
        _351 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_351)] = mem[s + 32 len ceil32(_351)]
        if ceil32(_351) > _351:
            mem[_351 + mem[64] + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_351) + 32]
    mem[_98 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _56
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_98]:
            revert with 0, 50
        mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _201 = mem[64]
    mem[64] = mem[64] + 64
    mem[_201] = 1
    mem[_201 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _98
    u = _53
    while idx < _50:
        if idx >= mem[96]:
            revert with 0, 50
        _347 = mem[(32 * idx) + 128]
        _348 = mem[mem[(32 * idx) + 128] + 64]
        if not mem[mem[(32 * idx) + 128] + 64]:
            _360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_360] = 1
            mem[_360 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _362 = mem[64]
            _366 = mem[s]
            u = 0
            while u < _366:
                mem[u + _362 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_366) <= _366:
                _483 = mem[_201]
                s = 0
                while s < _483:
                    mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_483) <= _483:
                    _689 = mem[_360]
                    s = 0
                    while s < _689:
                        mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_689) <= _689:
                        _873 = mem[64]
                        mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                        mem[64] = _689 + _362 + _366 + _483 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _873
                        u = _347
                        continue 
                    mem[_689 + _362 + _366 + _483 + 32] = 0
                    _874 = mem[64]
                    mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                    mem[64] = _689 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _874
                    u = _347
                    continue 
                mem[_483 + _362 + _366 + 32] = 0
                _690 = mem[_360]
                s = 0
                while s < _690:
                    mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_690) <= _690:
                    _875 = mem[64]
                    mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                    mem[64] = _690 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _875
                    u = _347
                    continue 
                mem[_690 + _362 + _366 + _483 + 32] = 0
                _876 = mem[64]
                mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                mem[64] = _690 + _362 + _366 + _483 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _876
                u = _347
                continue 
            mem[_366 + _362 + 32] = 0
            _484 = mem[_201]
            s = 0
            while s < _484:
                mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_484) <= _484:
                _691 = mem[_360]
                s = 0
                while s < _691:
                    mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_691) <= _691:
                    _877 = mem[64]
                    mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                    mem[64] = _691 + _362 + _366 + _484 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    u = _347
                    continue 
                mem[_691 + _362 + _366 + _484 + 32] = 0
                _878 = mem[64]
                mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                mem[64] = _691 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                u = _347
                continue 
            mem[_484 + _362 + _366 + 32] = 0
            _692 = mem[_360]
            s = 0
            while s < _692:
                mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                s = s + 32
                continue 
            if ceil32(_692) <= _692:
                _879 = mem[64]
                mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
                mem[64] = _692 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _879
                u = _347
                continue 
            mem[_692 + _362 + _366 + _484 + 32] = 0
            _880 = mem[64]
            mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
            mem[64] = _692 + _362 + _366 + _484 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _880
            u = _347
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 64]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _480 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _348
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_480]:
                    revert with 0, 50
                mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _679 = mem[64]
            _687 = mem[s]
            t = 0
            while t < _687:
                mem[t + _679 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_687) <= _687:
                _861 = mem[_201]
                s = 0
                while s < _861:
                    mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_861) <= _861:
                    _985 = mem[_480]
                    s = 0
                    while s < _985:
                        mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1073 = mem[64]
                        mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                        mem[64] = _985 + _679 + _687 + _861 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1073
                        u = _347
                        continue 
                    mem[_985 + _679 + _687 + _861 + 32] = 0
                    _1074 = mem[64]
                    mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                    mem[64] = _985 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1074
                    u = _347
                    continue 
                mem[_861 + _679 + _687 + 32] = 0
                _986 = mem[_480]
                s = 0
                while s < _986:
                    mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1075 = mem[64]
                    mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                    mem[64] = _986 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    u = _347
                    continue 
                mem[_986 + _679 + _687 + _861 + 32] = 0
                _1076 = mem[64]
                mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                mem[64] = _986 + _679 + _687 + _861 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                u = _347
                continue 
            mem[_687 + _679 + 32] = 0
            _862 = mem[_201]
            s = 0
            while s < _862:
                mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_862) <= _862:
                _987 = mem[_480]
                s = 0
                while s < _987:
                    mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_987) <= _987:
                    _1077 = mem[64]
                    mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                    mem[64] = _987 + _679 + _687 + _862 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1077
                    u = _347
                    continue 
                mem[_987 + _679 + _687 + _862 + 32] = 0
                _1078 = mem[64]
                mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                mem[64] = _987 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1078
                u = _347
                continue 
            mem[_862 + _679 + _687 + 32] = 0
            _988 = mem[_480]
            s = 0
            while s < _988:
                mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                s = s + 32
                continue 
            if ceil32(_988) <= _988:
                _1079 = mem[64]
                mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
                mem[64] = _988 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1079
                u = _347
                continue 
            mem[_988 + _679 + _687 + _862 + 32] = 0
            _1080 = mem[64]
            mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
            mem[64] = _988 + _679 + _687 + _862 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1080
            u = _347
            continue 
        mem[_480 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _348
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_480]:
                revert with 0, 50
            mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _680 = mem[64]
        _688 = mem[s]
        t = 0
        while t < _688:
            mem[t + _680 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_688) <= _688:
            _863 = mem[_201]
            s = 0
            while s < _863:
                mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_863) <= _863:
                _989 = mem[_480]
                idx = 0
                while idx < _989:
                    mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1081 = mem[64]
                    mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                    mem[64] = _989 + _680 + _688 + _863 + 32
                    if ceil32(_863) == -1:
                        revert with 0, 17
                    s = ceil32(_863) + 1
                    s = _1081
                    u = _347
                    continue 
                mem[_989 + _680 + _688 + _863 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                mem[64] = _989 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1082
                u = _347
                continue 
            mem[_863 + _680 + _688 + 32] = 0
            _990 = mem[_480]
            idx = 0
            while idx < _990:
                mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_990) <= _990:
                _1083 = mem[64]
                mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
                mem[64] = _990 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1083
                u = _347
                continue 
            mem[_990 + _680 + _688 + _863 + 32] = 0
            _1084 = mem[64]
            mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
            mem[64] = _990 + _680 + _688 + _863 + 32
            if ceil32(_863) == -1:
                revert with 0, 17
            s = ceil32(_863) + 1
            s = _1084
            u = _347
            continue 
        mem[_688 + _680 + 32] = 0
        _864 = mem[_201]
        s = 0
        while s < _864:
            mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
            s = s + 32
            continue 
        if ceil32(_864) <= _864:
            _991 = mem[_480]
            idx = 0
            while idx < _991:
                mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_991) <= _991:
                _1085 = mem[64]
                mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
                mem[64] = _991 + _680 + _688 + _864 + 32
                if ceil32(_864) == -1:
                    revert with 0, 17
                s = ceil32(_864) + 1
                s = _1085
                u = _347
                continue 
            mem[_991 + _680 + _688 + _864 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
            mem[64] = _991 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1086
            u = _347
            continue 
        mem[_864 + _680 + _688 + 32] = 0
        _992 = mem[_480]
        idx = 0
        while idx < _992:
            mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
            idx = idx + 32
            continue 
        if ceil32(_992) <= _992:
            _1087 = mem[64]
            mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
            mem[64] = _992 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1087
            u = _347
            continue 
        mem[_992 + _680 + _688 + _864 + 32] = 0
        _1088 = mem[64]
        mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
        mem[64] = _992 + _680 + _688 + _864 + 32
        if ceil32(_864) == -1:
            revert with 0, 17
        s = ceil32(_864) + 1
        s = _1088
        u = _347
        continue 
    mem[mem[64]] = 32
    _352 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_352)] = mem[s + 32 len ceil32(_352)]
    if ceil32(_352) > _352:
        mem[_352 + mem[64] + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_352) + 32]
}

function sub_a7b75767(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 4
    mem[64] = (32 * stor4[address(arg1)].field_0) + 128
    mem[96] = stor4[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _52 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _57 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_57] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_57 + 32] = stor4[address(arg1)][idx].field_0
                        t = _57 + 32
                        u = sha3(mem[0])
                        while _57 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            if not stor4[address(arg1)][idx].field_1 % 128:
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_57 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _57
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_57 + 32] = stor4[address(arg1)][idx].field_0
            t = _57 + 32
            u = sha3(mem[0])
            while _57 + stor4[address(arg1)][u].field_1 % 128 > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _57
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        _59 = mem[64]
        mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
        mem[_59] = stor4[address(arg1)][idx].field_1 % 128
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                mem[_52] = _59
                mem[_52 + 32] = stor4[address(arg1)][idx].field_256
                mem[_52 + 64] = stor4[address(arg1)][idx].field_512
                mem[_52 + 96] = stor4[address(arg1)][idx].field_768
                mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
                mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
                mem[s] = _52
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
            mem[_59 + 32] = stor4[address(arg1)][idx].field_0
            t = _59 + 32
            u = sha3(mem[0])
            while _59 + (uint255(stor4[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = stor1[u]
                t = t + 32
                u = u + 1
                continue 
            mem[_52] = _59
            mem[_52 + 32] = stor4[address(arg1)][u].field_256
            mem[_52 + 64] = stor4[address(arg1)][u].field_512
            mem[_52 + 96] = stor4[address(arg1)][u].field_768
            mem[_52 + 128] = stor4[address(arg1)][u].field_1024
            mem[_52 + 160] = stor4[address(arg1)][u].field_1280
            mem[t] = _52
            t = t + 32
            u = u + 1
            continue 
        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
            revert with 0, 34
        if stor4[address(arg1)][idx].field_1 % 128:
            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                mem[_59 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
            else:
                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                mem[_59 + 32] = stor4[address(arg1)][idx].field_0
                t = _59 + 32
                u = sha3(mem[0])
                while _59 + stor4[address(arg1)][idx].field_1 % 128 > t:
                    mem[t + 32] = stor1[u]
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_52] = _59
        mem[_52 + 32] = stor4[address(arg1)][idx].field_256
        mem[_52 + 64] = stor4[address(arg1)][idx].field_512
        mem[_52 + 96] = stor4[address(arg1)][idx].field_768
        mem[_52 + 128] = stor4[address(arg1)][idx].field_1024
        mem[_52 + 160] = stor4[address(arg1)][idx].field_1280
        mem[s] = _52
        s = s + 32
        idx = idx + 1
        continue 
    _50 = mem[96]
    _53 = mem[64]
    mem[64] = mem[64] + 192
    mem[_53] = 96
    mem[_53 + 32] = 0
    mem[_53 + 64] = 0
    mem[_53 + 96] = 0
    mem[_53 + 128] = 0
    mem[_53 + 160] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _56 = mem[mem[128] + 128]
    if not mem[mem[128] + 128]:
        _58 = mem[64]
        mem[64] = mem[64] + 64
        mem[_58] = 1
        mem[_58 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _60 = mem[64]
        mem[64] = mem[64] + 64
        mem[_60] = 1
        mem[_60 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _58
        t = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _100 = mem[(32 * idx) + 128]
            _101 = mem[mem[(32 * idx) + 128] + 128]
            if not mem[mem[(32 * idx) + 128] + 128]:
                _103 = mem[64]
                mem[64] = mem[64] + 64
                mem[_103] = 1
                mem[_103 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _104 = mem[64]
                _107 = mem[s]
                t = 0
                while t < _107:
                    mem[t + _104 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_107) <= _107:
                    _203 = mem[_60]
                    s = 0
                    while s < _203:
                        mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_203) <= _203:
                        _355 = mem[_103]
                        s = 0
                        while s < _355:
                            mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_355) <= _355:
                            _493 = mem[64]
                            mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                            mem[64] = _355 + _104 + _107 + _203 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _493
                            t = _100
                            continue 
                        mem[_355 + _104 + _107 + _203 + 32] = 0
                        _494 = mem[64]
                        mem[mem[64]] = _355 + _104 + _107 + _203 - mem[64]
                        mem[64] = _355 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _494
                        t = _100
                        continue 
                    mem[_203 + _104 + _107 + 32] = 0
                    _356 = mem[_103]
                    s = 0
                    while s < _356:
                        mem[s + _104 + _107 + _203 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_356) <= _356:
                        _495 = mem[64]
                        mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                        mem[64] = _356 + _104 + _107 + _203 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _495
                        t = _100
                        continue 
                    mem[_356 + _104 + _107 + _203 + 32] = 0
                    _496 = mem[64]
                    mem[mem[64]] = _356 + _104 + _107 + _203 - mem[64]
                    mem[64] = _356 + _104 + _107 + _203 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _496
                    t = _100
                    continue 
                mem[_107 + _104 + 32] = 0
                _204 = mem[_60]
                s = 0
                while s < _204:
                    mem[s + _104 + _107 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_204) <= _204:
                    _357 = mem[_103]
                    s = 0
                    while s < _357:
                        mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_357) <= _357:
                        _497 = mem[64]
                        mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                        mem[64] = _357 + _104 + _107 + _204 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _497
                        t = _100
                        continue 
                    mem[_357 + _104 + _107 + _204 + 32] = 0
                    _498 = mem[64]
                    mem[mem[64]] = _357 + _104 + _107 + _204 - mem[64]
                    mem[64] = _357 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _498
                    t = _100
                    continue 
                mem[_204 + _104 + _107 + 32] = 0
                _358 = mem[_103]
                s = 0
                while s < _358:
                    mem[s + _104 + _107 + _204 + 32] = mem[s + _103 + 32]
                    s = s + 32
                    continue 
                if ceil32(_358) <= _358:
                    _499 = mem[64]
                    mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                    mem[64] = _358 + _104 + _107 + _204 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _499
                    t = _100
                    continue 
                mem[_358 + _104 + _107 + _204 + 32] = 0
                _500 = mem[64]
                mem[mem[64]] = _358 + _104 + _107 + _204 - mem[64]
                mem[64] = _358 + _104 + _107 + _204 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _500
                t = _100
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 128]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _202 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _101
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_202]:
                        revert with 0, 50
                    mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _349 = mem[64]
                _353 = mem[s]
                t = 0
                while t < _353:
                    mem[t + _349 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_353) <= _353:
                    _485 = mem[_60]
                    s = 0
                    while s < _485:
                        mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_485) <= _485:
                        _693 = mem[_202]
                        s = 0
                        while s < _693:
                            mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_693) <= _693:
                            _881 = mem[64]
                            mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                            mem[64] = _693 + _349 + _353 + _485 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _881
                            t = _100
                            continue 
                        mem[_693 + _349 + _353 + _485 + 32] = 0
                        _882 = mem[64]
                        mem[mem[64]] = _693 + _349 + _353 + _485 - mem[64]
                        mem[64] = _693 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _882
                        t = _100
                        continue 
                    mem[_485 + _349 + _353 + 32] = 0
                    _694 = mem[_202]
                    s = 0
                    while s < _694:
                        mem[s + _349 + _353 + _485 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_694) <= _694:
                        _883 = mem[64]
                        mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                        mem[64] = _694 + _349 + _353 + _485 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _883
                        t = _100
                        continue 
                    mem[_694 + _349 + _353 + _485 + 32] = 0
                    _884 = mem[64]
                    mem[mem[64]] = _694 + _349 + _353 + _485 - mem[64]
                    mem[64] = _694 + _349 + _353 + _485 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _884
                    t = _100
                    continue 
                mem[_353 + _349 + 32] = 0
                _486 = mem[_60]
                s = 0
                while s < _486:
                    mem[s + _349 + _353 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_486) <= _486:
                    _695 = mem[_202]
                    s = 0
                    while s < _695:
                        mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_695) <= _695:
                        _885 = mem[64]
                        mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                        mem[64] = _695 + _349 + _353 + _486 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _885
                        t = _100
                        continue 
                    mem[_695 + _349 + _353 + _486 + 32] = 0
                    _886 = mem[64]
                    mem[mem[64]] = _695 + _349 + _353 + _486 - mem[64]
                    mem[64] = _695 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _886
                    t = _100
                    continue 
                mem[_486 + _349 + _353 + 32] = 0
                _696 = mem[_202]
                s = 0
                while s < _696:
                    mem[s + _349 + _353 + _486 + 32] = mem[s + _202 + 32]
                    s = s + 32
                    continue 
                if ceil32(_696) <= _696:
                    _887 = mem[64]
                    mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                    mem[64] = _696 + _349 + _353 + _486 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _887
                    t = _100
                    continue 
                mem[_696 + _349 + _353 + _486 + 32] = 0
                _888 = mem[64]
                mem[mem[64]] = _696 + _349 + _353 + _486 - mem[64]
                mem[64] = _696 + _349 + _353 + _486 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _888
                t = _100
                continue 
            mem[_202 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _101
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_202]:
                    revert with 0, 50
                mem[v + _202 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _350 = mem[64]
            _354 = mem[s]
            t = 0
            while t < _354:
                mem[t + _350 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_354) <= _354:
                _487 = mem[_60]
                s = 0
                while s < _487:
                    mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                    s = s + 32
                    continue 
                if ceil32(_487) <= _487:
                    _697 = mem[_202]
                    idx = 0
                    while idx < _697:
                        mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_697) <= _697:
                        _889 = mem[64]
                        mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                        mem[64] = _697 + _350 + _354 + _487 + 32
                        if ceil32(_487) == -1:
                            revert with 0, 17
                        s = ceil32(_487) + 1
                        s = _889
                        t = _100
                        continue 
                    mem[_697 + _350 + _354 + _487 + 32] = 0
                    _890 = mem[64]
                    mem[mem[64]] = _697 + _350 + _354 + _487 - mem[64]
                    mem[64] = _697 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _890
                    t = _100
                    continue 
                mem[_487 + _350 + _354 + 32] = 0
                _698 = mem[_202]
                idx = 0
                while idx < _698:
                    mem[idx + _350 + _354 + _487 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_698) <= _698:
                    _891 = mem[64]
                    mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                    mem[64] = _698 + _350 + _354 + _487 + 32
                    if ceil32(_487) == -1:
                        revert with 0, 17
                    s = ceil32(_487) + 1
                    s = _891
                    t = _100
                    continue 
                mem[_698 + _350 + _354 + _487 + 32] = 0
                _892 = mem[64]
                mem[mem[64]] = _698 + _350 + _354 + _487 - mem[64]
                mem[64] = _698 + _350 + _354 + _487 + 32
                if ceil32(_487) == -1:
                    revert with 0, 17
                s = ceil32(_487) + 1
                s = _892
                t = _100
                continue 
            mem[_354 + _350 + 32] = 0
            _488 = mem[_60]
            s = 0
            while s < _488:
                mem[s + _350 + _354 + 32] = mem[s + _60 + 32]
                s = s + 32
                continue 
            if ceil32(_488) <= _488:
                _699 = mem[_202]
                idx = 0
                while idx < _699:
                    mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_699) <= _699:
                    _893 = mem[64]
                    mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                    mem[64] = _699 + _350 + _354 + _488 + 32
                    if ceil32(_488) == -1:
                        revert with 0, 17
                    s = ceil32(_488) + 1
                    s = _893
                    t = _100
                    continue 
                mem[_699 + _350 + _354 + _488 + 32] = 0
                _894 = mem[64]
                mem[mem[64]] = _699 + _350 + _354 + _488 - mem[64]
                mem[64] = _699 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _894
                t = _100
                continue 
            mem[_488 + _350 + _354 + 32] = 0
            _700 = mem[_202]
            idx = 0
            while idx < _700:
                mem[idx + _350 + _354 + _488 + 32] = mem[idx + _202 + 32]
                idx = idx + 32
                continue 
            if ceil32(_700) <= _700:
                _895 = mem[64]
                mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
                mem[64] = _700 + _350 + _354 + _488 + 32
                if ceil32(_488) == -1:
                    revert with 0, 17
                s = ceil32(_488) + 1
                s = _895
                t = _100
                continue 
            mem[_700 + _350 + _354 + _488 + 32] = 0
            _896 = mem[64]
            mem[mem[64]] = _700 + _350 + _354 + _488 - mem[64]
            mem[64] = _700 + _350 + _354 + _488 + 32
            if ceil32(_488) == -1:
                revert with 0, 17
            s = ceil32(_488) + 1
            s = _896
            t = _100
            continue 
        _99 = mem[64]
        mem[mem[64]] = 32
        _102 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_102)] = mem[s + 32 len ceil32(_102)]
        if ceil32(_102) <= _102:
            return 32, mem[mem[64] + 32 len ceil32(_102) + 32]
        mem[_102 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_102) + _99 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 128]
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _98 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _56
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_98]:
                revert with 0, 50
            mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 1
        mem[_200 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _98
        u = _53
        while idx < _50:
            if idx >= mem[96]:
                revert with 0, 50
            _344 = mem[(32 * idx) + 128]
            _345 = mem[mem[(32 * idx) + 128] + 128]
            if not mem[mem[(32 * idx) + 128] + 128]:
                _359 = mem[64]
                mem[64] = mem[64] + 64
                mem[_359] = 1
                mem[_359 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _361 = mem[64]
                _364 = mem[s]
                u = 0
                while u < _364:
                    mem[u + _361 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_364) <= _364:
                    _481 = mem[_200]
                    s = 0
                    while s < _481:
                        mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_481) <= _481:
                        _683 = mem[_359]
                        s = 0
                        while s < _683:
                            mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_683) <= _683:
                            _865 = mem[64]
                            mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                            mem[64] = _683 + _361 + _364 + _481 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _865
                            u = _344
                            continue 
                        mem[_683 + _361 + _364 + _481 + 32] = 0
                        _866 = mem[64]
                        mem[mem[64]] = _683 + _361 + _364 + _481 - mem[64]
                        mem[64] = _683 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _866
                        u = _344
                        continue 
                    mem[_481 + _361 + _364 + 32] = 0
                    _684 = mem[_359]
                    s = 0
                    while s < _684:
                        mem[s + _361 + _364 + _481 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_684) <= _684:
                        _867 = mem[64]
                        mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                        mem[64] = _684 + _361 + _364 + _481 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _867
                        u = _344
                        continue 
                    mem[_684 + _361 + _364 + _481 + 32] = 0
                    _868 = mem[64]
                    mem[mem[64]] = _684 + _361 + _364 + _481 - mem[64]
                    mem[64] = _684 + _361 + _364 + _481 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _868
                    u = _344
                    continue 
                mem[_364 + _361 + 32] = 0
                _482 = mem[_200]
                s = 0
                while s < _482:
                    mem[s + _361 + _364 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_482) <= _482:
                    _685 = mem[_359]
                    s = 0
                    while s < _685:
                        mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_685) <= _685:
                        _869 = mem[64]
                        mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                        mem[64] = _685 + _361 + _364 + _482 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _869
                        u = _344
                        continue 
                    mem[_685 + _361 + _364 + _482 + 32] = 0
                    _870 = mem[64]
                    mem[mem[64]] = _685 + _361 + _364 + _482 - mem[64]
                    mem[64] = _685 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _870
                    u = _344
                    continue 
                mem[_482 + _361 + _364 + 32] = 0
                _686 = mem[_359]
                s = 0
                while s < _686:
                    mem[s + _361 + _364 + _482 + 32] = mem[s + _359 + 32]
                    s = s + 32
                    continue 
                if ceil32(_686) <= _686:
                    _871 = mem[64]
                    mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                    mem[64] = _686 + _361 + _364 + _482 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _871
                    u = _344
                    continue 
                mem[_686 + _361 + _364 + _482 + 32] = 0
                _872 = mem[64]
                mem[mem[64]] = _686 + _361 + _364 + _482 - mem[64]
                mem[64] = _686 + _361 + _364 + _482 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _872
                u = _344
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 128]
            while t:
                if u == -1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _479 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _345
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_479]:
                        revert with 0, 50
                    mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _677 = mem[64]
                _681 = mem[s]
                t = 0
                while t < _681:
                    mem[t + _677 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_681) <= _681:
                    _857 = mem[_200]
                    s = 0
                    while s < _857:
                        mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_857) <= _857:
                        _977 = mem[_479]
                        s = 0
                        while s < _977:
                            mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_977) <= _977:
                            _1057 = mem[64]
                            mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                            mem[64] = _977 + _677 + _681 + _857 + 32
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1057
                            u = _344
                            continue 
                        mem[_977 + _677 + _681 + _857 + 32] = 0
                        _1058 = mem[64]
                        mem[mem[64]] = _977 + _677 + _681 + _857 - mem[64]
                        mem[64] = _977 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1058
                        u = _344
                        continue 
                    mem[_857 + _677 + _681 + 32] = 0
                    _978 = mem[_479]
                    s = 0
                    while s < _978:
                        mem[s + _677 + _681 + _857 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_978) <= _978:
                        _1059 = mem[64]
                        mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                        mem[64] = _978 + _677 + _681 + _857 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1059
                        u = _344
                        continue 
                    mem[_978 + _677 + _681 + _857 + 32] = 0
                    _1060 = mem[64]
                    mem[mem[64]] = _978 + _677 + _681 + _857 - mem[64]
                    mem[64] = _978 + _677 + _681 + _857 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1060
                    u = _344
                    continue 
                mem[_681 + _677 + 32] = 0
                _858 = mem[_200]
                s = 0
                while s < _858:
                    mem[s + _677 + _681 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_858) <= _858:
                    _979 = mem[_479]
                    s = 0
                    while s < _979:
                        mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_979) <= _979:
                        _1061 = mem[64]
                        mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                        mem[64] = _979 + _677 + _681 + _858 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1061
                        u = _344
                        continue 
                    mem[_979 + _677 + _681 + _858 + 32] = 0
                    _1062 = mem[64]
                    mem[mem[64]] = _979 + _677 + _681 + _858 - mem[64]
                    mem[64] = _979 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1062
                    u = _344
                    continue 
                mem[_858 + _677 + _681 + 32] = 0
                _980 = mem[_479]
                s = 0
                while s < _980:
                    mem[s + _677 + _681 + _858 + 32] = mem[s + _479 + 32]
                    s = s + 32
                    continue 
                if ceil32(_980) <= _980:
                    _1063 = mem[64]
                    mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                    mem[64] = _980 + _677 + _681 + _858 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1063
                    u = _344
                    continue 
                mem[_980 + _677 + _681 + _858 + 32] = 0
                _1064 = mem[64]
                mem[mem[64]] = _980 + _677 + _681 + _858 - mem[64]
                mem[64] = _980 + _677 + _681 + _858 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1064
                u = _344
                continue 
            mem[_479 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _345
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_479]:
                    revert with 0, 50
                mem[v + _479 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _678 = mem[64]
            _682 = mem[s]
            t = 0
            while t < _682:
                mem[t + _678 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_682) <= _682:
                _859 = mem[_200]
                s = 0
                while s < _859:
                    mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                    s = s + 32
                    continue 
                if ceil32(_859) <= _859:
                    _981 = mem[_479]
                    idx = 0
                    while idx < _981:
                        mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_981) <= _981:
                        _1065 = mem[64]
                        mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                        mem[64] = _981 + _678 + _682 + _859 + 32
                        if ceil32(_859) == -1:
                            revert with 0, 17
                        s = ceil32(_859) + 1
                        s = _1065
                        u = _344
                        continue 
                    mem[_981 + _678 + _682 + _859 + 32] = 0
                    _1066 = mem[64]
                    mem[mem[64]] = _981 + _678 + _682 + _859 - mem[64]
                    mem[64] = _981 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1066
                    u = _344
                    continue 
                mem[_859 + _678 + _682 + 32] = 0
                _982 = mem[_479]
                idx = 0
                while idx < _982:
                    mem[idx + _678 + _682 + _859 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_982) <= _982:
                    _1067 = mem[64]
                    mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                    mem[64] = _982 + _678 + _682 + _859 + 32
                    if ceil32(_859) == -1:
                        revert with 0, 17
                    s = ceil32(_859) + 1
                    s = _1067
                    u = _344
                    continue 
                mem[_982 + _678 + _682 + _859 + 32] = 0
                _1068 = mem[64]
                mem[mem[64]] = _982 + _678 + _682 + _859 - mem[64]
                mem[64] = _982 + _678 + _682 + _859 + 32
                if ceil32(_859) == -1:
                    revert with 0, 17
                s = ceil32(_859) + 1
                s = _1068
                u = _344
                continue 
            mem[_682 + _678 + 32] = 0
            _860 = mem[_200]
            s = 0
            while s < _860:
                mem[s + _678 + _682 + 32] = mem[s + _200 + 32]
                s = s + 32
                continue 
            if ceil32(_860) <= _860:
                _983 = mem[_479]
                idx = 0
                while idx < _983:
                    mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_983) <= _983:
                    _1069 = mem[64]
                    mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                    mem[64] = _983 + _678 + _682 + _860 + 32
                    if ceil32(_860) == -1:
                        revert with 0, 17
                    s = ceil32(_860) + 1
                    s = _1069
                    u = _344
                    continue 
                mem[_983 + _678 + _682 + _860 + 32] = 0
                _1070 = mem[64]
                mem[mem[64]] = _983 + _678 + _682 + _860 - mem[64]
                mem[64] = _983 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1070
                u = _344
                continue 
            mem[_860 + _678 + _682 + 32] = 0
            _984 = mem[_479]
            idx = 0
            while idx < _984:
                mem[idx + _678 + _682 + _860 + 32] = mem[idx + _479 + 32]
                idx = idx + 32
                continue 
            if ceil32(_984) <= _984:
                _1071 = mem[64]
                mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
                mem[64] = _984 + _678 + _682 + _860 + 32
                if ceil32(_860) == -1:
                    revert with 0, 17
                s = ceil32(_860) + 1
                s = _1071
                u = _344
                continue 
            mem[_984 + _678 + _682 + _860 + 32] = 0
            _1072 = mem[64]
            mem[mem[64]] = _984 + _678 + _682 + _860 - mem[64]
            mem[64] = _984 + _678 + _682 + _860 + 32
            if ceil32(_860) == -1:
                revert with 0, 17
            s = ceil32(_860) + 1
            s = _1072
            u = _344
            continue 
        mem[mem[64]] = 32
        _351 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_351)] = mem[s + 32 len ceil32(_351)]
        if ceil32(_351) > _351:
            mem[_351 + mem[64] + 64] = 0
        return 32, mem[mem[64] + 32 len ceil32(_351) + 32]
    mem[_98 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _56
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_98]:
            revert with 0, 50
        mem[t + _98 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _201 = mem[64]
    mem[64] = mem[64] + 64
    mem[_201] = 1
    mem[_201 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _98
    u = _53
    while idx < _50:
        if idx >= mem[96]:
            revert with 0, 50
        _347 = mem[(32 * idx) + 128]
        _348 = mem[mem[(32 * idx) + 128] + 128]
        if not mem[mem[(32 * idx) + 128] + 128]:
            _360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_360] = 1
            mem[_360 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _362 = mem[64]
            _366 = mem[s]
            u = 0
            while u < _366:
                mem[u + _362 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_366) <= _366:
                _483 = mem[_201]
                s = 0
                while s < _483:
                    mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_483) <= _483:
                    _689 = mem[_360]
                    s = 0
                    while s < _689:
                        mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_689) <= _689:
                        _873 = mem[64]
                        mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                        mem[64] = _689 + _362 + _366 + _483 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _873
                        u = _347
                        continue 
                    mem[_689 + _362 + _366 + _483 + 32] = 0
                    _874 = mem[64]
                    mem[mem[64]] = _689 + _362 + _366 + _483 - mem[64]
                    mem[64] = _689 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _874
                    u = _347
                    continue 
                mem[_483 + _362 + _366 + 32] = 0
                _690 = mem[_360]
                s = 0
                while s < _690:
                    mem[s + _362 + _366 + _483 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_690) <= _690:
                    _875 = mem[64]
                    mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                    mem[64] = _690 + _362 + _366 + _483 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _875
                    u = _347
                    continue 
                mem[_690 + _362 + _366 + _483 + 32] = 0
                _876 = mem[64]
                mem[mem[64]] = _690 + _362 + _366 + _483 - mem[64]
                mem[64] = _690 + _362 + _366 + _483 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _876
                u = _347
                continue 
            mem[_366 + _362 + 32] = 0
            _484 = mem[_201]
            s = 0
            while s < _484:
                mem[s + _362 + _366 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_484) <= _484:
                _691 = mem[_360]
                s = 0
                while s < _691:
                    mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                    s = s + 32
                    continue 
                if ceil32(_691) <= _691:
                    _877 = mem[64]
                    mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                    mem[64] = _691 + _362 + _366 + _484 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _877
                    u = _347
                    continue 
                mem[_691 + _362 + _366 + _484 + 32] = 0
                _878 = mem[64]
                mem[mem[64]] = _691 + _362 + _366 + _484 - mem[64]
                mem[64] = _691 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _878
                u = _347
                continue 
            mem[_484 + _362 + _366 + 32] = 0
            _692 = mem[_360]
            s = 0
            while s < _692:
                mem[s + _362 + _366 + _484 + 32] = mem[s + _360 + 32]
                s = s + 32
                continue 
            if ceil32(_692) <= _692:
                _879 = mem[64]
                mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
                mem[64] = _692 + _362 + _366 + _484 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _879
                u = _347
                continue 
            mem[_692 + _362 + _366 + _484 + 32] = 0
            _880 = mem[64]
            mem[mem[64]] = _692 + _362 + _366 + _484 - mem[64]
            mem[64] = _692 + _362 + _366 + _484 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _880
            u = _347
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 128]
        while t:
            if u == -1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _480 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _348
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_480]:
                    revert with 0, 50
                mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _679 = mem[64]
            _687 = mem[s]
            t = 0
            while t < _687:
                mem[t + _679 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_687) <= _687:
                _861 = mem[_201]
                s = 0
                while s < _861:
                    mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                    s = s + 32
                    continue 
                if ceil32(_861) <= _861:
                    _985 = mem[_480]
                    s = 0
                    while s < _985:
                        mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_985) <= _985:
                        _1073 = mem[64]
                        mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                        mem[64] = _985 + _679 + _687 + _861 + 32
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1073
                        u = _347
                        continue 
                    mem[_985 + _679 + _687 + _861 + 32] = 0
                    _1074 = mem[64]
                    mem[mem[64]] = _985 + _679 + _687 + _861 - mem[64]
                    mem[64] = _985 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1074
                    u = _347
                    continue 
                mem[_861 + _679 + _687 + 32] = 0
                _986 = mem[_480]
                s = 0
                while s < _986:
                    mem[s + _679 + _687 + _861 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_986) <= _986:
                    _1075 = mem[64]
                    mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                    mem[64] = _986 + _679 + _687 + _861 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1075
                    u = _347
                    continue 
                mem[_986 + _679 + _687 + _861 + 32] = 0
                _1076 = mem[64]
                mem[mem[64]] = _986 + _679 + _687 + _861 - mem[64]
                mem[64] = _986 + _679 + _687 + _861 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1076
                u = _347
                continue 
            mem[_687 + _679 + 32] = 0
            _862 = mem[_201]
            s = 0
            while s < _862:
                mem[s + _679 + _687 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_862) <= _862:
                _987 = mem[_480]
                s = 0
                while s < _987:
                    mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                    s = s + 32
                    continue 
                if ceil32(_987) <= _987:
                    _1077 = mem[64]
                    mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                    mem[64] = _987 + _679 + _687 + _862 + 32
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1077
                    u = _347
                    continue 
                mem[_987 + _679 + _687 + _862 + 32] = 0
                _1078 = mem[64]
                mem[mem[64]] = _987 + _679 + _687 + _862 - mem[64]
                mem[64] = _987 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1078
                u = _347
                continue 
            mem[_862 + _679 + _687 + 32] = 0
            _988 = mem[_480]
            s = 0
            while s < _988:
                mem[s + _679 + _687 + _862 + 32] = mem[s + _480 + 32]
                s = s + 32
                continue 
            if ceil32(_988) <= _988:
                _1079 = mem[64]
                mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
                mem[64] = _988 + _679 + _687 + _862 + 32
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1079
                u = _347
                continue 
            mem[_988 + _679 + _687 + _862 + 32] = 0
            _1080 = mem[64]
            mem[mem[64]] = _988 + _679 + _687 + _862 - mem[64]
            mem[64] = _988 + _679 + _687 + _862 + 32
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1080
            u = _347
            continue 
        mem[_480 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _348
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_480]:
                revert with 0, 50
            mem[v + _480 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _680 = mem[64]
        _688 = mem[s]
        t = 0
        while t < _688:
            mem[t + _680 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_688) <= _688:
            _863 = mem[_201]
            s = 0
            while s < _863:
                mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
                s = s + 32
                continue 
            if ceil32(_863) <= _863:
                _989 = mem[_480]
                idx = 0
                while idx < _989:
                    mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_989) <= _989:
                    _1081 = mem[64]
                    mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                    mem[64] = _989 + _680 + _688 + _863 + 32
                    if ceil32(_863) == -1:
                        revert with 0, 17
                    s = ceil32(_863) + 1
                    s = _1081
                    u = _347
                    continue 
                mem[_989 + _680 + _688 + _863 + 32] = 0
                _1082 = mem[64]
                mem[mem[64]] = _989 + _680 + _688 + _863 - mem[64]
                mem[64] = _989 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1082
                u = _347
                continue 
            mem[_863 + _680 + _688 + 32] = 0
            _990 = mem[_480]
            idx = 0
            while idx < _990:
                mem[idx + _680 + _688 + _863 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_990) <= _990:
                _1083 = mem[64]
                mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
                mem[64] = _990 + _680 + _688 + _863 + 32
                if ceil32(_863) == -1:
                    revert with 0, 17
                s = ceil32(_863) + 1
                s = _1083
                u = _347
                continue 
            mem[_990 + _680 + _688 + _863 + 32] = 0
            _1084 = mem[64]
            mem[mem[64]] = _990 + _680 + _688 + _863 - mem[64]
            mem[64] = _990 + _680 + _688 + _863 + 32
            if ceil32(_863) == -1:
                revert with 0, 17
            s = ceil32(_863) + 1
            s = _1084
            u = _347
            continue 
        mem[_688 + _680 + 32] = 0
        _864 = mem[_201]
        s = 0
        while s < _864:
            mem[s + _680 + _688 + 32] = mem[s + _201 + 32]
            s = s + 32
            continue 
        if ceil32(_864) <= _864:
            _991 = mem[_480]
            idx = 0
            while idx < _991:
                mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
                idx = idx + 32
                continue 
            if ceil32(_991) <= _991:
                _1085 = mem[64]
                mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
                mem[64] = _991 + _680 + _688 + _864 + 32
                if ceil32(_864) == -1:
                    revert with 0, 17
                s = ceil32(_864) + 1
                s = _1085
                u = _347
                continue 
            mem[_991 + _680 + _688 + _864 + 32] = 0
            _1086 = mem[64]
            mem[mem[64]] = _991 + _680 + _688 + _864 - mem[64]
            mem[64] = _991 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1086
            u = _347
            continue 
        mem[_864 + _680 + _688 + 32] = 0
        _992 = mem[_480]
        idx = 0
        while idx < _992:
            mem[idx + _680 + _688 + _864 + 32] = mem[idx + _480 + 32]
            idx = idx + 32
            continue 
        if ceil32(_992) <= _992:
            _1087 = mem[64]
            mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
            mem[64] = _992 + _680 + _688 + _864 + 32
            if ceil32(_864) == -1:
                revert with 0, 17
            s = ceil32(_864) + 1
            s = _1087
            u = _347
            continue 
        mem[_992 + _680 + _688 + _864 + 32] = 0
        _1088 = mem[64]
        mem[mem[64]] = _992 + _680 + _688 + _864 - mem[64]
        mem[64] = _992 + _680 + _688 + _864 + 32
        if ceil32(_864) == -1:
            revert with 0, 17
        s = ceil32(_864) + 1
        s = _1088
        u = _347
        continue 
    mem[mem[64]] = 32
    _352 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_352)] = mem[s + 32 len ceil32(_352)]
    if ceil32(_352) > _352:
        mem[_352 + mem[64] + 64] = 0
    return 32, mem[mem[64] + 32 len ceil32(_352) + 32]
}

function _getRewardAmountOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 4
    idx = 0
    s = 0
    while idx < stor4[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 4)
        _521 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _522 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_522] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    mem[_521] = _522
                    mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                    if stor4[address(arg1)][idx].field_512:
                        _530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_530] = 30
                        mem[_530 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > block.timestamp:
                            _538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _538 + 68] = mem[idx + _530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _538 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_581] = 26
                        mem[_581 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _603 + 68] = mem[idx + _581 + 32]
                                idx = idx + 32
                                continue 
                            mem[_603 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _603 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _572 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_572] = 30
                    mem[_572 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > block.timestamp:
                        _593 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _593 + 68] = mem[idx + _572 + 32]
                            idx = idx + 32
                            continue 
                        mem[_593 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _593 + -mem[64] + 100
                    if block.timestamp < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _686 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_686] = 26
                    mem[_686 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _714 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _714 + 68] = mem[idx + _686 + 32]
                            idx = idx + 32
                            continue 
                        mem[_714 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _714 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_522 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_521] = _522
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_540] = 30
                            mem[_540 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _551 + 68] = mem[idx + _540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _551 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _606 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_606] = 26
                            mem[_606 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _638 + 68] = mem[idx + _606 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_638 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _638 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_595] = 30
                        mem[_595 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _623 + 68] = mem[idx + _595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _623 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _716 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_716] = 26
                        mem[_716 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _746 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _746 + 68] = mem[idx + _716 + 32]
                                idx = idx + 32
                                continue 
                            mem[_746 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _746 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_522 + 32] = stor4[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1132 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1132] = 30
                            mem[_1132 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1136 + 68] = mem[idx + _1132 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1136 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1156] = 26
                            mem[_1156 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1172 + 68] = mem[idx + _1156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1172 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1172 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1152] = 30
                        mem[_1152 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1162 + 68] = mem[idx + _1152 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1162 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1192] = 26
                        mem[_1192 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1206 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1206 + 68] = mem[idx + _1192 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1206 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1206 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor4[address(arg1)][idx].field_1 % 128:
                    mem[_521] = _522
                    mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                    if stor4[address(arg1)][idx].field_512:
                        _534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_534] = 30
                        mem[_534 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > block.timestamp:
                            _544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _544 + 68] = mem[idx + _534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _544 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _596 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_596] = 26
                        mem[_596 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _624 + 68] = mem[idx + _596 + 32]
                                idx = idx + 32
                                continue 
                            mem[_624 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _624 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_583] = 30
                    mem[_583 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > block.timestamp:
                        _609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _609 + 68] = mem[idx + _583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _609 + -mem[64] + 100
                    if block.timestamp < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _703 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_703] = 26
                    mem[_703 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _732 + 68] = mem[idx + _703 + 32]
                            idx = idx + 32
                            continue 
                        mem[_732 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _732 + -mem[64] + 100
                else:
                    if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                        mem[_522 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_521] = _522
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_546] = 30
                            mem[_546 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _560 + 68] = mem[idx + _546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_560 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _560 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_627] = 26
                            mem[_627 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _660 + 68] = mem[idx + _627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_660 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _660 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_611] = 30
                        mem[_611 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _644 + 68] = mem[idx + _611 + 32]
                                idx = idx + 32
                                continue 
                            mem[_644 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _644 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_734] = 26
                        mem[_734 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _767 + 68] = mem[idx + _734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_767 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _767 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_522 + 32] = stor4[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + stor4[address(arg1)][idx].field_1 % 128 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1133] = 30
                            mem[_1133 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1137 + 68] = mem[idx + _1133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1137 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1157] = 26
                            mem[_1157 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1174 + 68] = mem[idx + _1157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1174 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1174 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1153] = 30
                        mem[_1153 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1165 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1165 + 68] = mem[idx + _1153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1165 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1165 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1193] = 26
                        mem[_1193 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1209 + 68] = mem[idx + _1193 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1209 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1209 + -mem[64] + 100
        else:
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            _523 = mem[64]
            mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
            mem[_523] = stor4[address(arg1)][idx].field_1 % 128
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    mem[_521] = _523
                    mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                    if stor4[address(arg1)][idx].field_512:
                        _536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_536] = 30
                        mem[_536 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > block.timestamp:
                            _547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _547 + 68] = mem[idx + _536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _547 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_598] = 26
                        mem[_598 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _628 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _628 + 68] = mem[idx + _598 + 32]
                                idx = idx + 32
                                continue 
                            mem[_628 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _628 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_586] = 30
                    mem[_586 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > block.timestamp:
                        _614 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _614 + 68] = mem[idx + _586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_614 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _614 + -mem[64] + 100
                    if block.timestamp < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _706 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_706] = 26
                    mem[_706 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _737 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _737 + 68] = mem[idx + _706 + 32]
                            idx = idx + 32
                            continue 
                        mem[_737 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _737 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_523 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_521] = _523
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _549 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_549] = 30
                            mem[_549 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _562 + 68] = mem[idx + _549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_562 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _562 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _631 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_631] = 26
                            mem[_631 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _663 + 68] = mem[idx + _631 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_663 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _663 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _616 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_616] = 30
                        mem[_616 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _649 + 68] = mem[idx + _616 + 32]
                                idx = idx + 32
                                continue 
                            mem[_649 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _649 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_739] = 26
                        mem[_739 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _771 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _771 + 68] = mem[idx + _739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_771 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _771 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_523 + 32] = stor4[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1134 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1134] = 30
                            mem[_1134 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1138 + 68] = mem[idx + _1134 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1138 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1158] = 26
                            mem[_1158 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1176 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1176 + 68] = mem[idx + _1158 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1176 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1176 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1154] = 30
                        mem[_1154 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1168 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1168 + 68] = mem[idx + _1154 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1168 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1168 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1194] = 26
                        mem[_1194 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1212 + 68] = mem[idx + _1194 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1212 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1212 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor4[address(arg1)][idx].field_1 % 128:
                    mem[_521] = _523
                    mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                    if stor4[address(arg1)][idx].field_512:
                        _541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_541] = 30
                        mem[_541 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > block.timestamp:
                            _554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _554 + 68] = mem[idx + _541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _554 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_617] = 26
                        mem[_617 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _650 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _650 + 68] = mem[idx + _617 + 32]
                                idx = idx + 32
                                continue 
                            mem[_650 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _650 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _600 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_600] = 30
                    mem[_600 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > block.timestamp:
                        _634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _634 + 68] = mem[idx + _600 + 32]
                            idx = idx + 32
                            continue 
                        mem[_634 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _634 + -mem[64] + 100
                    if block.timestamp < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_723] = 26
                    mem[_723 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _757 + 68] = mem[idx + _723 + 32]
                            idx = idx + 32
                            continue 
                        mem[_757 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _757 + -mem[64] + 100
                else:
                    if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                        mem[_523 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_521] = _523
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_556] = 30
                            mem[_556 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _571 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _571 + 68] = mem[idx + _556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_571 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _571 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_653] = 26
                            mem[_653 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _684 + 68] = mem[idx + _653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_684 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _684 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_636] = 30
                        mem[_636 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _669 + 68] = mem[idx + _636 + 32]
                                idx = idx + 32
                                continue 
                            mem[_669 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _669 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_759] = 26
                        mem[_759 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _792 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _792 + 68] = mem[idx + _759 + 32]
                                idx = idx + 32
                                continue 
                            mem[_792 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _792 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_523 + 32] = stor4[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + stor4[address(arg1)][idx].field_1 % 128 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_521 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_521 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1135] = 30
                            mem[_1135 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1139 + 68] = mem[idx + _1135 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1139 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1159] = 26
                            mem[_1159 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1178 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1178 + 68] = mem[idx + _1159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1178 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1178 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1155] = 30
                        mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1171 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1171 + 68] = mem[idx + _1155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1171 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1171 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1195 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1195] = 26
                        mem[_1195 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1215 + 68] = mem[idx + _1195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1215 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1215 + -mem[64] + 100
        ('stor', ('name', 'claimTime', 7))
        if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
            revert with 0, 17
        if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
            revert with 0, 'SafeMath: addition overflow'
        if not rewardPerNode:
            if 0 > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if stor4[address(arg1)][idx].field_1280 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + stor4[address(arg1)][idx].field_1280
            continue 
        if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
            revert with 0, 17
        if not rewardPerNode:
            revert with 0, 18
        if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
            revert with 0, 'SafeMath: multiplication overflow'
        if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
            revert with 0, 17
        if stor4[address(arg1)][idx].field_1280 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if s > !(rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
        continue 
    return s
}

function sub_10afd86e(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 4
    idx = 0
    s = 0
    while idx < stor4[address(arg1)].field_0:
        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
            revert with 0, 17
        if idx >= stor4[address(arg1)].field_0:
            revert with 0, 50
        if block.timestamp < stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
            mem[0] = sha3(address(arg1), 4)
            _1051 = mem[64]
            mem[64] = mem[64] + 192
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                _1053 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_1053] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1051] = _1053
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1066] = 30
                            mem[_1066 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1074 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1074 + 68] = mem[idx + _1066 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1074 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1074 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1131] = 26
                            mem[_1131 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1161 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1161 + 68] = mem[idx + _1131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1161 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1161 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1119] = 30
                        mem[_1119 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1147 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1147 + 68] = mem[idx + _1119 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1147 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1147 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1274] = 26
                        mem[_1274 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1319 + 68] = mem[idx + _1274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1319 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1319 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1053 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1076] = 30
                                mem[_1076 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1089 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1089 + 68] = mem[idx + _1076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1089 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1089 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1164] = 26
                                mem[_1164 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1205 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1205 + 68] = mem[idx + _1164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1205 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1205 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _1149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1149] = 30
                            mem[_1149 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1185 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1185 + 68] = mem[idx + _1149 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1185 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1185 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1321] = 26
                            mem[_1321 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1373 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1373 + 68] = mem[idx + _1321 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1373 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1373 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1053 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1053 + 32
                            u = sha3(mem[0])
                            while _1053 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2288] = 30
                                mem[_2288 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2296 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2296 + 68] = mem[idx + _2288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2296 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2296 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2328] = 26
                                mem[_2328 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2352 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2352 + 68] = mem[idx + _2328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2352 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2352 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2324] = 30
                            mem[_2324 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2338 + 68] = mem[idx + _2324 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2338 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2338 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2404 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2404] = 26
                            mem[_2404 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2422 + 68] = mem[idx + _2404 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2422 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2422 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1051] = _1053
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1070] = 30
                            mem[_1070 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1080 + 68] = mem[idx + _1070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1080 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1080 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1150] = 26
                            mem[_1150 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1186 + 68] = mem[idx + _1150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1186 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1186 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1133] = 30
                        mem[_1133 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1167 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1167 + 68] = mem[idx + _1133 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1167 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1167 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1299] = 26
                        mem[_1299 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1347 + 68] = mem[idx + _1299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1347 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1347 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1053 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1082] = 30
                                mem[_1082 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1102 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1102 + 68] = mem[idx + _1082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1102 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1102 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1189] = 26
                                mem[_1189 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1234 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1234 + 68] = mem[idx + _1189 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1234 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1234 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _1169 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1169] = 30
                            mem[_1169 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1211 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1211 + 68] = mem[idx + _1169 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1211 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1211 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1349] = 26
                            mem[_1349 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1410 + 68] = mem[idx + _1349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1410 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1410 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1053 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1053 + 32
                            u = sha3(mem[0])
                            while _1053 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2289] = 30
                                mem[_2289 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2297 + 68] = mem[idx + _2289 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2297 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2329] = 26
                                mem[_2329 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2354 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2354 + 68] = mem[idx + _2329 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2354 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2354 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2325] = 30
                            mem[_2325 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2341 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2341 + 68] = mem[idx + _2325 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2341 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2341 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2405] = 26
                            mem[_2405 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2425 + 68] = mem[idx + _2405 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2425 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2425 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                _1055 = mem[64]
                mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                mem[_1055] = stor4[address(arg1)][idx].field_1 % 128
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1051] = _1055
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1072 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1072] = 30
                            mem[_1072 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1083 + 68] = mem[idx + _1072 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1083 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1152 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1152] = 26
                            mem[_1152 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1190 + 68] = mem[idx + _1152 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1190 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1190 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1136 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1136] = 30
                        mem[_1136 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1172 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1172 + 68] = mem[idx + _1136 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1172 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1172 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1302 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1302] = 26
                        mem[_1302 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1352 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1352 + 68] = mem[idx + _1302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1352 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1352 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1055 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1085] = 30
                                mem[_1085 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1104 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1104 + 68] = mem[idx + _1085 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1104 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1104 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1193] = 26
                                mem[_1193 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1237 + 68] = mem[idx + _1193 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1237 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1237 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _1174 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1174] = 30
                            mem[_1174 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1216 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1216 + 68] = mem[idx + _1174 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1216 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1216 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1354 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1354] = 26
                            mem[_1354 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1414 + 68] = mem[idx + _1354 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1414 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1414 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1055 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1055 + 32
                            u = sha3(mem[0])
                            while _1055 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2290] = 30
                                mem[_2290 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2298 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2298 + 68] = mem[idx + _2290 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2298 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2298 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2330] = 26
                                mem[_2330 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2356 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2356 + 68] = mem[idx + _2330 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2356 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2356 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2326] = 30
                            mem[_2326 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2344 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2344 + 68] = mem[idx + _2326 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2344 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2344 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2406 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2406] = 26
                            mem[_2406 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2428 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2428 + 68] = mem[idx + _2406 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2428 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2428 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1051] = _1055
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1077] = 30
                            mem[_1077 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1092 + 68] = mem[idx + _1077 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1092 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1175] = 26
                            mem[_1175 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1217 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1217 + 68] = mem[idx + _1175 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1217 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1217 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1154] = 30
                        mem[_1154 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > block.timestamp:
                            _1196 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1196 + 68] = mem[idx + _1154 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1196 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1196 + -mem[64] + 100
                        if block.timestamp < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1328] = 26
                        mem[_1328 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1384 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1384 + 68] = mem[idx + _1328 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1384 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1384 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1055 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1094] = 30
                                mem[_1094 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1116 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1116 + 68] = mem[idx + _1094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1116 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1116 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1220 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1220] = 26
                                mem[_1220 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1265 + 68] = mem[idx + _1220 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1265 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1265 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _1198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1198] = 30
                            mem[_1198 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1243 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1243 + 68] = mem[idx + _1198 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1243 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1243 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1386] = 26
                            mem[_1386 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1453 + 68] = mem[idx + _1386 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1453 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1453 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1055 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1055 + 32
                            u = sha3(mem[0])
                            while _1055 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2291] = 30
                                mem[_2291 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2299 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2299 + 68] = mem[idx + _2291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2299 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2299 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2331] = 26
                                mem[_2331 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2358 + 68] = mem[idx + _2331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2358 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2358 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2327] = 30
                            mem[_2327 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2347 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2347 + 68] = mem[idx + _2327 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2347 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2347 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2407] = 26
                            mem[_2407 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2431 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2431 + 68] = mem[idx + _2407 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2431 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2431 + -mem[64] + 100
            ('stor', ('name', 'claimTime', 7))
            if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                revert with 0, 17
            if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                revert with 0, 'SafeMath: addition overflow'
            if not rewardPerNode:
                if 0 > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if stor4[address(arg1)][idx].field_1280 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + stor4[address(arg1)][idx].field_1280
                continue 
            if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                revert with 0, 17
            if not rewardPerNode:
                revert with 0, 18
            if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                revert with 0, 'SafeMath: multiplication overflow'
            if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if stor4[address(arg1)][idx].field_1280 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !(rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
            continue 
        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
            revert with 0, 17
        if idx >= stor4[address(arg1)].field_0:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 4)
        if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
            if s > -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if idx >= stor4[address(arg1)].field_0:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 4)
        _1057 = mem[64]
        mem[64] = mem[64] + 192
        if bool(stor4[address(arg1)][idx].field_0):
            if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                revert with 0, 34
            _1058 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_1058] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    mem[_1057] = _1058
                    mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    mem[0] = sha3(address(arg1), 4)
                    if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_512:
                        _1157 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1157] = 30
                        mem[_1157 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1199 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1199 + 68] = mem[idx + _1157 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1199 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1199 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _1331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1331] = 26
                        mem[_1331 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1387 + 68] = mem[idx + _1331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1387 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1387 + -mem[64] + 100
                        if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _1308 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1308] = 30
                    mem[_1308 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                        _1360 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1360 + 68] = mem[idx + _1308 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1360 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1360 + -mem[64] + 100
                    if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _1539 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1539] = 26
                    mem[_1539 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _1586 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1586 + 68] = mem[idx + _1539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1586 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1586 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_1058 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1201] = 30
                            mem[_1201 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1245 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1245 + 68] = mem[idx + _1201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1245 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1245 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1390] = 26
                            mem[_1390 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1455 + 68] = mem[idx + _1390 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1455 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1455 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1362] = 30
                        mem[_1362 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1423 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1423 + 68] = mem[idx + _1362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1423 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1423 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1588] = 26
                        mem[_1588 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1632 + 68] = mem[idx + _1588 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1632 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1632 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_1058 + 32] = stor4[address(arg1)][idx].field_0
                        t = _1058 + 32
                        u = sha3(mem[0])
                        while _1058 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2304 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2304] = 30
                            mem[_2304 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2312 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2312 + 68] = mem[idx + _2304 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2312 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2312 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2368 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2368] = 26
                            mem[_2368 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2388 + 68] = mem[idx + _2368 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2388 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2388 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _2360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2360] = 30
                        mem[_2360 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _2374 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2374 + 68] = mem[idx + _2360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2374 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2374 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2440 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2440] = 26
                        mem[_2440 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _2458 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2458 + 68] = mem[idx + _2440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2458 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2458 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor4[address(arg1)][idx].field_1 % 128:
                    mem[_1057] = _1058
                    mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    mem[0] = sha3(address(arg1), 4)
                    if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_512:
                        _1177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1177] = 30
                        mem[_1177 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1222 + 68] = mem[idx + _1177 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1222 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _1363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1363] = 26
                        mem[_1363 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1424 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1424 + 68] = mem[idx + _1363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1424 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1424 + -mem[64] + 100
                        if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _1333 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1333] = 30
                    mem[_1333 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                        _1393 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1393 + 68] = mem[idx + _1333 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1393 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1393 + -mem[64] + 100
                    if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _1566 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1566] = 26
                    mem[_1566 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _1611 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1611 + 68] = mem[idx + _1566 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1611 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1611 + -mem[64] + 100
                else:
                    if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1058 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1224 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1224] = 30
                            mem[_1224 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1270 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1270 + 68] = mem[idx + _1224 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1270 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1270 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1427 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1427] = 26
                            mem[_1427 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1493 + 68] = mem[idx + _1427 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1493 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1493 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1395] = 30
                        mem[_1395 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1461 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1461 + 68] = mem[idx + _1395 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1461 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1461 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1613] = 26
                        mem[_1613 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1661 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1661 + 68] = mem[idx + _1613 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1661 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1661 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_1058 + 32] = stor4[address(arg1)][idx].field_0
                        t = _1058 + 32
                        u = sha3(mem[0])
                        while _1058 + stor4[address(arg1)][idx].field_1 % 128 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2305] = 30
                            mem[_2305 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2313 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2313 + 68] = mem[idx + _2305 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2313 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2313 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2369] = 26
                            mem[_2369 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2390 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2390 + 68] = mem[idx + _2369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2390 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2390 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _2361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2361] = 30
                        mem[_2361 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _2377 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2377 + 68] = mem[idx + _2361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2377 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2377 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2441 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2441] = 26
                        mem[_2441 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _2461 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2461 + 68] = mem[idx + _2441 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2461 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2461 + -mem[64] + 100
        else:
            if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                revert with 0, 34
            _1061 = mem[64]
            mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
            mem[_1061] = stor4[address(arg1)][idx].field_1 % 128
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                    mem[_1057] = _1061
                    mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    mem[0] = sha3(address(arg1), 4)
                    if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_512:
                        _1179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1179] = 30
                        mem[_1179 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1225 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1225 + 68] = mem[idx + _1179 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1225 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1225 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _1365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1365] = 26
                        mem[_1365 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1428 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1428 + 68] = mem[idx + _1365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1428 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1428 + -mem[64] + 100
                        if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _1336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1336] = 30
                    mem[_1336 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                        _1398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1398 + 68] = mem[idx + _1336 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1398 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1398 + -mem[64] + 100
                    if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _1569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1569] = 26
                    mem[_1569 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _1616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1616 + 68] = mem[idx + _1569 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1616 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1616 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                        mem[_1061 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1227 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1227] = 30
                            mem[_1227 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1272 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1272 + 68] = mem[idx + _1227 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1272 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1272 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1431] = 26
                            mem[_1431 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1496 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1496 + 68] = mem[idx + _1431 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1496 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1496 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1400 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1400] = 30
                        mem[_1400 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1466 + 68] = mem[idx + _1400 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1466 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1466 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1618 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1618] = 26
                        mem[_1618 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1665 + 68] = mem[idx + _1618 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1665 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1665 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_1061 + 32] = stor4[address(arg1)][idx].field_0
                        t = _1061 + 32
                        u = sha3(mem[0])
                        while _1061 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2306] = 30
                            mem[_2306 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2314 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2314 + 68] = mem[idx + _2306 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2314 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2314 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2370 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2370] = 26
                            mem[_2370 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2392 + 68] = mem[idx + _2370 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2392 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2392 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _2362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2362] = 30
                        mem[_2362 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _2380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2380 + 68] = mem[idx + _2362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2380 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2380 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2442 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2442] = 26
                        mem[_2442 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _2464 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2464 + 68] = mem[idx + _2442 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2464 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2464 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor4[address(arg1)][idx].field_1 % 128:
                    mem[_1057] = _1061
                    mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                    mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                    mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                    mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                    mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    mem[0] = sha3(address(arg1), 4)
                    if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_512:
                        _1202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1202] = 30
                        mem[_1202 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1248 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1248 + 68] = mem[idx + _1202 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1248 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1248 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _1401 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1401] = 26
                        mem[_1401 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1467 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1467 + 68] = mem[idx + _1401 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1467 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1467 + -mem[64] + 100
                        if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not rewardPerNode:
                            if 0 > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_1280 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor4[address(arg1)][idx].field_1280
                            continue 
                        if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                            revert with 0, 17
                        if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                        continue 
                    _1367 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1367] = 30
                    mem[_1367 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                        _1434 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1434 + 68] = mem[idx + _1367 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1434 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1434 + -mem[64] + 100
                    if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _1595 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1595] = 26
                    mem[_1595 + 32] = 'SafeMath: division by zero' << 48
                    if not claimTime:
                        _1643 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1643 + 68] = mem[idx + _1595 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1643 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1643 + -mem[64] + 100
                else:
                    if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1061 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1250 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1250] = 30
                            mem[_1250 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1295 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1295 + 68] = mem[idx + _1250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1295 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1295 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1470 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1470] = 26
                            mem[_1470 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1528 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1528 + 68] = mem[idx + _1470 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1528 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1528 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _1436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1436] = 30
                        mem[_1436 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _1502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1502 + 68] = mem[idx + _1436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1502 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1502 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1645 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1645] = 26
                        mem[_1645 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _1693 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1693 + 68] = mem[idx + _1645 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1693 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1693 + -mem[64] + 100
                    else:
                        mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                        mem[_1061 + 32] = stor4[address(arg1)][idx].field_0
                        t = _1061 + 32
                        u = sha3(mem[0])
                        while _1061 + stor4[address(arg1)][idx].field_1 % 128 > t:
                            mem[t + 32] = stor1[u]
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2307] = 30
                            mem[_2307 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2315 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2315 + 68] = mem[idx + _2307 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2315 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2315 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2371 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2371] = 26
                            mem[_2371 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _2394 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2394 + 68] = mem[idx + _2371 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2394 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2394 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _2363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2363] = 30
                        mem[_2363 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _2383 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2383 + 68] = mem[idx + _2363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2383 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2383 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2443 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2443] = 26
                        mem[_2443 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _2467 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2467 + 68] = mem[idx + _2443 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2467 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2467 + -mem[64] + 100
        ('stor', ('name', 'claimTime', 7))
        if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
            revert with 0, 17
        if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
            revert with 0, 'SafeMath: addition overflow'
        if not rewardPerNode:
            if 0 > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if stor4[address(arg1)][idx].field_1280 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + stor4[address(arg1)][idx].field_1280
            continue 
        if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
            revert with 0, 17
        if not rewardPerNode:
            revert with 0, 18
        if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
            revert with 0, 'SafeMath: multiplication overflow'
        if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
            revert with 0, 17
        if stor4[address(arg1)][idx].field_1280 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if s > !(rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
        continue 
    return s
}

function sub_53beeda8(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 4
    idx = 0
    s = 0
    while idx < stor4[address(arg1)].field_0:
        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
            revert with 0, 17
        if idx >= stor4[address(arg1)].field_0:
            revert with 0, 50
        if block.timestamp < stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
            mem[0] = sha3(address(arg1), 4)
            _1051 = mem[64]
            mem[64] = mem[64] + 192
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                _1053 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_1053] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1051] = _1053
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1066] = 30
                            mem[_1066 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1074 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1074 + 68] = mem[idx + _1066 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1074 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1074 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1131] = 26
                            mem[_1131 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1161 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1161 + 68] = mem[idx + _1131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1161 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1161 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1119 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1119] = 30
                            mem[_1119 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1147 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1147 + 68] = mem[idx + _1119 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1147 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1147 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1274] = 26
                            mem[_1274 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1319 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1319 + 68] = mem[idx + _1274 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1319 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1319 + -mem[64] + 100
                            if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1053 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1076] = 30
                                mem[_1076 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1089 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1089 + 68] = mem[idx + _1076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1089 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1089 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1164] = 26
                                mem[_1164 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1205 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1205 + 68] = mem[idx + _1164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1205 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1205 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1149] = 30
                                mem[_1149 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _1185 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1185 + 68] = mem[idx + _1149 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1185 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1185 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1321] = 26
                                mem[_1321 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1373 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1373 + 68] = mem[idx + _1321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1373 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1373 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1053 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1053 + 32
                            u = sha3(mem[0])
                            while _1053 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2288] = 30
                                mem[_2288 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2296 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2296 + 68] = mem[idx + _2288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2296 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2296 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2328] = 26
                                mem[_2328 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2352 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2352 + 68] = mem[idx + _2328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2352 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2352 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2324] = 30
                                mem[_2324 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2338 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2338 + 68] = mem[idx + _2324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2338 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2338 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2404] = 26
                                mem[_2404 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2422 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2422 + 68] = mem[idx + _2404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2422 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2422 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1051] = _1053
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1070] = 30
                            mem[_1070 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1080 + 68] = mem[idx + _1070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1080 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1080 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1150] = 26
                            mem[_1150 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1186 + 68] = mem[idx + _1150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1186 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1186 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1133] = 30
                            mem[_1133 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1167 + 68] = mem[idx + _1133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1167 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1167 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1299] = 26
                            mem[_1299 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1347 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1347 + 68] = mem[idx + _1299 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1347 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1347 + -mem[64] + 100
                            if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1053 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1082] = 30
                                mem[_1082 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1102 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1102 + 68] = mem[idx + _1082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1102 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1102 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1189] = 26
                                mem[_1189 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1234 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1234 + 68] = mem[idx + _1189 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1234 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1234 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1169] = 30
                                mem[_1169 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _1211 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1211 + 68] = mem[idx + _1169 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1211 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1211 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1349] = 26
                                mem[_1349 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1410 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1410 + 68] = mem[idx + _1349 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1410 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1410 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1053 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1053 + 32
                            u = sha3(mem[0])
                            while _1053 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1053
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2289] = 30
                                mem[_2289 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2297 + 68] = mem[idx + _2289 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2297 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2329] = 26
                                mem[_2329 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2354 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2354 + 68] = mem[idx + _2329 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2354 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2354 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2325 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2325] = 30
                                mem[_2325 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2341 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2341 + 68] = mem[idx + _2325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2341 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2341 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2405] = 26
                                mem[_2405 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2425 + 68] = mem[idx + _2405 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2425 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2425 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                _1055 = mem[64]
                mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                mem[_1055] = stor4[address(arg1)][idx].field_1 % 128
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1051] = _1055
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1072 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1072] = 30
                            mem[_1072 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1083 + 68] = mem[idx + _1072 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1083 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1152 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1152] = 26
                            mem[_1152 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1190 + 68] = mem[idx + _1152 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1190 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1190 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1136] = 30
                            mem[_1136 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1172 + 68] = mem[idx + _1136 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1172 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1172 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1302] = 26
                            mem[_1302 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1352 + 68] = mem[idx + _1302 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1352 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1352 + -mem[64] + 100
                            if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1055 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1085] = 30
                                mem[_1085 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1104 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1104 + 68] = mem[idx + _1085 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1104 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1104 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1193] = 26
                                mem[_1193 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1237 + 68] = mem[idx + _1193 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1237 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1237 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1174] = 30
                                mem[_1174 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _1216 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1216 + 68] = mem[idx + _1174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1216 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1216 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1354 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1354] = 26
                                mem[_1354 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1414 + 68] = mem[idx + _1354 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1414 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1414 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1055 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1055 + 32
                            u = sha3(mem[0])
                            while _1055 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2290] = 30
                                mem[_2290 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2298 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2298 + 68] = mem[idx + _2290 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2298 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2298 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2330] = 26
                                mem[_2330 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2356 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2356 + 68] = mem[idx + _2330 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2356 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2356 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2326] = 30
                                mem[_2326 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2344 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2344 + 68] = mem[idx + _2326 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2344 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2344 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2406] = 26
                                mem[_2406 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2428 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2428 + 68] = mem[idx + _2406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2428 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2428 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1051] = _1055
                        mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                        if stor4[address(arg1)][idx].field_512:
                            _1077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1077] = 30
                            mem[_1077 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                _1092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1092 + 68] = mem[idx + _1077 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1092 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1175] = 26
                            mem[_1175 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1217 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1217 + 68] = mem[idx + _1175 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1217 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1217 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1154] = 30
                            mem[_1154 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _1196 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1196 + 68] = mem[idx + _1154 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1196 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1196 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1328] = 26
                            mem[_1328 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1384 + 68] = mem[idx + _1328 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1384 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1384 + -mem[64] + 100
                            if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1055 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _1094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1094] = 30
                                mem[_1094 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _1116 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1116 + 68] = mem[idx + _1094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1116 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1116 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1220 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1220] = 26
                                mem[_1220 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1265 + 68] = mem[idx + _1220 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1265 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1265 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1198 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1198] = 30
                                mem[_1198 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _1243 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1243 + 68] = mem[idx + _1198 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1243 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1243 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1386 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1386] = 26
                                mem[_1386 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1453 + 68] = mem[idx + _1386 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1453 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1453 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1055 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1055 + 32
                            u = sha3(mem[0])
                            while _1055 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1051] = _1055
                            mem[_1051 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1051 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1051 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1051 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1051 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2291] = 30
                                mem[_2291 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2299 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2299 + 68] = mem[idx + _2291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2299 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2299 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2331 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2331] = 26
                                mem[_2331 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2358 + 68] = mem[idx + _2331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2358 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2358 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2327] = 30
                                mem[_2327 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2347 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2347 + 68] = mem[idx + _2327 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2347 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2347 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2407] = 26
                                mem[_2407 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2431 + 68] = mem[idx + _2407 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2431 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2431 + -mem[64] + 100
                                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
        else:
            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 4)
            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 4)
            _1057 = mem[64]
            mem[64] = mem[64] + 192
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                _1058 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_1058] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1157] = 30
                            mem[_1157 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1199 + 68] = mem[idx + _1157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1199 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1331] = 26
                            mem[_1331 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1387 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1387 + 68] = mem[idx + _1331 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1387 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1387 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1308] = 30
                            mem[_1308 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1360 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1360 + 68] = mem[idx + _1308 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1360 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1360 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1539] = 26
                            mem[_1539 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1586 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1586 + 68] = mem[idx + _1539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1586 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1586 + -mem[64] + 100
                            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1058 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1057] = _1058
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _1201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1201] = 30
                                mem[_1201 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1245 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1245 + 68] = mem[idx + _1201 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1245 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1245 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1390] = 26
                                mem[_1390 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1455 + 68] = mem[idx + _1390 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1455 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1455 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1362 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1362] = 30
                                mem[_1362 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1423 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1423 + 68] = mem[idx + _1362 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1423 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1423 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1588] = 26
                                mem[_1588 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1632 + 68] = mem[idx + _1588 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1632 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1632 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1058 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1058 + 32
                            u = sha3(mem[0])
                            while _1058 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1057] = _1058
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2304] = 30
                                mem[_2304 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2312 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2312 + 68] = mem[idx + _2304 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2312 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2312 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2368 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2368] = 26
                                mem[_2368 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2388 + 68] = mem[idx + _2368 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2388 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2388 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2360 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2360] = 30
                                mem[_2360 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2374 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2374 + 68] = mem[idx + _2360 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2374 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2374 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2440] = 26
                                mem[_2440 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2458 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2458 + 68] = mem[idx + _2440 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2458 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2458 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1057] = _1058
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1177] = 30
                            mem[_1177 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1222 + 68] = mem[idx + _1177 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1222 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1363 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1363] = 26
                            mem[_1363 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1424 + 68] = mem[idx + _1363 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1424 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1424 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1333] = 30
                            mem[_1333 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1393 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1393 + 68] = mem[idx + _1333 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1393 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1393 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1566] = 26
                            mem[_1566 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1611 + 68] = mem[idx + _1566 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1611 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1611 + -mem[64] + 100
                            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1058 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1057] = _1058
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _1224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1224] = 30
                                mem[_1224 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1270 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1270 + 68] = mem[idx + _1224 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1270 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1270 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1427] = 26
                                mem[_1427 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1493 + 68] = mem[idx + _1427 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1493 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1493 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1395] = 30
                                mem[_1395 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1461 + 68] = mem[idx + _1395 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1461 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1461 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1613 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1613] = 26
                                mem[_1613 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1661 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1661 + 68] = mem[idx + _1613 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1661 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1661 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1058 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1058 + 32
                            u = sha3(mem[0])
                            while _1058 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1057] = _1058
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2305] = 30
                                mem[_2305 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2313 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2313 + 68] = mem[idx + _2305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2313 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2313 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2369] = 26
                                mem[_2369 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2390 + 68] = mem[idx + _2369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2390 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2390 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2361] = 30
                                mem[_2361 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2377 + 68] = mem[idx + _2361 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2377 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2377 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2441] = 26
                                mem[_2441 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2461 + 68] = mem[idx + _2441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2461 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2461 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                _1061 = mem[64]
                mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                mem[_1061] = stor4[address(arg1)][idx].field_1 % 128
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1179] = 30
                            mem[_1179 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1225 + 68] = mem[idx + _1179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1225 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1365 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1365] = 26
                            mem[_1365 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1428 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1428 + 68] = mem[idx + _1365 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1428 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1428 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1336] = 30
                            mem[_1336 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1398 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1398 + 68] = mem[idx + _1336 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1398 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1398 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1569] = 26
                            mem[_1569 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1616 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1616 + 68] = mem[idx + _1569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1616 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1616 + -mem[64] + 100
                            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_1061 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1057] = _1061
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _1227 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1227] = 30
                                mem[_1227 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1272 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1272 + 68] = mem[idx + _1227 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1272 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1272 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1431] = 26
                                mem[_1431 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1496 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1496 + 68] = mem[idx + _1431 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1496 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1496 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1400] = 30
                                mem[_1400 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1466 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1466 + 68] = mem[idx + _1400 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1466 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1466 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1618] = 26
                                mem[_1618 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1665 + 68] = mem[idx + _1618 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1665 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1665 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1061 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1061 + 32
                            u = sha3(mem[0])
                            while _1061 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1057] = _1061
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2306 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2306] = 30
                                mem[_2306 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2314 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2314 + 68] = mem[idx + _2306 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2314 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2314 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2370] = 26
                                mem[_2370 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2392 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2392 + 68] = mem[idx + _2370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2392 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2392 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2362 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2362] = 30
                                mem[_2362 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2380 + 68] = mem[idx + _2362 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2380 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2380 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2442] = 26
                                mem[_2442 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2464 + 68] = mem[idx + _2442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2464 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2464 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_1057] = _1061
                        mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _1202 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1202] = 30
                            mem[_1202 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1248 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1248 + 68] = mem[idx + _1202 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1248 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1248 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1401] = 26
                            mem[_1401 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1467 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1467 + 68] = mem[idx + _1401 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1467 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1467 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                        else:
                            _1367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1367] = 30
                            mem[_1367 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _1434 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1434 + 68] = mem[idx + _1367 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1434 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1434 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _1595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1595] = 26
                            mem[_1595 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _1643 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1643 + 68] = mem[idx + _1595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1643 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1643 + -mem[64] + 100
                            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                            else:
                                if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s
                                    continue 
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_1061 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_1057] = _1061
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _1250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1250] = 30
                                mem[_1250 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1295 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1295 + 68] = mem[idx + _1250 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1295 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1295 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _1470 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1470] = 26
                                mem[_1470 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1528 + 68] = mem[idx + _1470 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1528 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1528 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _1436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1436] = 30
                                mem[_1436 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _1502 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1502 + 68] = mem[idx + _1436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1502 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1502 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _1645 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1645] = 26
                                mem[_1645 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _1693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _1693 + 68] = mem[idx + _1645 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1693 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1693 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_1061 + 32] = stor4[address(arg1)][idx].field_0
                            t = _1061 + 32
                            u = sha3(mem[0])
                            while _1061 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1057] = _1061
                            mem[_1057 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_1057 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_1057 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_1057 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_1057 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2307] = 30
                                mem[_2307 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2315 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2315 + 68] = mem[idx + _2307 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2315 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2315 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2371 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2371] = 26
                                mem[_2371 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2394 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2394 + 68] = mem[idx + _2371 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2394 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2394 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                            else:
                                _2363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2363] = 30
                                mem[_2363 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2383 + 68] = mem[idx + _2363 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2383 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2383 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2443 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2443] = 26
                                mem[_2443 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2467 + 68] = mem[idx + _2443 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2467 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2467 + -mem[64] + 100
                                if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
                                else:
                                    if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280 <= 0:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s
                                        continue 
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    return s
}

function _cashoutAllNodesReward(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == tokenAddress:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)].field_0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'NODE: CREATIME must be higher than zero'
        idx = 0
        s = 0
        while idx < stor4[address(arg1)].field_0:
            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if block.timestamp < stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                mem[0] = sha3(address(arg1), 4)
                _2494 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    _2499 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_2499] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                    if bool(stor4[address(arg1)][idx].field_0):
                        if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                            mem[_2494] = _2499
                            mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2529] = 30
                                mem[_2529 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2545 + 68] = mem[idx + _2529 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2545 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2545 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2656] = 26
                                mem[_2656 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2715 + 68] = mem[idx + _2656 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2715 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2715 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2633] = 30
                            mem[_2633 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2685 + 68] = mem[idx + _2633 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2685 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2685 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2938] = 26
                            mem[_2938 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3024 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3024 + 68] = mem[idx + _2938 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3024 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3024 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                                mem[_2499 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2494] = _2499
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2547] = 30
                                    mem[_2547 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2572 + 68] = mem[idx + _2547 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2572 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2572 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2718] = 26
                                    mem[_2718 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2801 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2801 + 68] = mem[idx + _2718 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2801 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2801 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2687] = 30
                                mem[_2687 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2759 + 68] = mem[idx + _2687 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2759 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3026] = 26
                                mem[_3026 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3128 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3128 + 68] = mem[idx + _3026 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3128 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3128 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2499 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2499 + 32
                                u = sha3(mem[0])
                                while _2499 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2494] = _2499
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5357] = 30
                                    mem[_5357 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5369 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5369 + 68] = mem[idx + _5357 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5369 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5369 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5437] = 26
                                    mem[_5437 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5481 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5481 + 68] = mem[idx + _5437 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5481 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5481 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5425] = 30
                                mem[_5425 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5451 + 68] = mem[idx + _5425 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5451 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5451 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5585 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5585] = 26
                                mem[_5585 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5619 + 68] = mem[idx + _5585 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5619 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5619 + -mem[64] + 100
                    else:
                        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2494] = _2499
                            mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2537] = 30
                                mem[_2537 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2556 + 68] = mem[idx + _2537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2556 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2556 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2688] = 26
                                mem[_2688 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2760 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2760 + 68] = mem[idx + _2688 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2760 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2760 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2658] = 30
                            mem[_2658 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2721 + 68] = mem[idx + _2658 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2721 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2984 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2984] = 26
                            mem[_2984 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3075 + 68] = mem[idx + _2984 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3075 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3075 + -mem[64] + 100
                        else:
                            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                                mem[_2499 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2494] = _2499
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2558] = 30
                                    mem[_2558 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2594 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2594 + 68] = mem[idx + _2558 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2594 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2594 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2763] = 26
                                    mem[_2763 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2852 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2852 + 68] = mem[idx + _2763 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2852 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2852 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2723] = 30
                                mem[_2723 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2807 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2807 + 68] = mem[idx + _2723 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2807 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2807 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3077] = 26
                                mem[_3077 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3194 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3194 + 68] = mem[idx + _3077 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3194 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3194 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2499 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2499 + 32
                                u = sha3(mem[0])
                                while _2499 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2494] = _2499
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5358] = 30
                                    mem[_5358 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5370 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5370 + 68] = mem[idx + _5358 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5370 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5370 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5438] = 26
                                    mem[_5438 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5483 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5483 + 68] = mem[idx + _5438 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5483 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5483 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5426] = 30
                                mem[_5426 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5454 + 68] = mem[idx + _5426 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5454 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5454 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5586] = 26
                                mem[_5586 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5622 + 68] = mem[idx + _5586 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5622 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5622 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _2502 = mem[64]
                    mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                    mem[_2502] = stor4[address(arg1)][idx].field_1 % 128
                    if bool(stor4[address(arg1)][idx].field_0):
                        if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                            mem[_2494] = _2502
                            mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2539 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2539] = 30
                                mem[_2539 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2559 + 68] = mem[idx + _2539 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2559 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2559 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2690 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2690] = 26
                                mem[_2690 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2764 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2764 + 68] = mem[idx + _2690 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2764 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2764 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2661] = 30
                            mem[_2661 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2726 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2726 + 68] = mem[idx + _2661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2726 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2726 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2987] = 26
                            mem[_2987 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3080 + 68] = mem[idx + _2987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3080 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3080 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                                mem[_2502 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2494] = _2502
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2561 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2561] = 30
                                    mem[_2561 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2596 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2596 + 68] = mem[idx + _2561 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2596 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2596 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2767] = 26
                                    mem[_2767 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2855 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2855 + 68] = mem[idx + _2767 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2855 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2855 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2728] = 30
                                mem[_2728 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2812 + 68] = mem[idx + _2728 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2812 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3082] = 26
                                mem[_3082 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3198 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3198 + 68] = mem[idx + _3082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3198 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3198 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2502 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2502 + 32
                                u = sha3(mem[0])
                                while _2502 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2494] = _2502
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5359] = 30
                                    mem[_5359 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5371 + 68] = mem[idx + _5359 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5371 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5371 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5439] = 26
                                    mem[_5439 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5485 + 68] = mem[idx + _5439 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5485 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5485 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5427] = 30
                                mem[_5427 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5457 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5457 + 68] = mem[idx + _5427 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5457 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5457 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5587] = 26
                                mem[_5587 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5625 + 68] = mem[idx + _5587 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5625 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5625 + -mem[64] + 100
                    else:
                        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2494] = _2502
                            mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2548 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2548] = 30
                                mem[_2548 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2575 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2575 + 68] = mem[idx + _2548 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2575 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2575 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2729] = 26
                                mem[_2729 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2813 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2813 + 68] = mem[idx + _2729 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2813 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2813 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2692] = 30
                            mem[_2692 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2770 + 68] = mem[idx + _2692 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2770 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3033] = 26
                            mem[_3033 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3139 + 68] = mem[idx + _3033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3139 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3139 + -mem[64] + 100
                        else:
                            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                                mem[_2502 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2494] = _2502
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2577] = 30
                                    mem[_2577 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2619 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2619 + 68] = mem[idx + _2577 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2619 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2619 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2816] = 26
                                    mem[_2816 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2906 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2906 + 68] = mem[idx + _2816 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2906 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2906 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2772] = 30
                                mem[_2772 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2861 + 68] = mem[idx + _2772 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2861 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3141] = 26
                                mem[_3141 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3269 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3269 + 68] = mem[idx + _3141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3269 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3269 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2502 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2502 + 32
                                u = sha3(mem[0])
                                while _2502 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2494] = _2502
                                mem[_2494 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2494 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2494 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2494 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2494 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5360] = 30
                                    mem[_5360 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5372 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5372 + 68] = mem[idx + _5360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5372 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5372 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5440] = 26
                                    mem[_5440 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5487 + 68] = mem[idx + _5440 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5487 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5487 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5428] = 30
                                mem[_5428 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5460 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5460 + 68] = mem[idx + _5428 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5460 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5460 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5588] = 26
                                mem[_5588 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5628 + 68] = mem[idx + _5588 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5628 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5628 + -mem[64] + 100
                ('stor', ('name', 'claimTime', 7))
                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                    revert with 0, 17
                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                    revert with 0, 'SafeMath: addition overflow'
                if not rewardPerNode:
                    if 0 > !stor4[address(arg1)][idx].field_1280:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_1280 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s > !stor4[address(arg1)][idx].field_1280:
                        revert with 0, 17
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    stor4[address(arg1)][idx].field_512 = block.timestamp
                    mem[0] = sha3(address(arg1), 4)
                    stor4[address(arg1)][idx].field_1280 = 0
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + stor4[address(arg1)][idx].field_1280
                    continue 
                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                    revert with 0, 17
                if not rewardPerNode:
                    revert with 0, 18
                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                    revert with 0, 'SafeMath: multiplication overflow'
                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if stor4[address(arg1)][idx].field_1280 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !(rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_1280 = 0
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
                continue 
            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                if s > -1:
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_1280 = 0
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 4)
            _2506 = mem[64]
            mem[64] = mem[64] + 192
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                _2513 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_2513] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_2506] = _2513
                        mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2711] = 30
                            mem[_2711 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2795 + 68] = mem[idx + _2711 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2795 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2795 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3059 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3059] = 26
                            mem[_3059 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3171 + 68] = mem[idx + _3059 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3171 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3171 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3013] = 30
                        mem[_3013 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3115 + 68] = mem[idx + _3013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3115 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3115 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3475] = 26
                        mem[_3475 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3567 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3567 + 68] = mem[idx + _3475 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3567 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3567 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_2513 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2506] = _2513
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2797] = 30
                                mem[_2797 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2886 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2886 + 68] = mem[idx + _2797 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2886 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2886 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3174] = 26
                                mem[_3174 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3306 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3306 + 68] = mem[idx + _3174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3306 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3306 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3117 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3117] = 30
                            mem[_3117 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3239 + 68] = mem[idx + _3117 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3239 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3239 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3569] = 26
                            mem[_3569 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3658 + 68] = mem[idx + _3569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3658 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3658 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2513 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2513 + 32
                            u = sha3(mem[0])
                            while _2513 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2506] = _2513
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5389 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5389] = 30
                                mem[_5389 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5405 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5405 + 68] = mem[idx + _5389 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5405 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5405 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5517 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5517] = 26
                                mem[_5517 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5557 + 68] = mem[idx + _5517 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5557 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5557 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5501] = 30
                            mem[_5501 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5527 + 68] = mem[idx + _5501 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5527 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5527 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5661] = 26
                            mem[_5661 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5695 + 68] = mem[idx + _5661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5695 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5695 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_2506] = _2513
                        mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2751] = 30
                            mem[_2751 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2840 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2840 + 68] = mem[idx + _2751 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2840 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2840 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3118 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3118] = 26
                            mem[_3118 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3240 + 68] = mem[idx + _3118 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3240 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3240 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3061] = 30
                        mem[_3061 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3177 + 68] = mem[idx + _3061 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3177 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3526] = 26
                        mem[_3526 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3613 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3613 + 68] = mem[idx + _3526 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3613 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3613 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2513 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2506] = _2513
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2842] = 30
                                mem[_2842 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2934 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2934 + 68] = mem[idx + _2842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2934 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2934 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3243] = 26
                                mem[_3243 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3377 + 68] = mem[idx + _3243 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3377 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3377 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3179] = 30
                            mem[_3179 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3312 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3312 + 68] = mem[idx + _3179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3312 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3312 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3615] = 26
                            mem[_3615 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3712 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3712 + 68] = mem[idx + _3615 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3712 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3712 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2513 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2513 + 32
                            u = sha3(mem[0])
                            while _2513 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2506] = _2513
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5390] = 30
                                mem[_5390 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5406 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5406 + 68] = mem[idx + _5390 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5406 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5406 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5518] = 26
                                mem[_5518 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5559 + 68] = mem[idx + _5518 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5559 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5559 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5502 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5502] = 30
                            mem[_5502 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5530 + 68] = mem[idx + _5502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5530 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5530 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5662] = 26
                            mem[_5662 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5698 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5698 + 68] = mem[idx + _5662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5698 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5698 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                _2519 = mem[64]
                mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                mem[_2519] = stor4[address(arg1)][idx].field_1 % 128
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_2506] = _2519
                        mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2753 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2753] = 30
                            mem[_2753 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2843 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2843 + 68] = mem[idx + _2753 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2843 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2843 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3120 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3120] = 26
                            mem[_3120 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3244 + 68] = mem[idx + _3120 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3244 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3244 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3064 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3064] = 30
                        mem[_3064 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3182 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3182 + 68] = mem[idx + _3064 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3182 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3182 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3529 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3529] = 26
                        mem[_3529 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3618 + 68] = mem[idx + _3529 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3618 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3618 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_2519 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2506] = _2519
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2845 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2845] = 30
                                mem[_2845 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2936 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2936 + 68] = mem[idx + _2845 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2936 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2936 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3247] = 26
                                mem[_3247 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3380 + 68] = mem[idx + _3247 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3380 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3380 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3184 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3184] = 30
                            mem[_3184 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3317 + 68] = mem[idx + _3184 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3317 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3317 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3620 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3620] = 26
                            mem[_3620 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3716 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3716 + 68] = mem[idx + _3620 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3716 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3716 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2519 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2519 + 32
                            u = sha3(mem[0])
                            while _2519 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2506] = _2519
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5391] = 30
                                mem[_5391 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5407 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5407 + 68] = mem[idx + _5391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5407 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5407 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5519 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5519] = 26
                                mem[_5519 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5561 + 68] = mem[idx + _5519 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5561 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5561 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5503] = 30
                            mem[_5503 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5533 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5533 + 68] = mem[idx + _5503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5533 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5533 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5663] = 26
                            mem[_5663 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5701 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5701 + 68] = mem[idx + _5663 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5701 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5701 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_2506] = _2519
                        mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2798] = 30
                            mem[_2798 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2889 + 68] = mem[idx + _2798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2889 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2889 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3185] = 26
                            mem[_3185 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3318 + 68] = mem[idx + _3185 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3318 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3318 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3122 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3122] = 30
                        mem[_3122 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3250 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3250 + 68] = mem[idx + _3122 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3250 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3250 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3576 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3576] = 26
                        mem[_3576 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3669 + 68] = mem[idx + _3576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3669 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3669 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2519 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2506] = _2519
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2891 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2891] = 30
                                mem[_2891 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2980 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2980 + 68] = mem[idx + _2891 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2980 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2980 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3321] = 26
                                mem[_3321 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3439 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3439 + 68] = mem[idx + _3321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3439 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3439 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3252 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3252] = 30
                            mem[_3252 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3386 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3386 + 68] = mem[idx + _3252 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3386 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3386 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3671] = 26
                            mem[_3671 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3767 + 68] = mem[idx + _3671 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3767 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3767 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2519 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2519 + 32
                            u = sha3(mem[0])
                            while _2519 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2506] = _2519
                            mem[_2506 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2506 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2506 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2506 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2506 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5392] = 30
                                mem[_5392 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5408 + 68] = mem[idx + _5392 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5408 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5408 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5520 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5520] = 26
                                mem[_5520 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5563 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5563 + 68] = mem[idx + _5520 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5563 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5563 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5504] = 30
                            mem[_5504 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5536 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5536 + 68] = mem[idx + _5504 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5536 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5536 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5664] = 26
                            mem[_5664 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5704 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5704 + 68] = mem[idx + _5664 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5704 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5704 + -mem[64] + 100
            ('stor', ('name', 'claimTime', 7))
            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                revert with 0, 17
            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                revert with 0, 'SafeMath: addition overflow'
            if not rewardPerNode:
                if 0 > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if stor4[address(arg1)][idx].field_1280 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_1280 = 0
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + stor4[address(arg1)][idx].field_1280
                continue 
            if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                revert with 0, 17
            if not rewardPerNode:
                revert with 0, 18
            if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                revert with 0, 'SafeMath: multiplication overflow'
            if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if stor4[address(arg1)][idx].field_1280 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !(rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            stor4[address(arg1)][idx].field_1280 = 0
            mem[0] = sha3(address(arg1), 4)
            stor4[address(arg1)][idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
            continue 
    else:
        if gateKeeperAddress != msg.sender:
            revert with 0, 'NOT AUTHORIZED'
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)].field_0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'NODE: CREATIME must be higher than zero'
        idx = 0
        s = 0
        while idx < stor4[address(arg1)].field_0:
            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if block.timestamp < stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                mem[0] = sha3(address(arg1), 4)
                _2496 = mem[64]
                mem[64] = mem[64] + 192
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    _2500 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_2500] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                    if bool(stor4[address(arg1)][idx].field_0):
                        if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                            mem[_2496] = _2500
                            mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2533] = 30
                                mem[_2533 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2550 + 68] = mem[idx + _2533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2550 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2550 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2669] = 26
                                mem[_2669 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2735 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2735 + 68] = mem[idx + _2669 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2735 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2735 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2644] = 30
                            mem[_2644 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2701 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2701 + 68] = mem[idx + _2644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2701 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2701 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2959] = 26
                            mem[_2959 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3047 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3047 + 68] = mem[idx + _2959 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3047 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3047 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                                mem[_2500 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2496] = _2500
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2552] = 30
                                    mem[_2552 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2581 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2581 + 68] = mem[idx + _2552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2581 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2581 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2738] = 26
                                    mem[_2738 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2823 + 68] = mem[idx + _2738 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2823 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2823 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2703 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2703] = 30
                                mem[_2703 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2781 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2781 + 68] = mem[idx + _2703 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2781 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2781 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3049] = 26
                                mem[_3049 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3157 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3157 + 68] = mem[idx + _3049 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3157 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3157 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2500 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2500 + 32
                                u = sha3(mem[0])
                                while _2500 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2496] = _2500
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5361] = 30
                                    mem[_5361 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5377 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5377 + 68] = mem[idx + _5361 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5377 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5377 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5441] = 26
                                    mem[_5441 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5493 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5493 + 68] = mem[idx + _5441 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5493 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5493 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5433] = 30
                                mem[_5433 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5467 + 68] = mem[idx + _5433 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5467 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5467 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5593 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5593] = 26
                                mem[_5593 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5635 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5635 + 68] = mem[idx + _5593 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5635 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5635 + -mem[64] + 100
                    else:
                        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2496] = _2500
                            mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2541 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2541] = 30
                                mem[_2541 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2563 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2563 + 68] = mem[idx + _2541 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2563 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2563 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2704 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2704] = 26
                                mem[_2704 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2782 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2782 + 68] = mem[idx + _2704 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2782 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2782 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2671] = 30
                            mem[_2671 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2741 + 68] = mem[idx + _2671 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2741 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2741 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3004 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3004] = 26
                            mem[_3004 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3102 + 68] = mem[idx + _3004 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3102 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3102 + -mem[64] + 100
                        else:
                            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                                mem[_2500 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2496] = _2500
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2565] = 30
                                    mem[_2565 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2605 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2605 + 68] = mem[idx + _2565 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2605 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2605 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2785 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2785] = 26
                                    mem[_2785 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2875 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2875 + 68] = mem[idx + _2785 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2875 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2875 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2743] = 30
                                mem[_2743 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2829 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2829 + 68] = mem[idx + _2743 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2829 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2829 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3104] = 26
                                mem[_3104 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3226 + 68] = mem[idx + _3104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3226 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3226 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2500 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2500 + 32
                                u = sha3(mem[0])
                                while _2500 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2496] = _2500
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5362] = 30
                                    mem[_5362 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5378 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5378 + 68] = mem[idx + _5362 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5378 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5378 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5442] = 26
                                    mem[_5442 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5495 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5495 + 68] = mem[idx + _5442 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5495 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5495 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5434] = 30
                                mem[_5434 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5470 + 68] = mem[idx + _5434 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5470 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5470 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5594] = 26
                                mem[_5594 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5638 + 68] = mem[idx + _5594 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5638 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5638 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    _2504 = mem[64]
                    mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                    mem[_2504] = stor4[address(arg1)][idx].field_1 % 128
                    if bool(stor4[address(arg1)][idx].field_0):
                        if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                            mem[_2496] = _2504
                            mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2543] = 30
                                mem[_2543 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2566 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2566 + 68] = mem[idx + _2543 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2566 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2566 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2706] = 26
                                mem[_2706 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2786 + 68] = mem[idx + _2706 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2786 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2786 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2674 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2674] = 30
                            mem[_2674 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2746 + 68] = mem[idx + _2674 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2746 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2746 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3007] = 26
                            mem[_3007 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3107 + 68] = mem[idx + _3007 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3107 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3107 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                                mem[_2504 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2496] = _2504
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2568 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2568] = 30
                                    mem[_2568 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2607 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2607 + 68] = mem[idx + _2568 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2607 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2607 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2789] = 26
                                    mem[_2789 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2878 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2878 + 68] = mem[idx + _2789 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2878 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2878 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2748] = 30
                                mem[_2748 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2834 + 68] = mem[idx + _2748 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2834 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2834 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3109 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3109] = 26
                                mem[_3109 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3230 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3230 + 68] = mem[idx + _3109 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3230 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3230 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2504 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2504 + 32
                                u = sha3(mem[0])
                                while _2504 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2496] = _2504
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5363] = 30
                                    mem[_5363 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5379 + 68] = mem[idx + _5363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5379 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5379 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5443] = 26
                                    mem[_5443 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5497 + 68] = mem[idx + _5443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5497 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5497 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5435] = 30
                                mem[_5435 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5473 + 68] = mem[idx + _5435 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5473 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5473 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5595] = 26
                                mem[_5595 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5641 + 68] = mem[idx + _5595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5641 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5641 + -mem[64] + 100
                    else:
                        if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2496] = _2504
                            mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                            if stor4[address(arg1)][idx].field_512:
                                _2553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2553] = 30
                                mem[_2553 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                    _2584 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2584 + 68] = mem[idx + _2553 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2584 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2584 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2749 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2749] = 26
                                mem[_2749 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _2835 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2835 + 68] = mem[idx + _2749 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2835 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2835 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_1280 = 0
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _2708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2708] = 30
                            mem[_2708 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                _2792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2792 + 68] = mem[idx + _2708 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2792 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2792 + -mem[64] + 100
                            if block.timestamp < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3056] = 26
                            mem[_3056 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3168 + 68] = mem[idx + _3056 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3168 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3168 + -mem[64] + 100
                        else:
                            if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                                mem[_2504 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                                mem[_2496] = _2504
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _2586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2586] = 30
                                    mem[_2586 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _2630 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _2630 + 68] = mem[idx + _2586 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2630 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2630 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2838 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2838] = 26
                                    mem[_2838 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _2929 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2929 + 68] = mem[idx + _2838 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2929 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2929 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _2794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2794] = 30
                                mem[_2794 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _2884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2884 + 68] = mem[idx + _2794 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2884 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2884 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _3170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3170] = 26
                                mem[_3170 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3304 + 68] = mem[idx + _3170 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3304 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3304 + -mem[64] + 100
                            else:
                                mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                                mem[_2504 + 32] = stor4[address(arg1)][idx].field_0
                                t = _2504 + 32
                                u = sha3(mem[0])
                                while _2504 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                    mem[t + 32] = stor1[u]
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_2496] = _2504
                                mem[_2496 + 32] = stor4[address(arg1)][idx].field_256
                                mem[_2496 + 64] = stor4[address(arg1)][idx].field_512
                                mem[_2496 + 96] = stor4[address(arg1)][idx].field_768
                                mem[_2496 + 128] = stor4[address(arg1)][idx].field_1024
                                mem[_2496 + 160] = stor4[address(arg1)][idx].field_1280
                                if stor4[address(arg1)][idx].field_512:
                                    _5364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5364] = 30
                                    mem[_5364 + 32] = 'SafeMath: subtraction overflow'
                                    if stor4[address(arg1)][idx].field_512 > block.timestamp:
                                        _5380 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _5380 + 68] = mem[idx + _5364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5380 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5380 + -mem[64] + 100
                                    if block.timestamp < stor4[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _5444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5444] = 26
                                    mem[_5444 + 32] = 'SafeMath: division by zero' << 48
                                    if not claimTime:
                                        _5499 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _5499 + 68] = mem[idx + _5444 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_5499 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _5499 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not rewardPerNode:
                                        if 0 > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if stor4[address(arg1)][idx].field_1280 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor4[address(arg1)][idx].field_1280:
                                            revert with 0, 17
                                        if idx >= stor4[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor4[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 4)
                                        stor4[address(arg1)][idx].field_1280 = 0
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor4[address(arg1)][idx].field_1280
                                        continue 
                                    if rewardPerNode and block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                    continue 
                                _5436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5436] = 30
                                mem[_5436 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_256 > block.timestamp:
                                    _5476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5476 + 68] = mem[idx + _5436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5476 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5476 + -mem[64] + 100
                                if block.timestamp < stor4[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _5596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5596] = 26
                                mem[_5596 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5644 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5644 + 68] = mem[idx + _5596 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5644 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5644 + -mem[64] + 100
                ('stor', ('name', 'claimTime', 7))
                if 1 > !(block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime):
                    revert with 0, 17
                if (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                    revert with 0, 'SafeMath: addition overflow'
                if not rewardPerNode:
                    if 0 > !stor4[address(arg1)][idx].field_1280:
                        revert with 0, 17
                    if stor4[address(arg1)][idx].field_1280 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s > !stor4[address(arg1)][idx].field_1280:
                        revert with 0, 17
                    if idx >= stor4[address(arg1)].field_0:
                        revert with 0, 50
                    stor4[address(arg1)][idx].field_512 = block.timestamp
                    mem[0] = sha3(address(arg1), 4)
                    stor4[address(arg1)][idx].field_1280 = 0
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + stor4[address(arg1)][idx].field_1280
                    continue 
                if rewardPerNode and (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                    revert with 0, 17
                if not rewardPerNode:
                    revert with 0, 18
                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                    revert with 0, 'SafeMath: multiplication overflow'
                if rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if stor4[address(arg1)][idx].field_1280 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !(rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_1280 = 0
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
                continue 
            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                if s > -1:
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_1280 = 0
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 4)
            _2508 = mem[64]
            mem[64] = mem[64] + 192
            if bool(stor4[address(arg1)][idx].field_0):
                if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                    revert with 0, 34
                _2516 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor4[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_2516] = uint255(stor4[address(arg1)][idx].field_0) * 0.5
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_2508] = _2516
                        mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2731] = 30
                            mem[_2731 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2817 + 68] = mem[idx + _2731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2817 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2817 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3086] = 26
                            mem[_3086 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3203 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3203 + 68] = mem[idx + _3086 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3203 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3203 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3036] = 30
                        mem[_3036 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3144 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3144 + 68] = mem[idx + _3036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3144 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3144 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3499] = 26
                        mem[_3499 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3588 + 68] = mem[idx + _3499 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3588 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3588 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_2516 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2508] = _2516
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2819] = 30
                                mem[_2819 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2909 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2909 + 68] = mem[idx + _2819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2909 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2909 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3206] = 26
                                mem[_3206 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3339 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3339 + 68] = mem[idx + _3206 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3339 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3339 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3146 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3146] = 30
                            mem[_3146 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3274 + 68] = mem[idx + _3146 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3274 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3274 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3590] = 26
                            mem[_3590 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3683 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3683 + 68] = mem[idx + _3590 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3683 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3683 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2516 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2516 + 32
                            u = sha3(mem[0])
                            while _2516 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2508] = _2516
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5393] = 30
                                mem[_5393 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5413 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5413 + 68] = mem[idx + _5393 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5413 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5413 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5521 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5521] = 26
                                mem[_5521 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5569 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5569 + 68] = mem[idx + _5521 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5569 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5569 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5509] = 30
                            mem[_5509 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5543 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5543 + 68] = mem[idx + _5509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5543 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5543 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5665] = 26
                            mem[_5665 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5715 + 68] = mem[idx + _5665 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5715 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5715 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_2508] = _2516
                        mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2773] = 30
                            mem[_2773 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2863 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2863 + 68] = mem[idx + _2773 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2863 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2863 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3147] = 26
                            mem[_3147 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3275 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3275 + 68] = mem[idx + _3147 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3275 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3275 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3088] = 30
                        mem[_3088 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3209 + 68] = mem[idx + _3088 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3209 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3209 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3547 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3547] = 26
                        mem[_3547 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3637 + 68] = mem[idx + _3547 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3637 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3637 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2516 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2508] = _2516
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2865 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2865] = 30
                                mem[_2865 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2955 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2955 + 68] = mem[idx + _2865 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2955 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2955 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3278 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3278] = 26
                                mem[_3278 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3404 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3404 + 68] = mem[idx + _3278 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3404 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3404 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3211] = 30
                            mem[_3211 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3345 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3345 + 68] = mem[idx + _3211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3345 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3345 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3639] = 26
                            mem[_3639 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3735 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3735 + 68] = mem[idx + _3639 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3735 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3735 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2516 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2516 + 32
                            u = sha3(mem[0])
                            while _2516 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2508] = _2516
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5394] = 30
                                mem[_5394 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5414 + 68] = mem[idx + _5394 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5414 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5414 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5522] = 26
                                mem[_5522 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5571 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5571 + 68] = mem[idx + _5522 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5571 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5571 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5510 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5510] = 30
                            mem[_5510 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5546 + 68] = mem[idx + _5510 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5546 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5546 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5666] = 26
                            mem[_5666 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5718 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5718 + 68] = mem[idx + _5666 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5718 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5718 + -mem[64] + 100
            else:
                if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                    revert with 0, 34
                _2524 = mem[64]
                mem[64] = mem[64] + ceil32(stor4[address(arg1)][idx].field_1 % 128) + 32
                mem[_2524] = stor4[address(arg1)][idx].field_1 % 128
                if bool(stor4[address(arg1)][idx].field_0):
                    if bool(stor4[address(arg1)][idx].field_0) == uint255(stor4[address(arg1)][idx].field_0) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor4[address(arg1)][idx].field_0):
                        mem[_2508] = _2524
                        mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2775 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2775] = 30
                            mem[_2775 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2866 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2866 + 68] = mem[idx + _2775 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2866 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2866 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3149] = 26
                            mem[_3149 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3279 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3279 + 68] = mem[idx + _3149 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3279 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3279 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3091 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3091] = 30
                        mem[_3091 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3214 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3214 + 68] = mem[idx + _3091 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3214 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3214 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3550] = 26
                        mem[_3550 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3642 + 68] = mem[idx + _3550 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3642 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3642 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor4[address(arg1)][idx].field_0) * 0.5:
                            mem[_2524 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2508] = _2524
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2868 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2868] = 30
                                mem[_2868 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _2957 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2957 + 68] = mem[idx + _2868 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2957 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2957 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3282] = 26
                                mem[_3282 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3407 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3407 + 68] = mem[idx + _3282 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3407 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3407 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3216] = 30
                            mem[_3216 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3350 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3350 + 68] = mem[idx + _3216 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3350 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3350 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3644] = 26
                            mem[_3644 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3739 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3739 + 68] = mem[idx + _3644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3739 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3739 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2524 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2524 + 32
                            u = sha3(mem[0])
                            while _2524 + (uint255(stor4[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2508] = _2524
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5395 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5395] = 30
                                mem[_5395 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5415 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5415 + 68] = mem[idx + _5395 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5415 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5415 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5523] = 26
                                mem[_5523 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5573 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5573 + 68] = mem[idx + _5523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5573 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5573 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5511] = 30
                            mem[_5511 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5549 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5549 + 68] = mem[idx + _5511 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5549 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5549 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5667 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5667] = 26
                            mem[_5667 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5721 + 68] = mem[idx + _5667 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5721 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5721 + -mem[64] + 100
                else:
                    if bool(stor4[address(arg1)][idx].field_0) == stor4[address(arg1)][idx].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor4[address(arg1)][idx].field_1 % 128:
                        mem[_2508] = _2524
                        mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                        mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                        mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                        mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                        mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                        if idx >= stor4[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 4)
                        if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                            revert with 0, 17
                        if stor4[address(arg1)][idx].field_512:
                            _2820 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2820] = 30
                            mem[_2820 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _2912 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2912 + 68] = mem[idx + _2820 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2912 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2912 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _3217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3217] = 26
                            mem[_3217 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3351 + 68] = mem[idx + _3217 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3351 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3351 + -mem[64] + 100
                            if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not rewardPerNode:
                                if 0 > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_1280 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor4[address(arg1)][idx].field_1280
                                continue 
                            if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                revert with 0, 17
                            if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                revert with 0, 17
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            stor4[address(arg1)][idx].field_1280 = 0
                            mem[0] = sha3(address(arg1), 4)
                            stor4[address(arg1)][idx].field_512 = block.timestamp
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                            continue 
                        _3151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3151] = 30
                        mem[_3151 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                            _3285 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _3285 + 68] = mem[idx + _3151 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3285 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _3285 + -mem[64] + 100
                        if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _3597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3597] = 26
                        mem[_3597 + 32] = 'SafeMath: division by zero' << 48
                        if not claimTime:
                            _3694 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3694 + 68] = mem[idx + _3597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_3694 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3694 + -mem[64] + 100
                    else:
                        if 31 >= stor4[address(arg1)][idx].field_1 % 128:
                            mem[_2524 + 32] = 256 * Mask(248, 0, stor4[address(arg1)][idx].field_8)
                            mem[_2508] = _2524
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _2914 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2914] = 30
                                mem[_2914 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _3000 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3000 + 68] = mem[idx + _2914 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3000 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3000 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _3354 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3354] = 26
                                mem[_3354 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _3464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _3464 + 68] = mem[idx + _3354 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3464 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3464 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _3287 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3287] = 30
                            mem[_3287 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _3413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _3413 + 68] = mem[idx + _3287 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3413 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _3413 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _3696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3696] = 26
                            mem[_3696 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _3792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _3792 + 68] = mem[idx + _3696 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3792 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3792 + -mem[64] + 100
                        else:
                            mem[0] = (6 * idx) + sha3(sha3(address(arg1), 4))
                            mem[_2524 + 32] = stor4[address(arg1)][idx].field_0
                            t = _2524 + 32
                            u = sha3(mem[0])
                            while _2524 + stor4[address(arg1)][idx].field_1 % 128 > t:
                                mem[t + 32] = stor1[u]
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_2508] = _2524
                            mem[_2508 + 32] = stor4[address(arg1)][idx].field_256
                            mem[_2508 + 64] = stor4[address(arg1)][idx].field_512
                            mem[_2508 + 96] = stor4[address(arg1)][idx].field_768
                            mem[_2508 + 128] = stor4[address(arg1)][idx].field_1024
                            mem[_2508 + 160] = stor4[address(arg1)][idx].field_1280
                            if idx >= stor4[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 4)
                            if stor4[address(arg1)][idx].field_768 > !sub_666c8c6d:
                                revert with 0, 17
                            if stor4[address(arg1)][idx].field_512:
                                _5396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5396] = 30
                                mem[_5396 + 32] = 'SafeMath: subtraction overflow'
                                if stor4[address(arg1)][idx].field_512 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                    _5416 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _5416 + 68] = mem[idx + _5396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5416 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5416 + -mem[64] + 100
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _5524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5524] = 26
                                mem[_5524 + 32] = 'SafeMath: division by zero' << 48
                                if not claimTime:
                                    _5575 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _5575 + 68] = mem[idx + _5524 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_5575 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _5575 + -mem[64] + 100
                                if 0 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not rewardPerNode:
                                    if 0 > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if stor4[address(arg1)][idx].field_1280 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor4[address(arg1)][idx].field_1280:
                                        revert with 0, 17
                                    if idx >= stor4[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor4[address(arg1)][idx].field_1280 = 0
                                    mem[0] = sha3(address(arg1), 4)
                                    stor4[address(arg1)][idx].field_512 = block.timestamp
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor4[address(arg1)][idx].field_1280
                                    continue 
                                if rewardPerNode and stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime / rewardPerNode != stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime > !stor4[address(arg1)][idx].field_1280:
                                    revert with 0, 17
                                if (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280 < rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280):
                                    revert with 0, 17
                                if idx >= stor4[address(arg1)].field_0:
                                    revert with 0, 50
                                stor4[address(arg1)][idx].field_1280 = 0
                                mem[0] = sha3(address(arg1), 4)
                                stor4[address(arg1)][idx].field_512 = block.timestamp
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_512 / claimTime) + stor4[address(arg1)][idx].field_1280
                                continue 
                            _5512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5512] = 30
                            mem[_5512 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[address(arg1)][idx].field_256 > stor4[address(arg1)][idx].field_768 + sub_666c8c6d:
                                _5552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _5552 + 68] = mem[idx + _5512 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5552 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _5552 + -mem[64] + 100
                            if stor4[address(arg1)][idx].field_768 + sub_666c8c6d < stor4[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _5668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5668] = 26
                            mem[_5668 + 32] = 'SafeMath: division by zero' << 48
                            if not claimTime:
                                _5724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5724 + 68] = mem[idx + _5668 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5724 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5724 + -mem[64] + 100
            ('stor', ('name', 'claimTime', 7))
            if 1 > !(stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime):
                revert with 0, 17
            if (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                revert with 0, 'SafeMath: addition overflow'
            if not rewardPerNode:
                if 0 > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if stor4[address(arg1)][idx].field_1280 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !stor4[address(arg1)][idx].field_1280:
                    revert with 0, 17
                if idx >= stor4[address(arg1)].field_0:
                    revert with 0, 50
                stor4[address(arg1)][idx].field_1280 = 0
                mem[0] = sha3(address(arg1), 4)
                stor4[address(arg1)][idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + stor4[address(arg1)][idx].field_1280
                continue 
            if rewardPerNode and (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                revert with 0, 17
            if not rewardPerNode:
                revert with 0, 18
            if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime) + 1:
                revert with 0, 'SafeMath: multiplication overflow'
            if rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor4[address(arg1)][idx].field_1280:
                revert with 0, 17
            if stor4[address(arg1)][idx].field_1280 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !(rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280):
                revert with 0, 17
            if idx >= stor4[address(arg1)].field_0:
                revert with 0, 50
            stor4[address(arg1)][idx].field_1280 = 0
            mem[0] = sha3(address(arg1), 4)
            stor4[address(arg1)][idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (stor4[address(arg1)][idx].field_768 + sub_666c8c6d - stor4[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor4[address(arg1)][idx].field_1280
            continue 
    if totalRewardStaked > !s:
        revert with 0, 17
    totalRewardStaked += s
    return s
}



}

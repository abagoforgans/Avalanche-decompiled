contract main {




// =====================  Runtime code  =====================


uint256 stor0;
mapping of uint8 stor1;

function _fallback() payable {
    revert
}

function sub_665166c8(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[64] = (32 * uint256(stor1[arg1])) + 128
    mem[96] = uint256(stor1[arg1])
    if not uint256(stor1[arg1]):
        mem[(32 * uint256(stor1[arg1])) + 128] = 32
        mem[(32 * uint256(stor1[arg1])) + 160] = uint256(stor1[arg1])
        idx = 0
        s = 128
        t = (32 * uint256(stor1[arg1])) + 192
        while idx < uint256(stor1[arg1]):
            mem[t] = mem[s + 31 len 1]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * uint256(stor1[arg1])) + 128
           len (96 * uint256(stor1[arg1])) + 64
    mem[128] = uint8(stor1[arg1])
    idx = 128
    s = 0
    while (32 * uint256(stor1[arg1])) + 96 > idx:
        mem[idx + 32] = stor('map', ('param', 'arg1'), ('name', 'stor1', 1))[-(0.03125 / s + 1) + s + (-1 * 0.03125 / s + 1 * s) + 1]
        idx = idx + 32
        s = -(s + 1 / 32) + s + (-1 * s + 1 / 32 * s) + 1
        continue 
    mem[(32 * uint256(stor1[arg1])) + 128] = 32
    mem[(32 * uint256(stor1[arg1])) + 160] = uint256(stor1[arg1])
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < uint256(stor1[arg1]):
        mem[t] = mem[s + 31 len 1]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * uint256(stor1[arg1])) + -mem[64] + 192
}

function sub_59598a2a(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 'NH{q', 65
    if floor32(('cd', 4).length) + 97 > test266151307() or floor32(('cd', 4).length) + 97 < 96:
        revert with 'NH{q', 65
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == uint8(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if stor0 > -2:
        revert with 'NH{q', 17
    stor0++
    uint256(stor1[stor0]) = ('cd', 4).length
    if not ('cd', 4).length:
        idx = 0
        while uint256(stor1[stor0]) + 31 / 32 > idx:
            uint256(stor1[stor0][idx]) = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 128
        while (32 * ('cd', 4).length) + 128 > idx:
            uint256(stor1[stor0]) = mem[idx + 31 len 1] * 256^s or !(255 * 256^s) and uint256(stor1[stor0])
            s = s + -(s + 1 / 32) + (-1 * s * s + 1 / 32) + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5
        s = sha3(sha3(stor0, 1))
        while idx:
            stor[s] = !(255 * 256^idx) and stor[s]
            idx = idx + -(idx + 1 / 32) + (-1 * idx * idx + 1 / 32) + 1
            s = (idx + 1 / 32) + s
            continue 
        idx = (floor32(None + 3) >> 4) + (None * None + 3 / 32) - (Mask(251, 0, (32 * ('cd', 4).length) + 31) >> 5 * None + 3 / 32)
        while uint256(stor1[stor0]) + 31 / 32 > idx:
            uint256(stor1[stor0][idx]) = 0
            idx = idx + 1
            continue 
    emit 0xe1c7c98c: stor0
    return stor0
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1)
#
uint8 stor0;
uint8 stor0; offset 8
uint256 stor0; offset 8
address owner;
address joeAddress;
uint256 sub_a090a2b4;
array of address rewardTokens;
mapping of uint8 stor104;
mapping of uint256 sub_5fc0d9e0;
address feeCollectorAddress;
uint256 depositFeePercent;
uint256 sub_a610708a;
mapping of uint256 sub_5dcea4d4;
uint256 sub_3c97d5ae;
mapping of struct userInfo;

function sub_3c97d5ae(?) payable {
    return sub_3c97d5ae
}

function sub_5dcea4d4(?) payable {
    require calldata.size - 4 >= 32
    return sub_5dcea4d4[arg1]
}

function sub_5fc0d9e0(?) payable {
    require calldata.size - 4 >= 32
    return sub_5fc0d9e0[arg1]
}

function rewardTokens(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < rewardTokens.length
    return rewardTokens[arg1]
}

function owner() payable {
    return owner
}

function sub_a090a2b4(?) payable {
    return sub_a090a2b4
}

function sub_a610708a(?) payable {
    return sub_a610708a
}

function isRewardToken(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor104[arg1])
}

function joe() payable {
    return joeAddress
}

function rewardTokensLength() payable {
    return rewardTokens.length
}

function feeCollector() payable {
    return feeCollectorAddress
}

function depositFeePercent() payable {
    return depositFeePercent
}

function getUserInfo(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[address(arg1)].field_0, userInfo[address(arg1)][1][address(arg2)].field_0
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x674f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setDepositFeePercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 5 * 10^17:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    55,
                    0x6e537461626c654a6f655374616b696e673a206465706f736974206665652063616e27742062652067726561746572207468616e203530,
                    mem[219 len 9]
    depositFeePercent = arg1
    emit 0x6be5411e: arg1, depositFeePercent
}

function emergencyWithdraw() payable {
    userInfo[address(msg.sender)].field_0 = 0
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = rewardTokens[idx]
        mem[32] = sha3(address(msg.sender), 111) + 1
        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0
        idx = idx + 1
        continue 
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if ext_code.size(joeAddress) <= 0:
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[address(msg.sender)].field_32
    mem[324 len 0] = 0
    call joeAddress with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[address(msg.sender)].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[address(msg.sender)].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[address(msg.sender)].field_0, msg.sender);
}

function updateReward(address arg1) payable {
    require calldata.size - 4 >= 32
    if not stor104[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65,
                    mem[200 len 28]
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg1 != joeAddress:
        if ext_call.return_data[0] != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0]
    else:
        if sub_a090a2b4 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] - sub_a090a2b4 != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0] - sub_a090a2b4:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0] - sub_a090a2b4
}

function initialize(address arg1, address arg2, address arg3, uint256 arg4) payable {
    require calldata.size - 4 >= 128
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(0, msg.sender);
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_0):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                            mem[210 len 18]
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(0, msg.sender);
        else:
            Mask(248, 0, stor0.field_8) = 1
            uint8(stor0.field_0) = 1
            if ext_code.size(this.address):
                if uint8(stor0.field_0):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                46,
                                0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                mem[210 len 18]
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(0, msg.sender);
            else:
                Mask(248, 0, stor0.field_8) = 1
                uint8(stor0.field_0) = 1
                if ext_code.size(this.address):
                    if uint8(stor0.field_0):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    46,
                                    0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                    mem[210 len 18]
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                else:
                    Mask(248, 0, stor0.field_8) = 1
                    uint8(stor0.field_0) = 1
                    Mask(248, 0, stor0.field_8) = 0
                    if ext_code.size(this.address):
                        if uint8(stor0.field_0):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        46,
                                        0x25496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                                        mem[210 len 18]
                    if uint8(stor0.field_8):
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                    else:
                        Mask(248, 0, stor0.field_8) = 1
                        uint8(stor0.field_0) = 1
                        owner = msg.sender
                        emit OwnershipTransferred(0, msg.sender);
                        Mask(248, 0, stor0.field_8) = 0
                        Mask(248, 0, stor0.field_8) = 0
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    50,
                    0x25537461626c654a6f655374616b696e673a2072657761726420746f6b656e2063616e277420626520616464726573732830,
                    mem[214 len 14]
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x73537461626c654a6f655374616b696e673a206a6f652063616e277420626520616464726573732830,
                    mem[205 len 23]
    if not arg3:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    51,
                    0x64537461626c654a6f655374616b696e673a2066656520636f6c6c6563746f722063616e277420626520616464726573732830,
                    mem[215 len 13]
    if arg4 > 5 * 10^17:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    59,
                    0x64537461626c654a6f655374616b696e673a206d6178206465706f736974206665652063616e27742062652067726561746572207468616e203530,
                    mem[223 len 5]
    joeAddress = arg2
    depositFeePercent = arg4
    feeCollectorAddress = arg3
    stor104[address(arg1)] = 1
    rewardTokens.length++
    rewardTokens[rewardTokens.length] = arg1
    sub_a610708a = 10^18
    sub_3c97d5ae = 1000000 * 10^18
    if not uint8(stor0.field_8):
        Mask(248, 0, stor0.field_8) = 0
}

function removeRewardToken(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor104[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    40,
                    0x64537461626c654a6f655374616b696e673a20746f6b656e2063616e27742062652072656d6f7665,
                    mem[204 len 24]
    if not stor104[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65,
                    mem[200 len 28]
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg1 != joeAddress:
        if ext_call.return_data[0] != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0]
    else:
        if sub_a090a2b4 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] - sub_a090a2b4 != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0] - sub_a090a2b4:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0] - sub_a090a2b4
    stor104[address(arg1)] = 0
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 103
        if rewardTokens[idx] != arg1:
            idx = idx + 1
            continue 
        require rewardTokens.length - 1 < rewardTokens.length
        require idx < rewardTokens.length
        rewardTokens[idx] = rewardTokens[rewardTokens.length]
        require rewardTokens.length
        rewardTokens[rewardTokens.length] = 0
        rewardTokens.length--
        emit RewardTokenRemoved(arg1);
    emit RewardTokenRemoved(arg1);
}

function addRewardToken(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor104[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x77537461626c654a6f655374616b696e673a20746f6b656e2063616e27742062652061646465,
                    mem[202 len 26]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x77537461626c654a6f655374616b696e673a20746f6b656e2063616e27742062652061646465,
                    mem[202 len 26]
    if rewardTokens.length >= 25:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0xfe537461626c654a6f655374616b696e673a206c697374206f6620746f6b656e20746f6f206269,
                    mem[203 len 25]
    rewardTokens.length++
    rewardTokens[rewardTokens.length] = arg1
    stor104[address(arg1)] = 1
    if not stor104[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65,
                    mem[200 len 28]
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg1 != joeAddress:
        if ext_call.return_data[0] != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0]
    else:
        if sub_a090a2b4 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if ext_call.return_data[0] - sub_a090a2b4 != sub_5fc0d9e0[address(arg1)]:
            if sub_a090a2b4:
                if sub_5fc0d9e0[address(arg1)] > ext_call.return_data[0] - sub_a090a2b4:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]:
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += 0 / sub_a090a2b4
                else:
                    require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)]
                    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg1)] != sub_3c97d5ae:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if sub_a090a2b4 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_a090a2b4
                    if sub_5dcea4d4[address(arg1)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[address(arg1)] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg1)] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[address(arg1)] = ext_call.return_data[0] - sub_a090a2b4
    emit RewardTokenAdded(arg1);
}

function pendingReward(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if not stor104[address(arg2)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65,
                    mem[200 len 28]
    require ext_code.size(arg2)
    staticcall arg2.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg2 != joeAddress:
        if ext_call.return_data[0] == sub_5fc0d9e0[address(arg2)]:
            if not userInfo[address(arg1)].field_0:
                if sub_3c97d5ae <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_3c97d5ae
                if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
            require userInfo[address(arg1)].field_0
            if userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        if not sub_a090a2b4:
            if not userInfo[address(arg1)].field_0:
                if sub_3c97d5ae <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_3c97d5ae
                if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
            require userInfo[address(arg1)].field_0
            if userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        if sub_5fc0d9e0[address(arg2)] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not ext_call.return_data[0] - sub_5fc0d9e0[address(arg2)]:
            if sub_a090a2b4 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_a090a2b4
            if sub_5dcea4d4[address(arg2)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg2)]:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[address(arg1)].field_0:
                if sub_3c97d5ae <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_3c97d5ae
                if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
            require userInfo[address(arg1)].field_0
            if (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)] + (0 / sub_a090a2b4):
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        require ext_call.return_data[0] - sub_5fc0d9e0[address(arg2)]
        if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[address(arg2)] != sub_3c97d5ae:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if sub_a090a2b4 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_a090a2b4
        if sub_5dcea4d4[address(arg2)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        require userInfo[address(arg1)].field_0
        if (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4):
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if sub_3c97d5ae <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_3c97d5ae
        if userInfo[address(arg1)][1][address(arg2)].field_0 > (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
    if sub_a090a2b4 > ext_call.return_data[0]:
        revert with 0, 'SafeMath: subtraction overflow'
    if ext_call.return_data[0] - sub_a090a2b4 == sub_5fc0d9e0[address(arg2)]:
        if not userInfo[address(arg1)].field_0:
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        require userInfo[address(arg1)].field_0
        if userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if sub_3c97d5ae <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_3c97d5ae
        if userInfo[address(arg1)][1][address(arg2)].field_0 > userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
    if not sub_a090a2b4:
        if not userInfo[address(arg1)].field_0:
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        require userInfo[address(arg1)].field_0
        if userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)]:
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if sub_3c97d5ae <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_3c97d5ae
        if userInfo[address(arg1)][1][address(arg2)].field_0 > userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[address(arg1)].field_0 * sub_5dcea4d4[address(arg2)] / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
    if sub_5fc0d9e0[address(arg2)] > ext_call.return_data[0] - sub_a090a2b4:
        revert with 0, 'SafeMath: subtraction overflow'
    if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg2)]:
        if sub_a090a2b4 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_a090a2b4
        if sub_5dcea4d4[address(arg2)] + (0 / sub_a090a2b4) < sub_5dcea4d4[address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[address(arg1)].field_0:
            if sub_3c97d5ae <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_3c97d5ae
            if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
        require userInfo[address(arg1)].field_0
        if (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)] + (0 / sub_a090a2b4):
            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_3c97d5ae <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_3c97d5ae
        if userInfo[address(arg1)][1][address(arg2)].field_0 > (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + (0 / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
    require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg2)]
    if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[address(arg2)] != sub_3c97d5ae:
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if sub_a090a2b4 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require sub_a090a2b4
    if sub_5dcea4d4[address(arg2)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[address(arg2)]:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[address(arg1)].field_0:
        if sub_3c97d5ae <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_3c97d5ae
        if userInfo[address(arg1)][1][address(arg2)].field_0 > 0 / sub_3c97d5ae:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((0 / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
    require userInfo[address(arg1)].field_0
    if (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / userInfo[address(arg1)].field_0 != sub_5dcea4d4[address(arg2)] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4):
        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if sub_3c97d5ae <= 0:
        revert with 0, 'SafeMath: division by zero'
    require sub_3c97d5ae
    if userInfo[address(arg1)][1][address(arg2)].field_0 > (sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((sub_5dcea4d4[address(arg2)] * userInfo[address(arg1)].field_0) + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[address(arg2)] * sub_3c97d5ae) / sub_a090a2b4 * userInfo[address(arg1)].field_0) / sub_3c97d5ae) - userInfo[address(arg1)][1][address(arg2)].field_0)
}

function deposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 111
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if sub_a610708a <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_a610708a
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 / sub_a610708a > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        if userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) < userInfo[address(msg.sender)].field_0:
            revert with 0, 'SafeMath: addition overflow'
        userInfo[address(msg.sender)].field_0 = userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
        idx = 0
        while idx < rewardTokens.length:
            mem[0] = rewardTokens[idx]
            mem[32] = 104
            if not stor104[stor103[idx]]:
                revert with 0, 32, 36, 0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65, mem[mem[64] + 104 len 28]
            mem[mem[64] + 4] = this.address
            require ext_code.size(rewardTokens[idx])
            staticcall rewardTokens[idx].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if rewardTokens[idx] != joeAddress:
                mem[0] = rewardTokens[idx]
                if ext_call.return_data[0] == sub_5fc0d9e0[stor103[idx]]:
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                        _9997 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9997] = 26
                        mem[_9997 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10025 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10025 + idx + 68] = mem[_9997 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10025 + 68] = mem[_10025 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10025 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _10343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10343] = 26
                        mem[_10343 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10393 + idx + 68] = mem[_10343 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10393 + 68] = mem[_10393 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10393 + -mem[64] + 100
                        require sub_3c97d5ae
                        _10519 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10519] = 30
                        mem[_10519 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _10588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10588 + idx + 68] = mem[_10519 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10588 + 68] = mem[_10588 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _10588 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _11273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11273] = 30
                                mem[_11273 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _11362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11362 + idx + 68] = mem[_11273 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11362 + 68] = mem[_11362 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _11362 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11570 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11571 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_11571 + 32] = mem[_11571 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _11570 + 164
                                mem[_11570 + 100] = 32
                                mem[_11570 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11570 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _12332 = mem[_11571]
                                t = _11571 + 32
                                u = mem[64]
                                s = mem[_11571]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_11571])] = mem[_11571 + floor32(mem[_11571]) + -(mem[_11571] % 32) + 64 len mem[_11571] % 32] or Mask(8 * -(mem[_11571] % 32) + 32, -(8 * -(mem[_11571] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11571])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _12332 + _11570 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_11570 + 100]
                                    _22548 = mem[_11570 + 100]
                                    idx = 0
                                    while idx < _22548:
                                        mem[_22546 + idx + 68] = mem[_11570 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22548 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22548 + _22546 + -mem[64] + 68
                                    mem[floor32(_22548) + _22546 + 68] = mem[floor32(_22548) + _22546 + -(_22548 % 32) + 100 len _22548 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22548) + _22546 + -mem[64] + 100
                                _21046 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_21046] = return_data.size
                                mem[_21046 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_21046 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11570 + 100]
                                _22552 = mem[_11570 + 100]
                                idx = 0
                                while idx < _22552:
                                    mem[_22550 + idx + 68] = mem[_11570 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22552 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22552 + _22550 + -mem[64] + 68
                                mem[floor32(_22552) + _22550 + 68] = mem[floor32(_22552) + _22550 + -(_22552 % 32) + 100 len _22552 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22552) + _22550 + -mem[64] + 100
                            _11274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11274] = 30
                            mem[_11274 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _11365 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11365 + idx + 68] = mem[_11274 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11365 + 68] = mem[_11365 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11365 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _11575 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _11576 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11576 + 32] = mem[_11576 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11575 + 164
                            mem[_11575 + 100] = 32
                            mem[_11575 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11575 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12336 = mem[_11576]
                            t = _11576 + 32
                            u = mem[64]
                            s = mem[_11576]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11576])] = mem[_11576 + floor32(mem[_11576]) + -(mem[_11576] % 32) + 64 len mem[_11576] % 32] or Mask(8 * -(mem[_11576] % 32) + 32, -(8 * -(mem[_11576] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11576])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12336 + _11575 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22554 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11575 + 100]
                                _22556 = mem[_11575 + 100]
                                idx = 0
                                while idx < _22556:
                                    mem[_22554 + idx + 68] = mem[_11575 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22556 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22556 + _22554 + -mem[64] + 68
                                mem[floor32(_22556) + _22554 + 68] = mem[floor32(_22556) + _22554 + -(_22556 % 32) + 100 len _22556 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22556) + _22554 + -mem[64] + 100
                            _21049 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21049] = return_data.size
                            mem[_21049 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21049 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22558 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11575 + 100]
                            _22560 = mem[_11575 + 100]
                            idx = 0
                            while idx < _22560:
                                mem[_22558 + idx + 68] = mem[_11575 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22560 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22560 + _22558 + -mem[64] + 68
                            mem[floor32(_22560) + _22558 + 68] = mem[floor32(_22560) + _22558 + -(_22560 % 32) + 100 len _22560 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22560) + _22558 + -mem[64] + 100
                        _11175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11175] = 30
                        mem[_11175 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _11270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11270 + idx + 68] = mem[_11175 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11270 + 68] = mem[_11270 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11270 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _11568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11568] = 30
                            mem[_11568 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11783 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11783 + idx + 68] = mem[_11568 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11783 + 68] = mem[_11783 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11783 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12076 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12077 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12077 + 32] = mem[_12077 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12076 + 164
                            mem[_12076 + 100] = 32
                            mem[_12076 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12076 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12858 = mem[_12077]
                            t = _12077 + 32
                            u = mem[64]
                            s = mem[_12077]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12077])] = mem[_12077 + floor32(mem[_12077]) + -(mem[_12077] % 32) + 64 len mem[_12077] % 32] or Mask(8 * -(mem[_12077] % 32) + 32, -(8 * -(mem[_12077] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12077])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12858 + _12076 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12076 + 100]
                                _22532 = mem[_12076 + 100]
                                idx = 0
                                while idx < _22532:
                                    mem[_22530 + idx + 68] = mem[_12076 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22532 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22532 + _22530 + -mem[64] + 68
                                mem[floor32(_22532) + _22530 + 68] = mem[floor32(_22532) + _22530 + -(_22532 % 32) + 100 len _22532 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22532) + _22530 + -mem[64] + 100
                            _21038 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21038] = return_data.size
                            mem[_21038 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21038 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22534 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12076 + 100]
                            _22536 = mem[_12076 + 100]
                            idx = 0
                            while idx < _22536:
                                mem[_22534 + idx + 68] = mem[_12076 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22536 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22536 + _22534 + -mem[64] + 68
                            mem[floor32(_22536) + _22534 + 68] = mem[floor32(_22536) + _22534 + -(_22536 % 32) + 100 len _22536 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22536) + _22534 + -mem[64] + 100
                        _11569 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11569] = 30
                        mem[_11569 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _11786 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11786 + idx + 68] = mem[_11569 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11786 + 68] = mem[_11786 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11786 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _12081 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _12082 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12082 + 32] = mem[_12082 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12081 + 164
                        mem[_12081 + 100] = 32
                        mem[_12081 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12081 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12862 = mem[_12082]
                        t = _12082 + 32
                        u = mem[64]
                        s = mem[_12082]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12082])] = mem[_12082 + floor32(mem[_12082]) + -(mem[_12082] % 32) + 64 len mem[_12082] % 32] or Mask(8 * -(mem[_12082] % 32) + 32, -(8 * -(mem[_12082] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12082])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12862 + _12081 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12081 + 100]
                            _22540 = mem[_12081 + 100]
                            idx = 0
                            while idx < _22540:
                                mem[_22538 + idx + 68] = mem[_12081 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22540 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22540 + _22538 + -mem[64] + 68
                            mem[floor32(_22540) + _22538 + 68] = mem[floor32(_22540) + _22538 + -(_22540 % 32) + 100 len _22540 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22540) + _22538 + -mem[64] + 100
                        _21041 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21041] = return_data.size
                        mem[_21041 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21041 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22542 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12081 + 100]
                        _22544 = mem[_12081 + 100]
                        idx = 0
                        while idx < _22544:
                            mem[_22542 + idx + 68] = mem[_12081 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22544 % 32:
                            revert with memory
                              from mem[64]
                               len _22544 + _22542 + -mem[64] + 68
                        mem[floor32(_22544) + _22542 + 68] = mem[floor32(_22544) + _22542 + -(_22544 % 32) + 100 len _22544 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22544) + _22542 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10024 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10024] = 26
                    mem[_10024 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10067 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10067 + idx + 68] = mem[_10024 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10067 + 68] = mem[_10067 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10067 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10392] = 26
                    mem[_10392 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10448 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10448 + idx + 68] = mem[_10392 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10448 + 68] = mem[_10448 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10448 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10586 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10586] = 30
                    mem[_10586 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10664 + idx + 68] = mem[_10586 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10664 + 68] = mem[_10664 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10664 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11359] = 30
                            mem[_11359 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11486 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11486 + idx + 68] = mem[_11359 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11486 + 68] = mem[_11486 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11486 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11773 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11774 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11774 + 32] = mem[_11774 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11773 + 164
                            mem[_11773 + 100] = 32
                            mem[_11773 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11773 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12537 = mem[_11774]
                            t = _11774 + 32
                            u = mem[64]
                            s = mem[_11774]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11774])] = mem[_11774 + floor32(mem[_11774]) + -(mem[_11774] % 32) + 64 len mem[_11774] % 32] or Mask(8 * -(mem[_11774] % 32) + 32, -(8 * -(mem[_11774] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11774])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12537 + _11773 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22514 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11773 + 100]
                                _22516 = mem[_11773 + 100]
                                idx = 0
                                while idx < _22516:
                                    mem[_22514 + idx + 68] = mem[_11773 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22516 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22516 + _22514 + -mem[64] + 68
                                mem[floor32(_22516) + _22514 + 68] = mem[floor32(_22516) + _22514 + -(_22516 % 32) + 100 len _22516 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22516) + _22514 + -mem[64] + 100
                            _21026 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21026] = return_data.size
                            mem[_21026 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21026 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11773 + 100]
                            _22520 = mem[_11773 + 100]
                            idx = 0
                            while idx < _22520:
                                mem[_22518 + idx + 68] = mem[_11773 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22520 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22520 + _22518 + -mem[64] + 68
                            mem[floor32(_22520) + _22518 + 68] = mem[floor32(_22520) + _22518 + -(_22520 % 32) + 100 len _22520 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22520) + _22518 + -mem[64] + 100
                        _11360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11360] = 30
                        mem[_11360 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11489 + idx + 68] = mem[_11360 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11489 + 68] = mem[_11489 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11489 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _11778 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _11779 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_11779 + 32] = mem[_11779 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _11778 + 164
                        mem[_11778 + 100] = 32
                        mem[_11778 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11778 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12541 = mem[_11779]
                        t = _11779 + 32
                        u = mem[64]
                        s = mem[_11779]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_11779])] = mem[_11779 + floor32(mem[_11779]) + -(mem[_11779] % 32) + 64 len mem[_11779] % 32] or Mask(8 * -(mem[_11779] % 32) + 32, -(8 * -(mem[_11779] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11779])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12541 + _11778 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22522 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11778 + 100]
                            _22524 = mem[_11778 + 100]
                            idx = 0
                            while idx < _22524:
                                mem[_22522 + idx + 68] = mem[_11778 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22524 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22524 + _22522 + -mem[64] + 68
                            mem[floor32(_22524) + _22522 + 68] = mem[floor32(_22524) + _22522 + -(_22524 % 32) + 100 len _22524 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22524) + _22522 + -mem[64] + 100
                        _21029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21029] = return_data.size
                        mem[_21029 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21029 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22526 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_11778 + 100]
                        _22528 = mem[_11778 + 100]
                        idx = 0
                        while idx < _22528:
                            mem[_22526 + idx + 68] = mem[_11778 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22528 % 32:
                            revert with memory
                              from mem[64]
                               len _22528 + _22526 + -mem[64] + 68
                        mem[floor32(_22528) + _22526 + 68] = mem[floor32(_22528) + _22526 + -(_22528 % 32) + 100 len _22528 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22528) + _22526 + -mem[64] + 100
                    _11269 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11269] = 30
                    mem[_11269 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11356 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11356 + idx + 68] = mem[_11269 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11356 + 68] = mem[_11356 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11356 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _11771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11771] = 30
                        mem[_11771 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _11962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11962 + idx + 68] = mem[_11771 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11962 + 68] = mem[_11962 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11962 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12321 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12322 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12322 + 32] = mem[_12322 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12321 + 164
                        mem[_12321 + 100] = 32
                        mem[_12321 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12321 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13067 = mem[_12322]
                        t = _12322 + 32
                        u = mem[64]
                        s = mem[_12322]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12322])] = mem[_12322 + floor32(mem[_12322]) + -(mem[_12322] % 32) + 64 len mem[_12322] % 32] or Mask(8 * -(mem[_12322] % 32) + 32, -(8 * -(mem[_12322] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12322])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13067 + _12321 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12321 + 100]
                            _22500 = mem[_12321 + 100]
                            idx = 0
                            while idx < _22500:
                                mem[_22498 + idx + 68] = mem[_12321 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22500 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22500 + _22498 + -mem[64] + 68
                            mem[floor32(_22500) + _22498 + 68] = mem[floor32(_22500) + _22498 + -(_22500 % 32) + 100 len _22500 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22500) + _22498 + -mem[64] + 100
                        _21018 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21018] = return_data.size
                        mem[_21018 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21018 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22502 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12321 + 100]
                        _22504 = mem[_12321 + 100]
                        idx = 0
                        while idx < _22504:
                            mem[_22502 + idx + 68] = mem[_12321 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22504 % 32:
                            revert with memory
                              from mem[64]
                               len _22504 + _22502 + -mem[64] + 68
                        mem[floor32(_22504) + _22502 + 68] = mem[floor32(_22504) + _22502 + -(_22504 % 32) + 100 len _22504 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22504) + _22502 + -mem[64] + 100
                    _11772 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11772] = 30
                    mem[_11772 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _11965 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11965 + idx + 68] = mem[_11772 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11965 + 68] = mem[_11965 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11965 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12326 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12327 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12327 + 32] = mem[_12327 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12326 + 164
                    mem[_12326 + 100] = 32
                    mem[_12326 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12326 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13071 = mem[_12327]
                    t = _12327 + 32
                    u = mem[64]
                    s = mem[_12327]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12327])] = mem[_12327 + floor32(mem[_12327]) + -(mem[_12327] % 32) + 64 len mem[_12327] % 32] or Mask(8 * -(mem[_12327] % 32) + 32, -(8 * -(mem[_12327] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12327])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13071 + _12326 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12326 + 100]
                        _22508 = mem[_12326 + 100]
                        idx = 0
                        while idx < _22508:
                            mem[_22506 + idx + 68] = mem[_12326 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22508 % 32:
                            revert with memory
                              from mem[64]
                               len _22508 + _22506 + -mem[64] + 68
                        mem[floor32(_22508) + _22506 + 68] = mem[floor32(_22508) + _22506 + -(_22508 % 32) + 100 len _22508 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22508) + _22506 + -mem[64] + 100
                    _21021 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21021] = return_data.size
                    mem[_21021 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21021 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22510 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12326 + 100]
                    _22512 = mem[_12326 + 100]
                    idx = 0
                    while idx < _22512:
                        mem[_22510 + idx + 68] = mem[_12326 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22512 % 32:
                        revert with memory
                          from mem[64]
                           len _22512 + _22510 + -mem[64] + 68
                    mem[floor32(_22512) + _22510 + 68] = mem[floor32(_22512) + _22510 + -(_22512 % 32) + 100 len _22512 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22512) + _22510 + -mem[64] + 100
                if not sub_a090a2b4:
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                        _10009 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10009] = 26
                        mem[_10009 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10053 + idx + 68] = mem[_10009 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10053 + 68] = mem[_10053 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10053 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _10367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10367] = 26
                        mem[_10367 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10431 + idx + 68] = mem[_10367 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10431 + 68] = mem[_10431 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10431 + -mem[64] + 100
                        require sub_3c97d5ae
                        _10544 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10544] = 30
                        mem[_10544 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _10633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10633 + idx + 68] = mem[_10544 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10633 + 68] = mem[_10633 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _10633 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _11320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11320] = 30
                                mem[_11320 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _11444 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11444 + idx + 68] = mem[_11320 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11444 + 68] = mem[_11444 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _11444 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11686 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11687 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_11687 + 32] = mem[_11687 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _11686 + 164
                                mem[_11686 + 100] = 32
                                mem[_11686 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11686 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _12459 = mem[_11687]
                                t = _11687 + 32
                                u = mem[64]
                                s = mem[_11687]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_11687])] = mem[_11687 + floor32(mem[_11687]) + -(mem[_11687] % 32) + 64 len mem[_11687] % 32] or Mask(8 * -(mem[_11687] % 32) + 32, -(8 * -(mem[_11687] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11687])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _12459 + _11686 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_11686 + 100]
                                    _22740 = mem[_11686 + 100]
                                    idx = 0
                                    while idx < _22740:
                                        mem[_22738 + idx + 68] = mem[_11686 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22740 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22740 + _22738 + -mem[64] + 68
                                    mem[floor32(_22740) + _22738 + 68] = mem[floor32(_22740) + _22738 + -(_22740 % 32) + 100 len _22740 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22740) + _22738 + -mem[64] + 100
                                _21172 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_21172] = return_data.size
                                mem[_21172 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_21172 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22742 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11686 + 100]
                                _22744 = mem[_11686 + 100]
                                idx = 0
                                while idx < _22744:
                                    mem[_22742 + idx + 68] = mem[_11686 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22744 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22744 + _22742 + -mem[64] + 68
                                mem[floor32(_22744) + _22742 + 68] = mem[floor32(_22744) + _22742 + -(_22744 % 32) + 100 len _22744 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22744) + _22742 + -mem[64] + 100
                            _11321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11321] = 30
                            mem[_11321 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _11447 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11447 + idx + 68] = mem[_11321 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11447 + 68] = mem[_11447 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11447 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _11691 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _11692 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11692 + 32] = mem[_11692 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11691 + 164
                            mem[_11691 + 100] = 32
                            mem[_11691 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11691 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12463 = mem[_11692]
                            t = _11692 + 32
                            u = mem[64]
                            s = mem[_11692]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11692])] = mem[_11692 + floor32(mem[_11692]) + -(mem[_11692] % 32) + 64 len mem[_11692] % 32] or Mask(8 * -(mem[_11692] % 32) + 32, -(8 * -(mem[_11692] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11692])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12463 + _11691 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11691 + 100]
                                _22748 = mem[_11691 + 100]
                                idx = 0
                                while idx < _22748:
                                    mem[_22746 + idx + 68] = mem[_11691 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22748 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22748 + _22746 + -mem[64] + 68
                                mem[floor32(_22748) + _22746 + 68] = mem[floor32(_22748) + _22746 + -(_22748 % 32) + 100 len _22748 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22748) + _22746 + -mem[64] + 100
                            _21175 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21175] = return_data.size
                            mem[_21175 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21175 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11691 + 100]
                            _22752 = mem[_11691 + 100]
                            idx = 0
                            while idx < _22752:
                                mem[_22750 + idx + 68] = mem[_11691 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22752 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22752 + _22750 + -mem[64] + 68
                            mem[floor32(_22752) + _22750 + 68] = mem[floor32(_22752) + _22750 + -(_22752 % 32) + 100 len _22752 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22752) + _22750 + -mem[64] + 100
                        _11217 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11217] = 30
                        mem[_11217 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _11317 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11317 + idx + 68] = mem[_11217 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11317 + 68] = mem[_11317 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11317 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _11684 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11684] = 30
                            mem[_11684 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11890 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11890 + idx + 68] = mem[_11684 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11890 + 68] = mem[_11890 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11890 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12214 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12215 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12215 + 32] = mem[_12215 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12214 + 164
                            mem[_12214 + 100] = 32
                            mem[_12214 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12214 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12955 = mem[_12215]
                            t = _12215 + 32
                            u = mem[64]
                            s = mem[_12215]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12215])] = mem[_12215 + floor32(mem[_12215]) + -(mem[_12215] % 32) + 64 len mem[_12215] % 32] or Mask(8 * -(mem[_12215] % 32) + 32, -(8 * -(mem[_12215] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12215])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12955 + _12214 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22722 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12214 + 100]
                                _22724 = mem[_12214 + 100]
                                idx = 0
                                while idx < _22724:
                                    mem[_22722 + idx + 68] = mem[_12214 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22724 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22724 + _22722 + -mem[64] + 68
                                mem[floor32(_22724) + _22722 + 68] = mem[floor32(_22724) + _22722 + -(_22724 % 32) + 100 len _22724 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22724) + _22722 + -mem[64] + 100
                            _21164 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21164] = return_data.size
                            mem[_21164 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21164 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22726 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12214 + 100]
                            _22728 = mem[_12214 + 100]
                            idx = 0
                            while idx < _22728:
                                mem[_22726 + idx + 68] = mem[_12214 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22728 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22728 + _22726 + -mem[64] + 68
                            mem[floor32(_22728) + _22726 + 68] = mem[floor32(_22728) + _22726 + -(_22728 % 32) + 100 len _22728 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22728) + _22726 + -mem[64] + 100
                        _11685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11685] = 30
                        mem[_11685 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _11893 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11893 + idx + 68] = mem[_11685 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11893 + 68] = mem[_11893 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11893 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _12219 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _12220 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12220 + 32] = mem[_12220 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12219 + 164
                        mem[_12219 + 100] = 32
                        mem[_12219 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12219 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12959 = mem[_12220]
                        t = _12220 + 32
                        u = mem[64]
                        s = mem[_12220]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12220])] = mem[_12220 + floor32(mem[_12220]) + -(mem[_12220] % 32) + 64 len mem[_12220] % 32] or Mask(8 * -(mem[_12220] % 32) + 32, -(8 * -(mem[_12220] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12220])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12959 + _12219 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12219 + 100]
                            _22732 = mem[_12219 + 100]
                            idx = 0
                            while idx < _22732:
                                mem[_22730 + idx + 68] = mem[_12219 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22732 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22732 + _22730 + -mem[64] + 68
                            mem[floor32(_22732) + _22730 + 68] = mem[floor32(_22732) + _22730 + -(_22732 % 32) + 100 len _22732 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22732) + _22730 + -mem[64] + 100
                        _21167 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21167] = return_data.size
                        mem[_21167 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21167 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22734 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12219 + 100]
                        _22736 = mem[_12219 + 100]
                        idx = 0
                        while idx < _22736:
                            mem[_22734 + idx + 68] = mem[_12219 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22736 % 32:
                            revert with memory
                              from mem[64]
                               len _22736 + _22734 + -mem[64] + 68
                        mem[floor32(_22736) + _22734 + 68] = mem[floor32(_22736) + _22734 + -(_22736 % 32) + 100 len _22736 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22736) + _22734 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10052 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10052] = 26
                    mem[_10052 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10096 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10096 + idx + 68] = mem[_10052 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10096 + 68] = mem[_10096 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10096 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10430 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10430] = 26
                    mem[_10430 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10474 + idx + 68] = mem[_10430 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10474 + 68] = mem[_10474 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10474 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10631 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10631] = 30
                    mem[_10631 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10718 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10718 + idx + 68] = mem[_10631 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10718 + 68] = mem[_10718 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10718 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11441 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11441] = 30
                            mem[_11441 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11585 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11585 + idx + 68] = mem[_11441 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11585 + 68] = mem[_11585 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11585 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11880 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11881 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11881 + 32] = mem[_11881 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11880 + 164
                            mem[_11880 + 100] = 32
                            mem[_11880 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11880 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12653 = mem[_11881]
                            t = _11881 + 32
                            u = mem[64]
                            s = mem[_11881]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11881])] = mem[_11881 + floor32(mem[_11881]) + -(mem[_11881] % 32) + 64 len mem[_11881] % 32] or Mask(8 * -(mem[_11881] % 32) + 32, -(8 * -(mem[_11881] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11881])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12653 + _11880 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22706 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11880 + 100]
                                _22708 = mem[_11880 + 100]
                                idx = 0
                                while idx < _22708:
                                    mem[_22706 + idx + 68] = mem[_11880 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22708 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22708 + _22706 + -mem[64] + 68
                                mem[floor32(_22708) + _22706 + 68] = mem[floor32(_22708) + _22706 + -(_22708 % 32) + 100 len _22708 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22708) + _22706 + -mem[64] + 100
                            _21152 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21152] = return_data.size
                            mem[_21152 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21152 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22710 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11880 + 100]
                            _22712 = mem[_11880 + 100]
                            idx = 0
                            while idx < _22712:
                                mem[_22710 + idx + 68] = mem[_11880 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22712 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22712 + _22710 + -mem[64] + 68
                            mem[floor32(_22712) + _22710 + 68] = mem[floor32(_22712) + _22710 + -(_22712 % 32) + 100 len _22712 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22712) + _22710 + -mem[64] + 100
                        _11442 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11442] = 30
                        mem[_11442 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11588 + idx + 68] = mem[_11442 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11588 + 68] = mem[_11588 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11588 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _11885 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _11886 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_11886 + 32] = mem[_11886 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _11885 + 164
                        mem[_11885 + 100] = 32
                        mem[_11885 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11885 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12657 = mem[_11886]
                        t = _11886 + 32
                        u = mem[64]
                        s = mem[_11886]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_11886])] = mem[_11886 + floor32(mem[_11886]) + -(mem[_11886] % 32) + 64 len mem[_11886] % 32] or Mask(8 * -(mem[_11886] % 32) + 32, -(8 * -(mem[_11886] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11886])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12657 + _11885 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22714 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11885 + 100]
                            _22716 = mem[_11885 + 100]
                            idx = 0
                            while idx < _22716:
                                mem[_22714 + idx + 68] = mem[_11885 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22716 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22716 + _22714 + -mem[64] + 68
                            mem[floor32(_22716) + _22714 + 68] = mem[floor32(_22716) + _22714 + -(_22716 % 32) + 100 len _22716 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22716) + _22714 + -mem[64] + 100
                        _21155 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21155] = return_data.size
                        mem[_21155 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21155 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22718 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_11885 + 100]
                        _22720 = mem[_11885 + 100]
                        idx = 0
                        while idx < _22720:
                            mem[_22718 + idx + 68] = mem[_11885 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22720 % 32:
                            revert with memory
                              from mem[64]
                               len _22720 + _22718 + -mem[64] + 68
                        mem[floor32(_22720) + _22718 + 68] = mem[floor32(_22720) + _22718 + -(_22720 % 32) + 100 len _22720 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22720) + _22718 + -mem[64] + 100
                    _11316 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11316] = 30
                    mem[_11316 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11438 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11438 + idx + 68] = mem[_11316 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11438 + 68] = mem[_11438 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11438 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _11878 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11878] = 30
                        mem[_11878 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12092 + idx + 68] = mem[_11878 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12092 + 68] = mem[_12092 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12092 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12448 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12449 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12449 + 32] = mem[_12449 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12448 + 164
                        mem[_12448 + 100] = 32
                        mem[_12448 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12448 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13209 = mem[_12449]
                        t = _12449 + 32
                        u = mem[64]
                        s = mem[_12449]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12449])] = mem[_12449 + floor32(mem[_12449]) + -(mem[_12449] % 32) + 64 len mem[_12449] % 32] or Mask(8 * -(mem[_12449] % 32) + 32, -(8 * -(mem[_12449] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12449])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13209 + _12448 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22690 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12448 + 100]
                            _22692 = mem[_12448 + 100]
                            idx = 0
                            while idx < _22692:
                                mem[_22690 + idx + 68] = mem[_12448 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22692 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22692 + _22690 + -mem[64] + 68
                            mem[floor32(_22692) + _22690 + 68] = mem[floor32(_22692) + _22690 + -(_22692 % 32) + 100 len _22692 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22692) + _22690 + -mem[64] + 100
                        _21144 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21144] = return_data.size
                        mem[_21144 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21144 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22694 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12448 + 100]
                        _22696 = mem[_12448 + 100]
                        idx = 0
                        while idx < _22696:
                            mem[_22694 + idx + 68] = mem[_12448 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22696 % 32:
                            revert with memory
                              from mem[64]
                               len _22696 + _22694 + -mem[64] + 68
                        mem[floor32(_22696) + _22694 + 68] = mem[floor32(_22696) + _22694 + -(_22696 % 32) + 100 len _22696 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22696) + _22694 + -mem[64] + 100
                    _11879 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11879] = 30
                    mem[_11879 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12095 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12095 + idx + 68] = mem[_11879 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12095 + 68] = mem[_12095 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12095 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12453 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12454 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12454 + 32] = mem[_12454 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12453 + 164
                    mem[_12453 + 100] = 32
                    mem[_12453 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12453 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13213 = mem[_12454]
                    t = _12454 + 32
                    u = mem[64]
                    s = mem[_12454]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12454])] = mem[_12454 + floor32(mem[_12454]) + -(mem[_12454] % 32) + 64 len mem[_12454] % 32] or Mask(8 * -(mem[_12454] % 32) + 32, -(8 * -(mem[_12454] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12454])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13213 + _12453 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22698 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12453 + 100]
                        _22700 = mem[_12453 + 100]
                        idx = 0
                        while idx < _22700:
                            mem[_22698 + idx + 68] = mem[_12453 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22700 % 32:
                            revert with memory
                              from mem[64]
                               len _22700 + _22698 + -mem[64] + 68
                        mem[floor32(_22700) + _22698 + 68] = mem[floor32(_22700) + _22698 + -(_22700 % 32) + 100 len _22700 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22700) + _22698 + -mem[64] + 100
                    _21147 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21147] = return_data.size
                    mem[_21147 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21147 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12453 + 100]
                    _22704 = mem[_12453 + 100]
                    idx = 0
                    while idx < _22704:
                        mem[_22702 + idx + 68] = mem[_12453 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22704 % 32:
                        revert with memory
                          from mem[64]
                           len _22704 + _22702 + -mem[64] + 68
                    mem[floor32(_22704) + _22702 + 68] = mem[floor32(_22704) + _22702 + -(_22704 % 32) + 100 len _22704 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22704) + _22702 + -mem[64] + 100
                mem[32] = 105
                _9941 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9941] = 30
                mem[_9941 + 32] = 'SafeMath: subtraction overflow'
                if sub_5fc0d9e0[stor103[idx]] > ext_call.return_data[0]:
                    _9965 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9965 + idx + 68] = mem[_9941 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9965 + 68] = mem[_9965 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _9965 + -mem[64] + 100
                if not ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]]:
                    _10071 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10071] = 26
                    mem[_10071 + 32] = 'SafeMath: division by zero'
                    if sub_a090a2b4 <= 0:
                        _10130 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10130 + idx + 68] = mem[_10071 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10130 + 68] = mem[_10130 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10130 + -mem[64] + 100
                    require sub_a090a2b4
                    if sub_5dcea4d4[stor103[idx]] + (0 / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[stor103[idx]] += 0 / sub_a090a2b4
                    sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0]
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                        _10521 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10521] = 26
                        mem[_10521 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10593 + idx + 68] = mem[_10521 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10593 + 68] = mem[_10593 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10593 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _11176 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11176] = 26
                        mem[_11176 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _11277 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_11277 + idx + 68] = mem[_11176 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11277 + 68] = mem[_11277 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _11277 + -mem[64] + 100
                        require sub_3c97d5ae
                        _11504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11504] = 30
                        mem[_11504 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _11679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11679 + idx + 68] = mem[_11504 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11679 + 68] = mem[_11679 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11679 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _13104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13104] = 30
                                mem[_13104 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _13368 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_13368 + idx + 68] = mem[_13104 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13368 + 68] = mem[_13368 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13368 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _13858 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _13859 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_13859 + 32] = mem[_13859 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _13858 + 164
                                mem[_13858 + 100] = 32
                                mem[_13858 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13858 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _15583 = mem[_13859]
                                t = _13859 + 32
                                u = mem[64]
                                s = mem[_13859]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_13859])] = mem[_13859 + floor32(mem[_13859]) + -(mem[_13859] % 32) + 64 len mem[_13859] % 32] or Mask(8 * -(mem[_13859] % 32) + 32, -(8 * -(mem[_13859] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13859])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _15583 + _13858 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22674 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_13858 + 100]
                                    _22676 = mem[_13858 + 100]
                                    idx = 0
                                    while idx < _22676:
                                        mem[_22674 + idx + 68] = mem[_13858 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22676 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22676 + _22674 + -mem[64] + 68
                                    mem[floor32(_22676) + _22674 + 68] = mem[floor32(_22676) + _22674 + -(_22676 % 32) + 100 len _22676 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22676) + _22674 + -mem[64] + 100
                                _21128 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_21128] = return_data.size
                                mem[_21128 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_21128 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22678 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_13858 + 100]
                                _22680 = mem[_13858 + 100]
                                idx = 0
                                while idx < _22680:
                                    mem[_22678 + idx + 68] = mem[_13858 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22680 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22680 + _22678 + -mem[64] + 68
                                mem[floor32(_22680) + _22678 + 68] = mem[floor32(_22680) + _22678 + -(_22680 % 32) + 100 len _22680 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22680) + _22678 + -mem[64] + 100
                            _13105 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13105] = 30
                            mem[_13105 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _13371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13371 + idx + 68] = mem[_13105 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13371 + 68] = mem[_13371 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13371 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _13863 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _13864 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_13864 + 32] = mem[_13864 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _13863 + 164
                            mem[_13863 + 100] = 32
                            mem[_13863 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13863 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _15587 = mem[_13864]
                            t = _13864 + 32
                            u = mem[64]
                            s = mem[_13864]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_13864])] = mem[_13864 + floor32(mem[_13864]) + -(mem[_13864] % 32) + 64 len mem[_13864] % 32] or Mask(8 * -(mem[_13864] % 32) + 32, -(8 * -(mem[_13864] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13864])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _15587 + _13863 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22682 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_13863 + 100]
                                _22684 = mem[_13863 + 100]
                                idx = 0
                                while idx < _22684:
                                    mem[_22682 + idx + 68] = mem[_13863 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22684 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22684 + _22682 + -mem[64] + 68
                                mem[floor32(_22684) + _22682 + 68] = mem[floor32(_22684) + _22682 + -(_22684 % 32) + 100 len _22684 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22684) + _22682 + -mem[64] + 100
                            _21131 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21131] = return_data.size
                            mem[_21131 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21131 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22686 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_13863 + 100]
                            _22688 = mem[_13863 + 100]
                            idx = 0
                            while idx < _22688:
                                mem[_22686 + idx + 68] = mem[_13863 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22688 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22688 + _22686 + -mem[64] + 68
                            mem[floor32(_22688) + _22686 + 68] = mem[floor32(_22688) + _22686 + -(_22688 % 32) + 100 len _22688 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22688) + _22686 + -mem[64] + 100
                        _12867 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12867] = 30
                        mem[_12867 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _13101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13101 + idx + 68] = mem[_12867 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13101 + 68] = mem[_13101 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13101 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _13856 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13856] = 30
                            mem[_13856 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _14352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14352 + idx + 68] = mem[_13856 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14352 + 68] = mem[_14352 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14352 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _15034 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _15035 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_15035 + 32] = mem[_15035 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _15034 + 164
                            mem[_15034 + 100] = 32
                            mem[_15034 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15034 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16565 = mem[_15035]
                            t = _15035 + 32
                            u = mem[64]
                            s = mem[_15035]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_15035])] = mem[_15035 + floor32(mem[_15035]) + -(mem[_15035] % 32) + 64 len mem[_15035] % 32] or Mask(8 * -(mem[_15035] % 32) + 32, -(8 * -(mem[_15035] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15035])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16565 + _15034 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_15034 + 100]
                                _22660 = mem[_15034 + 100]
                                idx = 0
                                while idx < _22660:
                                    mem[_22658 + idx + 68] = mem[_15034 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22660 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22660 + _22658 + -mem[64] + 68
                                mem[floor32(_22660) + _22658 + 68] = mem[floor32(_22660) + _22658 + -(_22660 % 32) + 100 len _22660 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22660) + _22658 + -mem[64] + 100
                            _21120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21120] = return_data.size
                            mem[_21120 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21120 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15034 + 100]
                            _22664 = mem[_15034 + 100]
                            idx = 0
                            while idx < _22664:
                                mem[_22662 + idx + 68] = mem[_15034 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22664 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22664 + _22662 + -mem[64] + 68
                            mem[floor32(_22664) + _22662 + 68] = mem[floor32(_22664) + _22662 + -(_22664 % 32) + 100 len _22664 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22664) + _22662 + -mem[64] + 100
                        _13857 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13857] = 30
                        mem[_13857 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _14355 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14355 + idx + 68] = mem[_13857 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14355 + 68] = mem[_14355 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14355 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _15039 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _15040 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15040 + 32] = mem[_15040 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15039 + 164
                        mem[_15039 + 100] = 32
                        mem[_15039 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15039 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16569 = mem[_15040]
                        t = _15040 + 32
                        u = mem[64]
                        s = mem[_15040]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15040])] = mem[_15040 + floor32(mem[_15040]) + -(mem[_15040] % 32) + 64 len mem[_15040] % 32] or Mask(8 * -(mem[_15040] % 32) + 32, -(8 * -(mem[_15040] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15040])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16569 + _15039 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22666 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15039 + 100]
                            _22668 = mem[_15039 + 100]
                            idx = 0
                            while idx < _22668:
                                mem[_22666 + idx + 68] = mem[_15039 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22668 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22668 + _22666 + -mem[64] + 68
                            mem[floor32(_22668) + _22666 + 68] = mem[floor32(_22668) + _22666 + -(_22668 % 32) + 100 len _22668 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22668) + _22666 + -mem[64] + 100
                        _21123 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21123] = return_data.size
                        mem[_21123 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21123 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22670 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15039 + 100]
                        _22672 = mem[_15039 + 100]
                        idx = 0
                        while idx < _22672:
                            mem[_22670 + idx + 68] = mem[_15039 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22672 % 32:
                            revert with memory
                              from mem[64]
                               len _22672 + _22670 + -mem[64] + 68
                        mem[floor32(_22672) + _22670 + 68] = mem[floor32(_22672) + _22670 + -(_22672 % 32) + 100 len _22672 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22672) + _22670 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10592 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10592] = 26
                    mem[_10592 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10672 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10672 + idx + 68] = mem[_10592 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10672 + 68] = mem[_10672 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10672 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11276 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11276] = 26
                    mem[_11276 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11372 + idx + 68] = mem[_11276 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11372 + 68] = mem[_11372 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11372 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11677 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11677] = 30
                    mem[_11677 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _11874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11874 + idx + 68] = mem[_11677 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11874 + 68] = mem[_11874 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11874 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13365 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13365] = 30
                            mem[_13365 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _13641 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13641 + idx + 68] = mem[_13365 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13641 + 68] = mem[_13641 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13641 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14342 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14343 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14343 + 32] = mem[_14343 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14342 + 164
                            mem[_14342 + 100] = 32
                            mem[_14342 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14342 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16013 = mem[_14343]
                            t = _14343 + 32
                            u = mem[64]
                            s = mem[_14343]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14343])] = mem[_14343 + floor32(mem[_14343]) + -(mem[_14343] % 32) + 64 len mem[_14343] % 32] or Mask(8 * -(mem[_14343] % 32) + 32, -(8 * -(mem[_14343] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14343])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16013 + _14342 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22642 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14342 + 100]
                                _22644 = mem[_14342 + 100]
                                idx = 0
                                while idx < _22644:
                                    mem[_22642 + idx + 68] = mem[_14342 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22644 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22644 + _22642 + -mem[64] + 68
                                mem[floor32(_22644) + _22642 + 68] = mem[floor32(_22644) + _22642 + -(_22644 % 32) + 100 len _22644 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22644) + _22642 + -mem[64] + 100
                            _21108 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21108] = return_data.size
                            mem[_21108 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21108 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14342 + 100]
                            _22648 = mem[_14342 + 100]
                            idx = 0
                            while idx < _22648:
                                mem[_22646 + idx + 68] = mem[_14342 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22648 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22648 + _22646 + -mem[64] + 68
                            mem[floor32(_22648) + _22646 + 68] = mem[floor32(_22648) + _22646 + -(_22648 % 32) + 100 len _22648 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22648) + _22646 + -mem[64] + 100
                        _13366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13366] = 30
                        mem[_13366 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _13644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13644 + idx + 68] = mem[_13366 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13644 + 68] = mem[_13644 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13644 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14347 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14348 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14348 + 32] = mem[_14348 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14347 + 164
                        mem[_14347 + 100] = 32
                        mem[_14347 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14347 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16017 = mem[_14348]
                        t = _14348 + 32
                        u = mem[64]
                        s = mem[_14348]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14348])] = mem[_14348 + floor32(mem[_14348]) + -(mem[_14348] % 32) + 64 len mem[_14348] % 32] or Mask(8 * -(mem[_14348] % 32) + 32, -(8 * -(mem[_14348] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14348])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16017 + _14347 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22650 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14347 + 100]
                            _22652 = mem[_14347 + 100]
                            idx = 0
                            while idx < _22652:
                                mem[_22650 + idx + 68] = mem[_14347 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22652 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22652 + _22650 + -mem[64] + 68
                            mem[floor32(_22652) + _22650 + 68] = mem[floor32(_22652) + _22650 + -(_22652 % 32) + 100 len _22652 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22652) + _22650 + -mem[64] + 100
                        _21111 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21111] = return_data.size
                        mem[_21111 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21111 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22654 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14347 + 100]
                        _22656 = mem[_14347 + 100]
                        idx = 0
                        while idx < _22656:
                            mem[_22654 + idx + 68] = mem[_14347 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22656 % 32:
                            revert with memory
                              from mem[64]
                               len _22656 + _22654 + -mem[64] + 68
                        mem[floor32(_22656) + _22654 + 68] = mem[floor32(_22656) + _22654 + -(_22656 % 32) + 100 len _22656 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22656) + _22654 + -mem[64] + 100
                    _13100 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13100] = 30
                    mem[_13100 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13362 + idx + 68] = mem[_13100 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13362 + 68] = mem[_13362 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13362 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14340 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14340] = 30
                        mem[_14340 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14794 + idx + 68] = mem[_14340 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14794 + 68] = mem[_14794 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14794 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15572 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15573 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15573 + 32] = mem[_15573 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15572 + 164
                        mem[_15572 + 100] = 32
                        mem[_15572 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15572 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16893 = mem[_15573]
                        t = _15573 + 32
                        u = mem[64]
                        s = mem[_15573]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15573])] = mem[_15573 + floor32(mem[_15573]) + -(mem[_15573] % 32) + 64 len mem[_15573] % 32] or Mask(8 * -(mem[_15573] % 32) + 32, -(8 * -(mem[_15573] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15573])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16893 + _15572 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15572 + 100]
                            _22628 = mem[_15572 + 100]
                            idx = 0
                            while idx < _22628:
                                mem[_22626 + idx + 68] = mem[_15572 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22628 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22628 + _22626 + -mem[64] + 68
                            mem[floor32(_22628) + _22626 + 68] = mem[floor32(_22628) + _22626 + -(_22628 % 32) + 100 len _22628 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22628) + _22626 + -mem[64] + 100
                        _21100 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21100] = return_data.size
                        mem[_21100 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21100 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22630 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15572 + 100]
                        _22632 = mem[_15572 + 100]
                        idx = 0
                        while idx < _22632:
                            mem[_22630 + idx + 68] = mem[_15572 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22632 % 32:
                            revert with memory
                              from mem[64]
                               len _22632 + _22630 + -mem[64] + 68
                        mem[floor32(_22632) + _22630 + 68] = mem[floor32(_22632) + _22630 + -(_22632 % 32) + 100 len _22632 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22632) + _22630 + -mem[64] + 100
                    _14341 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14341] = 30
                    mem[_14341 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _14797 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14797 + idx + 68] = mem[_14341 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14797 + 68] = mem[_14797 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14797 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _15577 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _15578 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15578 + 32] = mem[_15578 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15577 + 164
                    mem[_15577 + 100] = 32
                    mem[_15577 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15577 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16897 = mem[_15578]
                    t = _15578 + 32
                    u = mem[64]
                    s = mem[_15578]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15578])] = mem[_15578 + floor32(mem[_15578]) + -(mem[_15578] % 32) + 64 len mem[_15578] % 32] or Mask(8 * -(mem[_15578] % 32) + 32, -(8 * -(mem[_15578] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15578])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16897 + _15577 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15577 + 100]
                        _22636 = mem[_15577 + 100]
                        idx = 0
                        while idx < _22636:
                            mem[_22634 + idx + 68] = mem[_15577 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22636 % 32:
                            revert with memory
                              from mem[64]
                               len _22636 + _22634 + -mem[64] + 68
                        mem[floor32(_22636) + _22634 + 68] = mem[floor32(_22636) + _22634 + -(_22636 % 32) + 100 len _22636 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22636) + _22634 + -mem[64] + 100
                    _21103 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21103] = return_data.size
                    mem[_21103 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21103 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22638 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15577 + 100]
                    _22640 = mem[_15577 + 100]
                    idx = 0
                    while idx < _22640:
                        mem[_22638 + idx + 68] = mem[_15577 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22640 % 32:
                        revert with memory
                          from mem[64]
                           len _22640 + _22638 + -mem[64] + 68
                    mem[floor32(_22640) + _22638 + 68] = mem[floor32(_22640) + _22638 + -(_22640 % 32) + 100 len _22640 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22640) + _22638 + -mem[64] + 100
                require ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]]
                if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]] != sub_3c97d5ae:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10129 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10129] = 26
                mem[_10129 + 32] = 'SafeMath: division by zero'
                if sub_a090a2b4 <= 0:
                    _10191 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10191 + idx + 68] = mem[_10129 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10191 + 68] = mem[_10191 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10191 + -mem[64] + 100
                require sub_a090a2b4
                if sub_5dcea4d4[stor103[idx]] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 'SafeMath: addition overflow'
                sub_5dcea4d4[stor103[idx]] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0]
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                    _10591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10591] = 26
                    mem[_10591 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10669 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10669 + idx + 68] = mem[_10591 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10669 + 68] = mem[_10669 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10669 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11275 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11275] = 26
                    mem[_11275 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11369 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11369 + idx + 68] = mem[_11275 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11369 + 68] = mem[_11369 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11369 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11675 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11675] = 30
                    mem[_11675 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _11871 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11871 + idx + 68] = mem[_11675 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11871 + 68] = mem[_11871 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11871 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13360] = 30
                            mem[_13360 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _13634 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13634 + idx + 68] = mem[_13360 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13634 + 68] = mem[_13634 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13634 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14330 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14331 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14331 + 32] = mem[_14331 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14330 + 164
                            mem[_14330 + 100] = 32
                            mem[_14330 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14330 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16005 = mem[_14331]
                            t = _14331 + 32
                            u = mem[64]
                            s = mem[_14331]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14331])] = mem[_14331 + floor32(mem[_14331]) + -(mem[_14331] % 32) + 64 len mem[_14331] % 32] or Mask(8 * -(mem[_14331] % 32) + 32, -(8 * -(mem[_14331] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14331])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16005 + _14330 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14330 + 100]
                                _22612 = mem[_14330 + 100]
                                idx = 0
                                while idx < _22612:
                                    mem[_22610 + idx + 68] = mem[_14330 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22612 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22612 + _22610 + -mem[64] + 68
                                mem[floor32(_22612) + _22610 + 68] = mem[floor32(_22612) + _22610 + -(_22612 % 32) + 100 len _22612 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22612) + _22610 + -mem[64] + 100
                            _21086 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21086] = return_data.size
                            mem[_21086 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21086 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22614 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14330 + 100]
                            _22616 = mem[_14330 + 100]
                            idx = 0
                            while idx < _22616:
                                mem[_22614 + idx + 68] = mem[_14330 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22616 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22616 + _22614 + -mem[64] + 68
                            mem[floor32(_22616) + _22614 + 68] = mem[floor32(_22616) + _22614 + -(_22616 % 32) + 100 len _22616 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22616) + _22614 + -mem[64] + 100
                        _13361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13361] = 30
                        mem[_13361 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _13637 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13637 + idx + 68] = mem[_13361 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13637 + 68] = mem[_13637 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13637 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14335 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14336 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14336 + 32] = mem[_14336 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14335 + 164
                        mem[_14335 + 100] = 32
                        mem[_14335 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14335 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16009 = mem[_14336]
                        t = _14336 + 32
                        u = mem[64]
                        s = mem[_14336]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14336])] = mem[_14336 + floor32(mem[_14336]) + -(mem[_14336] % 32) + 64 len mem[_14336] % 32] or Mask(8 * -(mem[_14336] % 32) + 32, -(8 * -(mem[_14336] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14336])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16009 + _14335 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14335 + 100]
                            _22620 = mem[_14335 + 100]
                            idx = 0
                            while idx < _22620:
                                mem[_22618 + idx + 68] = mem[_14335 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22620 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22620 + _22618 + -mem[64] + 68
                            mem[floor32(_22620) + _22618 + 68] = mem[floor32(_22620) + _22618 + -(_22620 % 32) + 100 len _22620 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22620) + _22618 + -mem[64] + 100
                        _21089 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21089] = return_data.size
                        mem[_21089 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21089 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22622 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14335 + 100]
                        _22624 = mem[_14335 + 100]
                        idx = 0
                        while idx < _22624:
                            mem[_22622 + idx + 68] = mem[_14335 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22624 % 32:
                            revert with memory
                              from mem[64]
                               len _22624 + _22622 + -mem[64] + 68
                        mem[floor32(_22624) + _22622 + 68] = mem[floor32(_22624) + _22622 + -(_22624 % 32) + 100 len _22624 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22624) + _22622 + -mem[64] + 100
                    _13099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13099] = 30
                    mem[_13099 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13357 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13357 + idx + 68] = mem[_13099 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13357 + 68] = mem[_13357 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13357 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14328] = 30
                        mem[_14328 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14788 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14788 + idx + 68] = mem[_14328 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14788 + 68] = mem[_14788 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14788 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15562 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15563 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15563 + 32] = mem[_15563 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15562 + 164
                        mem[_15562 + 100] = 32
                        mem[_15562 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15562 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16885 = mem[_15563]
                        t = _15563 + 32
                        u = mem[64]
                        s = mem[_15563]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15563])] = mem[_15563 + floor32(mem[_15563]) + -(mem[_15563] % 32) + 64 len mem[_15563] % 32] or Mask(8 * -(mem[_15563] % 32) + 32, -(8 * -(mem[_15563] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15563])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16885 + _15562 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22594 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15562 + 100]
                            _22596 = mem[_15562 + 100]
                            idx = 0
                            while idx < _22596:
                                mem[_22594 + idx + 68] = mem[_15562 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22596 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22596 + _22594 + -mem[64] + 68
                            mem[floor32(_22596) + _22594 + 68] = mem[floor32(_22596) + _22594 + -(_22596 % 32) + 100 len _22596 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22596) + _22594 + -mem[64] + 100
                        _21078 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21078] = return_data.size
                        mem[_21078 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21078 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22598 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15562 + 100]
                        _22600 = mem[_15562 + 100]
                        idx = 0
                        while idx < _22600:
                            mem[_22598 + idx + 68] = mem[_15562 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22600 % 32:
                            revert with memory
                              from mem[64]
                               len _22600 + _22598 + -mem[64] + 68
                        mem[floor32(_22600) + _22598 + 68] = mem[floor32(_22600) + _22598 + -(_22600 % 32) + 100 len _22600 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22600) + _22598 + -mem[64] + 100
                    _14329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14329] = 30
                    mem[_14329 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _14791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14791 + idx + 68] = mem[_14329 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14791 + 68] = mem[_14791 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14791 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _15567 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _15568 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15568 + 32] = mem[_15568 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15567 + 164
                    mem[_15567 + 100] = 32
                    mem[_15567 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15567 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16889 = mem[_15568]
                    t = _15568 + 32
                    u = mem[64]
                    s = mem[_15568]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15568])] = mem[_15568 + floor32(mem[_15568]) + -(mem[_15568] % 32) + 64 len mem[_15568] % 32] or Mask(8 * -(mem[_15568] % 32) + 32, -(8 * -(mem[_15568] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15568])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16889 + _15567 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15567 + 100]
                        _22604 = mem[_15567 + 100]
                        idx = 0
                        while idx < _22604:
                            mem[_22602 + idx + 68] = mem[_15567 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22604 % 32:
                            revert with memory
                              from mem[64]
                               len _22604 + _22602 + -mem[64] + 68
                        mem[floor32(_22604) + _22602 + 68] = mem[floor32(_22604) + _22602 + -(_22604 % 32) + 100 len _22604 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22604) + _22602 + -mem[64] + 100
                    _21081 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21081] = return_data.size
                    mem[_21081 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21081 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22606 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15567 + 100]
                    _22608 = mem[_15567 + 100]
                    idx = 0
                    while idx < _22608:
                        mem[_22606 + idx + 68] = mem[_15567 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22608 % 32:
                        revert with memory
                          from mem[64]
                           len _22608 + _22606 + -mem[64] + 68
                    mem[floor32(_22608) + _22606 + 68] = mem[floor32(_22608) + _22606 + -(_22608 % 32) + 100 len _22608 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22608) + _22606 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10668 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10668] = 26
                mem[_10668 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10761 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10761 + idx + 68] = mem[_10668 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10761 + 68] = mem[_10761 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10761 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11368 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11368] = 26
                mem[_11368 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11499 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11499 + idx + 68] = mem[_11368 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11499 + 68] = mem[_11499 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11499 + -mem[64] + 100
                require sub_3c97d5ae
                _11869 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11869] = 30
                mem[_11869 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12086 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12086 + idx + 68] = mem[_11869 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12086 + 68] = mem[_12086 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12086 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _13631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13631] = 30
                        mem[_13631 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14066 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14066 + idx + 68] = mem[_13631 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14066 + 68] = mem[_14066 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14066 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _14778 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _14779 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14779 + 32] = mem[_14779 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14778 + 164
                        mem[_14778 + 100] = 32
                        mem[_14778 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14778 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16373 = mem[_14779]
                        t = _14779 + 32
                        u = mem[64]
                        s = mem[_14779]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14779])] = mem[_14779 + floor32(mem[_14779]) + -(mem[_14779] % 32) + 64 len mem[_14779] % 32] or Mask(8 * -(mem[_14779] % 32) + 32, -(8 * -(mem[_14779] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14779])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16373 + _14778 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14778 + 100]
                            _22580 = mem[_14778 + 100]
                            idx = 0
                            while idx < _22580:
                                mem[_22578 + idx + 68] = mem[_14778 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22580 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22580 + _22578 + -mem[64] + 68
                            mem[floor32(_22580) + _22578 + 68] = mem[floor32(_22580) + _22578 + -(_22580 % 32) + 100 len _22580 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22580) + _22578 + -mem[64] + 100
                        _21066 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21066] = return_data.size
                        mem[_21066 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21066 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14778 + 100]
                        _22584 = mem[_14778 + 100]
                        idx = 0
                        while idx < _22584:
                            mem[_22582 + idx + 68] = mem[_14778 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22584 % 32:
                            revert with memory
                              from mem[64]
                               len _22584 + _22582 + -mem[64] + 68
                        mem[floor32(_22584) + _22582 + 68] = mem[floor32(_22584) + _22582 + -(_22584 % 32) + 100 len _22584 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22584) + _22582 + -mem[64] + 100
                    _13632 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13632] = 30
                    mem[_13632 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _14069 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14069 + idx + 68] = mem[_13632 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14069 + 68] = mem[_14069 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14069 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _14783 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _14784 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_14784 + 32] = mem[_14784 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _14783 + 164
                    mem[_14783 + 100] = 32
                    mem[_14783 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14783 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16377 = mem[_14784]
                    t = _14784 + 32
                    u = mem[64]
                    s = mem[_14784]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_14784])] = mem[_14784 + floor32(mem[_14784]) + -(mem[_14784] % 32) + 64 len mem[_14784] % 32] or Mask(8 * -(mem[_14784] % 32) + 32, -(8 * -(mem[_14784] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14784])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16377 + _14783 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22586 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14783 + 100]
                        _22588 = mem[_14783 + 100]
                        idx = 0
                        while idx < _22588:
                            mem[_22586 + idx + 68] = mem[_14783 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22588 % 32:
                            revert with memory
                              from mem[64]
                               len _22588 + _22586 + -mem[64] + 68
                        mem[floor32(_22588) + _22586 + 68] = mem[floor32(_22588) + _22586 + -(_22588 % 32) + 100 len _22588 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22588) + _22586 + -mem[64] + 100
                    _21069 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21069] = return_data.size
                    mem[_21069 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21069 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22590 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_14783 + 100]
                    _22592 = mem[_14783 + 100]
                    idx = 0
                    while idx < _22592:
                        mem[_22590 + idx + 68] = mem[_14783 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22592 % 32:
                        revert with memory
                          from mem[64]
                           len _22592 + _22590 + -mem[64] + 68
                    mem[floor32(_22592) + _22590 + 68] = mem[floor32(_22592) + _22590 + -(_22592 % 32) + 100 len _22592 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22592) + _22590 + -mem[64] + 100
                _13356 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13356] = 30
                mem[_13356 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _13628 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13628 + idx + 68] = mem[_13356 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13628 + 68] = mem[_13628 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _13628 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _14776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14776] = 30
                    mem[_14776 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15292 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15292 + idx + 68] = mem[_14776 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15292 + 68] = mem[_15292 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15292 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15994 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15995 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15995 + 32] = mem[_15995 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15994 + 164
                    mem[_15994 + 100] = 32
                    mem[_15994 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15994 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17177 = mem[_15995]
                    t = _15995 + 32
                    u = mem[64]
                    s = mem[_15995]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15995])] = mem[_15995 + floor32(mem[_15995]) + -(mem[_15995] % 32) + 64 len mem[_15995] % 32] or Mask(8 * -(mem[_15995] % 32) + 32, -(8 * -(mem[_15995] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15995])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17177 + _15994 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22562 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15994 + 100]
                        _22564 = mem[_15994 + 100]
                        idx = 0
                        while idx < _22564:
                            mem[_22562 + idx + 68] = mem[_15994 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22564 % 32:
                            revert with memory
                              from mem[64]
                               len _22564 + _22562 + -mem[64] + 68
                        mem[floor32(_22564) + _22562 + 68] = mem[floor32(_22564) + _22562 + -(_22564 % 32) + 100 len _22564 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22564) + _22562 + -mem[64] + 100
                    _21058 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_21058] = return_data.size
                    mem[_21058 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_21058 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22566 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15994 + 100]
                    _22568 = mem[_15994 + 100]
                    idx = 0
                    while idx < _22568:
                        mem[_22566 + idx + 68] = mem[_15994 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22568 % 32:
                        revert with memory
                          from mem[64]
                           len _22568 + _22566 + -mem[64] + 68
                    mem[floor32(_22568) + _22566 + 68] = mem[floor32(_22568) + _22566 + -(_22568 % 32) + 100 len _22568 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22568) + _22566 + -mem[64] + 100
                _14777 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14777] = 30
                mem[_14777 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15295 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15295 + idx + 68] = mem[_14777 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15295 + 68] = mem[_15295 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15295 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _15999 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _16000 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16000 + 32] = mem[_16000 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _15999 + 164
                mem[_15999 + 100] = 32
                mem[_15999 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15999 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17181 = mem[_16000]
                t = _16000 + 32
                u = mem[64]
                s = mem[_16000]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16000])] = mem[_16000 + floor32(mem[_16000]) + -(mem[_16000] % 32) + 64 len mem[_16000] % 32] or Mask(8 * -(mem[_16000] % 32) + 32, -(8 * -(mem[_16000] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16000])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17181 + _15999 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22570 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15999 + 100]
                    _22572 = mem[_15999 + 100]
                    idx = 0
                    while idx < _22572:
                        mem[_22570 + idx + 68] = mem[_15999 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22572 % 32:
                        revert with memory
                          from mem[64]
                           len _22572 + _22570 + -mem[64] + 68
                    mem[floor32(_22572) + _22570 + 68] = mem[floor32(_22572) + _22570 + -(_22572 % 32) + 100 len _22572 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22572) + _22570 + -mem[64] + 100
                _21061 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_21061] = return_data.size
                mem[_21061 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_21061 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22574 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_15999 + 100]
                _22576 = mem[_15999 + 100]
                idx = 0
                while idx < _22576:
                    mem[_22574 + idx + 68] = mem[_15999 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22576 % 32:
                    revert with memory
                      from mem[64]
                       len _22576 + _22574 + -mem[64] + 68
                mem[floor32(_22576) + _22574 + 68] = mem[floor32(_22576) + _22574 + -(_22576 % 32) + 100 len _22576 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22576) + _22574 + -mem[64] + 100
            _9920 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9920] = 30
            mem[_9920 + 32] = 'SafeMath: subtraction overflow'
            if sub_a090a2b4 > ext_call.return_data[0]:
                _9929 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9929 + idx + 68] = mem[_9920 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9929 + 68] = mem[_9929 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _9929 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            if ext_call.return_data[0] - sub_a090a2b4 == sub_5fc0d9e0[stor103[idx]]:
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                    _10088 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10088] = 26
                    mem[_10088 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10155 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10155 + idx + 68] = mem[_10088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10155 + 68] = mem[_10155 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10155 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10465 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10465] = 26
                    mem[_10465 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10536 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10536 + idx + 68] = mem[_10465 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10536 + 68] = mem[_10536 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10536 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10708 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10708] = 30
                    mem[_10708 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10826 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10826 + idx + 68] = mem[_10708 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10826 + 68] = mem[_10826 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10826 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11557] = 30
                            mem[_11557 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11755 + idx + 68] = mem[_11557 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11755 + 68] = mem[_11755 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11755 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12048 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12049 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12049 + 32] = mem[_12049 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12048 + 164
                            mem[_12048 + 100] = 32
                            mem[_12048 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12048 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12831 = mem[_12049]
                            t = _12049 + 32
                            u = mem[64]
                            s = mem[_12049]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12049])] = mem[_12049 + floor32(mem[_12049]) + -(mem[_12049] % 32) + 64 len mem[_12049] % 32] or Mask(8 * -(mem[_12049] % 32) + 32, -(8 * -(mem[_12049] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12049])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12831 + _12048 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12048 + 100]
                                _22292 = mem[_12048 + 100]
                                idx = 0
                                while idx < _22292:
                                    mem[_22290 + idx + 68] = mem[_12048 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22292 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22292 + _22290 + -mem[64] + 68
                                mem[floor32(_22292) + _22290 + 68] = mem[floor32(_22292) + _22290 + -(_22292 % 32) + 100 len _22292 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22292) + _22290 + -mem[64] + 100
                            _20878 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20878] = return_data.size
                            mem[_20878 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20878 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22294 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12048 + 100]
                            _22296 = mem[_12048 + 100]
                            idx = 0
                            while idx < _22296:
                                mem[_22294 + idx + 68] = mem[_12048 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22296 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22296 + _22294 + -mem[64] + 68
                            mem[floor32(_22296) + _22294 + 68] = mem[floor32(_22296) + _22294 + -(_22296 % 32) + 100 len _22296 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22296) + _22294 + -mem[64] + 100
                        _11558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11558] = 30
                        mem[_11558 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11758 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11758 + idx + 68] = mem[_11558 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11758 + 68] = mem[_11758 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11758 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _12053 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _12054 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12054 + 32] = mem[_12054 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12053 + 164
                        mem[_12053 + 100] = 32
                        mem[_12053 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12053 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12835 = mem[_12054]
                        t = _12054 + 32
                        u = mem[64]
                        s = mem[_12054]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12054])] = mem[_12054 + floor32(mem[_12054]) + -(mem[_12054] % 32) + 64 len mem[_12054] % 32] or Mask(8 * -(mem[_12054] % 32) + 32, -(8 * -(mem[_12054] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12054])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12835 + _12053 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22298 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12053 + 100]
                            _22300 = mem[_12053 + 100]
                            idx = 0
                            while idx < _22300:
                                mem[_22298 + idx + 68] = mem[_12053 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22300 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22300 + _22298 + -mem[64] + 68
                            mem[floor32(_22300) + _22298 + 68] = mem[floor32(_22300) + _22298 + -(_22300 % 32) + 100 len _22300 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22300) + _22298 + -mem[64] + 100
                        _20881 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20881] = return_data.size
                        mem[_20881 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20881 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12053 + 100]
                        _22304 = mem[_12053 + 100]
                        idx = 0
                        while idx < _22304:
                            mem[_22302 + idx + 68] = mem[_12053 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22304 % 32:
                            revert with memory
                              from mem[64]
                               len _22304 + _22302 + -mem[64] + 68
                        mem[floor32(_22304) + _22302 + 68] = mem[floor32(_22304) + _22302 + -(_22304 % 32) + 100 len _22304 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22304) + _22302 + -mem[64] + 100
                    _11431 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11431] = 30
                    mem[_11431 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11554 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11554 + idx + 68] = mem[_11431 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11554 + 68] = mem[_11554 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11554 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _12046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12046] = 30
                        mem[_12046 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12302 + idx + 68] = mem[_12046 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12302 + 68] = mem[_12302 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12302 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12619 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12620 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12620 + 32] = mem[_12620 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12619 + 164
                        mem[_12619 + 100] = 32
                        mem[_12619 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12619 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13454 = mem[_12620]
                        t = _12620 + 32
                        u = mem[64]
                        s = mem[_12620]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12620])] = mem[_12620 + floor32(mem[_12620]) + -(mem[_12620] % 32) + 64 len mem[_12620] % 32] or Mask(8 * -(mem[_12620] % 32) + 32, -(8 * -(mem[_12620] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12620])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13454 + _12619 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22274 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12619 + 100]
                            _22276 = mem[_12619 + 100]
                            idx = 0
                            while idx < _22276:
                                mem[_22274 + idx + 68] = mem[_12619 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22276 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22276 + _22274 + -mem[64] + 68
                            mem[floor32(_22276) + _22274 + 68] = mem[floor32(_22276) + _22274 + -(_22276 % 32) + 100 len _22276 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22276) + _22274 + -mem[64] + 100
                        _20870 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20870] = return_data.size
                        mem[_20870 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20870 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22278 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12619 + 100]
                        _22280 = mem[_12619 + 100]
                        idx = 0
                        while idx < _22280:
                            mem[_22278 + idx + 68] = mem[_12619 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22280 % 32:
                            revert with memory
                              from mem[64]
                               len _22280 + _22278 + -mem[64] + 68
                        mem[floor32(_22280) + _22278 + 68] = mem[floor32(_22280) + _22278 + -(_22280 % 32) + 100 len _22280 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22280) + _22278 + -mem[64] + 100
                    _12047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12047] = 30
                    mem[_12047 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12305 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12305 + idx + 68] = mem[_12047 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12305 + 68] = mem[_12305 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12305 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12624 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12625 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12625 + 32] = mem[_12625 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12624 + 164
                    mem[_12624 + 100] = 32
                    mem[_12624 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12624 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13458 = mem[_12625]
                    t = _12625 + 32
                    u = mem[64]
                    s = mem[_12625]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12625])] = mem[_12625 + floor32(mem[_12625]) + -(mem[_12625] % 32) + 64 len mem[_12625] % 32] or Mask(8 * -(mem[_12625] % 32) + 32, -(8 * -(mem[_12625] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12625])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13458 + _12624 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12624 + 100]
                        _22284 = mem[_12624 + 100]
                        idx = 0
                        while idx < _22284:
                            mem[_22282 + idx + 68] = mem[_12624 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22284 % 32:
                            revert with memory
                              from mem[64]
                               len _22284 + _22282 + -mem[64] + 68
                        mem[floor32(_22284) + _22282 + 68] = mem[floor32(_22284) + _22282 + -(_22284 % 32) + 100 len _22284 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22284) + _22282 + -mem[64] + 100
                    _20873 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20873] = return_data.size
                    mem[_20873 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20873 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22286 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12624 + 100]
                    _22288 = mem[_12624 + 100]
                    idx = 0
                    while idx < _22288:
                        mem[_22286 + idx + 68] = mem[_12624 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22288 % 32:
                        revert with memory
                          from mem[64]
                           len _22288 + _22286 + -mem[64] + 68
                    mem[floor32(_22288) + _22286 + 68] = mem[floor32(_22288) + _22286 + -(_22288 % 32) + 100 len _22288 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22288) + _22286 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10154 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10154] = 26
                mem[_10154 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10216 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10216 + idx + 68] = mem[_10154 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10216 + 68] = mem[_10216 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10216 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10535 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10535] = 26
                mem[_10535 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10627 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10627 + idx + 68] = mem[_10535 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10627 + 68] = mem[_10627 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10627 + -mem[64] + 100
                require sub_3c97d5ae
                _10824 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10824] = 30
                mem[_10824 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _10910 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10910 + idx + 68] = mem[_10824 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10910 + 68] = mem[_10910 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _10910 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _11752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11752] = 30
                        mem[_11752 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _11940 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11940 + idx + 68] = mem[_11752 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11940 + 68] = mem[_11940 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11940 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12292 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12293 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12293 + 32] = mem[_12293 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12292 + 164
                        mem[_12292 + 100] = 32
                        mem[_12292 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12292 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13037 = mem[_12293]
                        t = _12293 + 32
                        u = mem[64]
                        s = mem[_12293]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12293])] = mem[_12293 + floor32(mem[_12293]) + -(mem[_12293] % 32) + 64 len mem[_12293] % 32] or Mask(8 * -(mem[_12293] % 32) + 32, -(8 * -(mem[_12293] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12293])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13037 + _12292 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12292 + 100]
                            _22260 = mem[_12292 + 100]
                            idx = 0
                            while idx < _22260:
                                mem[_22258 + idx + 68] = mem[_12292 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22260 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22260 + _22258 + -mem[64] + 68
                            mem[floor32(_22260) + _22258 + 68] = mem[floor32(_22260) + _22258 + -(_22260 % 32) + 100 len _22260 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22260) + _22258 + -mem[64] + 100
                        _20858 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20858] = return_data.size
                        mem[_20858 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20858 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22262 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12292 + 100]
                        _22264 = mem[_12292 + 100]
                        idx = 0
                        while idx < _22264:
                            mem[_22262 + idx + 68] = mem[_12292 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22264 % 32:
                            revert with memory
                              from mem[64]
                               len _22264 + _22262 + -mem[64] + 68
                        mem[floor32(_22264) + _22262 + 68] = mem[floor32(_22264) + _22262 + -(_22264 % 32) + 100 len _22264 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22264) + _22262 + -mem[64] + 100
                    _11753 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11753] = 30
                    mem[_11753 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _11943 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11943 + idx + 68] = mem[_11753 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11943 + 68] = mem[_11943 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11943 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _12297 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _12298 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12298 + 32] = mem[_12298 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12297 + 164
                    mem[_12297 + 100] = 32
                    mem[_12297 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12297 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13041 = mem[_12298]
                    t = _12298 + 32
                    u = mem[64]
                    s = mem[_12298]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12298])] = mem[_12298 + floor32(mem[_12298]) + -(mem[_12298] % 32) + 64 len mem[_12298] % 32] or Mask(8 * -(mem[_12298] % 32) + 32, -(8 * -(mem[_12298] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12298])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13041 + _12297 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22266 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12297 + 100]
                        _22268 = mem[_12297 + 100]
                        idx = 0
                        while idx < _22268:
                            mem[_22266 + idx + 68] = mem[_12297 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22268 % 32:
                            revert with memory
                              from mem[64]
                               len _22268 + _22266 + -mem[64] + 68
                        mem[floor32(_22268) + _22266 + 68] = mem[floor32(_22268) + _22266 + -(_22268 % 32) + 100 len _22268 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22268) + _22266 + -mem[64] + 100
                    _20861 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20861] = return_data.size
                    mem[_20861 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20861 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22270 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12297 + 100]
                    _22272 = mem[_12297 + 100]
                    idx = 0
                    while idx < _22272:
                        mem[_22270 + idx + 68] = mem[_12297 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22272 % 32:
                        revert with memory
                          from mem[64]
                           len _22272 + _22270 + -mem[64] + 68
                    mem[floor32(_22272) + _22270 + 68] = mem[floor32(_22272) + _22270 + -(_22272 % 32) + 100 len _22272 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22272) + _22270 + -mem[64] + 100
                _11553 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11553] = 30
                mem[_11553 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _11749 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_11749 + idx + 68] = mem[_11553 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11749 + 68] = mem[_11749 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _11749 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _12290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12290] = 30
                    mem[_12290 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _12516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12516 + idx + 68] = mem[_12290 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12516 + 68] = mem[_12516 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12516 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12820 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12821 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12821 + 32] = mem[_12821 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12820 + 164
                    mem[_12820 + 100] = 32
                    mem[_12820 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12820 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13777 = mem[_12821]
                    t = _12821 + 32
                    u = mem[64]
                    s = mem[_12821]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12821])] = mem[_12821 + floor32(mem[_12821]) + -(mem[_12821] % 32) + 64 len mem[_12821] % 32] or Mask(8 * -(mem[_12821] % 32) + 32, -(8 * -(mem[_12821] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12821])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13777 + _12820 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22242 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12820 + 100]
                        _22244 = mem[_12820 + 100]
                        s = 0
                        while s < _22244:
                            mem[_22242 + s + 68] = mem[_12820 + s + 132]
                            s = s + 32
                            continue 
                        if not _22244 % 32:
                            revert with memory
                              from mem[64]
                               len _22244 + _22242 + -mem[64] + 68
                        mem[floor32(_22244) + _22242 + 68] = mem[floor32(_22244) + _22242 + -(_22244 % 32) + 100 len _22244 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22244) + _22242 + -mem[64] + 100
                    _20850 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20850] = return_data.size
                    mem[_20850 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20850 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22246 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12820 + 100]
                    _22248 = mem[_12820 + 100]
                    s = 0
                    while s < _22248:
                        mem[_22246 + s + 68] = mem[_12820 + s + 132]
                        s = s + 32
                        continue 
                    if not _22248 % 32:
                        revert with memory
                          from mem[64]
                           len _22248 + _22246 + -mem[64] + 68
                    mem[floor32(_22248) + _22246 + 68] = mem[floor32(_22248) + _22246 + -(_22248 % 32) + 100 len _22248 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22248) + _22246 + -mem[64] + 100
                _12291 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12291] = 30
                mem[_12291 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _12519 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12519 + idx + 68] = mem[_12291 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12519 + 68] = mem[_12519 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12519 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _12825 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _12826 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12826 + 32] = mem[_12826 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _12825 + 164
                mem[_12825 + 100] = 32
                mem[_12825 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12825 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _13781 = mem[_12826]
                t = _12826 + 32
                u = mem[64]
                s = mem[_12826]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_12826])] = mem[_12826 + floor32(mem[_12826]) + -(mem[_12826] % 32) + 64 len mem[_12826] % 32] or Mask(8 * -(mem[_12826] % 32) + 32, -(8 * -(mem[_12826] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12826])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13781 + _12825 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22250 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12825 + 100]
                    _22252 = mem[_12825 + 100]
                    s = 0
                    while s < _22252:
                        mem[_22250 + s + 68] = mem[_12825 + s + 132]
                        s = s + 32
                        continue 
                    if not _22252 % 32:
                        revert with memory
                          from mem[64]
                           len _22252 + _22250 + -mem[64] + 68
                    mem[floor32(_22252) + _22250 + 68] = mem[floor32(_22252) + _22250 + -(_22252 % 32) + 100 len _22252 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22252) + _22250 + -mem[64] + 100
                _20853 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20853] = return_data.size
                mem[_20853 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20853 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22254 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_12825 + 100]
                _22256 = mem[_12825 + 100]
                s = 0
                while s < _22256:
                    mem[_22254 + s + 68] = mem[_12825 + s + 132]
                    s = s + 32
                    continue 
                if not _22256 % 32:
                    revert with memory
                      from mem[64]
                       len _22256 + _22254 + -mem[64] + 68
                mem[floor32(_22256) + _22254 + 68] = mem[floor32(_22256) + _22254 + -(_22256 % 32) + 100 len _22256 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22256) + _22254 + -mem[64] + 100
            if not sub_a090a2b4:
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                    _10125 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10125] = 26
                    mem[_10125 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10186 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10186 + idx + 68] = mem[_10125 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10186 + 68] = mem[_10186 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10186 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10517 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10517] = 26
                    mem[_10517 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10583 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10583 + idx + 68] = mem[_10517 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10583 + 68] = mem[_10583 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10583 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10757 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10757] = 30
                    mem[_10757 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10863 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10863 + idx + 68] = mem[_10757 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10863 + 68] = mem[_10863 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10863 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11661] = 30
                            mem[_11661 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11859 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11859 + idx + 68] = mem[_11661 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11859 + 68] = mem[_11859 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11859 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12188 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12189 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12189 + 32] = mem[_12189 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12188 + 164
                            mem[_12188 + 100] = 32
                            mem[_12188 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12188 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12938 = mem[_12189]
                            t = _12189 + 32
                            u = mem[64]
                            s = mem[_12189]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12189])] = mem[_12189 + floor32(mem[_12189]) + -(mem[_12189] % 32) + 64 len mem[_12189] % 32] or Mask(8 * -(mem[_12189] % 32) + 32, -(8 * -(mem[_12189] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12189])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12938 + _12188 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22482 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12188 + 100]
                                _22484 = mem[_12188 + 100]
                                idx = 0
                                while idx < _22484:
                                    mem[_22482 + idx + 68] = mem[_12188 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22484 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22484 + _22482 + -mem[64] + 68
                                mem[floor32(_22484) + _22482 + 68] = mem[floor32(_22484) + _22482 + -(_22484 % 32) + 100 len _22484 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22484) + _22482 + -mem[64] + 100
                            _21004 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_21004] = return_data.size
                            mem[_21004 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_21004 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22486 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12188 + 100]
                            _22488 = mem[_12188 + 100]
                            idx = 0
                            while idx < _22488:
                                mem[_22486 + idx + 68] = mem[_12188 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22488 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22488 + _22486 + -mem[64] + 68
                            mem[floor32(_22488) + _22486 + 68] = mem[floor32(_22488) + _22486 + -(_22488 % 32) + 100 len _22488 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22488) + _22486 + -mem[64] + 100
                        _11662 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11662] = 30
                        mem[_11662 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11862 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11862 + idx + 68] = mem[_11662 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11862 + 68] = mem[_11862 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11862 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _12193 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _12194 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12194 + 32] = mem[_12194 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12193 + 164
                        mem[_12193 + 100] = 32
                        mem[_12193 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12193 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12942 = mem[_12194]
                        t = _12194 + 32
                        u = mem[64]
                        s = mem[_12194]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12194])] = mem[_12194 + floor32(mem[_12194]) + -(mem[_12194] % 32) + 64 len mem[_12194] % 32] or Mask(8 * -(mem[_12194] % 32) + 32, -(8 * -(mem[_12194] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12194])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12942 + _12193 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22490 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12193 + 100]
                            _22492 = mem[_12193 + 100]
                            idx = 0
                            while idx < _22492:
                                mem[_22490 + idx + 68] = mem[_12193 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22492 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22492 + _22490 + -mem[64] + 68
                            mem[floor32(_22492) + _22490 + 68] = mem[floor32(_22492) + _22490 + -(_22492 % 32) + 100 len _22492 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22492) + _22490 + -mem[64] + 100
                        _21007 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_21007] = return_data.size
                        mem[_21007 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_21007 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22494 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12193 + 100]
                        _22496 = mem[_12193 + 100]
                        idx = 0
                        while idx < _22496:
                            mem[_22494 + idx + 68] = mem[_12193 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22496 % 32:
                            revert with memory
                              from mem[64]
                               len _22496 + _22494 + -mem[64] + 68
                        mem[floor32(_22496) + _22494 + 68] = mem[floor32(_22496) + _22494 + -(_22496 % 32) + 100 len _22496 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22496) + _22494 + -mem[64] + 100
                    _11484 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11484] = 30
                    mem[_11484 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11658 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11658 + idx + 68] = mem[_11484 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11658 + 68] = mem[_11658 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11658 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _12186 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12186] = 30
                        mem[_12186 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12436 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12436 + idx + 68] = mem[_12186 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12436 + 68] = mem[_12436 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12436 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12732 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12733 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12733 + 32] = mem[_12733 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12732 + 164
                        mem[_12732 + 100] = 32
                        mem[_12732 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12732 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13605 = mem[_12733]
                        t = _12733 + 32
                        u = mem[64]
                        s = mem[_12733]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12733])] = mem[_12733 + floor32(mem[_12733]) + -(mem[_12733] % 32) + 64 len mem[_12733] % 32] or Mask(8 * -(mem[_12733] % 32) + 32, -(8 * -(mem[_12733] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12733])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13605 + _12732 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12732 + 100]
                            _22468 = mem[_12732 + 100]
                            idx = 0
                            while idx < _22468:
                                mem[_22466 + idx + 68] = mem[_12732 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22468 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22468 + _22466 + -mem[64] + 68
                            mem[floor32(_22468) + _22466 + 68] = mem[floor32(_22468) + _22466 + -(_22468 % 32) + 100 len _22468 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22468) + _22466 + -mem[64] + 100
                        _20996 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20996] = return_data.size
                        mem[_20996 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20996 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12732 + 100]
                        _22472 = mem[_12732 + 100]
                        idx = 0
                        while idx < _22472:
                            mem[_22470 + idx + 68] = mem[_12732 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22472 % 32:
                            revert with memory
                              from mem[64]
                               len _22472 + _22470 + -mem[64] + 68
                        mem[floor32(_22472) + _22470 + 68] = mem[floor32(_22472) + _22470 + -(_22472 % 32) + 100 len _22472 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22472) + _22470 + -mem[64] + 100
                    _12187 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12187] = 30
                    mem[_12187 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12439 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12439 + idx + 68] = mem[_12187 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12439 + 68] = mem[_12439 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12439 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12737 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12738 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12738 + 32] = mem[_12738 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12737 + 164
                    mem[_12737 + 100] = 32
                    mem[_12737 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12737 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13609 = mem[_12738]
                    t = _12738 + 32
                    u = mem[64]
                    s = mem[_12738]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12738])] = mem[_12738 + floor32(mem[_12738]) + -(mem[_12738] % 32) + 64 len mem[_12738] % 32] or Mask(8 * -(mem[_12738] % 32) + 32, -(8 * -(mem[_12738] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12738])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13609 + _12737 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12737 + 100]
                        _22476 = mem[_12737 + 100]
                        idx = 0
                        while idx < _22476:
                            mem[_22474 + idx + 68] = mem[_12737 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22476 % 32:
                            revert with memory
                              from mem[64]
                               len _22476 + _22474 + -mem[64] + 68
                        mem[floor32(_22476) + _22474 + 68] = mem[floor32(_22476) + _22474 + -(_22476 % 32) + 100 len _22476 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22476) + _22474 + -mem[64] + 100
                    _20999 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20999] = return_data.size
                    mem[_20999 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20999 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22478 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12737 + 100]
                    _22480 = mem[_12737 + 100]
                    idx = 0
                    while idx < _22480:
                        mem[_22478 + idx + 68] = mem[_12737 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22480 % 32:
                        revert with memory
                          from mem[64]
                           len _22480 + _22478 + -mem[64] + 68
                    mem[floor32(_22480) + _22478 + 68] = mem[floor32(_22480) + _22478 + -(_22480 % 32) + 100 len _22480 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22480) + _22478 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10185 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10185] = 26
                mem[_10185 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10240 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10240 + idx + 68] = mem[_10185 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10240 + 68] = mem[_10240 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10240 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10582 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10582] = 26
                mem[_10582 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10660 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10660 + idx + 68] = mem[_10582 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10660 + 68] = mem[_10660 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10660 + -mem[64] + 100
                require sub_3c97d5ae
                _10861 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10861] = 30
                mem[_10861 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _11005 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_11005 + idx + 68] = mem[_10861 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11005 + 68] = mem[_11005 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _11005 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _11856 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11856] = 30
                        mem[_11856 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12063 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12063 + idx + 68] = mem[_11856 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12063 + 68] = mem[_12063 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12063 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12426 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12427 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12427 + 32] = mem[_12427 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12426 + 164
                        mem[_12426 + 100] = 32
                        mem[_12426 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12426 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13179 = mem[_12427]
                        t = _12427 + 32
                        u = mem[64]
                        s = mem[_12427]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12427])] = mem[_12427 + floor32(mem[_12427]) + -(mem[_12427] % 32) + 64 len mem[_12427] % 32] or Mask(8 * -(mem[_12427] % 32) + 32, -(8 * -(mem[_12427] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12427])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13179 + _12426 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22450 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12426 + 100]
                            _22452 = mem[_12426 + 100]
                            idx = 0
                            while idx < _22452:
                                mem[_22450 + idx + 68] = mem[_12426 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22452 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22452 + _22450 + -mem[64] + 68
                            mem[floor32(_22452) + _22450 + 68] = mem[floor32(_22452) + _22450 + -(_22452 % 32) + 100 len _22452 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22452) + _22450 + -mem[64] + 100
                        _20984 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20984] = return_data.size
                        mem[_20984 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20984 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12426 + 100]
                        _22456 = mem[_12426 + 100]
                        idx = 0
                        while idx < _22456:
                            mem[_22454 + idx + 68] = mem[_12426 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22456 % 32:
                            revert with memory
                              from mem[64]
                               len _22456 + _22454 + -mem[64] + 68
                        mem[floor32(_22456) + _22454 + 68] = mem[floor32(_22456) + _22454 + -(_22456 % 32) + 100 len _22456 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22456) + _22454 + -mem[64] + 100
                    _11857 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11857] = 30
                    mem[_11857 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _12066 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12066 + idx + 68] = mem[_11857 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12066 + 68] = mem[_12066 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12066 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _12431 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _12432 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12432 + 32] = mem[_12432 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12431 + 164
                    mem[_12431 + 100] = 32
                    mem[_12431 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12431 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13183 = mem[_12432]
                    t = _12432 + 32
                    u = mem[64]
                    s = mem[_12432]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12432])] = mem[_12432 + floor32(mem[_12432]) + -(mem[_12432] % 32) + 64 len mem[_12432] % 32] or Mask(8 * -(mem[_12432] % 32) + 32, -(8 * -(mem[_12432] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12432])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13183 + _12431 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22458 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12431 + 100]
                        _22460 = mem[_12431 + 100]
                        idx = 0
                        while idx < _22460:
                            mem[_22458 + idx + 68] = mem[_12431 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22460 % 32:
                            revert with memory
                              from mem[64]
                               len _22460 + _22458 + -mem[64] + 68
                        mem[floor32(_22460) + _22458 + 68] = mem[floor32(_22460) + _22458 + -(_22460 % 32) + 100 len _22460 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22460) + _22458 + -mem[64] + 100
                    _20987 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20987] = return_data.size
                    mem[_20987 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20987 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22462 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12431 + 100]
                    _22464 = mem[_12431 + 100]
                    idx = 0
                    while idx < _22464:
                        mem[_22462 + idx + 68] = mem[_12431 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22464 % 32:
                        revert with memory
                          from mem[64]
                           len _22464 + _22462 + -mem[64] + 68
                    mem[floor32(_22464) + _22462 + 68] = mem[floor32(_22464) + _22462 + -(_22464 % 32) + 100 len _22464 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22464) + _22462 + -mem[64] + 100
                _11657 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11657] = 30
                mem[_11657 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _11853 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_11853 + idx + 68] = mem[_11657 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11853 + 68] = mem[_11853 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _11853 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _12424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12424] = 30
                    mem[_12424 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _12635 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12635 + idx + 68] = mem[_12424 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12635 + 68] = mem[_12635 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12635 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12927 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12928 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12928 + 32] = mem[_12928 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12927 + 164
                    mem[_12927 + 100] = 32
                    mem[_12927 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12927 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _14014 = mem[_12928]
                    t = _12928 + 32
                    u = mem[64]
                    s = mem[_12928]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12928])] = mem[_12928 + floor32(mem[_12928]) + -(mem[_12928] % 32) + 64 len mem[_12928] % 32] or Mask(8 * -(mem[_12928] % 32) + 32, -(8 * -(mem[_12928] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12928])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _14014 + _12927 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22434 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12927 + 100]
                        _22436 = mem[_12927 + 100]
                        idx = 0
                        while idx < _22436:
                            mem[_22434 + idx + 68] = mem[_12927 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22436 % 32:
                            revert with memory
                              from mem[64]
                               len _22436 + _22434 + -mem[64] + 68
                        mem[floor32(_22436) + _22434 + 68] = mem[floor32(_22436) + _22434 + -(_22436 % 32) + 100 len _22436 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22436) + _22434 + -mem[64] + 100
                    _20976 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20976] = return_data.size
                    mem[_20976 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20976 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22438 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12927 + 100]
                    _22440 = mem[_12927 + 100]
                    idx = 0
                    while idx < _22440:
                        mem[_22438 + idx + 68] = mem[_12927 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22440 % 32:
                        revert with memory
                          from mem[64]
                           len _22440 + _22438 + -mem[64] + 68
                    mem[floor32(_22440) + _22438 + 68] = mem[floor32(_22440) + _22438 + -(_22440 % 32) + 100 len _22440 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22440) + _22438 + -mem[64] + 100
                _12425 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12425] = 30
                mem[_12425 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _12638 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12638 + idx + 68] = mem[_12425 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12638 + 68] = mem[_12638 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12638 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _12932 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _12933 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12933 + 32] = mem[_12933 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _12932 + 164
                mem[_12932 + 100] = 32
                mem[_12932 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12932 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _14018 = mem[_12933]
                t = _12933 + 32
                u = mem[64]
                s = mem[_12933]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_12933])] = mem[_12933 + floor32(mem[_12933]) + -(mem[_12933] % 32) + 64 len mem[_12933] % 32] or Mask(8 * -(mem[_12933] % 32) + 32, -(8 * -(mem[_12933] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12933])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _14018 + _12932 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22442 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12932 + 100]
                    _22444 = mem[_12932 + 100]
                    idx = 0
                    while idx < _22444:
                        mem[_22442 + idx + 68] = mem[_12932 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22444 % 32:
                        revert with memory
                          from mem[64]
                           len _22444 + _22442 + -mem[64] + 68
                    mem[floor32(_22444) + _22442 + 68] = mem[floor32(_22444) + _22442 + -(_22444 % 32) + 100 len _22444 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22444) + _22442 + -mem[64] + 100
                _20979 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20979] = return_data.size
                mem[_20979 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20979 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22446 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_12932 + 100]
                _22448 = mem[_12932 + 100]
                idx = 0
                while idx < _22448:
                    mem[_22446 + idx + 68] = mem[_12932 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22448 % 32:
                    revert with memory
                      from mem[64]
                       len _22448 + _22446 + -mem[64] + 68
                mem[floor32(_22448) + _22446 + 68] = mem[floor32(_22448) + _22446 + -(_22448 % 32) + 100 len _22448 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22448) + _22446 + -mem[64] + 100
            mem[32] = 105
            _9996 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9996] = 30
            mem[_9996 + 32] = 'SafeMath: subtraction overflow'
            if sub_5fc0d9e0[stor103[idx]] > ext_call.return_data[0] - sub_a090a2b4:
                _10021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_10021 + idx + 68] = mem[_9996 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10021 + 68] = mem[_10021 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _10021 + -mem[64] + 100
            if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]]:
                _10220 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10220] = 26
                mem[_10220 + 32] = 'SafeMath: division by zero'
                if sub_a090a2b4 <= 0:
                    _10269 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10269 + idx + 68] = mem[_10220 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10269 + 68] = mem[_10269 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10269 + -mem[64] + 100
                require sub_a090a2b4
                if sub_5dcea4d4[stor103[idx]] + (0 / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 'SafeMath: addition overflow'
                sub_5dcea4d4[stor103[idx]] += 0 / sub_a090a2b4
                sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0] - sub_a090a2b4
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                    _10710 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10710] = 26
                    mem[_10710 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10831 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10831 + idx + 68] = mem[_10710 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10831 + 68] = mem[_10831 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10831 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11432] = 26
                    mem[_11432 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11561 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11561 + idx + 68] = mem[_11432 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11561 + 68] = mem[_11561 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11561 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11958 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11958] = 30
                    mem[_11958 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _12181 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12181 + idx + 68] = mem[_11958 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12181 + 68] = mem[_12181 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12181 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13814 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13814] = 30
                            mem[_13814 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _14290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14290 + idx + 68] = mem[_13814 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14290 + 68] = mem[_14290 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14290 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14980 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14981 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14981 + 32] = mem[_14981 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14980 + 164
                            mem[_14980 + 100] = 32
                            mem[_14980 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14980 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16529 = mem[_14981]
                            t = _14981 + 32
                            u = mem[64]
                            s = mem[_14981]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14981])] = mem[_14981 + floor32(mem[_14981]) + -(mem[_14981] % 32) + 64 len mem[_14981] % 32] or Mask(8 * -(mem[_14981] % 32) + 32, -(8 * -(mem[_14981] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14981])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16529 + _14980 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14980 + 100]
                                _22420 = mem[_14980 + 100]
                                idx = 0
                                while idx < _22420:
                                    mem[_22418 + idx + 68] = mem[_14980 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22420 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22420 + _22418 + -mem[64] + 68
                                mem[floor32(_22420) + _22418 + 68] = mem[floor32(_22420) + _22418 + -(_22420 % 32) + 100 len _22420 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22420) + _22418 + -mem[64] + 100
                            _20960 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20960] = return_data.size
                            mem[_20960 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20960 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22422 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14980 + 100]
                            _22424 = mem[_14980 + 100]
                            idx = 0
                            while idx < _22424:
                                mem[_22422 + idx + 68] = mem[_14980 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22424 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22424 + _22422 + -mem[64] + 68
                            mem[floor32(_22424) + _22422 + 68] = mem[floor32(_22424) + _22422 + -(_22424 % 32) + 100 len _22424 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22424) + _22422 + -mem[64] + 100
                        _13815 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13815] = 30
                        mem[_13815 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _14293 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14293 + idx + 68] = mem[_13815 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14293 + 68] = mem[_14293 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14293 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14985 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14986 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14986 + 32] = mem[_14986 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14985 + 164
                        mem[_14985 + 100] = 32
                        mem[_14985 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14985 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16533 = mem[_14986]
                        t = _14986 + 32
                        u = mem[64]
                        s = mem[_14986]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14986])] = mem[_14986 + floor32(mem[_14986]) + -(mem[_14986] % 32) + 64 len mem[_14986] % 32] or Mask(8 * -(mem[_14986] % 32) + 32, -(8 * -(mem[_14986] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14986])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16533 + _14985 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14985 + 100]
                            _22428 = mem[_14985 + 100]
                            idx = 0
                            while idx < _22428:
                                mem[_22426 + idx + 68] = mem[_14985 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22428 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22428 + _22426 + -mem[64] + 68
                            mem[floor32(_22428) + _22426 + 68] = mem[floor32(_22428) + _22426 + -(_22428 % 32) + 100 len _22428 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22428) + _22426 + -mem[64] + 100
                        _20963 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20963] = return_data.size
                        mem[_20963 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20963 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22430 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14985 + 100]
                        _22432 = mem[_14985 + 100]
                        idx = 0
                        while idx < _22432:
                            mem[_22430 + idx + 68] = mem[_14985 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22432 % 32:
                            revert with memory
                              from mem[64]
                               len _22432 + _22430 + -mem[64] + 68
                        mem[floor32(_22432) + _22430 + 68] = mem[floor32(_22432) + _22430 + -(_22432 % 32) + 100 len _22432 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22432) + _22430 + -mem[64] + 100
                    _13463 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13463] = 30
                    mem[_13463 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13811 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13811 + idx + 68] = mem[_13463 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13811 + 68] = mem[_13811 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13811 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14978] = 30
                        mem[_14978 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _15524 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15524 + idx + 68] = mem[_14978 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15524 + 68] = mem[_15524 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15524 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _16148 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _16149 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_16149 + 32] = mem[_16149 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _16148 + 164
                        mem[_16148 + 100] = 32
                        mem[_16148 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16148 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _17297 = mem[_16149]
                        t = _16149 + 32
                        u = mem[64]
                        s = mem[_16149]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_16149])] = mem[_16149 + floor32(mem[_16149]) + -(mem[_16149] % 32) + 64 len mem[_16149] % 32] or Mask(8 * -(mem[_16149] % 32) + 32, -(8 * -(mem[_16149] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16149])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _17297 + _16148 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_16148 + 100]
                            _22404 = mem[_16148 + 100]
                            idx = 0
                            while idx < _22404:
                                mem[_22402 + idx + 68] = mem[_16148 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22404 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22404 + _22402 + -mem[64] + 68
                            mem[floor32(_22404) + _22402 + 68] = mem[floor32(_22404) + _22402 + -(_22404 % 32) + 100 len _22404 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22404) + _22402 + -mem[64] + 100
                        _20952 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20952] = return_data.size
                        mem[_20952 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20952 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16148 + 100]
                        _22408 = mem[_16148 + 100]
                        idx = 0
                        while idx < _22408:
                            mem[_22406 + idx + 68] = mem[_16148 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22408 % 32:
                            revert with memory
                              from mem[64]
                               len _22408 + _22406 + -mem[64] + 68
                        mem[floor32(_22408) + _22406 + 68] = mem[floor32(_22408) + _22406 + -(_22408 % 32) + 100 len _22408 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22408) + _22406 + -mem[64] + 100
                    _14979 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14979] = 30
                    mem[_14979 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _15527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15527 + idx + 68] = mem[_14979 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15527 + 68] = mem[_15527 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15527 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _16153 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _16154 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16154 + 32] = mem[_16154 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16153 + 164
                    mem[_16153 + 100] = 32
                    mem[_16153 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16153 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17301 = mem[_16154]
                    t = _16154 + 32
                    u = mem[64]
                    s = mem[_16154]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16154])] = mem[_16154 + floor32(mem[_16154]) + -(mem[_16154] % 32) + 64 len mem[_16154] % 32] or Mask(8 * -(mem[_16154] % 32) + 32, -(8 * -(mem[_16154] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16154])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17301 + _16153 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16153 + 100]
                        _22412 = mem[_16153 + 100]
                        idx = 0
                        while idx < _22412:
                            mem[_22410 + idx + 68] = mem[_16153 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22412 % 32:
                            revert with memory
                              from mem[64]
                               len _22412 + _22410 + -mem[64] + 68
                        mem[floor32(_22412) + _22410 + 68] = mem[floor32(_22412) + _22410 + -(_22412 % 32) + 100 len _22412 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22412) + _22410 + -mem[64] + 100
                    _20955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20955] = return_data.size
                    mem[_20955 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20955 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22414 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16153 + 100]
                    _22416 = mem[_16153 + 100]
                    idx = 0
                    while idx < _22416:
                        mem[_22414 + idx + 68] = mem[_16153 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22416 % 32:
                        revert with memory
                          from mem[64]
                           len _22416 + _22414 + -mem[64] + 68
                    mem[floor32(_22416) + _22414 + 68] = mem[floor32(_22416) + _22414 + -(_22416 % 32) + 100 len _22416 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22416) + _22414 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10830 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10830] = 26
                mem[_10830 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10918 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10918 + idx + 68] = mem[_10830 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10918 + 68] = mem[_10918 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10918 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11560 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11560] = 26
                mem[_11560 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11765 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11765 + idx + 68] = mem[_11560 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11765 + 68] = mem[_11765 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11765 + -mem[64] + 100
                require sub_3c97d5ae
                _12179 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12179] = 30
                mem[_12179 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12420 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12420 + idx + 68] = mem[_12179 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12420 + 68] = mem[_12420 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12420 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _14287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14287] = 30
                        mem[_14287 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14737 + idx + 68] = mem[_14287 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14737 + 68] = mem[_14737 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14737 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15514 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15515 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15515 + 32] = mem[_15515 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15514 + 164
                        mem[_15514 + 100] = 32
                        mem[_15514 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15514 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16847 = mem[_15515]
                        t = _15515 + 32
                        u = mem[64]
                        s = mem[_15515]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15515])] = mem[_15515 + floor32(mem[_15515]) + -(mem[_15515] % 32) + 64 len mem[_15515] % 32] or Mask(8 * -(mem[_15515] % 32) + 32, -(8 * -(mem[_15515] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15515])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16847 + _15514 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22386 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15514 + 100]
                            _22388 = mem[_15514 + 100]
                            idx = 0
                            while idx < _22388:
                                mem[_22386 + idx + 68] = mem[_15514 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22388 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22388 + _22386 + -mem[64] + 68
                            mem[floor32(_22388) + _22386 + 68] = mem[floor32(_22388) + _22386 + -(_22388 % 32) + 100 len _22388 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22388) + _22386 + -mem[64] + 100
                        _20940 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20940] = return_data.size
                        mem[_20940 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20940 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15514 + 100]
                        _22392 = mem[_15514 + 100]
                        idx = 0
                        while idx < _22392:
                            mem[_22390 + idx + 68] = mem[_15514 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22392 % 32:
                            revert with memory
                              from mem[64]
                               len _22392 + _22390 + -mem[64] + 68
                        mem[floor32(_22392) + _22390 + 68] = mem[floor32(_22392) + _22390 + -(_22392 % 32) + 100 len _22392 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22392) + _22390 + -mem[64] + 100
                    _14288 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14288] = 30
                    mem[_14288 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _14740 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14740 + idx + 68] = mem[_14288 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14740 + 68] = mem[_14740 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14740 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _15519 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _15520 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15520 + 32] = mem[_15520 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15519 + 164
                    mem[_15519 + 100] = 32
                    mem[_15519 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15519 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16851 = mem[_15520]
                    t = _15520 + 32
                    u = mem[64]
                    s = mem[_15520]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15520])] = mem[_15520 + floor32(mem[_15520]) + -(mem[_15520] % 32) + 64 len mem[_15520] % 32] or Mask(8 * -(mem[_15520] % 32) + 32, -(8 * -(mem[_15520] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15520])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16851 + _15519 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22394 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15519 + 100]
                        _22396 = mem[_15519 + 100]
                        idx = 0
                        while idx < _22396:
                            mem[_22394 + idx + 68] = mem[_15519 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22396 % 32:
                            revert with memory
                              from mem[64]
                               len _22396 + _22394 + -mem[64] + 68
                        mem[floor32(_22396) + _22394 + 68] = mem[floor32(_22396) + _22394 + -(_22396 % 32) + 100 len _22396 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22396) + _22394 + -mem[64] + 100
                    _20943 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20943] = return_data.size
                    mem[_20943 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20943 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22398 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15519 + 100]
                    _22400 = mem[_15519 + 100]
                    idx = 0
                    while idx < _22400:
                        mem[_22398 + idx + 68] = mem[_15519 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22400 % 32:
                        revert with memory
                          from mem[64]
                           len _22400 + _22398 + -mem[64] + 68
                    mem[floor32(_22400) + _22398 + 68] = mem[floor32(_22400) + _22398 + -(_22400 % 32) + 100 len _22400 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22400) + _22398 + -mem[64] + 100
                _13810 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13810] = 30
                mem[_13810 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _14284 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14284 + idx + 68] = mem[_13810 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14284 + 68] = mem[_14284 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _14284 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _15512 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15512] = 30
                    mem[_15512 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15960 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15960 + idx + 68] = mem[_15512 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15960 + 68] = mem[_15960 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15960 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16518 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16519 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16519 + 32] = mem[_16519 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16518 + 164
                    mem[_16518 + 100] = 32
                    mem[_16518 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16518 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17583 = mem[_16519]
                    t = _16519 + 32
                    u = mem[64]
                    s = mem[_16519]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16519])] = mem[_16519 + floor32(mem[_16519]) + -(mem[_16519] % 32) + 64 len mem[_16519] % 32] or Mask(8 * -(mem[_16519] % 32) + 32, -(8 * -(mem[_16519] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16519])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17583 + _16518 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22370 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16518 + 100]
                        _22372 = mem[_16518 + 100]
                        idx = 0
                        while idx < _22372:
                            mem[_22370 + idx + 68] = mem[_16518 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22372 % 32:
                            revert with memory
                              from mem[64]
                               len _22372 + _22370 + -mem[64] + 68
                        mem[floor32(_22372) + _22370 + 68] = mem[floor32(_22372) + _22370 + -(_22372 % 32) + 100 len _22372 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22372) + _22370 + -mem[64] + 100
                    _20932 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20932] = return_data.size
                    mem[_20932 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20932 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22374 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16518 + 100]
                    _22376 = mem[_16518 + 100]
                    idx = 0
                    while idx < _22376:
                        mem[_22374 + idx + 68] = mem[_16518 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22376 % 32:
                        revert with memory
                          from mem[64]
                           len _22376 + _22374 + -mem[64] + 68
                    mem[floor32(_22376) + _22374 + 68] = mem[floor32(_22376) + _22374 + -(_22376 % 32) + 100 len _22376 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22376) + _22374 + -mem[64] + 100
                _15513 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15513] = 30
                mem[_15513 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15963 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15963 + idx + 68] = mem[_15513 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15963 + 68] = mem[_15963 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15963 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _16523 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _16524 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16524 + 32] = mem[_16524 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16523 + 164
                mem[_16523 + 100] = 32
                mem[_16523 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16523 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17587 = mem[_16524]
                t = _16524 + 32
                u = mem[64]
                s = mem[_16524]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16524])] = mem[_16524 + floor32(mem[_16524]) + -(mem[_16524] % 32) + 64 len mem[_16524] % 32] or Mask(8 * -(mem[_16524] % 32) + 32, -(8 * -(mem[_16524] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16524])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17587 + _16523 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22378 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16523 + 100]
                    _22380 = mem[_16523 + 100]
                    idx = 0
                    while idx < _22380:
                        mem[_22378 + idx + 68] = mem[_16523 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22380 % 32:
                        revert with memory
                          from mem[64]
                           len _22380 + _22378 + -mem[64] + 68
                    mem[floor32(_22380) + _22378 + 68] = mem[floor32(_22380) + _22378 + -(_22380 % 32) + 100 len _22380 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22380) + _22378 + -mem[64] + 100
                _20935 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20935] = return_data.size
                mem[_20935 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20935 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22382 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16523 + 100]
                _22384 = mem[_16523 + 100]
                idx = 0
                while idx < _22384:
                    mem[_22382 + idx + 68] = mem[_16523 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22384 % 32:
                    revert with memory
                      from mem[64]
                       len _22384 + _22382 + -mem[64] + 68
                mem[floor32(_22384) + _22382 + 68] = mem[floor32(_22384) + _22382 + -(_22384 % 32) + 100 len _22384 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22384) + _22382 + -mem[64] + 100
            require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]]
            if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]] != sub_3c97d5ae:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _10268 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10268] = 26
            mem[_10268 + 32] = 'SafeMath: division by zero'
            if sub_a090a2b4 <= 0:
                _10336 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_10336 + idx + 68] = mem[_10268 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10336 + 68] = mem[_10336 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _10336 + -mem[64] + 100
            require sub_a090a2b4
            if sub_5dcea4d4[stor103[idx]] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                revert with 0, 'SafeMath: addition overflow'
            sub_5dcea4d4[stor103[idx]] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4
            sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0] - sub_a090a2b4
            mem[0] = rewardTokens[idx]
            mem[32] = 109
            if not userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a):
                _10829 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10829] = 26
                mem[_10829 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10915 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10915 + idx + 68] = mem[_10829 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10915 + 68] = mem[_10915 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10915 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11559 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11559] = 26
                mem[_11559 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11762 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11762 + idx + 68] = mem[_11559 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11762 + 68] = mem[_11762 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11762 + -mem[64] + 100
                require sub_3c97d5ae
                _12177 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12177] = 30
                mem[_12177 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12417 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12417 + idx + 68] = mem[_12177 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12417 + 68] = mem[_12417 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12417 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _14282 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14282] = 30
                        mem[_14282 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14730 + idx + 68] = mem[_14282 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14730 + 68] = mem[_14730 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14730 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15502 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15503 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15503 + 32] = mem[_15503 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15502 + 164
                        mem[_15502 + 100] = 32
                        mem[_15502 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15502 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16839 = mem[_15503]
                        t = _15503 + 32
                        u = mem[64]
                        s = mem[_15503]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15503])] = mem[_15503 + floor32(mem[_15503]) + -(mem[_15503] % 32) + 64 len mem[_15503] % 32] or Mask(8 * -(mem[_15503] % 32) + 32, -(8 * -(mem[_15503] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15503])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16839 + _15502 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15502 + 100]
                            _22356 = mem[_15502 + 100]
                            idx = 0
                            while idx < _22356:
                                mem[_22354 + idx + 68] = mem[_15502 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22356 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22356 + _22354 + -mem[64] + 68
                            mem[floor32(_22356) + _22354 + 68] = mem[floor32(_22356) + _22354 + -(_22356 % 32) + 100 len _22356 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22356) + _22354 + -mem[64] + 100
                        _20918 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20918] = return_data.size
                        mem[_20918 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20918 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22358 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15502 + 100]
                        _22360 = mem[_15502 + 100]
                        idx = 0
                        while idx < _22360:
                            mem[_22358 + idx + 68] = mem[_15502 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22360 % 32:
                            revert with memory
                              from mem[64]
                               len _22360 + _22358 + -mem[64] + 68
                        mem[floor32(_22360) + _22358 + 68] = mem[floor32(_22360) + _22358 + -(_22360 % 32) + 100 len _22360 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22360) + _22358 + -mem[64] + 100
                    _14283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14283] = 30
                    mem[_14283 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _14733 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14733 + idx + 68] = mem[_14283 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14733 + 68] = mem[_14733 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14733 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _15507 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _15508 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15508 + 32] = mem[_15508 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15507 + 164
                    mem[_15507 + 100] = 32
                    mem[_15507 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15507 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16843 = mem[_15508]
                    t = _15508 + 32
                    u = mem[64]
                    s = mem[_15508]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15508])] = mem[_15508 + floor32(mem[_15508]) + -(mem[_15508] % 32) + 64 len mem[_15508] % 32] or Mask(8 * -(mem[_15508] % 32) + 32, -(8 * -(mem[_15508] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15508])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16843 + _15507 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15507 + 100]
                        _22364 = mem[_15507 + 100]
                        idx = 0
                        while idx < _22364:
                            mem[_22362 + idx + 68] = mem[_15507 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22364 % 32:
                            revert with memory
                              from mem[64]
                               len _22364 + _22362 + -mem[64] + 68
                        mem[floor32(_22364) + _22362 + 68] = mem[floor32(_22364) + _22362 + -(_22364 % 32) + 100 len _22364 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22364) + _22362 + -mem[64] + 100
                    _20921 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20921] = return_data.size
                    mem[_20921 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20921 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22366 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15507 + 100]
                    _22368 = mem[_15507 + 100]
                    idx = 0
                    while idx < _22368:
                        mem[_22366 + idx + 68] = mem[_15507 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22368 % 32:
                        revert with memory
                          from mem[64]
                           len _22368 + _22366 + -mem[64] + 68
                    mem[floor32(_22368) + _22366 + 68] = mem[floor32(_22368) + _22366 + -(_22368 % 32) + 100 len _22368 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22368) + _22366 + -mem[64] + 100
                _13809 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13809] = 30
                mem[_13809 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _14279 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14279 + idx + 68] = mem[_13809 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14279 + 68] = mem[_14279 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _14279 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _15500 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15500] = 30
                    mem[_15500 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15954 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15954 + idx + 68] = mem[_15500 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15954 + 68] = mem[_15954 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15954 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16508 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16509 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16509 + 32] = mem[_16509 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16508 + 164
                    mem[_16508 + 100] = 32
                    mem[_16508 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16508 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17575 = mem[_16509]
                    t = _16509 + 32
                    u = mem[64]
                    s = mem[_16509]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16509])] = mem[_16509 + floor32(mem[_16509]) + -(mem[_16509] % 32) + 64 len mem[_16509] % 32] or Mask(8 * -(mem[_16509] % 32) + 32, -(8 * -(mem[_16509] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16509])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17575 + _16508 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22338 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16508 + 100]
                        _22340 = mem[_16508 + 100]
                        idx = 0
                        while idx < _22340:
                            mem[_22338 + idx + 68] = mem[_16508 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22340 % 32:
                            revert with memory
                              from mem[64]
                               len _22340 + _22338 + -mem[64] + 68
                        mem[floor32(_22340) + _22338 + 68] = mem[floor32(_22340) + _22338 + -(_22340 % 32) + 100 len _22340 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22340) + _22338 + -mem[64] + 100
                    _20910 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20910] = return_data.size
                    mem[_20910 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20910 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22342 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16508 + 100]
                    _22344 = mem[_16508 + 100]
                    idx = 0
                    while idx < _22344:
                        mem[_22342 + idx + 68] = mem[_16508 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22344 % 32:
                        revert with memory
                          from mem[64]
                           len _22344 + _22342 + -mem[64] + 68
                    mem[floor32(_22344) + _22342 + 68] = mem[floor32(_22344) + _22342 + -(_22344 % 32) + 100 len _22344 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22344) + _22342 + -mem[64] + 100
                _15501 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15501] = 30
                mem[_15501 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15957 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15957 + idx + 68] = mem[_15501 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15957 + 68] = mem[_15957 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15957 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _16513 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _16514 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16514 + 32] = mem[_16514 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16513 + 164
                mem[_16513 + 100] = 32
                mem[_16513 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16513 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17579 = mem[_16514]
                t = _16514 + 32
                u = mem[64]
                s = mem[_16514]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16514])] = mem[_16514 + floor32(mem[_16514]) + -(mem[_16514] % 32) + 64 len mem[_16514] % 32] or Mask(8 * -(mem[_16514] % 32) + 32, -(8 * -(mem[_16514] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16514])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17579 + _16513 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22346 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16513 + 100]
                    _22348 = mem[_16513 + 100]
                    idx = 0
                    while idx < _22348:
                        mem[_22346 + idx + 68] = mem[_16513 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22348 % 32:
                        revert with memory
                          from mem[64]
                           len _22348 + _22346 + -mem[64] + 68
                    mem[floor32(_22348) + _22346 + 68] = mem[floor32(_22348) + _22346 + -(_22348 % 32) + 100 len _22348 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22348) + _22346 + -mem[64] + 100
                _20913 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20913] = return_data.size
                mem[_20913 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20913 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22350 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16513 + 100]
                _22352 = mem[_16513 + 100]
                idx = 0
                while idx < _22352:
                    mem[_22350 + idx + 68] = mem[_16513 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22352 % 32:
                    revert with memory
                      from mem[64]
                       len _22352 + _22350 + -mem[64] + 68
                mem[floor32(_22352) + _22350 + 68] = mem[floor32(_22352) + _22350 + -(_22352 % 32) + 100 len _22352 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22352) + _22350 + -mem[64] + 100
            require userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a)
            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (0 / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _10914 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10914] = 26
            mem[_10914 + 32] = 'SafeMath: division by zero'
            if sub_3c97d5ae <= 0:
                _11049 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_11049 + idx + 68] = mem[_10914 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_11049 + 68] = mem[_11049 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _11049 + -mem[64] + 100
            require sub_3c97d5ae
            mem[0] = rewardTokens[idx]
            mem[32] = sha3(address(msg.sender), 111) + 1
            userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (0 / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
            if not userInfo[address(msg.sender)].field_0:
                idx = idx + 1
                continue 
            mem[0] = rewardTokens[idx]
            mem[32] = 109
            require userInfo[address(msg.sender)].field_0
            if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _11761 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11761] = 26
            mem[_11761 + 32] = 'SafeMath: division by zero'
            if sub_3c97d5ae <= 0:
                _11953 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_11953 + idx + 68] = mem[_11761 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_11953 + 68] = mem[_11953 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _11953 + -mem[64] + 100
            require sub_3c97d5ae
            _12415 = mem[64]
            mem[64] = mem[64] + 64
            mem[_12415] = 30
            mem[_12415 + 32] = 'SafeMath: subtraction overflow'
            if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                _12629 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_12629 + idx + 68] = mem[_12415 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_12629 + 68] = mem[_12629 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _12629 + -mem[64] + 100
            if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(rewardTokens[idx])
            staticcall rewardTokens[idx].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if rewardTokens[idx] != joeAddress:
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                    _14727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14727] = 30
                    mem[_14727 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15220 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15220 + idx + 68] = mem[_14727 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15220 + 68] = mem[_15220 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15220 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15944 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15945 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15945 + 32] = mem[_15945 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15944 + 164
                    mem[_15944 + 100] = 32
                    mem[_15944 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15944 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17129 = mem[_15945]
                    t = _15945 + 32
                    u = mem[64]
                    s = mem[_15945]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15945])] = mem[_15945 + floor32(mem[_15945]) + -(mem[_15945] % 32) + 64 len mem[_15945] % 32] or Mask(8 * -(mem[_15945] % 32) + 32, -(8 * -(mem[_15945] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15945])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17129 + _15944 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22322 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15944 + 100]
                        _22324 = mem[_15944 + 100]
                        idx = 0
                        while idx < _22324:
                            mem[_22322 + idx + 68] = mem[_15944 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22324 % 32:
                            revert with memory
                              from mem[64]
                               len _22324 + _22322 + -mem[64] + 68
                        mem[floor32(_22324) + _22322 + 68] = mem[floor32(_22324) + _22322 + -(_22324 % 32) + 100 len _22324 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22324) + _22322 + -mem[64] + 100
                    _20898 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20898] = return_data.size
                    mem[_20898 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20898 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22326 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15944 + 100]
                    _22328 = mem[_15944 + 100]
                    idx = 0
                    while idx < _22328:
                        mem[_22326 + idx + 68] = mem[_15944 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22328 % 32:
                        revert with memory
                          from mem[64]
                           len _22328 + _22326 + -mem[64] + 68
                    mem[floor32(_22328) + _22326 + 68] = mem[floor32(_22328) + _22326 + -(_22328 % 32) + 100 len _22328 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22328) + _22326 + -mem[64] + 100
                _14728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14728] = 30
                mem[_14728 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                    _15223 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15223 + idx + 68] = mem[_14728 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15223 + 68] = mem[_15223 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15223 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                _15949 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0]
                _15950 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_15950 + 32] = mem[_15950 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _15949 + 164
                mem[_15949 + 100] = 32
                mem[_15949 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15949 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17133 = mem[_15950]
                t = _15950 + 32
                u = mem[64]
                s = mem[_15950]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_15950])] = mem[_15950 + floor32(mem[_15950]) + -(mem[_15950] % 32) + 64 len mem[_15950] % 32] or Mask(8 * -(mem[_15950] % 32) + 32, -(8 * -(mem[_15950] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15950])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17133 + _15949 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22330 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15949 + 100]
                    _22332 = mem[_15949 + 100]
                    idx = 0
                    while idx < _22332:
                        mem[_22330 + idx + 68] = mem[_15949 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22332 % 32:
                        revert with memory
                          from mem[64]
                           len _22332 + _22330 + -mem[64] + 68
                    mem[floor32(_22332) + _22330 + 68] = mem[floor32(_22332) + _22330 + -(_22332 % 32) + 100 len _22332 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22332) + _22330 + -mem[64] + 100
                _20901 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20901] = return_data.size
                mem[_20901 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20901 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22334 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_15949 + 100]
                _22336 = mem[_15949 + 100]
                idx = 0
                while idx < _22336:
                    mem[_22334 + idx + 68] = mem[_15949 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22336 % 32:
                    revert with memory
                      from mem[64]
                       len _22336 + _22334 + -mem[64] + 68
                mem[floor32(_22336) + _22334 + 68] = mem[floor32(_22336) + _22334 + -(_22336 % 32) + 100 len _22336 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22336) + _22334 + -mem[64] + 100
            _14278 = mem[64]
            mem[64] = mem[64] + 64
            mem[_14278] = 30
            mem[_14278 + 32] = 'SafeMath: subtraction overflow'
            if sub_a090a2b4 > ext_call.return_data[0]:
                _14724 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_14724 + idx + 68] = mem[_14278 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_14724 + 68] = mem[_14724 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _14724 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            mem[32] = 105
            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                _15942 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15942] = 30
                mem[_15942 + 32] = 'SafeMath: subtraction overflow'
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                    _16322 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16322 + idx + 68] = mem[_15942 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16322 + 68] = mem[_16322 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _16322 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                _16828 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                _16829 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16829 + 32] = mem[_16829 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16828 + 164
                mem[_16828 + 100] = 32
                mem[_16828 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16828 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17901 = mem[_16829]
                t = _16829 + 32
                u = mem[64]
                s = mem[_16829]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16829])] = mem[_16829 + floor32(mem[_16829]) + -(mem[_16829] % 32) + 64 len mem[_16829] % 32] or Mask(8 * -(mem[_16829] % 32) + 32, -(8 * -(mem[_16829] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16829])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17901 + _16828 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22306 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16828 + 100]
                    _22308 = mem[_16828 + 100]
                    idx = 0
                    while idx < _22308:
                        mem[_22306 + idx + 68] = mem[_16828 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22308 % 32:
                        revert with memory
                          from mem[64]
                           len _22308 + _22306 + -mem[64] + 68
                    mem[floor32(_22308) + _22306 + 68] = mem[floor32(_22308) + _22306 + -(_22308 % 32) + 100 len _22308 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22308) + _22306 + -mem[64] + 100
                _20890 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20890] = return_data.size
                mem[_20890 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20890 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22310 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16828 + 100]
                _22312 = mem[_16828 + 100]
                idx = 0
                while idx < _22312:
                    mem[_22310 + idx + 68] = mem[_16828 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22312 % 32:
                    revert with memory
                      from mem[64]
                       len _22312 + _22310 + -mem[64] + 68
                mem[floor32(_22312) + _22310 + 68] = mem[floor32(_22312) + _22310 + -(_22312 % 32) + 100 len _22312 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22312) + _22310 + -mem[64] + 100
            _15943 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15943] = 30
            mem[_15943 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                _16325 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16325 + idx + 68] = mem[_15943 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16325 + 68] = mem[_16325 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _16325 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            mem[32] = 105
            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
            _16833 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
            _16834 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_16834 + 32] = mem[_16834 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
            mem[64] = _16833 + 164
            mem[_16833 + 100] = 32
            mem[_16833 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16833 + 270 len 26]
            if ext_code.size(rewardTokens[idx]) <= 0:
                revert with 0, 'Address: call to non-contract'
            _17905 = mem[_16834]
            t = _16834 + 32
            u = mem[64]
            s = mem[_16834]
            while s >= 32:
                mem[u] = mem[t]
                t = t + 32
                u = u + 32
                s = s - 32
                continue 
            mem[mem[64] + floor32(mem[_16834])] = mem[_16834 + floor32(mem[_16834]) + -(mem[_16834] % 32) + 64 len mem[_16834] % 32] or Mask(8 * -(mem[_16834] % 32) + 32, -(8 * -(mem[_16834] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16834])])
            call rewardTokens[idx].mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _17905 + _16833 + -mem[64] + 160]
            if not return_data.size:
                if ext_call.success:
                    if mem[96] > 0:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if mem[96] > 0:
                    revert with memory
                      from 128
                       len mem[96]
                _22314 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16833 + 100]
                _22316 = mem[_16833 + 100]
                idx = 0
                while idx < _22316:
                    mem[_22314 + idx + 68] = mem[_16833 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22316 % 32:
                    revert with memory
                      from mem[64]
                       len _22316 + _22314 + -mem[64] + 68
                mem[floor32(_22316) + _22314 + 68] = mem[floor32(_22316) + _22314 + -(_22316 % 32) + 100 len _22316 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22316) + _22314 + -mem[64] + 100
            _20893 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_20893] = return_data.size
            mem[_20893 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if ext_call.success:
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_20893 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                idx = idx + 1
                continue 
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            _22318 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_16833 + 100]
            _22320 = mem[_16833 + 100]
            idx = 0
            while idx < _22320:
                mem[_22318 + idx + 68] = mem[_16833 + idx + 132]
                idx = idx + 32
                continue 
            if not _22320 % 32:
                revert with memory
                  from mem[64]
                   len _22320 + _22318 + -mem[64] + 68
            mem[floor32(_22320) + _22318 + 68] = mem[floor32(_22320) + _22318 + -(_22320 % 32) + 100 len _22320 % 32]
            revert with memory
              from mem[64]
               len floor32(_22320) + _22318 + -mem[64] + 100
        if sub_a090a2b4 + arg1 - (0 / sub_a610708a) < sub_a090a2b4:
            revert with 0, 'SafeMath: addition overflow'
        sub_a090a2b4 = sub_a090a2b4 + arg1 - (0 / sub_a610708a)
        _9912 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = feeCollectorAddress
        mem[mem[64] + 100] = 0 / sub_a610708a
        _9913 = mem[64]
        mem[mem[64]] = 100
        mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
        mem[64] = mem[64] + 196
        mem[_9912 + 132] = 32
        mem[_9912 + 164] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_9912 + 302 len 26]
        if ext_code.size(joeAddress) <= 0:
            revert with 0, 'Address: call to non-contract'
        _9952 = mem[_9913]
        mem[_9912 + 196 len floor32(mem[_9913])] = mem[_9913 + 32 len floor32(mem[_9913])]
        mem[_9912 + floor32(mem[_9913]) + -(mem[_9913] % 32) + 228 len mem[_9913] % 32] = mem[_9913 + floor32(mem[_9913]) + -(mem[_9913] % 32) + 64 len mem[_9913] % 32]
        call joeAddress with:
             gas gas_remaining wei
            args mem[_9912 + 200 len _9952 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96] > 0:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96] > 0:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_9912 + 306 len 22]
            mem[_9912 + 232] = msg.sender
            mem[_9912 + 264] = this.address
            mem[_9912 + 296] = arg1 - (0 / sub_a610708a)
            mem[_9912 + 196] = 100
            mem[_9912 + 228 len 4] = unknown_0x23b872dd(?????)
            mem[_9912 + 328] = 32
            mem[_9912 + 360] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_9912 + 498 len 26]
            if ext_code.size(joeAddress) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[_9912 + 392 len 96] = 0, msg.sender, address(this.address), Mask(224, 32, arg1 - (0 / sub_a610708a)) >> 32
            mem[_9912 + 516 len 4] = 0
            call joeAddress with:
                 gas gas_remaining wei
                args arg1 - (0 / sub_a610708a), 32, Mask(224, 32, 'SafeERC20: low-level call failed') >> 32, mem[_9912 + 488 len 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96] > 0:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9912 + 502 len 14],
                                    0,
                                    mem[_9912 + 520 len 4]
            else:
                mem[_9912 + 424 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_9912 + 424]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9912 + ceil32(return_data.size) + 503 len 22]
        else:
            mem[_9912 + 196] = return_data.size
            mem[_9912 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size > 0:
                require return_data.size >= 32
                if not mem[_9912 + 228]:
                    revert with 0, 
                                32,
                                42,
                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_9912 + ceil32(return_data.size) + 307 len 22]
            mem[_9912 + ceil32(return_data.size) + 233] = msg.sender
            mem[_9912 + ceil32(return_data.size) + 265] = this.address
            mem[_9912 + ceil32(return_data.size) + 297] = arg1 - (0 / sub_a610708a)
            mem[_9912 + ceil32(return_data.size) + 197] = 100
            mem[_9912 + ceil32(return_data.size) + 229 len 4] = unknown_0x23b872dd(?????)
            mem[_9912 + ceil32(return_data.size) + 329] = 32
            mem[_9912 + ceil32(return_data.size) + 361] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[_9912 + ceil32(return_data.size) + 499 len 26]
            if ext_code.size(joeAddress) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[_9912 + ceil32(return_data.size) + 393 len 96] = 0, msg.sender, address(this.address), Mask(224, 32, arg1 - (0 / sub_a610708a)) >> 32
            mem[_9912 + ceil32(return_data.size) + 517 len 4] = 0
            call joeAddress with:
                 gas gas_remaining wei
                args arg1 - (0 / sub_a610708a), 32, Mask(224, 32, 'SafeERC20: low-level call failed') >> 32, mem[_9912 + ceil32(return_data.size) + 489 len 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96] > 0:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9912 + ceil32(return_data.size) + 503 len 14],
                                    0,
                                    mem[_9912 + ceil32(return_data.size) + 521 len 4]
            else:
                mem[_9912 + ceil32(return_data.size) + 425 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 
                                'SafeERC20: low-level call failed',
                                mem[_9912 + (2 * ceil32(return_data.size)) + 494 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_9912 + ceil32(return_data.size) + 425]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9912 + (2 * ceil32(return_data.size)) + 504 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
        emit Deposit(arg1 - (0 / sub_a610708a), 0 / sub_a610708a, msg.sender);
    else:
        require arg1
        if arg1 * depositFeePercent / arg1 != depositFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if sub_a610708a <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_a610708a
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if arg1 * depositFeePercent / sub_a610708a > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        if userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) < userInfo[address(msg.sender)].field_0:
            revert with 0, 'SafeMath: addition overflow'
        userInfo[address(msg.sender)].field_0 = userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
        idx = 0
        while idx < rewardTokens.length:
            mem[0] = rewardTokens[idx]
            mem[32] = 104
            if not stor104[stor103[idx]]:
                revert with 0, 32, 36, 0x6c537461626c654a6f655374616b696e673a2077726f6e672072657761726420746f6b65, mem[mem[64] + 104 len 28]
            mem[mem[64] + 4] = this.address
            require ext_code.size(rewardTokens[idx])
            staticcall rewardTokens[idx].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if rewardTokens[idx] != joeAddress:
                mem[0] = rewardTokens[idx]
                if ext_call.return_data[0] == sub_5fc0d9e0[stor103[idx]]:
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                        _9989 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9989] = 26
                        mem[_9989 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10016 + idx + 68] = mem[_9989 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10016 + 68] = mem[_10016 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10016 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _10327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10327] = 26
                        mem[_10327 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10379 + idx + 68] = mem[_10327 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10379 + 68] = mem[_10379 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10379 + -mem[64] + 100
                        require sub_3c97d5ae
                        _10496 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10496] = 30
                        mem[_10496 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _10562 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10562 + idx + 68] = mem[_10496 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10562 + 68] = mem[_10562 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _10562 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _11241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11241] = 30
                                mem[_11241 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _11334 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11334 + idx + 68] = mem[_11241 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11334 + 68] = mem[_11334 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _11334 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11525 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11526 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_11526 + 32] = mem[_11526 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _11525 + 164
                                mem[_11525 + 100] = 32
                                mem[_11525 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11525 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _12266 = mem[_11526]
                                t = _11526 + 32
                                u = mem[64]
                                s = mem[_11526]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_11526])] = mem[_11526 + floor32(mem[_11526]) + -(mem[_11526] % 32) + 64 len mem[_11526] % 32] or Mask(8 * -(mem[_11526] % 32) + 32, -(8 * -(mem[_11526] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11526])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _12266 + _11525 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22026 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_11525 + 100]
                                    _22028 = mem[_11525 + 100]
                                    idx = 0
                                    while idx < _22028:
                                        mem[_22026 + idx + 68] = mem[_11525 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22028 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22028 + _22026 + -mem[64] + 68
                                    mem[floor32(_22028) + _22026 + 68] = mem[floor32(_22028) + _22026 + -(_22028 % 32) + 100 len _22028 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22028) + _22026 + -mem[64] + 100
                                _20711 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_20711] = return_data.size
                                mem[_20711 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_20711 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11525 + 100]
                                _22032 = mem[_11525 + 100]
                                idx = 0
                                while idx < _22032:
                                    mem[_22030 + idx + 68] = mem[_11525 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22032 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22032 + _22030 + -mem[64] + 68
                                mem[floor32(_22032) + _22030 + 68] = mem[floor32(_22032) + _22030 + -(_22032 % 32) + 100 len _22032 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22032) + _22030 + -mem[64] + 100
                            _11242 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11242] = 30
                            mem[_11242 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _11337 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11337 + idx + 68] = mem[_11242 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11337 + 68] = mem[_11337 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11337 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _11530 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _11531 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11531 + 32] = mem[_11531 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11530 + 164
                            mem[_11530 + 100] = 32
                            mem[_11530 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11530 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12270 = mem[_11531]
                            t = _11531 + 32
                            u = mem[64]
                            s = mem[_11531]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11531])] = mem[_11531 + floor32(mem[_11531]) + -(mem[_11531] % 32) + 64 len mem[_11531] % 32] or Mask(8 * -(mem[_11531] % 32) + 32, -(8 * -(mem[_11531] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11531])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12270 + _11530 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22034 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11530 + 100]
                                _22036 = mem[_11530 + 100]
                                idx = 0
                                while idx < _22036:
                                    mem[_22034 + idx + 68] = mem[_11530 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22036 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22036 + _22034 + -mem[64] + 68
                                mem[floor32(_22036) + _22034 + 68] = mem[floor32(_22036) + _22034 + -(_22036 % 32) + 100 len _22036 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22036) + _22034 + -mem[64] + 100
                            _20714 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20714] = return_data.size
                            mem[_20714 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20714 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22038 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11530 + 100]
                            _22040 = mem[_11530 + 100]
                            idx = 0
                            while idx < _22040:
                                mem[_22038 + idx + 68] = mem[_11530 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22040 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22040 + _22038 + -mem[64] + 68
                            mem[floor32(_22040) + _22038 + 68] = mem[floor32(_22040) + _22038 + -(_22040 % 32) + 100 len _22040 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22040) + _22038 + -mem[64] + 100
                        _11141 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11141] = 30
                        mem[_11141 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _11238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11238 + idx + 68] = mem[_11141 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11238 + 68] = mem[_11238 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11238 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _11523 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11523] = 30
                            mem[_11523 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11730 + idx + 68] = mem[_11523 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11730 + 68] = mem[_11730 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11730 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12014 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12015 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12015 + 32] = mem[_12015 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12014 + 164
                            mem[_12014 + 100] = 32
                            mem[_12014 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12014 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12798 = mem[_12015]
                            t = _12015 + 32
                            u = mem[64]
                            s = mem[_12015]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12015])] = mem[_12015 + floor32(mem[_12015]) + -(mem[_12015] % 32) + 64 len mem[_12015] % 32] or Mask(8 * -(mem[_12015] % 32) + 32, -(8 * -(mem[_12015] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12015])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12798 + _12014 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22010 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12014 + 100]
                                _22012 = mem[_12014 + 100]
                                idx = 0
                                while idx < _22012:
                                    mem[_22010 + idx + 68] = mem[_12014 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22012 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22012 + _22010 + -mem[64] + 68
                                mem[floor32(_22012) + _22010 + 68] = mem[floor32(_22012) + _22010 + -(_22012 % 32) + 100 len _22012 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22012) + _22010 + -mem[64] + 100
                            _20703 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20703] = return_data.size
                            mem[_20703 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20703 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22014 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12014 + 100]
                            _22016 = mem[_12014 + 100]
                            idx = 0
                            while idx < _22016:
                                mem[_22014 + idx + 68] = mem[_12014 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22016 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22016 + _22014 + -mem[64] + 68
                            mem[floor32(_22016) + _22014 + 68] = mem[floor32(_22016) + _22014 + -(_22016 % 32) + 100 len _22016 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22016) + _22014 + -mem[64] + 100
                        _11524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11524] = 30
                        mem[_11524 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _11733 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11733 + idx + 68] = mem[_11524 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11733 + 68] = mem[_11733 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11733 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _12019 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _12020 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12020 + 32] = mem[_12020 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12019 + 164
                        mem[_12019 + 100] = 32
                        mem[_12019 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12019 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12802 = mem[_12020]
                        t = _12020 + 32
                        u = mem[64]
                        s = mem[_12020]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12020])] = mem[_12020 + floor32(mem[_12020]) + -(mem[_12020] % 32) + 64 len mem[_12020] % 32] or Mask(8 * -(mem[_12020] % 32) + 32, -(8 * -(mem[_12020] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12020])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12802 + _12019 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22018 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12019 + 100]
                            _22020 = mem[_12019 + 100]
                            idx = 0
                            while idx < _22020:
                                mem[_22018 + idx + 68] = mem[_12019 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22020 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22020 + _22018 + -mem[64] + 68
                            mem[floor32(_22020) + _22018 + 68] = mem[floor32(_22020) + _22018 + -(_22020 % 32) + 100 len _22020 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22020) + _22018 + -mem[64] + 100
                        _20706 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20706] = return_data.size
                        mem[_20706 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20706 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22022 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12019 + 100]
                        _22024 = mem[_12019 + 100]
                        idx = 0
                        while idx < _22024:
                            mem[_22022 + idx + 68] = mem[_12019 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22024 % 32:
                            revert with memory
                              from mem[64]
                               len _22024 + _22022 + -mem[64] + 68
                        mem[floor32(_22024) + _22022 + 68] = mem[floor32(_22024) + _22022 + -(_22024 % 32) + 100 len _22024 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22024) + _22022 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10015 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10015] = 26
                    mem[_10015 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10059 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10059 + idx + 68] = mem[_10015 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10059 + 68] = mem[_10059 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10059 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10378 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10378] = 26
                    mem[_10378 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10439 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10439 + idx + 68] = mem[_10378 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10439 + 68] = mem[_10439 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10439 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10560 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10560] = 30
                    mem[_10560 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10644 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10644 + idx + 68] = mem[_10560 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10644 + 68] = mem[_10644 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10644 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11331] = 30
                            mem[_11331 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11457 + idx + 68] = mem[_11331 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11457 + 68] = mem[_11457 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11457 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11720 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11721 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11721 + 32] = mem[_11721 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11720 + 164
                            mem[_11720 + 100] = 32
                            mem[_11720 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11720 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12487 = mem[_11721]
                            t = _11721 + 32
                            u = mem[64]
                            s = mem[_11721]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11721])] = mem[_11721 + floor32(mem[_11721]) + -(mem[_11721] % 32) + 64 len mem[_11721] % 32] or Mask(8 * -(mem[_11721] % 32) + 32, -(8 * -(mem[_11721] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11721])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12487 + _11720 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _21994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11720 + 100]
                                _21996 = mem[_11720 + 100]
                                idx = 0
                                while idx < _21996:
                                    mem[_21994 + idx + 68] = mem[_11720 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _21996 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _21996 + _21994 + -mem[64] + 68
                                mem[floor32(_21996) + _21994 + 68] = mem[floor32(_21996) + _21994 + -(_21996 % 32) + 100 len _21996 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_21996) + _21994 + -mem[64] + 100
                            _20691 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20691] = return_data.size
                            mem[_20691 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20691 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21998 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11720 + 100]
                            _22000 = mem[_11720 + 100]
                            idx = 0
                            while idx < _22000:
                                mem[_21998 + idx + 68] = mem[_11720 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22000 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22000 + _21998 + -mem[64] + 68
                            mem[floor32(_22000) + _21998 + 68] = mem[floor32(_22000) + _21998 + -(_22000 % 32) + 100 len _22000 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22000) + _21998 + -mem[64] + 100
                        _11332 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11332] = 30
                        mem[_11332 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11460 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11460 + idx + 68] = mem[_11332 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11460 + 68] = mem[_11460 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11460 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _11725 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _11726 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_11726 + 32] = mem[_11726 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _11725 + 164
                        mem[_11725 + 100] = 32
                        mem[_11725 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11725 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12491 = mem[_11726]
                        t = _11726 + 32
                        u = mem[64]
                        s = mem[_11726]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_11726])] = mem[_11726 + floor32(mem[_11726]) + -(mem[_11726] % 32) + 64 len mem[_11726] % 32] or Mask(8 * -(mem[_11726] % 32) + 32, -(8 * -(mem[_11726] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11726])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12491 + _11725 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22002 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11725 + 100]
                            _22004 = mem[_11725 + 100]
                            idx = 0
                            while idx < _22004:
                                mem[_22002 + idx + 68] = mem[_11725 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22004 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22004 + _22002 + -mem[64] + 68
                            mem[floor32(_22004) + _22002 + 68] = mem[floor32(_22004) + _22002 + -(_22004 % 32) + 100 len _22004 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22004) + _22002 + -mem[64] + 100
                        _20694 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20694] = return_data.size
                        mem[_20694 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20694 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_11725 + 100]
                        _22008 = mem[_11725 + 100]
                        idx = 0
                        while idx < _22008:
                            mem[_22006 + idx + 68] = mem[_11725 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22008 % 32:
                            revert with memory
                              from mem[64]
                               len _22008 + _22006 + -mem[64] + 68
                        mem[floor32(_22008) + _22006 + 68] = mem[floor32(_22008) + _22006 + -(_22008 % 32) + 100 len _22008 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22008) + _22006 + -mem[64] + 100
                    _11237 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11237] = 30
                    mem[_11237 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11328 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11328 + idx + 68] = mem[_11237 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11328 + 68] = mem[_11328 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11328 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _11718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11718] = 30
                        mem[_11718 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _11919 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11919 + idx + 68] = mem[_11718 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11919 + 68] = mem[_11919 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11919 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12255 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12256 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12256 + 32] = mem[_12256 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12255 + 164
                        mem[_12255 + 100] = 32
                        mem[_12255 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12255 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12993 = mem[_12256]
                        t = _12256 + 32
                        u = mem[64]
                        s = mem[_12256]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12256])] = mem[_12256 + floor32(mem[_12256]) + -(mem[_12256] % 32) + 64 len mem[_12256] % 32] or Mask(8 * -(mem[_12256] % 32) + 32, -(8 * -(mem[_12256] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12256])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12993 + _12255 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12255 + 100]
                            _21980 = mem[_12255 + 100]
                            idx = 0
                            while idx < _21980:
                                mem[_21978 + idx + 68] = mem[_12255 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21980 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21980 + _21978 + -mem[64] + 68
                            mem[floor32(_21980) + _21978 + 68] = mem[floor32(_21980) + _21978 + -(_21980 % 32) + 100 len _21980 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21980) + _21978 + -mem[64] + 100
                        _20683 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20683] = return_data.size
                        mem[_20683 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20683 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21982 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12255 + 100]
                        _21984 = mem[_12255 + 100]
                        idx = 0
                        while idx < _21984:
                            mem[_21982 + idx + 68] = mem[_12255 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21984 % 32:
                            revert with memory
                              from mem[64]
                               len _21984 + _21982 + -mem[64] + 68
                        mem[floor32(_21984) + _21982 + 68] = mem[floor32(_21984) + _21982 + -(_21984 % 32) + 100 len _21984 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21984) + _21982 + -mem[64] + 100
                    _11719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11719] = 30
                    mem[_11719 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _11922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11922 + idx + 68] = mem[_11719 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11922 + 68] = mem[_11922 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11922 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12260 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12261 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12261 + 32] = mem[_12261 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12260 + 164
                    mem[_12260 + 100] = 32
                    mem[_12260 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12260 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _12997 = mem[_12261]
                    t = _12261 + 32
                    u = mem[64]
                    s = mem[_12261]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12261])] = mem[_12261 + floor32(mem[_12261]) + -(mem[_12261] % 32) + 64 len mem[_12261] % 32] or Mask(8 * -(mem[_12261] % 32) + 32, -(8 * -(mem[_12261] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12261])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _12997 + _12260 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21986 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12260 + 100]
                        _21988 = mem[_12260 + 100]
                        idx = 0
                        while idx < _21988:
                            mem[_21986 + idx + 68] = mem[_12260 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21988 % 32:
                            revert with memory
                              from mem[64]
                               len _21988 + _21986 + -mem[64] + 68
                        mem[floor32(_21988) + _21986 + 68] = mem[floor32(_21988) + _21986 + -(_21988 % 32) + 100 len _21988 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21988) + _21986 + -mem[64] + 100
                    _20686 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20686] = return_data.size
                    mem[_20686 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20686 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21990 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12260 + 100]
                    _21992 = mem[_12260 + 100]
                    idx = 0
                    while idx < _21992:
                        mem[_21990 + idx + 68] = mem[_12260 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21992 % 32:
                        revert with memory
                          from mem[64]
                           len _21992 + _21990 + -mem[64] + 68
                    mem[floor32(_21992) + _21990 + 68] = mem[floor32(_21992) + _21990 + -(_21992 % 32) + 100 len _21992 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21992) + _21990 + -mem[64] + 100
                if not sub_a090a2b4:
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                        _10005 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10005] = 26
                        mem[_10005 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10039 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10039 + idx + 68] = mem[_10005 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10039 + 68] = mem[_10039 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10039 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _10357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10357] = 26
                        mem[_10357 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10412 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10412 + idx + 68] = mem[_10357 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10412 + 68] = mem[_10412 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10412 + -mem[64] + 100
                        require sub_3c97d5ae
                        _10533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10533] = 30
                        mem[_10533 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _10614 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_10614 + idx + 68] = mem[_10533 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10614 + 68] = mem[_10614 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _10614 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _11300 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11300] = 30
                                mem[_11300 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _11408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11408 + idx + 68] = mem[_11300 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11408 + 68] = mem[_11408 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _11408 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11637 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _11638 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_11638 + 32] = mem[_11638 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _11637 + 164
                                mem[_11637 + 100] = 32
                                mem[_11637 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11637 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _12404 = mem[_11638]
                                t = _11638 + 32
                                u = mem[64]
                                s = mem[_11638]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_11638])] = mem[_11638 + floor32(mem[_11638]) + -(mem[_11638] % 32) + 64 len mem[_11638] % 32] or Mask(8 * -(mem[_11638] % 32) + 32, -(8 * -(mem[_11638] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11638])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _12404 + _11637 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22218 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_11637 + 100]
                                    _22220 = mem[_11637 + 100]
                                    idx = 0
                                    while idx < _22220:
                                        mem[_22218 + idx + 68] = mem[_11637 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22220 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22220 + _22218 + -mem[64] + 68
                                    mem[floor32(_22220) + _22218 + 68] = mem[floor32(_22220) + _22218 + -(_22220 % 32) + 100 len _22220 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22220) + _22218 + -mem[64] + 100
                                _20837 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_20837] = return_data.size
                                mem[_20837 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_20837 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11637 + 100]
                                _22224 = mem[_11637 + 100]
                                idx = 0
                                while idx < _22224:
                                    mem[_22222 + idx + 68] = mem[_11637 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22224 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22224 + _22222 + -mem[64] + 68
                                mem[floor32(_22224) + _22222 + 68] = mem[floor32(_22224) + _22222 + -(_22224 % 32) + 100 len _22224 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22224) + _22222 + -mem[64] + 100
                            _11301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11301] = 30
                            mem[_11301 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _11411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11411 + idx + 68] = mem[_11301 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11411 + 68] = mem[_11411 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11411 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _11642 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _11643 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11643 + 32] = mem[_11643 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11642 + 164
                            mem[_11642 + 100] = 32
                            mem[_11642 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11642 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12408 = mem[_11643]
                            t = _11643 + 32
                            u = mem[64]
                            s = mem[_11643]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11643])] = mem[_11643 + floor32(mem[_11643]) + -(mem[_11643] % 32) + 64 len mem[_11643] % 32] or Mask(8 * -(mem[_11643] % 32) + 32, -(8 * -(mem[_11643] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11643])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12408 + _11642 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11642 + 100]
                                _22228 = mem[_11642 + 100]
                                idx = 0
                                while idx < _22228:
                                    mem[_22226 + idx + 68] = mem[_11642 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22228 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22228 + _22226 + -mem[64] + 68
                                mem[floor32(_22228) + _22226 + 68] = mem[floor32(_22228) + _22226 + -(_22228 % 32) + 100 len _22228 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22228) + _22226 + -mem[64] + 100
                            _20840 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20840] = return_data.size
                            mem[_20840 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20840 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22230 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11642 + 100]
                            _22232 = mem[_11642 + 100]
                            idx = 0
                            while idx < _22232:
                                mem[_22230 + idx + 68] = mem[_11642 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22232 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22232 + _22230 + -mem[64] + 68
                            mem[floor32(_22232) + _22230 + 68] = mem[floor32(_22232) + _22230 + -(_22232 % 32) + 100 len _22232 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22232) + _22230 + -mem[64] + 100
                        _11197 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11197] = 30
                        mem[_11197 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _11297 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11297 + idx + 68] = mem[_11197 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11297 + 68] = mem[_11297 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11297 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _11635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11635] = 30
                            mem[_11635 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11843 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11843 + idx + 68] = mem[_11635 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11843 + 68] = mem[_11843 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11843 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12155 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12156 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12156 + 32] = mem[_12156 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12155 + 164
                            mem[_12155 + 100] = 32
                            mem[_12155 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12155 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12914 = mem[_12156]
                            t = _12156 + 32
                            u = mem[64]
                            s = mem[_12156]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12156])] = mem[_12156 + floor32(mem[_12156]) + -(mem[_12156] % 32) + 64 len mem[_12156] % 32] or Mask(8 * -(mem[_12156] % 32) + 32, -(8 * -(mem[_12156] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12156])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12914 + _12155 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12155 + 100]
                                _22204 = mem[_12155 + 100]
                                idx = 0
                                while idx < _22204:
                                    mem[_22202 + idx + 68] = mem[_12155 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22204 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22204 + _22202 + -mem[64] + 68
                                mem[floor32(_22204) + _22202 + 68] = mem[floor32(_22204) + _22202 + -(_22204 % 32) + 100 len _22204 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22204) + _22202 + -mem[64] + 100
                            _20829 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20829] = return_data.size
                            mem[_20829 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20829 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22206 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12155 + 100]
                            _22208 = mem[_12155 + 100]
                            idx = 0
                            while idx < _22208:
                                mem[_22206 + idx + 68] = mem[_12155 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22208 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22208 + _22206 + -mem[64] + 68
                            mem[floor32(_22208) + _22206 + 68] = mem[floor32(_22208) + _22206 + -(_22208 % 32) + 100 len _22208 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22208) + _22206 + -mem[64] + 100
                        _11636 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11636] = 30
                        mem[_11636 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _11846 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11846 + idx + 68] = mem[_11636 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11846 + 68] = mem[_11846 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11846 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _12160 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _12161 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12161 + 32] = mem[_12161 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12160 + 164
                        mem[_12160 + 100] = 32
                        mem[_12160 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12160 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12918 = mem[_12161]
                        t = _12161 + 32
                        u = mem[64]
                        s = mem[_12161]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12161])] = mem[_12161 + floor32(mem[_12161]) + -(mem[_12161] % 32) + 64 len mem[_12161] % 32] or Mask(8 * -(mem[_12161] % 32) + 32, -(8 * -(mem[_12161] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12161])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12918 + _12160 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12160 + 100]
                            _22212 = mem[_12160 + 100]
                            idx = 0
                            while idx < _22212:
                                mem[_22210 + idx + 68] = mem[_12160 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22212 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22212 + _22210 + -mem[64] + 68
                            mem[floor32(_22212) + _22210 + 68] = mem[floor32(_22212) + _22210 + -(_22212 % 32) + 100 len _22212 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22212) + _22210 + -mem[64] + 100
                        _20832 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20832] = return_data.size
                        mem[_20832 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20832 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22214 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12160 + 100]
                        _22216 = mem[_12160 + 100]
                        idx = 0
                        while idx < _22216:
                            mem[_22214 + idx + 68] = mem[_12160 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22216 % 32:
                            revert with memory
                              from mem[64]
                               len _22216 + _22214 + -mem[64] + 68
                        mem[floor32(_22216) + _22214 + 68] = mem[floor32(_22216) + _22214 + -(_22216 % 32) + 100 len _22216 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22216) + _22214 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10038 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10038] = 26
                    mem[_10038 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10082 + idx + 68] = mem[_10038 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10082 + 68] = mem[_10082 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10082 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10411 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10411] = 26
                    mem[_10411 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10461 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10461 + idx + 68] = mem[_10411 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10461 + 68] = mem[_10461 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10461 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10612 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10612] = 30
                    mem[_10612 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10695 + idx + 68] = mem[_10612 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10695 + 68] = mem[_10695 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10695 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11405] = 30
                            mem[_11405 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11540 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11540 + idx + 68] = mem[_11405 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11540 + 68] = mem[_11540 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11540 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11833 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11834 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11834 + 32] = mem[_11834 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11833 + 164
                            mem[_11833 + 100] = 32
                            mem[_11833 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11833 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12600 = mem[_11834]
                            t = _11834 + 32
                            u = mem[64]
                            s = mem[_11834]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11834])] = mem[_11834 + floor32(mem[_11834]) + -(mem[_11834] % 32) + 64 len mem[_11834] % 32] or Mask(8 * -(mem[_11834] % 32) + 32, -(8 * -(mem[_11834] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11834])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12600 + _11833 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11833 + 100]
                                _22188 = mem[_11833 + 100]
                                idx = 0
                                while idx < _22188:
                                    mem[_22186 + idx + 68] = mem[_11833 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22188 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22188 + _22186 + -mem[64] + 68
                                mem[floor32(_22188) + _22186 + 68] = mem[floor32(_22188) + _22186 + -(_22188 % 32) + 100 len _22188 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22188) + _22186 + -mem[64] + 100
                            _20817 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20817] = return_data.size
                            mem[_20817 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20817 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22190 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11833 + 100]
                            _22192 = mem[_11833 + 100]
                            idx = 0
                            while idx < _22192:
                                mem[_22190 + idx + 68] = mem[_11833 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22192 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22192 + _22190 + -mem[64] + 68
                            mem[floor32(_22192) + _22190 + 68] = mem[floor32(_22192) + _22190 + -(_22192 % 32) + 100 len _22192 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22192) + _22190 + -mem[64] + 100
                        _11406 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11406] = 30
                        mem[_11406 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11543 + idx + 68] = mem[_11406 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11543 + 68] = mem[_11543 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11543 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _11838 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _11839 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_11839 + 32] = mem[_11839 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _11838 + 164
                        mem[_11838 + 100] = 32
                        mem[_11838 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11838 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12604 = mem[_11839]
                        t = _11839 + 32
                        u = mem[64]
                        s = mem[_11839]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_11839])] = mem[_11839 + floor32(mem[_11839]) + -(mem[_11839] % 32) + 64 len mem[_11839] % 32] or Mask(8 * -(mem[_11839] % 32) + 32, -(8 * -(mem[_11839] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11839])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12604 + _11838 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22194 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11838 + 100]
                            _22196 = mem[_11838 + 100]
                            idx = 0
                            while idx < _22196:
                                mem[_22194 + idx + 68] = mem[_11838 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22196 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22196 + _22194 + -mem[64] + 68
                            mem[floor32(_22196) + _22194 + 68] = mem[floor32(_22196) + _22194 + -(_22196 % 32) + 100 len _22196 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22196) + _22194 + -mem[64] + 100
                        _20820 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20820] = return_data.size
                        mem[_20820 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20820 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22198 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_11838 + 100]
                        _22200 = mem[_11838 + 100]
                        idx = 0
                        while idx < _22200:
                            mem[_22198 + idx + 68] = mem[_11838 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22200 % 32:
                            revert with memory
                              from mem[64]
                               len _22200 + _22198 + -mem[64] + 68
                        mem[floor32(_22200) + _22198 + 68] = mem[floor32(_22200) + _22198 + -(_22200 % 32) + 100 len _22200 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22200) + _22198 + -mem[64] + 100
                    _11296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11296] = 30
                    mem[_11296 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11402 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11402 + idx + 68] = mem[_11296 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11402 + 68] = mem[_11402 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11402 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _11831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11831] = 30
                        mem[_11831 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12030 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12030 + idx + 68] = mem[_11831 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12030 + 68] = mem[_12030 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12030 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12393 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12394 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12394 + 32] = mem[_12394 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12393 + 164
                        mem[_12393 + 100] = 32
                        mem[_12393 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12393 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13144 = mem[_12394]
                        t = _12394 + 32
                        u = mem[64]
                        s = mem[_12394]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12394])] = mem[_12394 + floor32(mem[_12394]) + -(mem[_12394] % 32) + 64 len mem[_12394] % 32] or Mask(8 * -(mem[_12394] % 32) + 32, -(8 * -(mem[_12394] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12394])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13144 + _12393 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12393 + 100]
                            _22172 = mem[_12393 + 100]
                            idx = 0
                            while idx < _22172:
                                mem[_22170 + idx + 68] = mem[_12393 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22172 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22172 + _22170 + -mem[64] + 68
                            mem[floor32(_22172) + _22170 + 68] = mem[floor32(_22172) + _22170 + -(_22172 % 32) + 100 len _22172 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22172) + _22170 + -mem[64] + 100
                        _20809 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20809] = return_data.size
                        mem[_20809 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20809 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22174 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12393 + 100]
                        _22176 = mem[_12393 + 100]
                        idx = 0
                        while idx < _22176:
                            mem[_22174 + idx + 68] = mem[_12393 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22176 % 32:
                            revert with memory
                              from mem[64]
                               len _22176 + _22174 + -mem[64] + 68
                        mem[floor32(_22176) + _22174 + 68] = mem[floor32(_22176) + _22174 + -(_22176 % 32) + 100 len _22176 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22176) + _22174 + -mem[64] + 100
                    _11832 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11832] = 30
                    mem[_11832 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12033 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12033 + idx + 68] = mem[_11832 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12033 + 68] = mem[_12033 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12033 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12398 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12399 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12399 + 32] = mem[_12399 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12398 + 164
                    mem[_12398 + 100] = 32
                    mem[_12398 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12398 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13148 = mem[_12399]
                    t = _12399 + 32
                    u = mem[64]
                    s = mem[_12399]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12399])] = mem[_12399 + floor32(mem[_12399]) + -(mem[_12399] % 32) + 64 len mem[_12399] % 32] or Mask(8 * -(mem[_12399] % 32) + 32, -(8 * -(mem[_12399] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12399])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13148 + _12398 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22178 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12398 + 100]
                        _22180 = mem[_12398 + 100]
                        idx = 0
                        while idx < _22180:
                            mem[_22178 + idx + 68] = mem[_12398 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22180 % 32:
                            revert with memory
                              from mem[64]
                               len _22180 + _22178 + -mem[64] + 68
                        mem[floor32(_22180) + _22178 + 68] = mem[floor32(_22180) + _22178 + -(_22180 % 32) + 100 len _22180 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22180) + _22178 + -mem[64] + 100
                    _20812 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20812] = return_data.size
                    mem[_20812 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20812 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22182 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12398 + 100]
                    _22184 = mem[_12398 + 100]
                    idx = 0
                    while idx < _22184:
                        mem[_22182 + idx + 68] = mem[_12398 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22184 % 32:
                        revert with memory
                          from mem[64]
                           len _22184 + _22182 + -mem[64] + 68
                    mem[floor32(_22184) + _22182 + 68] = mem[floor32(_22184) + _22182 + -(_22184 % 32) + 100 len _22184 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22184) + _22182 + -mem[64] + 100
                mem[32] = 105
                _9937 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9937] = 30
                mem[_9937 + 32] = 'SafeMath: subtraction overflow'
                if sub_5fc0d9e0[stor103[idx]] > ext_call.return_data[0]:
                    _9961 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_9961 + idx + 68] = mem[_9937 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_9961 + 68] = mem[_9961 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _9961 + -mem[64] + 100
                if not ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]]:
                    _10063 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10063] = 26
                    mem[_10063 + 32] = 'SafeMath: division by zero'
                    if sub_a090a2b4 <= 0:
                        _10112 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10112 + idx + 68] = mem[_10063 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10112 + 68] = mem[_10112 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10112 + -mem[64] + 100
                    require sub_a090a2b4
                    if sub_5dcea4d4[stor103[idx]] + (0 / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 'SafeMath: addition overflow'
                    sub_5dcea4d4[stor103[idx]] += 0 / sub_a090a2b4
                    sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0]
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                        _10498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10498] = 26
                        mem[_10498 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _10567 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_10567 + idx + 68] = mem[_10498 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_10567 + 68] = mem[_10567 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _10567 + -mem[64] + 100
                        require sub_3c97d5ae
                        mem[0] = rewardTokens[idx]
                        mem[32] = sha3(address(msg.sender), 111) + 1
                        userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                        if not userInfo[address(msg.sender)].field_0:
                            idx = idx + 1
                            continue 
                        mem[0] = rewardTokens[idx]
                        mem[32] = 109
                        require userInfo[address(msg.sender)].field_0
                        if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _11142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11142] = 26
                        mem[_11142 + 32] = 'SafeMath: division by zero'
                        if sub_3c97d5ae <= 0:
                            _11245 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_11245 + idx + 68] = mem[_11142 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11245 + 68] = mem[_11245 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _11245 + -mem[64] + 100
                        require sub_3c97d5ae
                        _11475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11475] = 30
                        mem[_11475 + 32] = 'SafeMath: subtraction overflow'
                        if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                            _11630 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11630 + idx + 68] = mem[_11475 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11630 + 68] = mem[_11630 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11630 + -mem[64] + 100
                        if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                            idx = idx + 1
                            continue 
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(rewardTokens[idx])
                        staticcall rewardTokens[idx].0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if rewardTokens[idx] != joeAddress:
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                                _13030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13030] = 30
                                mem[_13030 + 32] = 'SafeMath: subtraction overflow'
                                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                    _13298 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_13298 + idx + 68] = mem[_13030 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13298 + 68] = mem[_13298 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13298 + -mem[64] + 100
                                mem[0] = rewardTokens[idx]
                                mem[32] = 105
                                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _13750 = mem[64]
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                _13751 = mem[64]
                                mem[mem[64]] = 68
                                mem[64] = mem[64] + 100
                                mem[_13751 + 32] = mem[_13751 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                                mem[64] = _13750 + 164
                                mem[_13750 + 100] = 32
                                mem[_13750 + 132] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13750 + 270 len 26]
                                if ext_code.size(rewardTokens[idx]) <= 0:
                                    revert with 0, 'Address: call to non-contract'
                                _15451 = mem[_13751]
                                t = _13751 + 32
                                u = mem[64]
                                s = mem[_13751]
                                while s >= 32:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s - 32
                                    continue 
                                mem[mem[64] + floor32(mem[_13751])] = mem[_13751 + floor32(mem[_13751]) + -(mem[_13751] % 32) + 64 len mem[_13751] % 32] or Mask(8 * -(mem[_13751] % 32) + 32, -(8 * -(mem[_13751] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13751])])
                                call rewardTokens[idx].mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _15451 + _13750 + -mem[64] + 160]
                                if not return_data.size:
                                    if ext_call.success:
                                        if mem[96] > 0:
                                            require mem[96] >= 32
                                            if not mem[128]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[mem[64] + 110 len 22]
                                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                        idx = idx + 1
                                        continue 
                                    if mem[96] > 0:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    _22154 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = mem[_13750 + 100]
                                    _22156 = mem[_13750 + 100]
                                    idx = 0
                                    while idx < _22156:
                                        mem[_22154 + idx + 68] = mem[_13750 + idx + 132]
                                        idx = idx + 32
                                        continue 
                                    if not _22156 % 32:
                                        revert with memory
                                          from mem[64]
                                           len _22156 + _22154 + -mem[64] + 68
                                    mem[floor32(_22156) + _22154 + 68] = mem[floor32(_22156) + _22154 + -(_22156 % 32) + 100 len _22156 % 32]
                                    revert with memory
                                      from mem[64]
                                       len floor32(_22156) + _22154 + -mem[64] + 100
                                _20793 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size) + 1
                                mem[_20793] = return_data.size
                                mem[_20793 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if ext_call.success:
                                    if return_data.size > 0:
                                        require return_data.size >= 32
                                        if not mem[_20793 + 32]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _22158 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_13750 + 100]
                                _22160 = mem[_13750 + 100]
                                idx = 0
                                while idx < _22160:
                                    mem[_22158 + idx + 68] = mem[_13750 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22160 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22160 + _22158 + -mem[64] + 68
                                mem[floor32(_22160) + _22158 + 68] = mem[floor32(_22160) + _22158 + -(_22160 % 32) + 100 len _22160 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22160) + _22158 + -mem[64] + 100
                            _13031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13031] = 30
                            mem[_13031 + 32] = 'SafeMath: subtraction overflow'
                            if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                                _13301 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13301 + idx + 68] = mem[_13031 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13301 + 68] = mem[_13301 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13301 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                            _13755 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0]
                            _13756 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_13756 + 32] = mem[_13756 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _13755 + 164
                            mem[_13755 + 100] = 32
                            mem[_13755 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_13755 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _15455 = mem[_13756]
                            t = _13756 + 32
                            u = mem[64]
                            s = mem[_13756]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_13756])] = mem[_13756 + floor32(mem[_13756]) + -(mem[_13756] % 32) + 64 len mem[_13756] % 32] or Mask(8 * -(mem[_13756] % 32) + 32, -(8 * -(mem[_13756] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_13756])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _15455 + _13755 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22162 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_13755 + 100]
                                _22164 = mem[_13755 + 100]
                                idx = 0
                                while idx < _22164:
                                    mem[_22162 + idx + 68] = mem[_13755 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22164 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22164 + _22162 + -mem[64] + 68
                                mem[floor32(_22164) + _22162 + 68] = mem[floor32(_22164) + _22162 + -(_22164 % 32) + 100 len _22164 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22164) + _22162 + -mem[64] + 100
                            _20796 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20796] = return_data.size
                            mem[_20796 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20796 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22166 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_13755 + 100]
                            _22168 = mem[_13755 + 100]
                            idx = 0
                            while idx < _22168:
                                mem[_22166 + idx + 68] = mem[_13755 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22168 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22168 + _22166 + -mem[64] + 68
                            mem[floor32(_22168) + _22166 + 68] = mem[floor32(_22168) + _22166 + -(_22168 % 32) + 100 len _22168 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22168) + _22166 + -mem[64] + 100
                        _12807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12807] = 30
                        mem[_12807 + 32] = 'SafeMath: subtraction overflow'
                        if sub_a090a2b4 > ext_call.return_data[0]:
                            _13027 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13027 + idx + 68] = mem[_12807 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13027 + 68] = mem[_13027 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13027 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                            _13748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13748] = 30
                            mem[_13748 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _14224 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14224 + idx + 68] = mem[_13748 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14224 + 68] = mem[_14224 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14224 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14920 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14921 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14921 + 32] = mem[_14921 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14920 + 164
                            mem[_14920 + 100] = 32
                            mem[_14920 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14920 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16489 = mem[_14921]
                            t = _14921 + 32
                            u = mem[64]
                            s = mem[_14921]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14921])] = mem[_14921 + floor32(mem[_14921]) + -(mem[_14921] % 32) + 64 len mem[_14921] % 32] or Mask(8 * -(mem[_14921] % 32) + 32, -(8 * -(mem[_14921] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14921])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16489 + _14920 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14920 + 100]
                                _22140 = mem[_14920 + 100]
                                idx = 0
                                while idx < _22140:
                                    mem[_22138 + idx + 68] = mem[_14920 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22140 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22140 + _22138 + -mem[64] + 68
                                mem[floor32(_22140) + _22138 + 68] = mem[floor32(_22140) + _22138 + -(_22140 % 32) + 100 len _22140 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22140) + _22138 + -mem[64] + 100
                            _20785 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20785] = return_data.size
                            mem[_20785 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20785 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22142 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14920 + 100]
                            _22144 = mem[_14920 + 100]
                            idx = 0
                            while idx < _22144:
                                mem[_22142 + idx + 68] = mem[_14920 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22144 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22144 + _22142 + -mem[64] + 68
                            mem[floor32(_22144) + _22142 + 68] = mem[floor32(_22144) + _22142 + -(_22144 % 32) + 100 len _22144 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22144) + _22142 + -mem[64] + 100
                        _13749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13749] = 30
                        mem[_13749 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                            _14227 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14227 + idx + 68] = mem[_13749 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14227 + 68] = mem[_14227 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14227 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                        _14925 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                        _14926 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14926 + 32] = mem[_14926 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14925 + 164
                        mem[_14925 + 100] = 32
                        mem[_14925 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14925 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16493 = mem[_14926]
                        t = _14926 + 32
                        u = mem[64]
                        s = mem[_14926]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14926])] = mem[_14926 + floor32(mem[_14926]) + -(mem[_14926] % 32) + 64 len mem[_14926] % 32] or Mask(8 * -(mem[_14926] % 32) + 32, -(8 * -(mem[_14926] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14926])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16493 + _14925 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22146 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14925 + 100]
                            _22148 = mem[_14925 + 100]
                            idx = 0
                            while idx < _22148:
                                mem[_22146 + idx + 68] = mem[_14925 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22148 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22148 + _22146 + -mem[64] + 68
                            mem[floor32(_22148) + _22146 + 68] = mem[floor32(_22148) + _22146 + -(_22148 % 32) + 100 len _22148 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22148) + _22146 + -mem[64] + 100
                        _20788 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20788] = return_data.size
                        mem[_20788 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20788 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22150 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14925 + 100]
                        _22152 = mem[_14925 + 100]
                        idx = 0
                        while idx < _22152:
                            mem[_22150 + idx + 68] = mem[_14925 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22152 % 32:
                            revert with memory
                              from mem[64]
                               len _22152 + _22150 + -mem[64] + 68
                        mem[floor32(_22152) + _22150 + 68] = mem[floor32(_22152) + _22150 + -(_22152 % 32) + 100 len _22152 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22152) + _22150 + -mem[64] + 100
                    require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10566 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10566] = 26
                    mem[_10566 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10652 + idx + 68] = mem[_10566 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10652 + 68] = mem[_10652 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10652 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11244] = 26
                    mem[_11244 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11344 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11344 + idx + 68] = mem[_11244 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11344 + 68] = mem[_11344 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11344 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11628] = 30
                    mem[_11628 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _11827 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11827 + idx + 68] = mem[_11628 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11827 + 68] = mem[_11827 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11827 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13295] = 30
                            mem[_13295 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _13568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13568 + idx + 68] = mem[_13295 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13568 + 68] = mem[_13568 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13568 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14214 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14215 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14215 + 32] = mem[_14215 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14214 + 164
                            mem[_14214 + 100] = 32
                            mem[_14214 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14214 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _15895 = mem[_14215]
                            t = _14215 + 32
                            u = mem[64]
                            s = mem[_14215]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14215])] = mem[_14215 + floor32(mem[_14215]) + -(mem[_14215] % 32) + 64 len mem[_14215] % 32] or Mask(8 * -(mem[_14215] % 32) + 32, -(8 * -(mem[_14215] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14215])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _15895 + _14214 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22122 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14214 + 100]
                                _22124 = mem[_14214 + 100]
                                idx = 0
                                while idx < _22124:
                                    mem[_22122 + idx + 68] = mem[_14214 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22124 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22124 + _22122 + -mem[64] + 68
                                mem[floor32(_22124) + _22122 + 68] = mem[floor32(_22124) + _22122 + -(_22124 % 32) + 100 len _22124 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22124) + _22122 + -mem[64] + 100
                            _20773 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20773] = return_data.size
                            mem[_20773 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20773 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22126 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14214 + 100]
                            _22128 = mem[_14214 + 100]
                            idx = 0
                            while idx < _22128:
                                mem[_22126 + idx + 68] = mem[_14214 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22128 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22128 + _22126 + -mem[64] + 68
                            mem[floor32(_22128) + _22126 + 68] = mem[floor32(_22128) + _22126 + -(_22128 % 32) + 100 len _22128 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22128) + _22126 + -mem[64] + 100
                        _13296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13296] = 30
                        mem[_13296 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _13571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13571 + idx + 68] = mem[_13296 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13571 + 68] = mem[_13571 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13571 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14219 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14220 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14220 + 32] = mem[_14220 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14219 + 164
                        mem[_14219 + 100] = 32
                        mem[_14219 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14219 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _15899 = mem[_14220]
                        t = _14220 + 32
                        u = mem[64]
                        s = mem[_14220]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14220])] = mem[_14220 + floor32(mem[_14220]) + -(mem[_14220] % 32) + 64 len mem[_14220] % 32] or Mask(8 * -(mem[_14220] % 32) + 32, -(8 * -(mem[_14220] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14220])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _15899 + _14219 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14219 + 100]
                            _22132 = mem[_14219 + 100]
                            idx = 0
                            while idx < _22132:
                                mem[_22130 + idx + 68] = mem[_14219 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22132 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22132 + _22130 + -mem[64] + 68
                            mem[floor32(_22132) + _22130 + 68] = mem[floor32(_22132) + _22130 + -(_22132 % 32) + 100 len _22132 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22132) + _22130 + -mem[64] + 100
                        _20776 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20776] = return_data.size
                        mem[_20776 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20776 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22134 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14219 + 100]
                        _22136 = mem[_14219 + 100]
                        idx = 0
                        while idx < _22136:
                            mem[_22134 + idx + 68] = mem[_14219 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22136 % 32:
                            revert with memory
                              from mem[64]
                               len _22136 + _22134 + -mem[64] + 68
                        mem[floor32(_22136) + _22134 + 68] = mem[floor32(_22136) + _22134 + -(_22136 % 32) + 100 len _22136 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22136) + _22134 + -mem[64] + 100
                    _13026 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13026] = 30
                    mem[_13026 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13292 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13292 + idx + 68] = mem[_13026 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13292 + 68] = mem[_13292 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13292 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14212] = 30
                        mem[_14212 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14674 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14674 + idx + 68] = mem[_14212 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14674 + 68] = mem[_14674 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14674 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15440 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15441 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15441 + 32] = mem[_15441 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15440 + 164
                        mem[_15440 + 100] = 32
                        mem[_15440 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15440 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16789 = mem[_15441]
                        t = _15441 + 32
                        u = mem[64]
                        s = mem[_15441]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15441])] = mem[_15441 + floor32(mem[_15441]) + -(mem[_15441] % 32) + 64 len mem[_15441] % 32] or Mask(8 * -(mem[_15441] % 32) + 32, -(8 * -(mem[_15441] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15441])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16789 + _15440 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22106 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15440 + 100]
                            _22108 = mem[_15440 + 100]
                            idx = 0
                            while idx < _22108:
                                mem[_22106 + idx + 68] = mem[_15440 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22108 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22108 + _22106 + -mem[64] + 68
                            mem[floor32(_22108) + _22106 + 68] = mem[floor32(_22108) + _22106 + -(_22108 % 32) + 100 len _22108 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22108) + _22106 + -mem[64] + 100
                        _20765 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20765] = return_data.size
                        mem[_20765 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20765 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22110 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15440 + 100]
                        _22112 = mem[_15440 + 100]
                        idx = 0
                        while idx < _22112:
                            mem[_22110 + idx + 68] = mem[_15440 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22112 % 32:
                            revert with memory
                              from mem[64]
                               len _22112 + _22110 + -mem[64] + 68
                        mem[floor32(_22112) + _22110 + 68] = mem[floor32(_22112) + _22110 + -(_22112 % 32) + 100 len _22112 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22112) + _22110 + -mem[64] + 100
                    _14213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14213] = 30
                    mem[_14213 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _14677 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14677 + idx + 68] = mem[_14213 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14677 + 68] = mem[_14677 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14677 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _15445 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _15446 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15446 + 32] = mem[_15446 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15445 + 164
                    mem[_15445 + 100] = 32
                    mem[_15445 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15445 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16793 = mem[_15446]
                    t = _15446 + 32
                    u = mem[64]
                    s = mem[_15446]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15446])] = mem[_15446 + floor32(mem[_15446]) + -(mem[_15446] % 32) + 64 len mem[_15446] % 32] or Mask(8 * -(mem[_15446] % 32) + 32, -(8 * -(mem[_15446] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15446])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16793 + _15445 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22114 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15445 + 100]
                        _22116 = mem[_15445 + 100]
                        idx = 0
                        while idx < _22116:
                            mem[_22114 + idx + 68] = mem[_15445 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22116 % 32:
                            revert with memory
                              from mem[64]
                               len _22116 + _22114 + -mem[64] + 68
                        mem[floor32(_22116) + _22114 + 68] = mem[floor32(_22116) + _22114 + -(_22116 % 32) + 100 len _22116 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22116) + _22114 + -mem[64] + 100
                    _20768 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20768] = return_data.size
                    mem[_20768 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20768 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22118 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15445 + 100]
                    _22120 = mem[_15445 + 100]
                    idx = 0
                    while idx < _22120:
                        mem[_22118 + idx + 68] = mem[_15445 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22120 % 32:
                        revert with memory
                          from mem[64]
                           len _22120 + _22118 + -mem[64] + 68
                    mem[floor32(_22120) + _22118 + 68] = mem[floor32(_22120) + _22118 + -(_22120 % 32) + 100 len _22120 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22120) + _22118 + -mem[64] + 100
                require ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]]
                if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / ext_call.return_data[0] - sub_5fc0d9e0[stor103[idx]] != sub_3c97d5ae:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10111 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10111] = 26
                mem[_10111 + 32] = 'SafeMath: division by zero'
                if sub_a090a2b4 <= 0:
                    _10174 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10174 + idx + 68] = mem[_10111 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10174 + 68] = mem[_10174 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10174 + -mem[64] + 100
                require sub_a090a2b4
                if sub_5dcea4d4[stor103[idx]] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 'SafeMath: addition overflow'
                sub_5dcea4d4[stor103[idx]] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4
                sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0]
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                    _10565 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10565] = 26
                    mem[_10565 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10649 + idx + 68] = mem[_10565 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10649 + 68] = mem[_10649 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10649 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11243 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11243] = 26
                    mem[_11243 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11341 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11341 + idx + 68] = mem[_11243 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11341 + 68] = mem[_11341 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11341 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11626] = 30
                    mem[_11626 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _11824 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11824 + idx + 68] = mem[_11626 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11824 + 68] = mem[_11824 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11824 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13290 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13290] = 30
                            mem[_13290 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _13561 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13561 + idx + 68] = mem[_13290 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13561 + 68] = mem[_13561 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _13561 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14202 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14203 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14203 + 32] = mem[_14203 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14202 + 164
                            mem[_14202 + 100] = 32
                            mem[_14202 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14202 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _15887 = mem[_14203]
                            t = _14203 + 32
                            u = mem[64]
                            s = mem[_14203]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14203])] = mem[_14203 + floor32(mem[_14203]) + -(mem[_14203] % 32) + 64 len mem[_14203] % 32] or Mask(8 * -(mem[_14203] % 32) + 32, -(8 * -(mem[_14203] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14203])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _15887 + _14202 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _22090 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14202 + 100]
                                _22092 = mem[_14202 + 100]
                                idx = 0
                                while idx < _22092:
                                    mem[_22090 + idx + 68] = mem[_14202 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _22092 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _22092 + _22090 + -mem[64] + 68
                                mem[floor32(_22092) + _22090 + 68] = mem[floor32(_22092) + _22090 + -(_22092 % 32) + 100 len _22092 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_22092) + _22090 + -mem[64] + 100
                            _20751 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20751] = return_data.size
                            mem[_20751 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20751 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _22094 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14202 + 100]
                            _22096 = mem[_14202 + 100]
                            idx = 0
                            while idx < _22096:
                                mem[_22094 + idx + 68] = mem[_14202 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22096 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22096 + _22094 + -mem[64] + 68
                            mem[floor32(_22096) + _22094 + 68] = mem[floor32(_22096) + _22094 + -(_22096 % 32) + 100 len _22096 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22096) + _22094 + -mem[64] + 100
                        _13291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13291] = 30
                        mem[_13291 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _13564 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13564 + idx + 68] = mem[_13291 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13564 + 68] = mem[_13564 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13564 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14207 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14208 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14208 + 32] = mem[_14208 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14207 + 164
                        mem[_14207 + 100] = 32
                        mem[_14207 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14207 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _15891 = mem[_14208]
                        t = _14208 + 32
                        u = mem[64]
                        s = mem[_14208]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14208])] = mem[_14208 + floor32(mem[_14208]) + -(mem[_14208] % 32) + 64 len mem[_14208] % 32] or Mask(8 * -(mem[_14208] % 32) + 32, -(8 * -(mem[_14208] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14208])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _15891 + _14207 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14207 + 100]
                            _22100 = mem[_14207 + 100]
                            idx = 0
                            while idx < _22100:
                                mem[_22098 + idx + 68] = mem[_14207 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22100 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22100 + _22098 + -mem[64] + 68
                            mem[floor32(_22100) + _22098 + 68] = mem[floor32(_22100) + _22098 + -(_22100 % 32) + 100 len _22100 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22100) + _22098 + -mem[64] + 100
                        _20754 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20754] = return_data.size
                        mem[_20754 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20754 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22102 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14207 + 100]
                        _22104 = mem[_14207 + 100]
                        idx = 0
                        while idx < _22104:
                            mem[_22102 + idx + 68] = mem[_14207 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22104 % 32:
                            revert with memory
                              from mem[64]
                               len _22104 + _22102 + -mem[64] + 68
                        mem[floor32(_22104) + _22102 + 68] = mem[floor32(_22104) + _22102 + -(_22104 % 32) + 100 len _22104 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22104) + _22102 + -mem[64] + 100
                    _13025 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13025] = 30
                    mem[_13025 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13287 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13287 + idx + 68] = mem[_13025 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13287 + 68] = mem[_13287 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13287 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14200] = 30
                        mem[_14200 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14668 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14668 + idx + 68] = mem[_14200 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14668 + 68] = mem[_14668 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14668 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15430 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15431 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15431 + 32] = mem[_15431 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15430 + 164
                        mem[_15430 + 100] = 32
                        mem[_15430 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15430 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16781 = mem[_15431]
                        t = _15431 + 32
                        u = mem[64]
                        s = mem[_15431]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15431])] = mem[_15431 + floor32(mem[_15431]) + -(mem[_15431] % 32) + 64 len mem[_15431] % 32] or Mask(8 * -(mem[_15431] % 32) + 32, -(8 * -(mem[_15431] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15431])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16781 + _15430 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22074 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15430 + 100]
                            _22076 = mem[_15430 + 100]
                            idx = 0
                            while idx < _22076:
                                mem[_22074 + idx + 68] = mem[_15430 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22076 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22076 + _22074 + -mem[64] + 68
                            mem[floor32(_22076) + _22074 + 68] = mem[floor32(_22076) + _22074 + -(_22076 % 32) + 100 len _22076 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22076) + _22074 + -mem[64] + 100
                        _20743 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20743] = return_data.size
                        mem[_20743 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20743 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22078 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15430 + 100]
                        _22080 = mem[_15430 + 100]
                        idx = 0
                        while idx < _22080:
                            mem[_22078 + idx + 68] = mem[_15430 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22080 % 32:
                            revert with memory
                              from mem[64]
                               len _22080 + _22078 + -mem[64] + 68
                        mem[floor32(_22080) + _22078 + 68] = mem[floor32(_22080) + _22078 + -(_22080 % 32) + 100 len _22080 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22080) + _22078 + -mem[64] + 100
                    _14201 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14201] = 30
                    mem[_14201 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _14671 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14671 + idx + 68] = mem[_14201 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14671 + 68] = mem[_14671 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14671 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _15435 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _15436 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15436 + 32] = mem[_15436 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15435 + 164
                    mem[_15435 + 100] = 32
                    mem[_15435 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15435 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16785 = mem[_15436]
                    t = _15436 + 32
                    u = mem[64]
                    s = mem[_15436]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15436])] = mem[_15436 + floor32(mem[_15436]) + -(mem[_15436] % 32) + 64 len mem[_15436] % 32] or Mask(8 * -(mem[_15436] % 32) + 32, -(8 * -(mem[_15436] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15436])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16785 + _15435 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15435 + 100]
                        _22084 = mem[_15435 + 100]
                        idx = 0
                        while idx < _22084:
                            mem[_22082 + idx + 68] = mem[_15435 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22084 % 32:
                            revert with memory
                              from mem[64]
                               len _22084 + _22082 + -mem[64] + 68
                        mem[floor32(_22084) + _22082 + 68] = mem[floor32(_22084) + _22082 + -(_22084 % 32) + 100 len _22084 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22084) + _22082 + -mem[64] + 100
                    _20746 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20746] = return_data.size
                    mem[_20746 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20746 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22086 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15435 + 100]
                    _22088 = mem[_15435 + 100]
                    idx = 0
                    while idx < _22088:
                        mem[_22086 + idx + 68] = mem[_15435 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22088 % 32:
                        revert with memory
                          from mem[64]
                           len _22088 + _22086 + -mem[64] + 68
                    mem[floor32(_22088) + _22086 + 68] = mem[floor32(_22088) + _22086 + -(_22088 % 32) + 100 len _22088 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22088) + _22086 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10648 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10648] = 26
                mem[_10648 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10737 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10737 + idx + 68] = mem[_10648 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10737 + 68] = mem[_10737 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10737 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11340 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11340] = 26
                mem[_11340 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11470 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11470 + idx + 68] = mem[_11340 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11470 + 68] = mem[_11470 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11470 + -mem[64] + 100
                require sub_3c97d5ae
                _11822 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11822] = 30
                mem[_11822 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12024 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12024 + idx + 68] = mem[_11822 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12024 + 68] = mem[_12024 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12024 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _13558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13558] = 30
                        mem[_13558 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _13947 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_13947 + idx + 68] = mem[_13558 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13947 + 68] = mem[_13947 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _13947 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _14658 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _14659 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14659 + 32] = mem[_14659 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14658 + 164
                        mem[_14658 + 100] = 32
                        mem[_14658 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14658 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16259 = mem[_14659]
                        t = _14659 + 32
                        u = mem[64]
                        s = mem[_14659]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14659])] = mem[_14659 + floor32(mem[_14659]) + -(mem[_14659] % 32) + 64 len mem[_14659] % 32] or Mask(8 * -(mem[_14659] % 32) + 32, -(8 * -(mem[_14659] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14659])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16259 + _14658 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _22058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14658 + 100]
                            _22060 = mem[_14658 + 100]
                            idx = 0
                            while idx < _22060:
                                mem[_22058 + idx + 68] = mem[_14658 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _22060 % 32:
                                revert with memory
                                  from mem[64]
                                   len _22060 + _22058 + -mem[64] + 68
                            mem[floor32(_22060) + _22058 + 68] = mem[floor32(_22060) + _22058 + -(_22060 % 32) + 100 len _22060 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_22060) + _22058 + -mem[64] + 100
                        _20731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20731] = return_data.size
                        mem[_20731 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20731 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22062 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14658 + 100]
                        _22064 = mem[_14658 + 100]
                        idx = 0
                        while idx < _22064:
                            mem[_22062 + idx + 68] = mem[_14658 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22064 % 32:
                            revert with memory
                              from mem[64]
                               len _22064 + _22062 + -mem[64] + 68
                        mem[floor32(_22064) + _22062 + 68] = mem[floor32(_22064) + _22062 + -(_22064 % 32) + 100 len _22064 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22064) + _22062 + -mem[64] + 100
                    _13559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13559] = 30
                    mem[_13559 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _13950 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13950 + idx + 68] = mem[_13559 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13950 + 68] = mem[_13950 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13950 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _14663 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _14664 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_14664 + 32] = mem[_14664 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _14663 + 164
                    mem[_14663 + 100] = 32
                    mem[_14663 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14663 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16263 = mem[_14664]
                    t = _14664 + 32
                    u = mem[64]
                    s = mem[_14664]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_14664])] = mem[_14664 + floor32(mem[_14664]) + -(mem[_14664] % 32) + 64 len mem[_14664] % 32] or Mask(8 * -(mem[_14664] % 32) + 32, -(8 * -(mem[_14664] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14664])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16263 + _14663 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22066 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14663 + 100]
                        _22068 = mem[_14663 + 100]
                        idx = 0
                        while idx < _22068:
                            mem[_22066 + idx + 68] = mem[_14663 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22068 % 32:
                            revert with memory
                              from mem[64]
                               len _22068 + _22066 + -mem[64] + 68
                        mem[floor32(_22068) + _22066 + 68] = mem[floor32(_22068) + _22066 + -(_22068 % 32) + 100 len _22068 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22068) + _22066 + -mem[64] + 100
                    _20734 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20734] = return_data.size
                    mem[_20734 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20734 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22070 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_14663 + 100]
                    _22072 = mem[_14663 + 100]
                    idx = 0
                    while idx < _22072:
                        mem[_22070 + idx + 68] = mem[_14663 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22072 % 32:
                        revert with memory
                          from mem[64]
                           len _22072 + _22070 + -mem[64] + 68
                    mem[floor32(_22072) + _22070 + 68] = mem[floor32(_22072) + _22070 + -(_22072 % 32) + 100 len _22072 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22072) + _22070 + -mem[64] + 100
                _13286 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13286] = 30
                mem[_13286 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _13555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_13555 + idx + 68] = mem[_13286 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13555 + 68] = mem[_13555 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _13555 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _14656 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14656] = 30
                    mem[_14656 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15149 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15149 + idx + 68] = mem[_14656 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15149 + 68] = mem[_15149 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15149 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15876 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15877 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15877 + 32] = mem[_15877 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15876 + 164
                    mem[_15876 + 100] = 32
                    mem[_15876 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15876 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17061 = mem[_15877]
                    t = _15877 + 32
                    u = mem[64]
                    s = mem[_15877]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15877])] = mem[_15877 + floor32(mem[_15877]) + -(mem[_15877] % 32) + 64 len mem[_15877] % 32] or Mask(8 * -(mem[_15877] % 32) + 32, -(8 * -(mem[_15877] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15877])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17061 + _15876 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _22042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15876 + 100]
                        _22044 = mem[_15876 + 100]
                        idx = 0
                        while idx < _22044:
                            mem[_22042 + idx + 68] = mem[_15876 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _22044 % 32:
                            revert with memory
                              from mem[64]
                               len _22044 + _22042 + -mem[64] + 68
                        mem[floor32(_22044) + _22042 + 68] = mem[floor32(_22044) + _22042 + -(_22044 % 32) + 100 len _22044 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_22044) + _22042 + -mem[64] + 100
                    _20723 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20723] = return_data.size
                    mem[_20723 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20723 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22046 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15876 + 100]
                    _22048 = mem[_15876 + 100]
                    idx = 0
                    while idx < _22048:
                        mem[_22046 + idx + 68] = mem[_15876 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22048 % 32:
                        revert with memory
                          from mem[64]
                           len _22048 + _22046 + -mem[64] + 68
                    mem[floor32(_22048) + _22046 + 68] = mem[floor32(_22048) + _22046 + -(_22048 % 32) + 100 len _22048 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22048) + _22046 + -mem[64] + 100
                _14657 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14657] = 30
                mem[_14657 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15152 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15152 + idx + 68] = mem[_14657 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15152 + 68] = mem[_15152 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15152 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _15881 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _15882 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_15882 + 32] = mem[_15882 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _15881 + 164
                mem[_15881 + 100] = 32
                mem[_15881 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15881 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17065 = mem[_15882]
                t = _15882 + 32
                u = mem[64]
                s = mem[_15882]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_15882])] = mem[_15882 + floor32(mem[_15882]) + -(mem[_15882] % 32) + 64 len mem[_15882] % 32] or Mask(8 * -(mem[_15882] % 32) + 32, -(8 * -(mem[_15882] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15882])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17065 + _15881 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _22050 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15881 + 100]
                    _22052 = mem[_15881 + 100]
                    idx = 0
                    while idx < _22052:
                        mem[_22050 + idx + 68] = mem[_15881 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _22052 % 32:
                        revert with memory
                          from mem[64]
                           len _22052 + _22050 + -mem[64] + 68
                    mem[floor32(_22052) + _22050 + 68] = mem[floor32(_22052) + _22050 + -(_22052 % 32) + 100 len _22052 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_22052) + _22050 + -mem[64] + 100
                _20726 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20726] = return_data.size
                mem[_20726 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20726 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _22054 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_15881 + 100]
                _22056 = mem[_15881 + 100]
                idx = 0
                while idx < _22056:
                    mem[_22054 + idx + 68] = mem[_15881 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _22056 % 32:
                    revert with memory
                      from mem[64]
                       len _22056 + _22054 + -mem[64] + 68
                mem[floor32(_22056) + _22054 + 68] = mem[floor32(_22056) + _22054 + -(_22056 % 32) + 100 len _22056 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_22056) + _22054 + -mem[64] + 100
            _9918 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9918] = 30
            mem[_9918 + 32] = 'SafeMath: subtraction overflow'
            if sub_a090a2b4 > ext_call.return_data[0]:
                _9924 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_9924 + idx + 68] = mem[_9918 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_9924 + 68] = mem[_9924 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _9924 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            if ext_call.return_data[0] - sub_a090a2b4 == sub_5fc0d9e0[stor103[idx]]:
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                    _10074 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10074] = 26
                    mem[_10074 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10141 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10141 + idx + 68] = mem[_10074 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10141 + 68] = mem[_10141 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10141 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10452 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10452] = 26
                    mem[_10452 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10525 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10525 + idx + 68] = mem[_10452 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10525 + 68] = mem[_10525 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10525 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10685 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10685] = 30
                    mem[_10685 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10788 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10788 + idx + 68] = mem[_10685 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10788 + 68] = mem[_10788 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10788 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11512] = 30
                            mem[_11512 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11702 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11702 + idx + 68] = mem[_11512 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11702 + 68] = mem[_11702 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11702 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11986 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _11987 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_11987 + 32] = mem[_11987 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _11986 + 164
                            mem[_11986 + 100] = 32
                            mem[_11986 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11986 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12771 = mem[_11987]
                            t = _11987 + 32
                            u = mem[64]
                            s = mem[_11987]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_11987])] = mem[_11987 + floor32(mem[_11987]) + -(mem[_11987] % 32) + 64 len mem[_11987] % 32] or Mask(8 * -(mem[_11987] % 32) + 32, -(8 * -(mem[_11987] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11987])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12771 + _11986 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _21770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_11986 + 100]
                                _21772 = mem[_11986 + 100]
                                idx = 0
                                while idx < _21772:
                                    mem[_21770 + idx + 68] = mem[_11986 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _21772 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _21772 + _21770 + -mem[64] + 68
                                mem[floor32(_21772) + _21770 + 68] = mem[floor32(_21772) + _21770 + -(_21772 % 32) + 100 len _21772 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_21772) + _21770 + -mem[64] + 100
                            _20543 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20543] = return_data.size
                            mem[_20543 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20543 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21774 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11986 + 100]
                            _21776 = mem[_11986 + 100]
                            idx = 0
                            while idx < _21776:
                                mem[_21774 + idx + 68] = mem[_11986 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21776 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21776 + _21774 + -mem[64] + 68
                            mem[floor32(_21776) + _21774 + 68] = mem[floor32(_21776) + _21774 + -(_21776 % 32) + 100 len _21776 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21776) + _21774 + -mem[64] + 100
                        _11513 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11513] = 30
                        mem[_11513 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11705 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11705 + idx + 68] = mem[_11513 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11705 + 68] = mem[_11705 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11705 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _11991 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _11992 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_11992 + 32] = mem[_11992 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _11991 + 164
                        mem[_11991 + 100] = 32
                        mem[_11991 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_11991 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12775 = mem[_11992]
                        t = _11992 + 32
                        u = mem[64]
                        s = mem[_11992]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_11992])] = mem[_11992 + floor32(mem[_11992]) + -(mem[_11992] % 32) + 64 len mem[_11992] % 32] or Mask(8 * -(mem[_11992] % 32) + 32, -(8 * -(mem[_11992] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_11992])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12775 + _11991 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21778 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_11991 + 100]
                            _21780 = mem[_11991 + 100]
                            idx = 0
                            while idx < _21780:
                                mem[_21778 + idx + 68] = mem[_11991 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21780 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21780 + _21778 + -mem[64] + 68
                            mem[floor32(_21780) + _21778 + 68] = mem[floor32(_21780) + _21778 + -(_21780 % 32) + 100 len _21780 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21780) + _21778 + -mem[64] + 100
                        _20546 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20546] = return_data.size
                        mem[_20546 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20546 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21782 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_11991 + 100]
                        _21784 = mem[_11991 + 100]
                        idx = 0
                        while idx < _21784:
                            mem[_21782 + idx + 68] = mem[_11991 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21784 % 32:
                            revert with memory
                              from mem[64]
                               len _21784 + _21782 + -mem[64] + 68
                        mem[floor32(_21784) + _21782 + 68] = mem[floor32(_21784) + _21782 + -(_21784 % 32) + 100 len _21784 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21784) + _21782 + -mem[64] + 100
                    _11395 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11395] = 30
                    mem[_11395 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11509 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11509 + idx + 68] = mem[_11395 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11509 + 68] = mem[_11509 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11509 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _11984 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11984] = 30
                        mem[_11984 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12236 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12236 + idx + 68] = mem[_11984 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12236 + 68] = mem[_12236 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12236 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12566 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12567 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12567 + 32] = mem[_12567 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12566 + 164
                        mem[_12566 + 100] = 32
                        mem[_12566 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12566 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13383 = mem[_12567]
                        t = _12567 + 32
                        u = mem[64]
                        s = mem[_12567]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12567])] = mem[_12567 + floor32(mem[_12567]) + -(mem[_12567] % 32) + 64 len mem[_12567] % 32] or Mask(8 * -(mem[_12567] % 32) + 32, -(8 * -(mem[_12567] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12567])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13383 + _12566 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21754 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12566 + 100]
                            _21756 = mem[_12566 + 100]
                            idx = 0
                            while idx < _21756:
                                mem[_21754 + idx + 68] = mem[_12566 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21756 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21756 + _21754 + -mem[64] + 68
                            mem[floor32(_21756) + _21754 + 68] = mem[floor32(_21756) + _21754 + -(_21756 % 32) + 100 len _21756 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21756) + _21754 + -mem[64] + 100
                        _20535 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20535] = return_data.size
                        mem[_20535 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20535 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21758 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12566 + 100]
                        _21760 = mem[_12566 + 100]
                        idx = 0
                        while idx < _21760:
                            mem[_21758 + idx + 68] = mem[_12566 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21760 % 32:
                            revert with memory
                              from mem[64]
                               len _21760 + _21758 + -mem[64] + 68
                        mem[floor32(_21760) + _21758 + 68] = mem[floor32(_21760) + _21758 + -(_21760 % 32) + 100 len _21760 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21760) + _21758 + -mem[64] + 100
                    _11985 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11985] = 30
                    mem[_11985 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12239 + idx + 68] = mem[_11985 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12239 + 68] = mem[_12239 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12239 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12571 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12572 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12572 + 32] = mem[_12572 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12571 + 164
                    mem[_12571 + 100] = 32
                    mem[_12571 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12571 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13387 = mem[_12572]
                    t = _12572 + 32
                    u = mem[64]
                    s = mem[_12572]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12572])] = mem[_12572 + floor32(mem[_12572]) + -(mem[_12572] % 32) + 64 len mem[_12572] % 32] or Mask(8 * -(mem[_12572] % 32) + 32, -(8 * -(mem[_12572] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12572])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13387 + _12571 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21762 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12571 + 100]
                        _21764 = mem[_12571 + 100]
                        idx = 0
                        while idx < _21764:
                            mem[_21762 + idx + 68] = mem[_12571 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21764 % 32:
                            revert with memory
                              from mem[64]
                               len _21764 + _21762 + -mem[64] + 68
                        mem[floor32(_21764) + _21762 + 68] = mem[floor32(_21764) + _21762 + -(_21764 % 32) + 100 len _21764 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21764) + _21762 + -mem[64] + 100
                    _20538 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20538] = return_data.size
                    mem[_20538 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20538 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21766 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12571 + 100]
                    _21768 = mem[_12571 + 100]
                    idx = 0
                    while idx < _21768:
                        mem[_21766 + idx + 68] = mem[_12571 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21768 % 32:
                        revert with memory
                          from mem[64]
                           len _21768 + _21766 + -mem[64] + 68
                    mem[floor32(_21768) + _21766 + 68] = mem[floor32(_21768) + _21766 + -(_21768 % 32) + 100 len _21768 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21768) + _21766 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10140 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10140] = 26
                mem[_10140 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10202 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10202 + idx + 68] = mem[_10140 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10202 + 68] = mem[_10202 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10202 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10524 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10524] = 26
                mem[_10524 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10608 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10608 + idx + 68] = mem[_10524 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10608 + 68] = mem[_10608 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10608 + -mem[64] + 100
                require sub_3c97d5ae
                _10786 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10786] = 30
                mem[_10786 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _10884 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10884 + idx + 68] = mem[_10786 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10884 + 68] = mem[_10884 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _10884 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _11699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11699] = 30
                        mem[_11699 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _11897 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11897 + idx + 68] = mem[_11699 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11897 + 68] = mem[_11897 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11897 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12226 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12227 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12227 + 32] = mem[_12227 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12226 + 164
                        mem[_12226 + 100] = 32
                        mem[_12226 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12226 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12963 = mem[_12227]
                        t = _12227 + 32
                        u = mem[64]
                        s = mem[_12227]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12227])] = mem[_12227 + floor32(mem[_12227]) + -(mem[_12227] % 32) + 64 len mem[_12227] % 32] or Mask(8 * -(mem[_12227] % 32) + 32, -(8 * -(mem[_12227] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12227])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12963 + _12226 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21738 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12226 + 100]
                            _21740 = mem[_12226 + 100]
                            idx = 0
                            while idx < _21740:
                                mem[_21738 + idx + 68] = mem[_12226 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21740 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21740 + _21738 + -mem[64] + 68
                            mem[floor32(_21740) + _21738 + 68] = mem[floor32(_21740) + _21738 + -(_21740 % 32) + 100 len _21740 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21740) + _21738 + -mem[64] + 100
                        _20523 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20523] = return_data.size
                        mem[_20523 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20523 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21742 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12226 + 100]
                        _21744 = mem[_12226 + 100]
                        idx = 0
                        while idx < _21744:
                            mem[_21742 + idx + 68] = mem[_12226 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21744 % 32:
                            revert with memory
                              from mem[64]
                               len _21744 + _21742 + -mem[64] + 68
                        mem[floor32(_21744) + _21742 + 68] = mem[floor32(_21744) + _21742 + -(_21744 % 32) + 100 len _21744 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21744) + _21742 + -mem[64] + 100
                    _11700 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11700] = 30
                    mem[_11700 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _11900 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11900 + idx + 68] = mem[_11700 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11900 + 68] = mem[_11900 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11900 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _12231 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _12232 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12232 + 32] = mem[_12232 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12231 + 164
                    mem[_12231 + 100] = 32
                    mem[_12231 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12231 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _12967 = mem[_12232]
                    t = _12232 + 32
                    u = mem[64]
                    s = mem[_12232]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12232])] = mem[_12232 + floor32(mem[_12232]) + -(mem[_12232] % 32) + 64 len mem[_12232] % 32] or Mask(8 * -(mem[_12232] % 32) + 32, -(8 * -(mem[_12232] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12232])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _12967 + _12231 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21746 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12231 + 100]
                        _21748 = mem[_12231 + 100]
                        idx = 0
                        while idx < _21748:
                            mem[_21746 + idx + 68] = mem[_12231 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21748 % 32:
                            revert with memory
                              from mem[64]
                               len _21748 + _21746 + -mem[64] + 68
                        mem[floor32(_21748) + _21746 + 68] = mem[floor32(_21748) + _21746 + -(_21748 % 32) + 100 len _21748 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21748) + _21746 + -mem[64] + 100
                    _20526 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20526] = return_data.size
                    mem[_20526 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20526 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21750 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12231 + 100]
                    _21752 = mem[_12231 + 100]
                    idx = 0
                    while idx < _21752:
                        mem[_21750 + idx + 68] = mem[_12231 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21752 % 32:
                        revert with memory
                          from mem[64]
                           len _21752 + _21750 + -mem[64] + 68
                    mem[floor32(_21752) + _21750 + 68] = mem[floor32(_21752) + _21750 + -(_21752 % 32) + 100 len _21752 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21752) + _21750 + -mem[64] + 100
                _11508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11508] = 30
                mem[_11508 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _11696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_11696 + idx + 68] = mem[_11508 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11696 + 68] = mem[_11696 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _11696 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _12224 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12224] = 30
                    mem[_12224 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _12466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12466 + idx + 68] = mem[_12224 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12466 + 68] = mem[_12466 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12466 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12760 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12761 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12761 + 32] = mem[_12761 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12760 + 164
                    mem[_12760 + 100] = 32
                    mem[_12760 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12760 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13669 = mem[_12761]
                    t = _12761 + 32
                    u = mem[64]
                    s = mem[_12761]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12761])] = mem[_12761 + floor32(mem[_12761]) + -(mem[_12761] % 32) + 64 len mem[_12761] % 32] or Mask(8 * -(mem[_12761] % 32) + 32, -(8 * -(mem[_12761] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12761])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13669 + _12760 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21722 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12760 + 100]
                        _21724 = mem[_12760 + 100]
                        s = 0
                        while s < _21724:
                            mem[_21722 + s + 68] = mem[_12760 + s + 132]
                            s = s + 32
                            continue 
                        if not _21724 % 32:
                            revert with memory
                              from mem[64]
                               len _21724 + _21722 + -mem[64] + 68
                        mem[floor32(_21724) + _21722 + 68] = mem[floor32(_21724) + _21722 + -(_21724 % 32) + 100 len _21724 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21724) + _21722 + -mem[64] + 100
                    _20515 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20515] = return_data.size
                    mem[_20515 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20515 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21726 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12760 + 100]
                    _21728 = mem[_12760 + 100]
                    s = 0
                    while s < _21728:
                        mem[_21726 + s + 68] = mem[_12760 + s + 132]
                        s = s + 32
                        continue 
                    if not _21728 % 32:
                        revert with memory
                          from mem[64]
                           len _21728 + _21726 + -mem[64] + 68
                    mem[floor32(_21728) + _21726 + 68] = mem[floor32(_21728) + _21726 + -(_21728 % 32) + 100 len _21728 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21728) + _21726 + -mem[64] + 100
                _12225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12225] = 30
                mem[_12225 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _12469 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12469 + idx + 68] = mem[_12225 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12469 + 68] = mem[_12469 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12469 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _12765 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _12766 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12766 + 32] = mem[_12766 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _12765 + 164
                mem[_12765 + 100] = 32
                mem[_12765 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12765 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _13673 = mem[_12766]
                t = _12766 + 32
                u = mem[64]
                s = mem[_12766]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_12766])] = mem[_12766 + floor32(mem[_12766]) + -(mem[_12766] % 32) + 64 len mem[_12766] % 32] or Mask(8 * -(mem[_12766] % 32) + 32, -(8 * -(mem[_12766] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12766])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13673 + _12765 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21730 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12765 + 100]
                    _21732 = mem[_12765 + 100]
                    s = 0
                    while s < _21732:
                        mem[_21730 + s + 68] = mem[_12765 + s + 132]
                        s = s + 32
                        continue 
                    if not _21732 % 32:
                        revert with memory
                          from mem[64]
                           len _21732 + _21730 + -mem[64] + 68
                    mem[floor32(_21732) + _21730 + 68] = mem[floor32(_21732) + _21730 + -(_21732 % 32) + 100 len _21732 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21732) + _21730 + -mem[64] + 100
                _20518 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20518] = return_data.size
                mem[_20518 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20518 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21734 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_12765 + 100]
                _21736 = mem[_12765 + 100]
                s = 0
                while s < _21736:
                    mem[_21734 + s + 68] = mem[_12765 + s + 132]
                    s = s + 32
                    continue 
                if not _21736 % 32:
                    revert with memory
                      from mem[64]
                       len _21736 + _21734 + -mem[64] + 68
                mem[floor32(_21736) + _21734 + 68] = mem[floor32(_21736) + _21734 + -(_21736 % 32) + 100 len _21736 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21736) + _21734 + -mem[64] + 100
            if not sub_a090a2b4:
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                    _10107 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10107] = 26
                    mem[_10107 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10169 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10169 + idx + 68] = mem[_10107 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10169 + 68] = mem[_10169 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10169 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _10494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10494] = 26
                    mem[_10494 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10557 + idx + 68] = mem[_10494 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10557 + 68] = mem[_10557 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10557 + -mem[64] + 100
                    require sub_3c97d5ae
                    _10733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10733] = 30
                    mem[_10733 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _10848 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_10848 + idx + 68] = mem[_10733 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10848 + 68] = mem[_10848 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _10848 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _11612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11612] = 30
                            mem[_11612 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _11812 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11812 + idx + 68] = mem[_11612 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11812 + 68] = mem[_11812 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _11812 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12129 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _12130 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_12130 + 32] = mem[_12130 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _12129 + 164
                            mem[_12129 + 100] = 32
                            mem[_12129 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12129 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _12897 = mem[_12130]
                            t = _12130 + 32
                            u = mem[64]
                            s = mem[_12130]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_12130])] = mem[_12130 + floor32(mem[_12130]) + -(mem[_12130] % 32) + 64 len mem[_12130] % 32] or Mask(8 * -(mem[_12130] % 32) + 32, -(8 * -(mem[_12130] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12130])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _12897 + _12129 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _21962 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_12129 + 100]
                                _21964 = mem[_12129 + 100]
                                idx = 0
                                while idx < _21964:
                                    mem[_21962 + idx + 68] = mem[_12129 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _21964 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _21964 + _21962 + -mem[64] + 68
                                mem[floor32(_21964) + _21962 + 68] = mem[floor32(_21964) + _21962 + -(_21964 % 32) + 100 len _21964 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_21964) + _21962 + -mem[64] + 100
                            _20669 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20669] = return_data.size
                            mem[_20669 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20669 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21966 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12129 + 100]
                            _21968 = mem[_12129 + 100]
                            idx = 0
                            while idx < _21968:
                                mem[_21966 + idx + 68] = mem[_12129 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21968 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21968 + _21966 + -mem[64] + 68
                            mem[floor32(_21968) + _21966 + 68] = mem[floor32(_21968) + _21966 + -(_21968 % 32) + 100 len _21968 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21968) + _21966 + -mem[64] + 100
                        _11613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11613] = 30
                        mem[_11613 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _11815 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11815 + idx + 68] = mem[_11613 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11815 + 68] = mem[_11815 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _11815 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _12134 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _12135 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12135 + 32] = mem[_12135 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12134 + 164
                        mem[_12134 + 100] = 32
                        mem[_12134 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12134 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _12901 = mem[_12135]
                        t = _12135 + 32
                        u = mem[64]
                        s = mem[_12135]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12135])] = mem[_12135 + floor32(mem[_12135]) + -(mem[_12135] % 32) + 64 len mem[_12135] % 32] or Mask(8 * -(mem[_12135] % 32) + 32, -(8 * -(mem[_12135] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12135])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _12901 + _12134 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12134 + 100]
                            _21972 = mem[_12134 + 100]
                            idx = 0
                            while idx < _21972:
                                mem[_21970 + idx + 68] = mem[_12134 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21972 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21972 + _21970 + -mem[64] + 68
                            mem[floor32(_21972) + _21970 + 68] = mem[floor32(_21972) + _21970 + -(_21972 % 32) + 100 len _21972 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21972) + _21970 + -mem[64] + 100
                        _20672 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20672] = return_data.size
                        mem[_20672 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20672 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21974 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12134 + 100]
                        _21976 = mem[_12134 + 100]
                        idx = 0
                        while idx < _21976:
                            mem[_21974 + idx + 68] = mem[_12134 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21976 % 32:
                            revert with memory
                              from mem[64]
                               len _21976 + _21974 + -mem[64] + 68
                        mem[floor32(_21976) + _21974 + 68] = mem[floor32(_21976) + _21974 + -(_21976 % 32) + 100 len _21976 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21976) + _21974 + -mem[64] + 100
                    _11455 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11455] = 30
                    mem[_11455 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _11609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11609 + idx + 68] = mem[_11455 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11609 + 68] = mem[_11609 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _11609 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _12127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12127] = 30
                        mem[_12127 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12381 + idx + 68] = mem[_12127 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12381 + 68] = mem[_12381 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12381 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12688 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12689 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12689 + 32] = mem[_12689 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12688 + 164
                        mem[_12688 + 100] = 32
                        mem[_12688 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12688 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13532 = mem[_12689]
                        t = _12689 + 32
                        u = mem[64]
                        s = mem[_12689]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12689])] = mem[_12689 + floor32(mem[_12689]) + -(mem[_12689] % 32) + 64 len mem[_12689] % 32] or Mask(8 * -(mem[_12689] % 32) + 32, -(8 * -(mem[_12689] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12689])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13532 + _12688 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21946 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12688 + 100]
                            _21948 = mem[_12688 + 100]
                            idx = 0
                            while idx < _21948:
                                mem[_21946 + idx + 68] = mem[_12688 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21948 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21948 + _21946 + -mem[64] + 68
                            mem[floor32(_21948) + _21946 + 68] = mem[floor32(_21948) + _21946 + -(_21948 % 32) + 100 len _21948 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21948) + _21946 + -mem[64] + 100
                        _20661 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20661] = return_data.size
                        mem[_20661 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20661 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21950 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12688 + 100]
                        _21952 = mem[_12688 + 100]
                        idx = 0
                        while idx < _21952:
                            mem[_21950 + idx + 68] = mem[_12688 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21952 % 32:
                            revert with memory
                              from mem[64]
                               len _21952 + _21950 + -mem[64] + 68
                        mem[floor32(_21952) + _21950 + 68] = mem[floor32(_21952) + _21950 + -(_21952 % 32) + 100 len _21952 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21952) + _21950 + -mem[64] + 100
                    _12128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12128] = 30
                    mem[_12128 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _12384 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12384 + idx + 68] = mem[_12128 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12384 + 68] = mem[_12384 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12384 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _12693 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _12694 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12694 + 32] = mem[_12694 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12693 + 164
                    mem[_12693 + 100] = 32
                    mem[_12693 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12693 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13536 = mem[_12694]
                    t = _12694 + 32
                    u = mem[64]
                    s = mem[_12694]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12694])] = mem[_12694 + floor32(mem[_12694]) + -(mem[_12694] % 32) + 64 len mem[_12694] % 32] or Mask(8 * -(mem[_12694] % 32) + 32, -(8 * -(mem[_12694] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12694])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13536 + _12693 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21954 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12693 + 100]
                        _21956 = mem[_12693 + 100]
                        idx = 0
                        while idx < _21956:
                            mem[_21954 + idx + 68] = mem[_12693 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21956 % 32:
                            revert with memory
                              from mem[64]
                               len _21956 + _21954 + -mem[64] + 68
                        mem[floor32(_21956) + _21954 + 68] = mem[floor32(_21956) + _21954 + -(_21956 % 32) + 100 len _21956 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21956) + _21954 + -mem[64] + 100
                    _20664 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20664] = return_data.size
                    mem[_20664 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20664 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12693 + 100]
                    _21960 = mem[_12693 + 100]
                    idx = 0
                    while idx < _21960:
                        mem[_21958 + idx + 68] = mem[_12693 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21960 % 32:
                        revert with memory
                          from mem[64]
                           len _21960 + _21958 + -mem[64] + 68
                    mem[floor32(_21960) + _21958 + 68] = mem[floor32(_21960) + _21958 + -(_21960 % 32) + 100 len _21960 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21960) + _21958 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10168 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10168] = 26
                mem[_10168 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10229 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10229 + idx + 68] = mem[_10168 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10229 + 68] = mem[_10229 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10229 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10556 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10556] = 26
                mem[_10556 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10640 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10640 + idx + 68] = mem[_10556 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10640 + 68] = mem[_10640 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10640 + -mem[64] + 100
                require sub_3c97d5ae
                _10846 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10846] = 30
                mem[_10846 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _10961 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_10961 + idx + 68] = mem[_10846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10961 + 68] = mem[_10961 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _10961 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _11809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11809] = 30
                        mem[_11809 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _12001 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12001 + idx + 68] = mem[_11809 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12001 + 68] = mem[_12001 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _12001 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12371 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _12372 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_12372 + 32] = mem[_12372 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _12371 + 164
                        mem[_12371 + 100] = 32
                        mem[_12371 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12371 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _13114 = mem[_12372]
                        t = _12372 + 32
                        u = mem[64]
                        s = mem[_12372]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_12372])] = mem[_12372 + floor32(mem[_12372]) + -(mem[_12372] % 32) + 64 len mem[_12372] % 32] or Mask(8 * -(mem[_12372] % 32) + 32, -(8 * -(mem[_12372] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12372])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _13114 + _12371 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21930 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_12371 + 100]
                            _21932 = mem[_12371 + 100]
                            idx = 0
                            while idx < _21932:
                                mem[_21930 + idx + 68] = mem[_12371 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21932 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21932 + _21930 + -mem[64] + 68
                            mem[floor32(_21932) + _21930 + 68] = mem[floor32(_21932) + _21930 + -(_21932 % 32) + 100 len _21932 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21932) + _21930 + -mem[64] + 100
                        _20649 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20649] = return_data.size
                        mem[_20649 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20649 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21934 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12371 + 100]
                        _21936 = mem[_12371 + 100]
                        idx = 0
                        while idx < _21936:
                            mem[_21934 + idx + 68] = mem[_12371 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21936 % 32:
                            revert with memory
                              from mem[64]
                               len _21936 + _21934 + -mem[64] + 68
                        mem[floor32(_21936) + _21934 + 68] = mem[floor32(_21936) + _21934 + -(_21936 % 32) + 100 len _21936 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21936) + _21934 + -mem[64] + 100
                    _11810 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11810] = 30
                    mem[_11810 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _12004 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12004 + idx + 68] = mem[_11810 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12004 + 68] = mem[_12004 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12004 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _12376 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _12377 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12377 + 32] = mem[_12377 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12376 + 164
                    mem[_12376 + 100] = 32
                    mem[_12376 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12376 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13118 = mem[_12377]
                    t = _12377 + 32
                    u = mem[64]
                    s = mem[_12377]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12377])] = mem[_12377 + floor32(mem[_12377]) + -(mem[_12377] % 32) + 64 len mem[_12377] % 32] or Mask(8 * -(mem[_12377] % 32) + 32, -(8 * -(mem[_12377] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12377])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13118 + _12376 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21938 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12376 + 100]
                        _21940 = mem[_12376 + 100]
                        idx = 0
                        while idx < _21940:
                            mem[_21938 + idx + 68] = mem[_12376 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21940 % 32:
                            revert with memory
                              from mem[64]
                               len _21940 + _21938 + -mem[64] + 68
                        mem[floor32(_21940) + _21938 + 68] = mem[floor32(_21940) + _21938 + -(_21940 % 32) + 100 len _21940 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21940) + _21938 + -mem[64] + 100
                    _20652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20652] = return_data.size
                    mem[_20652 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20652 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21942 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12376 + 100]
                    _21944 = mem[_12376 + 100]
                    idx = 0
                    while idx < _21944:
                        mem[_21942 + idx + 68] = mem[_12376 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21944 % 32:
                        revert with memory
                          from mem[64]
                           len _21944 + _21942 + -mem[64] + 68
                    mem[floor32(_21944) + _21942 + 68] = mem[floor32(_21944) + _21942 + -(_21944 % 32) + 100 len _21944 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21944) + _21942 + -mem[64] + 100
                _11608 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11608] = 30
                mem[_11608 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _11806 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_11806 + idx + 68] = mem[_11608 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11806 + 68] = mem[_11806 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _11806 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _12369 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12369] = 30
                    mem[_12369 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _12582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12582 + idx + 68] = mem[_12369 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12582 + 68] = mem[_12582 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12582 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12886 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _12887 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_12887 + 32] = mem[_12887 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _12886 + 164
                    mem[_12886 + 100] = 32
                    mem[_12886 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12886 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _13895 = mem[_12887]
                    t = _12887 + 32
                    u = mem[64]
                    s = mem[_12887]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_12887])] = mem[_12887 + floor32(mem[_12887]) + -(mem[_12887] % 32) + 64 len mem[_12887] % 32] or Mask(8 * -(mem[_12887] % 32) + 32, -(8 * -(mem[_12887] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12887])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _13895 + _12886 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21914 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_12886 + 100]
                        _21916 = mem[_12886 + 100]
                        idx = 0
                        while idx < _21916:
                            mem[_21914 + idx + 68] = mem[_12886 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21916 % 32:
                            revert with memory
                              from mem[64]
                               len _21916 + _21914 + -mem[64] + 68
                        mem[floor32(_21916) + _21914 + 68] = mem[floor32(_21916) + _21914 + -(_21916 % 32) + 100 len _21916 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21916) + _21914 + -mem[64] + 100
                    _20641 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20641] = return_data.size
                    mem[_20641 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20641 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21918 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12886 + 100]
                    _21920 = mem[_12886 + 100]
                    idx = 0
                    while idx < _21920:
                        mem[_21918 + idx + 68] = mem[_12886 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21920 % 32:
                        revert with memory
                          from mem[64]
                           len _21920 + _21918 + -mem[64] + 68
                    mem[floor32(_21920) + _21918 + 68] = mem[floor32(_21920) + _21918 + -(_21920 % 32) + 100 len _21920 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21920) + _21918 + -mem[64] + 100
                _12370 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12370] = 30
                mem[_12370 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _12585 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12585 + idx + 68] = mem[_12370 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12585 + 68] = mem[_12585 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12585 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _12891 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _12892 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_12892 + 32] = mem[_12892 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _12891 + 164
                mem[_12891 + 100] = 32
                mem[_12891 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_12891 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _13899 = mem[_12892]
                t = _12892 + 32
                u = mem[64]
                s = mem[_12892]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_12892])] = mem[_12892 + floor32(mem[_12892]) + -(mem[_12892] % 32) + 64 len mem[_12892] % 32] or Mask(8 * -(mem[_12892] % 32) + 32, -(8 * -(mem[_12892] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_12892])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _13899 + _12891 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21922 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_12891 + 100]
                    _21924 = mem[_12891 + 100]
                    idx = 0
                    while idx < _21924:
                        mem[_21922 + idx + 68] = mem[_12891 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21924 % 32:
                        revert with memory
                          from mem[64]
                           len _21924 + _21922 + -mem[64] + 68
                    mem[floor32(_21924) + _21922 + 68] = mem[floor32(_21924) + _21922 + -(_21924 % 32) + 100 len _21924 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21924) + _21922 + -mem[64] + 100
                _20644 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20644] = return_data.size
                mem[_20644 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20644 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21926 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_12891 + 100]
                _21928 = mem[_12891 + 100]
                idx = 0
                while idx < _21928:
                    mem[_21926 + idx + 68] = mem[_12891 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21928 % 32:
                    revert with memory
                      from mem[64]
                       len _21928 + _21926 + -mem[64] + 68
                mem[floor32(_21928) + _21926 + 68] = mem[floor32(_21928) + _21926 + -(_21928 % 32) + 100 len _21928 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21928) + _21926 + -mem[64] + 100
            mem[32] = 105
            _9988 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9988] = 30
            mem[_9988 + 32] = 'SafeMath: subtraction overflow'
            if sub_5fc0d9e0[stor103[idx]] > ext_call.return_data[0] - sub_a090a2b4:
                _10012 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_10012 + idx + 68] = mem[_9988 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10012 + 68] = mem[_10012 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _10012 + -mem[64] + 100
            if not ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]]:
                _10206 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10206] = 26
                mem[_10206 + 32] = 'SafeMath: division by zero'
                if sub_a090a2b4 <= 0:
                    _10252 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10252 + idx + 68] = mem[_10206 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10252 + 68] = mem[_10252 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10252 + -mem[64] + 100
                require sub_a090a2b4
                if sub_5dcea4d4[stor103[idx]] + (0 / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 'SafeMath: addition overflow'
                sub_5dcea4d4[stor103[idx]] += 0 / sub_a090a2b4
                sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0] - sub_a090a2b4
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                    _10687 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10687] = 26
                    mem[_10687 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _10793 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_10793 + idx + 68] = mem[_10687 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_10793 + 68] = mem[_10793 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _10793 + -mem[64] + 100
                    require sub_3c97d5ae
                    mem[0] = rewardTokens[idx]
                    mem[32] = sha3(address(msg.sender), 111) + 1
                    userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                    if not userInfo[address(msg.sender)].field_0:
                        idx = idx + 1
                        continue 
                    mem[0] = rewardTokens[idx]
                    mem[32] = 109
                    require userInfo[address(msg.sender)].field_0
                    if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _11396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11396] = 26
                    mem[_11396 + 32] = 'SafeMath: division by zero'
                    if sub_3c97d5ae <= 0:
                        _11516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_11516 + idx + 68] = mem[_11396 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11516 + 68] = mem[_11516 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _11516 + -mem[64] + 100
                    require sub_3c97d5ae
                    _11915 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11915] = 30
                    mem[_11915 + 32] = 'SafeMath: subtraction overflow'
                    if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                        _12122 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12122 + idx + 68] = mem[_11915 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12122 + 68] = mem[_12122 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _12122 + -mem[64] + 100
                    if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                        idx = idx + 1
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(rewardTokens[idx])
                    staticcall rewardTokens[idx].0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if rewardTokens[idx] != joeAddress:
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                            _13706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13706] = 30
                            mem[_13706 + 32] = 'SafeMath: subtraction overflow'
                            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                                _14162 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14162 + idx + 68] = mem[_13706 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14162 + 68] = mem[_14162 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14162 + -mem[64] + 100
                            mem[0] = rewardTokens[idx]
                            mem[32] = 105
                            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14866 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            _14867 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_14867 + 32] = mem[_14867 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                            mem[64] = _14866 + 164
                            mem[_14866 + 100] = 32
                            mem[_14866 + 132] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14866 + 270 len 26]
                            if ext_code.size(rewardTokens[idx]) <= 0:
                                revert with 0, 'Address: call to non-contract'
                            _16453 = mem[_14867]
                            t = _14867 + 32
                            u = mem[64]
                            s = mem[_14867]
                            while s >= 32:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s - 32
                                continue 
                            mem[mem[64] + floor32(mem[_14867])] = mem[_14867 + floor32(mem[_14867]) + -(mem[_14867] % 32) + 64 len mem[_14867] % 32] or Mask(8 * -(mem[_14867] % 32) + 32, -(8 * -(mem[_14867] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14867])])
                            call rewardTokens[idx].mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _16453 + _14866 + -mem[64] + 160]
                            if not return_data.size:
                                if ext_call.success:
                                    if mem[96] > 0:
                                        require mem[96] >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[mem[64] + 110 len 22]
                                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                    idx = idx + 1
                                    continue 
                                if mem[96] > 0:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                _21898 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = mem[_14866 + 100]
                                _21900 = mem[_14866 + 100]
                                idx = 0
                                while idx < _21900:
                                    mem[_21898 + idx + 68] = mem[_14866 + idx + 132]
                                    idx = idx + 32
                                    continue 
                                if not _21900 % 32:
                                    revert with memory
                                      from mem[64]
                                       len _21900 + _21898 + -mem[64] + 68
                                mem[floor32(_21900) + _21898 + 68] = mem[floor32(_21900) + _21898 + -(_21900 % 32) + 100 len _21900 % 32]
                                revert with memory
                                  from mem[64]
                                   len floor32(_21900) + _21898 + -mem[64] + 100
                            _20625 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size) + 1
                            mem[_20625] = return_data.size
                            mem[_20625 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if ext_call.success:
                                if return_data.size > 0:
                                    require return_data.size >= 32
                                    if not mem[_20625 + 32]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21902 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14866 + 100]
                            _21904 = mem[_14866 + 100]
                            idx = 0
                            while idx < _21904:
                                mem[_21902 + idx + 68] = mem[_14866 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21904 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21904 + _21902 + -mem[64] + 68
                            mem[floor32(_21904) + _21902 + 68] = mem[floor32(_21904) + _21902 + -(_21904 % 32) + 100 len _21904 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21904) + _21902 + -mem[64] + 100
                        _13707 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13707] = 30
                        mem[_13707 + 32] = 'SafeMath: subtraction overflow'
                        if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                            _14165 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14165 + idx + 68] = mem[_13707 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14165 + 68] = mem[_14165 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14165 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                        _14871 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = ext_call.return_data[0]
                        _14872 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_14872 + 32] = mem[_14872 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _14871 + 164
                        mem[_14871 + 100] = 32
                        mem[_14871 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_14871 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16457 = mem[_14872]
                        t = _14872 + 32
                        u = mem[64]
                        s = mem[_14872]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_14872])] = mem[_14872 + floor32(mem[_14872]) + -(mem[_14872] % 32) + 64 len mem[_14872] % 32] or Mask(8 * -(mem[_14872] % 32) + 32, -(8 * -(mem[_14872] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_14872])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16457 + _14871 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21906 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_14871 + 100]
                            _21908 = mem[_14871 + 100]
                            idx = 0
                            while idx < _21908:
                                mem[_21906 + idx + 68] = mem[_14871 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21908 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21908 + _21906 + -mem[64] + 68
                            mem[floor32(_21908) + _21906 + 68] = mem[floor32(_21908) + _21906 + -(_21908 % 32) + 100 len _21908 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21908) + _21906 + -mem[64] + 100
                        _20628 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20628] = return_data.size
                        mem[_20628 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20628 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21910 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_14871 + 100]
                        _21912 = mem[_14871 + 100]
                        idx = 0
                        while idx < _21912:
                            mem[_21910 + idx + 68] = mem[_14871 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21912 % 32:
                            revert with memory
                              from mem[64]
                               len _21912 + _21910 + -mem[64] + 68
                        mem[floor32(_21912) + _21910 + 68] = mem[floor32(_21912) + _21910 + -(_21912 % 32) + 100 len _21912 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21912) + _21910 + -mem[64] + 100
                    _13392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13392] = 30
                    mem[_13392 + 32] = 'SafeMath: subtraction overflow'
                    if sub_a090a2b4 > ext_call.return_data[0]:
                        _13703 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_13703 + idx + 68] = mem[_13392 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13703 + 68] = mem[_13703 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _13703 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                        _14864 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14864] = 30
                        mem[_14864 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _15392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15392 + idx + 68] = mem[_14864 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15392 + 68] = mem[_15392 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15392 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _16076 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _16077 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_16077 + 32] = mem[_16077 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _16076 + 164
                        mem[_16076 + 100] = 32
                        mem[_16076 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16076 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _17257 = mem[_16077]
                        t = _16077 + 32
                        u = mem[64]
                        s = mem[_16077]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_16077])] = mem[_16077 + floor32(mem[_16077]) + -(mem[_16077] % 32) + 64 len mem[_16077] % 32] or Mask(8 * -(mem[_16077] % 32) + 32, -(8 * -(mem[_16077] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16077])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _17257 + _16076 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_16076 + 100]
                            _21884 = mem[_16076 + 100]
                            idx = 0
                            while idx < _21884:
                                mem[_21882 + idx + 68] = mem[_16076 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21884 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21884 + _21882 + -mem[64] + 68
                            mem[floor32(_21884) + _21882 + 68] = mem[floor32(_21884) + _21882 + -(_21884 % 32) + 100 len _21884 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21884) + _21882 + -mem[64] + 100
                        _20617 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20617] = return_data.size
                        mem[_20617 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20617 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21886 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16076 + 100]
                        _21888 = mem[_16076 + 100]
                        idx = 0
                        while idx < _21888:
                            mem[_21886 + idx + 68] = mem[_16076 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21888 % 32:
                            revert with memory
                              from mem[64]
                               len _21888 + _21886 + -mem[64] + 68
                        mem[floor32(_21888) + _21886 + 68] = mem[floor32(_21888) + _21886 + -(_21888 % 32) + 100 len _21888 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21888) + _21886 + -mem[64] + 100
                    _14865 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14865] = 30
                    mem[_14865 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                        _15395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15395 + idx + 68] = mem[_14865 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15395 + 68] = mem[_15395 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15395 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                    _16081 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                    _16082 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16082 + 32] = mem[_16082 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16081 + 164
                    mem[_16081 + 100] = 32
                    mem[_16081 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16081 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17261 = mem[_16082]
                    t = _16082 + 32
                    u = mem[64]
                    s = mem[_16082]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16082])] = mem[_16082 + floor32(mem[_16082]) + -(mem[_16082] % 32) + 64 len mem[_16082] % 32] or Mask(8 * -(mem[_16082] % 32) + 32, -(8 * -(mem[_16082] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16082])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17261 + _16081 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21890 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16081 + 100]
                        _21892 = mem[_16081 + 100]
                        idx = 0
                        while idx < _21892:
                            mem[_21890 + idx + 68] = mem[_16081 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21892 % 32:
                            revert with memory
                              from mem[64]
                               len _21892 + _21890 + -mem[64] + 68
                        mem[floor32(_21892) + _21890 + 68] = mem[floor32(_21892) + _21890 + -(_21892 % 32) + 100 len _21892 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21892) + _21890 + -mem[64] + 100
                    _20620 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20620] = return_data.size
                    mem[_20620 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20620 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21894 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16081 + 100]
                    _21896 = mem[_16081 + 100]
                    idx = 0
                    while idx < _21896:
                        mem[_21894 + idx + 68] = mem[_16081 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21896 % 32:
                        revert with memory
                          from mem[64]
                           len _21896 + _21894 + -mem[64] + 68
                    mem[floor32(_21896) + _21894 + 68] = mem[floor32(_21896) + _21894 + -(_21896 % 32) + 100 len _21896 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21896) + _21894 + -mem[64] + 100
                require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _10792 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10792] = 26
                mem[_10792 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10892 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10892 + idx + 68] = mem[_10792 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10892 + 68] = mem[_10892 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10892 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11515 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11515] = 26
                mem[_11515 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11712 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11712 + idx + 68] = mem[_11515 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11712 + 68] = mem[_11712 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11712 + -mem[64] + 100
                require sub_3c97d5ae
                _12120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12120] = 30
                mem[_12120 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12365 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12365 + idx + 68] = mem[_12120 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12365 + 68] = mem[_12365 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12365 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _14159 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14159] = 30
                        mem[_14159 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14617 + idx + 68] = mem[_14159 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14617 + 68] = mem[_14617 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14617 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15382 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15383 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15383 + 32] = mem[_15383 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15382 + 164
                        mem[_15382 + 100] = 32
                        mem[_15382 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15382 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16743 = mem[_15383]
                        t = _15383 + 32
                        u = mem[64]
                        s = mem[_15383]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15383])] = mem[_15383 + floor32(mem[_15383]) + -(mem[_15383] % 32) + 64 len mem[_15383] % 32] or Mask(8 * -(mem[_15383] % 32) + 32, -(8 * -(mem[_15383] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15383])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16743 + _15382 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21866 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15382 + 100]
                            _21868 = mem[_15382 + 100]
                            idx = 0
                            while idx < _21868:
                                mem[_21866 + idx + 68] = mem[_15382 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21868 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21868 + _21866 + -mem[64] + 68
                            mem[floor32(_21868) + _21866 + 68] = mem[floor32(_21868) + _21866 + -(_21868 % 32) + 100 len _21868 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21868) + _21866 + -mem[64] + 100
                        _20605 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20605] = return_data.size
                        mem[_20605 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20605 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21870 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15382 + 100]
                        _21872 = mem[_15382 + 100]
                        idx = 0
                        while idx < _21872:
                            mem[_21870 + idx + 68] = mem[_15382 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21872 % 32:
                            revert with memory
                              from mem[64]
                               len _21872 + _21870 + -mem[64] + 68
                        mem[floor32(_21872) + _21870 + 68] = mem[floor32(_21872) + _21870 + -(_21872 % 32) + 100 len _21872 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21872) + _21870 + -mem[64] + 100
                    _14160 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14160] = 30
                    mem[_14160 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _14620 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14620 + idx + 68] = mem[_14160 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14620 + 68] = mem[_14620 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14620 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _15387 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _15388 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15388 + 32] = mem[_15388 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15387 + 164
                    mem[_15387 + 100] = 32
                    mem[_15387 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15387 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16747 = mem[_15388]
                    t = _15388 + 32
                    u = mem[64]
                    s = mem[_15388]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15388])] = mem[_15388 + floor32(mem[_15388]) + -(mem[_15388] % 32) + 64 len mem[_15388] % 32] or Mask(8 * -(mem[_15388] % 32) + 32, -(8 * -(mem[_15388] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15388])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16747 + _15387 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15387 + 100]
                        _21876 = mem[_15387 + 100]
                        idx = 0
                        while idx < _21876:
                            mem[_21874 + idx + 68] = mem[_15387 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21876 % 32:
                            revert with memory
                              from mem[64]
                               len _21876 + _21874 + -mem[64] + 68
                        mem[floor32(_21876) + _21874 + 68] = mem[floor32(_21876) + _21874 + -(_21876 % 32) + 100 len _21876 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21876) + _21874 + -mem[64] + 100
                    _20608 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20608] = return_data.size
                    mem[_20608 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20608 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21878 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15387 + 100]
                    _21880 = mem[_15387 + 100]
                    idx = 0
                    while idx < _21880:
                        mem[_21878 + idx + 68] = mem[_15387 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21880 % 32:
                        revert with memory
                          from mem[64]
                           len _21880 + _21878 + -mem[64] + 68
                    mem[floor32(_21880) + _21878 + 68] = mem[floor32(_21880) + _21878 + -(_21880 % 32) + 100 len _21880 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21880) + _21878 + -mem[64] + 100
                _13702 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13702] = 30
                mem[_13702 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _14156 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14156 + idx + 68] = mem[_13702 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14156 + 68] = mem[_14156 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _14156 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _15380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15380] = 30
                    mem[_15380 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15842 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15842 + idx + 68] = mem[_15380 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15842 + 68] = mem[_15842 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15842 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16442 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16443 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16443 + 32] = mem[_16443 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16442 + 164
                    mem[_16442 + 100] = 32
                    mem[_16442 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16442 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17487 = mem[_16443]
                    t = _16443 + 32
                    u = mem[64]
                    s = mem[_16443]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16443])] = mem[_16443 + floor32(mem[_16443]) + -(mem[_16443] % 32) + 64 len mem[_16443] % 32] or Mask(8 * -(mem[_16443] % 32) + 32, -(8 * -(mem[_16443] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16443])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17487 + _16442 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21850 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16442 + 100]
                        _21852 = mem[_16442 + 100]
                        idx = 0
                        while idx < _21852:
                            mem[_21850 + idx + 68] = mem[_16442 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21852 % 32:
                            revert with memory
                              from mem[64]
                               len _21852 + _21850 + -mem[64] + 68
                        mem[floor32(_21852) + _21850 + 68] = mem[floor32(_21852) + _21850 + -(_21852 % 32) + 100 len _21852 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21852) + _21850 + -mem[64] + 100
                    _20597 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20597] = return_data.size
                    mem[_20597 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20597 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21854 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16442 + 100]
                    _21856 = mem[_16442 + 100]
                    idx = 0
                    while idx < _21856:
                        mem[_21854 + idx + 68] = mem[_16442 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21856 % 32:
                        revert with memory
                          from mem[64]
                           len _21856 + _21854 + -mem[64] + 68
                    mem[floor32(_21856) + _21854 + 68] = mem[floor32(_21856) + _21854 + -(_21856 % 32) + 100 len _21856 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21856) + _21854 + -mem[64] + 100
                _15381 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15381] = 30
                mem[_15381 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15845 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15845 + idx + 68] = mem[_15381 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15845 + 68] = mem[_15845 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15845 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _16447 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _16448 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16448 + 32] = mem[_16448 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16447 + 164
                mem[_16447 + 100] = 32
                mem[_16447 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16447 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17491 = mem[_16448]
                t = _16448 + 32
                u = mem[64]
                s = mem[_16448]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16448])] = mem[_16448 + floor32(mem[_16448]) + -(mem[_16448] % 32) + 64 len mem[_16448] % 32] or Mask(8 * -(mem[_16448] % 32) + 32, -(8 * -(mem[_16448] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16448])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17491 + _16447 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21858 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16447 + 100]
                    _21860 = mem[_16447 + 100]
                    idx = 0
                    while idx < _21860:
                        mem[_21858 + idx + 68] = mem[_16447 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21860 % 32:
                        revert with memory
                          from mem[64]
                           len _21860 + _21858 + -mem[64] + 68
                    mem[floor32(_21860) + _21858 + 68] = mem[floor32(_21860) + _21858 + -(_21860 % 32) + 100 len _21860 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21860) + _21858 + -mem[64] + 100
                _20600 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20600] = return_data.size
                mem[_20600 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20600 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21862 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16447 + 100]
                _21864 = mem[_16447 + 100]
                idx = 0
                while idx < _21864:
                    mem[_21862 + idx + 68] = mem[_16447 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21864 % 32:
                    revert with memory
                      from mem[64]
                       len _21864 + _21862 + -mem[64] + 68
                mem[floor32(_21864) + _21862 + 68] = mem[floor32(_21864) + _21862 + -(_21864 % 32) + 100 len _21864 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21864) + _21862 + -mem[64] + 100
            require ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]]
            if (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / ext_call.return_data[0] - sub_a090a2b4 - sub_5fc0d9e0[stor103[idx]] != sub_3c97d5ae:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _10251 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10251] = 26
            mem[_10251 + 32] = 'SafeMath: division by zero'
            if sub_a090a2b4 <= 0:
                _10320 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_10320 + idx + 68] = mem[_10251 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_10320 + 68] = mem[_10320 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _10320 + -mem[64] + 100
            require sub_a090a2b4
            if sub_5dcea4d4[stor103[idx]] + ((ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4) < sub_5dcea4d4[stor103[idx]]:
                revert with 0, 'SafeMath: addition overflow'
            sub_5dcea4d4[stor103[idx]] += (ext_call.return_data[0] * sub_3c97d5ae) - (sub_a090a2b4 * sub_3c97d5ae) - (sub_5fc0d9e0[stor103[idx]] * sub_3c97d5ae) / sub_a090a2b4
            sub_5fc0d9e0[stor103[idx]] = ext_call.return_data[0] - sub_a090a2b4
            mem[0] = rewardTokens[idx]
            mem[32] = 109
            if not userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a):
                _10791 = mem[64]
                mem[64] = mem[64] + 64
                mem[_10791] = 26
                mem[_10791 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _10889 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_10889 + idx + 68] = mem[_10791 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_10889 + 68] = mem[_10889 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _10889 + -mem[64] + 100
                require sub_3c97d5ae
                mem[0] = rewardTokens[idx]
                mem[32] = sha3(address(msg.sender), 111) + 1
                userInfo[address(msg.sender)][1][stor103[idx]].field_0 = 0 / sub_3c97d5ae
                if not userInfo[address(msg.sender)].field_0:
                    idx = idx + 1
                    continue 
                mem[0] = rewardTokens[idx]
                mem[32] = 109
                require userInfo[address(msg.sender)].field_0
                if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _11514 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11514] = 26
                mem[_11514 + 32] = 'SafeMath: division by zero'
                if sub_3c97d5ae <= 0:
                    _11709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_11709 + idx + 68] = mem[_11514 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_11709 + 68] = mem[_11709 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _11709 + -mem[64] + 100
                require sub_3c97d5ae
                _12118 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12118] = 30
                mem[_12118 + 32] = 'SafeMath: subtraction overflow'
                if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                    _12362 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_12362 + idx + 68] = mem[_12118 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_12362 + 68] = mem[_12362 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _12362 + -mem[64] + 100
                if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                    idx = idx + 1
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(rewardTokens[idx])
                staticcall rewardTokens[idx].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if rewardTokens[idx] != joeAddress:
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                        _14154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14154] = 30
                        mem[_14154 + 32] = 'SafeMath: subtraction overflow'
                        if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                            _14610 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14610 + idx + 68] = mem[_14154 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14610 + 68] = mem[_14610 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14610 + -mem[64] + 100
                        mem[0] = rewardTokens[idx]
                        mem[32] = 105
                        sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15370 = mem[64]
                        mem[mem[64] + 36] = msg.sender
                        mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        _15371 = mem[64]
                        mem[mem[64]] = 68
                        mem[64] = mem[64] + 100
                        mem[_15371 + 32] = mem[_15371 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                        mem[64] = _15370 + 164
                        mem[_15370 + 100] = 32
                        mem[_15370 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15370 + 270 len 26]
                        if ext_code.size(rewardTokens[idx]) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _16735 = mem[_15371]
                        t = _15371 + 32
                        u = mem[64]
                        s = mem[_15371]
                        while s >= 32:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s - 32
                            continue 
                        mem[mem[64] + floor32(mem[_15371])] = mem[_15371 + floor32(mem[_15371]) + -(mem[_15371] % 32) + 64 len mem[_15371] % 32] or Mask(8 * -(mem[_15371] % 32) + 32, -(8 * -(mem[_15371] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15371])])
                        call rewardTokens[idx].mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _16735 + _15370 + -mem[64] + 160]
                        if not return_data.size:
                            if ext_call.success:
                                if mem[96] > 0:
                                    require mem[96] >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[mem[64] + 110 len 22]
                                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                                idx = idx + 1
                                continue 
                            if mem[96] > 0:
                                revert with memory
                                  from 128
                                   len mem[96]
                            _21834 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = mem[_15370 + 100]
                            _21836 = mem[_15370 + 100]
                            idx = 0
                            while idx < _21836:
                                mem[_21834 + idx + 68] = mem[_15370 + idx + 132]
                                idx = idx + 32
                                continue 
                            if not _21836 % 32:
                                revert with memory
                                  from mem[64]
                                   len _21836 + _21834 + -mem[64] + 68
                            mem[floor32(_21836) + _21834 + 68] = mem[floor32(_21836) + _21834 + -(_21836 % 32) + 100 len _21836 % 32]
                            revert with memory
                              from mem[64]
                               len floor32(_21836) + _21834 + -mem[64] + 100
                        _20583 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size) + 1
                        mem[_20583] = return_data.size
                        mem[_20583 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if ext_call.success:
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[_20583 + 32]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if return_data.size > 0:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21838 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15370 + 100]
                        _21840 = mem[_15370 + 100]
                        idx = 0
                        while idx < _21840:
                            mem[_21838 + idx + 68] = mem[_15370 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21840 % 32:
                            revert with memory
                              from mem[64]
                               len _21840 + _21838 + -mem[64] + 68
                        mem[floor32(_21840) + _21838 + 68] = mem[floor32(_21840) + _21838 + -(_21840 % 32) + 100 len _21840 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21840) + _21838 + -mem[64] + 100
                    _14155 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14155] = 30
                    mem[_14155 + 32] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                        _14613 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14613 + idx + 68] = mem[_14155 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14613 + 68] = mem[_14613 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _14613 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                    _15375 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0]
                    _15376 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15376 + 32] = mem[_15376 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15375 + 164
                    mem[_15375 + 100] = 32
                    mem[_15375 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15375 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _16739 = mem[_15376]
                    t = _15376 + 32
                    u = mem[64]
                    s = mem[_15376]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15376])] = mem[_15376 + floor32(mem[_15376]) + -(mem[_15376] % 32) + 64 len mem[_15376] % 32] or Mask(8 * -(mem[_15376] % 32) + 32, -(8 * -(mem[_15376] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15376])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _16739 + _15375 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21842 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15375 + 100]
                        _21844 = mem[_15375 + 100]
                        idx = 0
                        while idx < _21844:
                            mem[_21842 + idx + 68] = mem[_15375 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21844 % 32:
                            revert with memory
                              from mem[64]
                               len _21844 + _21842 + -mem[64] + 68
                        mem[floor32(_21844) + _21842 + 68] = mem[floor32(_21844) + _21842 + -(_21844 % 32) + 100 len _21844 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21844) + _21842 + -mem[64] + 100
                    _20586 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20586] = return_data.size
                    mem[_20586 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20586 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21846 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15375 + 100]
                    _21848 = mem[_15375 + 100]
                    idx = 0
                    while idx < _21848:
                        mem[_21846 + idx + 68] = mem[_15375 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21848 % 32:
                        revert with memory
                          from mem[64]
                           len _21848 + _21846 + -mem[64] + 68
                    mem[floor32(_21848) + _21846 + 68] = mem[floor32(_21848) + _21846 + -(_21848 % 32) + 100 len _21848 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21848) + _21846 + -mem[64] + 100
                _13701 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13701] = 30
                mem[_13701 + 32] = 'SafeMath: subtraction overflow'
                if sub_a090a2b4 > ext_call.return_data[0]:
                    _14151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_14151 + idx + 68] = mem[_13701 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14151 + 68] = mem[_14151 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _14151 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                    _15368 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15368] = 30
                    mem[_15368 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15836 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15836 + idx + 68] = mem[_15368 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15836 + 68] = mem[_15836 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15836 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16432 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _16433 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_16433 + 32] = mem[_16433 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _16432 + 164
                    mem[_16432 + 100] = 32
                    mem[_16432 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16432 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17479 = mem[_16433]
                    t = _16433 + 32
                    u = mem[64]
                    s = mem[_16433]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_16433])] = mem[_16433 + floor32(mem[_16433]) + -(mem[_16433] % 32) + 64 len mem[_16433] % 32] or Mask(8 * -(mem[_16433] % 32) + 32, -(8 * -(mem[_16433] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16433])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17479 + _16432 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21818 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_16432 + 100]
                        _21820 = mem[_16432 + 100]
                        idx = 0
                        while idx < _21820:
                            mem[_21818 + idx + 68] = mem[_16432 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21820 % 32:
                            revert with memory
                              from mem[64]
                               len _21820 + _21818 + -mem[64] + 68
                        mem[floor32(_21820) + _21818 + 68] = mem[floor32(_21820) + _21818 + -(_21820 % 32) + 100 len _21820 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21820) + _21818 + -mem[64] + 100
                    _20575 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20575] = return_data.size
                    mem[_20575 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20575 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21822 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16432 + 100]
                    _21824 = mem[_16432 + 100]
                    idx = 0
                    while idx < _21824:
                        mem[_21822 + idx + 68] = mem[_16432 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21824 % 32:
                        revert with memory
                          from mem[64]
                           len _21824 + _21822 + -mem[64] + 68
                    mem[floor32(_21824) + _21822 + 68] = mem[floor32(_21824) + _21822 + -(_21824 % 32) + 100 len _21824 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21824) + _21822 + -mem[64] + 100
                _15369 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15369] = 30
                mem[_15369 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                    _15839 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15839 + idx + 68] = mem[_15369 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15839 + 68] = mem[_15839 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15839 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
                _16437 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
                _16438 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16438 + 32] = mem[_16438 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16437 + 164
                mem[_16437 + 100] = 32
                mem[_16437 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16437 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17483 = mem[_16438]
                t = _16438 + 32
                u = mem[64]
                s = mem[_16438]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16438])] = mem[_16438 + floor32(mem[_16438]) + -(mem[_16438] % 32) + 64 len mem[_16438] % 32] or Mask(8 * -(mem[_16438] % 32) + 32, -(8 * -(mem[_16438] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16438])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17483 + _16437 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21826 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16437 + 100]
                    _21828 = mem[_16437 + 100]
                    idx = 0
                    while idx < _21828:
                        mem[_21826 + idx + 68] = mem[_16437 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21828 % 32:
                        revert with memory
                          from mem[64]
                           len _21828 + _21826 + -mem[64] + 68
                    mem[floor32(_21828) + _21826 + 68] = mem[floor32(_21828) + _21826 + -(_21828 % 32) + 100 len _21828 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21828) + _21826 + -mem[64] + 100
                _20578 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20578] = return_data.size
                mem[_20578 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20578 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21830 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16437 + 100]
                _21832 = mem[_16437 + 100]
                idx = 0
                while idx < _21832:
                    mem[_21830 + idx + 68] = mem[_16437 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21832 % 32:
                    revert with memory
                      from mem[64]
                       len _21832 + _21830 + -mem[64] + 68
                mem[floor32(_21832) + _21830 + 68] = mem[floor32(_21832) + _21830 + -(_21832 % 32) + 100 len _21832 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21832) + _21830 + -mem[64] + 100
            require userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / userInfo[address(msg.sender)].field_0 + arg1 - (arg1 * depositFeePercent / sub_a610708a) != sub_5dcea4d4[stor103[idx]]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _10888 = mem[64]
            mem[64] = mem[64] + 64
            mem[_10888] = 26
            mem[_10888 + 32] = 'SafeMath: division by zero'
            if sub_3c97d5ae <= 0:
                _11026 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_11026 + idx + 68] = mem[_10888 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_11026 + 68] = mem[_11026 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _11026 + -mem[64] + 100
            require sub_3c97d5ae
            mem[0] = rewardTokens[idx]
            mem[32] = sha3(address(msg.sender), 111) + 1
            userInfo[address(msg.sender)][1][stor103[idx]].field_0 = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]]) + (arg1 * sub_5dcea4d4[stor103[idx]]) - (arg1 * depositFeePercent / sub_a610708a * sub_5dcea4d4[stor103[idx]]) / sub_3c97d5ae
            if not userInfo[address(msg.sender)].field_0:
                idx = idx + 1
                continue 
            mem[0] = rewardTokens[idx]
            mem[32] = 109
            require userInfo[address(msg.sender)].field_0
            if userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / userInfo[address(msg.sender)].field_0 != sub_5dcea4d4[stor103[idx]]:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _11708 = mem[64]
            mem[64] = mem[64] + 64
            mem[_11708] = 26
            mem[_11708 + 32] = 'SafeMath: division by zero'
            if sub_3c97d5ae <= 0:
                _11910 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_11910 + idx + 68] = mem[_11708 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_11910 + 68] = mem[_11910 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _11910 + -mem[64] + 100
            require sub_3c97d5ae
            _12360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_12360] = 30
            mem[_12360 + 32] = 'SafeMath: subtraction overflow'
            if userInfo[address(msg.sender)][1][stor103[idx]].field_0 > userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae:
                _12576 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_12576 + idx + 68] = mem[_12360 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_12576 + 68] = mem[_12576 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _12576 + -mem[64] + 100
            if not (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0:
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(rewardTokens[idx])
            staticcall rewardTokens[idx].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if rewardTokens[idx] != joeAddress:
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0]:
                    _14607 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14607] = 30
                    mem[_14607 + 32] = 'SafeMath: subtraction overflow'
                    if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                        _15077 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15077 + idx + 68] = mem[_14607 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15077 + 68] = mem[_15077 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15077 + -mem[64] + 100
                    mem[0] = rewardTokens[idx]
                    mem[32] = 105
                    sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15826 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    _15827 = mem[64]
                    mem[mem[64]] = 68
                    mem[64] = mem[64] + 100
                    mem[_15827 + 32] = mem[_15827 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                    mem[64] = _15826 + 164
                    mem[_15826 + 100] = 32
                    mem[_15826 + 132] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15826 + 270 len 26]
                    if ext_code.size(rewardTokens[idx]) <= 0:
                        revert with 0, 'Address: call to non-contract'
                    _17013 = mem[_15827]
                    t = _15827 + 32
                    u = mem[64]
                    s = mem[_15827]
                    while s >= 32:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s - 32
                        continue 
                    mem[mem[64] + floor32(mem[_15827])] = mem[_15827 + floor32(mem[_15827]) + -(mem[_15827] % 32) + 64 len mem[_15827] % 32] or Mask(8 * -(mem[_15827] % 32) + 32, -(8 * -(mem[_15827] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15827])])
                    call rewardTokens[idx].mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _17013 + _15826 + -mem[64] + 160]
                    if not return_data.size:
                        if ext_call.success:
                            if mem[96] > 0:
                                require mem[96] >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[mem[64] + 110 len 22]
                            mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                            emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                            idx = idx + 1
                            continue 
                        if mem[96] > 0:
                            revert with memory
                              from 128
                               len mem[96]
                        _21802 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = mem[_15826 + 100]
                        _21804 = mem[_15826 + 100]
                        idx = 0
                        while idx < _21804:
                            mem[_21802 + idx + 68] = mem[_15826 + idx + 132]
                            idx = idx + 32
                            continue 
                        if not _21804 % 32:
                            revert with memory
                              from mem[64]
                               len _21804 + _21802 + -mem[64] + 68
                        mem[floor32(_21804) + _21802 + 68] = mem[floor32(_21804) + _21802 + -(_21804 % 32) + 100 len _21804 % 32]
                        revert with memory
                          from mem[64]
                           len floor32(_21804) + _21802 + -mem[64] + 100
                    _20563 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size) + 1
                    mem[_20563] = return_data.size
                    mem[_20563 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if ext_call.success:
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[_20563 + 32]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    _21806 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15826 + 100]
                    _21808 = mem[_15826 + 100]
                    idx = 0
                    while idx < _21808:
                        mem[_21806 + idx + 68] = mem[_15826 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21808 % 32:
                        revert with memory
                          from mem[64]
                           len _21808 + _21806 + -mem[64] + 68
                    mem[floor32(_21808) + _21806 + 68] = mem[floor32(_21808) + _21806 + -(_21808 % 32) + 100 len _21808 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21808) + _21806 + -mem[64] + 100
                _14608 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14608] = 30
                mem[_14608 + 32] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] > sub_5fc0d9e0[stor103[idx]]:
                    _15080 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_15080 + idx + 68] = mem[_14608 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15080 + 68] = mem[_15080 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _15080 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] -= ext_call.return_data[0]
                _15831 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = ext_call.return_data[0]
                _15832 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_15832 + 32] = mem[_15832 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _15831 + 164
                mem[_15831 + 100] = 32
                mem[_15831 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_15831 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17017 = mem[_15832]
                t = _15832 + 32
                u = mem[64]
                s = mem[_15832]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_15832])] = mem[_15832 + floor32(mem[_15832]) + -(mem[_15832] % 32) + 64 len mem[_15832] % 32] or Mask(8 * -(mem[_15832] % 32) + 32, -(8 * -(mem[_15832] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_15832])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17017 + _15831 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21810 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_15831 + 100]
                    _21812 = mem[_15831 + 100]
                    idx = 0
                    while idx < _21812:
                        mem[_21810 + idx + 68] = mem[_15831 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21812 % 32:
                        revert with memory
                          from mem[64]
                           len _21812 + _21810 + -mem[64] + 68
                    mem[floor32(_21812) + _21810 + 68] = mem[floor32(_21812) + _21810 + -(_21812 % 32) + 100 len _21812 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21812) + _21810 + -mem[64] + 100
                _20566 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20566] = return_data.size
                mem[_20566 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20566 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21814 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_15831 + 100]
                _21816 = mem[_15831 + 100]
                idx = 0
                while idx < _21816:
                    mem[_21814 + idx + 68] = mem[_15831 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21816 % 32:
                    revert with memory
                      from mem[64]
                       len _21816 + _21814 + -mem[64] + 68
                mem[floor32(_21816) + _21814 + 68] = mem[floor32(_21816) + _21814 + -(_21816 % 32) + 100 len _21816 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21816) + _21814 + -mem[64] + 100
            _14150 = mem[64]
            mem[64] = mem[64] + 64
            mem[_14150] = 30
            mem[_14150 + 32] = 'SafeMath: subtraction overflow'
            if sub_a090a2b4 > ext_call.return_data[0]:
                _14604 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_14604 + idx + 68] = mem[_14150 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_14604 + 68] = mem[_14604 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _14604 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            mem[32] = 105
            if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 <= ext_call.return_data[0] - sub_a090a2b4:
                _15824 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15824] = 30
                mem[_15824 + 32] = 'SafeMath: subtraction overflow'
                if (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0 > sub_5fc0d9e0[stor103[idx]]:
                    _16208 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_16208 + idx + 68] = mem[_15824 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_16208 + 68] = mem[_16208 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _16208 + -mem[64] + 100
                mem[0] = rewardTokens[idx]
                mem[32] = 105
                sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) + userInfo[address(msg.sender)][1][stor103[idx]].field_0
                _16724 = mem[64]
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                _16725 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_16725 + 32] = mem[_16725 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
                mem[64] = _16724 + 164
                mem[_16724 + 100] = 32
                mem[_16724 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16724 + 270 len 26]
                if ext_code.size(rewardTokens[idx]) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _17777 = mem[_16725]
                t = _16725 + 32
                u = mem[64]
                s = mem[_16725]
                while s >= 32:
                    mem[u] = mem[t]
                    t = t + 32
                    u = u + 32
                    s = s - 32
                    continue 
                mem[mem[64] + floor32(mem[_16725])] = mem[_16725 + floor32(mem[_16725]) + -(mem[_16725] % 32) + 64 len mem[_16725] % 32] or Mask(8 * -(mem[_16725] % 32) + 32, -(8 * -(mem[_16725] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16725])])
                call rewardTokens[idx].mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _17777 + _16724 + -mem[64] + 160]
                if not return_data.size:
                    if ext_call.success:
                        if mem[96] > 0:
                            require mem[96] >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[mem[64] + 110 len 22]
                        mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                        emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                        idx = idx + 1
                        continue 
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    _21786 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_16724 + 100]
                    _21788 = mem[_16724 + 100]
                    idx = 0
                    while idx < _21788:
                        mem[_21786 + idx + 68] = mem[_16724 + idx + 132]
                        idx = idx + 32
                        continue 
                    if not _21788 % 32:
                        revert with memory
                          from mem[64]
                           len _21788 + _21786 + -mem[64] + 68
                    mem[floor32(_21788) + _21786 + 68] = mem[floor32(_21788) + _21786 + -(_21788 % 32) + 100 len _21788 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_21788) + _21786 + -mem[64] + 100
                _20555 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size) + 1
                mem[_20555] = return_data.size
                mem[_20555 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if ext_call.success:
                    if return_data.size > 0:
                        require return_data.size >= 32
                        if not mem[_20555 + 32]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                _21790 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16724 + 100]
                _21792 = mem[_16724 + 100]
                idx = 0
                while idx < _21792:
                    mem[_21790 + idx + 68] = mem[_16724 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21792 % 32:
                    revert with memory
                      from mem[64]
                       len _21792 + _21790 + -mem[64] + 68
                mem[floor32(_21792) + _21790 + 68] = mem[floor32(_21792) + _21790 + -(_21792 % 32) + 100 len _21792 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21792) + _21790 + -mem[64] + 100
            _15825 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15825] = 30
            mem[_15825 + 32] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - sub_a090a2b4 > sub_5fc0d9e0[stor103[idx]]:
                _16211 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_16211 + idx + 68] = mem[_15825 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_16211 + 68] = mem[_16211 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _16211 + -mem[64] + 100
            mem[0] = rewardTokens[idx]
            mem[32] = 105
            sub_5fc0d9e0[stor103[idx]] = sub_5fc0d9e0[stor103[idx]] - ext_call.return_data[0] + sub_a090a2b4
            _16729 = mem[64]
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = ext_call.return_data[0] - sub_a090a2b4
            _16730 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_16730 + 32] = mem[_16730 + 36 len 28] or 0xa9059cbb00000000000000000000000000000000000000000000000000000000
            mem[64] = _16729 + 164
            mem[_16729 + 100] = 32
            mem[_16729 + 132] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_16729 + 270 len 26]
            if ext_code.size(rewardTokens[idx]) <= 0:
                revert with 0, 'Address: call to non-contract'
            _17781 = mem[_16730]
            t = _16730 + 32
            u = mem[64]
            s = mem[_16730]
            while s >= 32:
                mem[u] = mem[t]
                t = t + 32
                u = u + 32
                s = s - 32
                continue 
            mem[mem[64] + floor32(mem[_16730])] = mem[_16730 + floor32(mem[_16730]) + -(mem[_16730] % 32) + 64 len mem[_16730] % 32] or Mask(8 * -(mem[_16730] % 32) + 32, -(8 * -(mem[_16730] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_16730])])
            call rewardTokens[idx].mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _17781 + _16729 + -mem[64] + 160]
            if not return_data.size:
                if ext_call.success:
                    if mem[96] > 0:
                        require mem[96] >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[mem[64] + 110 len 22]
                    mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                    emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                    idx = idx + 1
                    continue 
                if mem[96] > 0:
                    revert with memory
                      from 128
                       len mem[96]
                _21794 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_16729 + 100]
                _21796 = mem[_16729 + 100]
                idx = 0
                while idx < _21796:
                    mem[_21794 + idx + 68] = mem[_16729 + idx + 132]
                    idx = idx + 32
                    continue 
                if not _21796 % 32:
                    revert with memory
                      from mem[64]
                       len _21796 + _21794 + -mem[64] + 68
                mem[floor32(_21796) + _21794 + 68] = mem[floor32(_21796) + _21794 + -(_21796 % 32) + 100 len _21796 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_21796) + _21794 + -mem[64] + 100
            _20558 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_20558] = return_data.size
            mem[_20558 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if ext_call.success:
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_20558 + 32]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                mem[mem[64]] = (userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0
                emit ClaimReward(((userInfo[address(msg.sender)].field_0 * sub_5dcea4d4[stor103[idx]] / sub_3c97d5ae) - userInfo[address(msg.sender)][1][stor103[idx]].field_0), msg.sender, rewardTokens[idx]);
                idx = idx + 1
                continue 
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            _21798 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_16729 + 100]
            _21800 = mem[_16729 + 100]
            idx = 0
            while idx < _21800:
                mem[_21798 + idx + 68] = mem[_16729 + idx + 132]
                idx = idx + 32
                continue 
            if not _21800 % 32:
                revert with memory
                  from mem[64]
                   len _21800 + _21798 + -mem[64] + 68
            mem[floor32(_21800) + _21798 + 68] = mem[floor32(_21800) + _21798 + -(_21800 % 32) + 100 len _21800 % 32]
            revert with memory
              from mem[64]
               len floor32(_21800) + _21798 + -mem[64] + 100
        if sub_a090a2b4 + arg1 - (arg1 * depositFeePercent / sub_a610708a) < sub_a090a2b4:
            revert with 0, 'SafeMath: addition overflow'
        sub_a090a2b4 = sub_a090a2b4 + arg1 - (arg1 * depositFeePercent / sub_a610708a)
        _9908 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = feeCollectorAddress
        mem[mem[64] + 100] = arg1 * depositFeePercent / sub_a610708a
        _9909 = mem[64]
        mem[mem[64]] = 100
        mem[mem[64] + 32 len 4] = unknown_0x23b872dd(?????)
        mem[64] = mem[64] + 196
        mem[_9908 + 132] = 32
        mem[_9908 + 164] = 'SafeERC20: low-level call failed'
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_9908 + 302 len 26]
        if ext_code.size(joeAddress) <= 0:
            revert with 0, 'Address: call to non-contract'
        _9943 = mem[_9909]
        mem[_9908 + 196 len floor32(mem[_9909])] = mem[_9909 + 32 len floor32(mem[_9909])]
        mem[_9908 + floor32(mem[_9909]) + -(mem[_9909] % 32) + 228 len mem[_9909] % 32] = mem[_9909 + floor32(mem[_9909]) + -(mem[_9909] % 32) + 64 len mem[_9909] % 32]
        call joeAddress with:
             gas gas_remaining wei
            args mem[_9908 + 200 len _9943 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96] > 0:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96] > 0:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_9908 + 306 len 22]
            mem[_9908 + 232] = msg.sender
            mem[_9908 + 264] = this.address
            mem[_9908 + 296] = arg1 - (arg1 * depositFeePercent / sub_a610708a)
            mem[_9908 + 196] = 100
            mem[_9908 + 228 len 4] = unknown_0x23b872dd(?????)
            mem[_9908 + 328] = 32
            mem[_9908 + 360] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[_9908 + 498 len 26]
            if ext_code.size(joeAddress) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[_9908 + 392 len 96] = 0, msg.sender, address(this.address), Mask(224, 32, arg1 - (arg1 * depositFeePercent / sub_a610708a)) >> 32
            mem[_9908 + 516 len 4] = 0
            call joeAddress with:
                 gas gas_remaining wei
                args arg1 - (arg1 * depositFeePercent / sub_a610708a), 32, Mask(224, 32, 'SafeERC20: low-level call failed') >> 32, mem[_9908 + 488 len 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96] > 0:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9908 + 502 len 14],
                                    0,
                                    mem[_9908 + 520 len 4]
            else:
                mem[_9908 + 424 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_9908 + 424]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9908 + ceil32(return_data.size) + 503 len 22]
        else:
            mem[_9908 + 196] = return_data.size
            mem[_9908 + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size > 0:
                require return_data.size >= 32
                if not mem[_9908 + 228]:
                    revert with 0, 
                                32,
                                42,
                                0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_9908 + ceil32(return_data.size) + 307 len 22]
            mem[_9908 + ceil32(return_data.size) + 233] = msg.sender
            mem[_9908 + ceil32(return_data.size) + 265] = this.address
            mem[_9908 + ceil32(return_data.size) + 297] = arg1 - (arg1 * depositFeePercent / sub_a610708a)
            mem[_9908 + ceil32(return_data.size) + 197] = 100
            mem[_9908 + ceil32(return_data.size) + 229 len 4] = unknown_0x23b872dd(?????)
            mem[_9908 + ceil32(return_data.size) + 329] = 32
            mem[_9908 + ceil32(return_data.size) + 361] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x29416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[_9908 + ceil32(return_data.size) + 499 len 26]
            if ext_code.size(joeAddress) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[_9908 + ceil32(return_data.size) + 393 len 96] = 0, msg.sender, address(this.address), Mask(224, 32, arg1 - (arg1 * depositFeePercent / sub_a610708a)) >> 32
            mem[_9908 + ceil32(return_data.size) + 517 len 4] = 0
            call joeAddress with:
                 gas gas_remaining wei
                args arg1 - (arg1 * depositFeePercent / sub_a610708a), 32, Mask(224, 32, 'SafeERC20: low-level call failed') >> 32, mem[_9908 + ceil32(return_data.size) + 489 len 4]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96] > 0:
                        revert with memory
                          from 128
                           len mem[96]
                    revert with 0, 'SafeERC20: low-level call failed'
                if mem[96] > 0:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9908 + ceil32(return_data.size) + 503 len 14],
                                    0,
                                    mem[_9908 + ceil32(return_data.size) + 521 len 4]
            else:
                mem[_9908 + ceil32(return_data.size) + 425 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 
                                'SafeERC20: low-level call failed',
                                mem[_9908 + (2 * ceil32(return_data.size)) + 494 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                if return_data.size > 0:
                    require return_data.size >= 32
                    if not mem[_9908 + ceil32(return_data.size) + 425]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x655361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[_9908 + (2 * ceil32(return_data.size)) + 504 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
        emit Deposit(arg1 - (arg1 * depositFeePercent / sub_a610708a), arg1 * depositFeePercent / sub_a610708a, msg.sender);
}



}

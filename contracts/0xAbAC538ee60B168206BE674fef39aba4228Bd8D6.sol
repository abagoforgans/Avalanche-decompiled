contract main {




// =====================  Runtime code  =====================


#
#  - deposit(address arg1, uint256 arg2)
#  - earn()
#  - withdraw(address arg1, uint256 arg2)
#
const controllerFeeUL = 300

const controllerFeeMax = 10000

const buyBackRateMax = 10000

const withdrawFeeFactorMax = 10000

const withdrawFeeFactorLL = 9950

const buyBackRateUL = 800

const slippageFactorUL = 995

const entranceFeeFactorLL = 9950

const entranceFeeFactorMax = 10000


address owner;
uint256 stor1;
uint8 stor2;
uint8 stor2; offset 8
uint8 stor2; offset 16
uint8 stor2; offset 24
uint32 stor2;
address farmContractAddress; offset 32
uint256 stor2;
uint256 pid;
address wantAddress;
address token0Address;
address token1Address;
address earnedAddress;
uint32 stor8;
address uniRouterAddress;
uint256 stor8;
address wbnbAddress;
address autoFarmAddress;
address aUTOAddress;
uint8 onlyGov; offset 160
uint128 stor12; offset 160
address govAddress;
uint256 lastEarnBlock;
uint256 wantLockedTotal;
uint256 sharesTotal;
uint256 controllerFee;
uint256 buyBackRate;
address buyBackAddress;
address rewardsAddress;
uint256 entranceFeeFactor;
uint256 withdrawFeeFactor;
uint256 slippageFactor;
uint256 safeSwapFactor;
array of address earnedToAUTOPath;
array of address earnedToToken0Path;
array of address earnedToToken1Path;
array of struct token0ToEarnedPath;
array of struct token1ToEarnedPath;

function token1ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token1ToEarnedPath.length
    return token1ToEarnedPath[arg1].field_0
}

function onlyGov() payable {
    return bool(onlyGov)
}

function lastEarnBlock() payable {
    return lastEarnBlock
}

function entranceFeeFactor() payable {
    return entranceFeeFactor
}

function buyBackRate() payable {
    return buyBackRate
}

function AUTOAddress() payable {
    return aUTOAddress
}

function wantLockedTotal() payable {
    return wantLockedTotal
}

function sharesTotal() payable {
    return sharesTotal
}

function govAddress() payable {
    return govAddress
}

function paused() payable {
    return bool(uint8(stor2.field_0))
}

function earnedToAUTOPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToAUTOPath.length
    return earnedToAUTOPath[arg1]
}

function wbnbAddress() payable {
    return wbnbAddress
}

function withdrawFeeFactor() payable {
    return withdrawFeeFactor
}

function uniRouterAddress() payable {
    return address(uniRouterAddress)
}

function buyBackAddress() payable {
    return buyBackAddress
}

function token0Address() payable {
    return token0Address
}

function isCAKEStaking() payable {
    return bool(uint8(stor2.field_8))
}

function controllerFee() payable {
    return controllerFee
}

function owner() payable {
    return owner
}

function earnedToToken1Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken1Path.length
    return earnedToToken1Path[arg1]
}

function isSameAssetDeposit() payable {
    return bool(uint8(stor2.field_16))
}

function farmContractAddress() payable {
    return farmContractAddress
}

function token0ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token0ToEarnedPath.length
    return token0ToEarnedPath[arg1].field_0
}

function rewardsAddress() payable {
    return rewardsAddress
}

function earnedToToken0Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken0Path.length
    return earnedToToken0Path[arg1]
}

function safeSwapFactor() payable {
    return safeSwapFactor
}

function token1Address() payable {
    return token1Address
}

function isAutoComp() payable {
    return bool(uint8(stor2.field_24))
}

function earnedAddress() payable {
    return earnedAddress
}

function wantAddress() payable {
    return wantAddress
}

function pid() payable {
    return pid
}

function autoFarmAddress() payable {
    return autoFarmAddress
}

function slippageFactor() payable {
    return slippageFactor
}

function _fallback() payable {
    revert
}

function updateSafeSwapFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    safeSwapFactor = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setGov(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    govAddress = arg1
    emit SetGov(arg1);
}

function setOnlyGov(bool arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    stor12 = Mask(96, 0, arg1)
    emit SetOnlyGov(arg1);
}

function setRewardsAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    rewardsAddress = arg1
    emit SetRewardsAddress(arg1);
}

function setBuyBackAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    buyBackAddress = arg1
    emit SetBuyBackAddress(arg1);
}

function pause() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if uint8(stor2.field_0):
        revert with 0, 'Pausable: paused'
    uint8(stor2.field_0) = 1
    emit Paused(msg.sender);
}

function setUniRouterAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    address(uniRouterAddress) = arg1
    emit SetUniRouterAddress(arg1);
}

function unpause() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if not uint8(stor2.field_0):
        revert with 0, 'Pausable: not paused'
    uint8(stor2.field_0) = 0
    emit Unpaused(msg.sender);
}

function wrapBNB() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if eth.balance(this.address):
        require ext_code.size(wbnbAddress)
        call wbnbAddress.deposit() with:
           value eth.balance(this.address) wei
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setSettings(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if arg1 < 9950:
        revert with 0, '_entranceFeeFactor too low'
    if arg1 > 10000:
        revert with 0, '_entranceFeeFactor too high'
    entranceFeeFactor = arg1
    if arg2 < 9950:
        revert with 0, '_withdrawFeeFactor too low'
    if arg2 > 10000:
        revert with 0, '_withdrawFeeFactor too high'
    withdrawFeeFactor = arg2
    if arg3 > 300:
        revert with 0, '_controllerFee too high'
    controllerFee = arg3
    if arg4 > 800:
        revert with 0, '_buyBackRate too high'
    buyBackRate = arg4
    if arg5 > 995:
        revert with 0, '_slippageFactor too high'
    slippageFactor = arg5
    emit SetSettings(arg1, arg2, arg3, arg4, arg5);
}

function inCaseTokensGetStuck(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if earnedAddress == arg1:
        revert with 0, '!safe'
    if wantAddress == arg1:
        revert with 0, '!safe'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, Mask(224, 32, arg2) >> 32
    mem[324 len 0] = 0
    call arg1 with:
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 224, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2
        if not unknown_0xa9059cbb(?????), address(arg3) << 64:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
}

function farm() payable {
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    if not uint8(stor2.field_24):
        revert with 0, '!isAutoComp'
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
        revert with 0, 'SafeMath: addition overflow'
    wantLockedTotal += ext_call.return_data[0]
    require ext_code.size(wantAddress)
    staticcall wantAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args address(this.address), farmContractAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(wantAddress):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
    mem[324 len 0] = 0
    call wantAddress with:
       funct uint32(stor2.field_0)
         gas gas_remaining wei
        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), 2 * ext_call.return_data[0]
        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0):
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    require ext_code.size(farmContractAddress)
    if not uint8(stor2.field_8):
        call farmContractAddress.deposit(uint256 rg1, uint256 rg2) with:
             gas gas_remaining wei
            args pid, ext_call.return_data[0]
    else:
        call farmContractAddress.enterStaking(uint256 rg1) with:
             gas gas_remaining wei
            args ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function convertDustToEarned() payable {
    if uint8(stor2.field_0):
        revert with 0, 'Pausable: paused'
    if not uint8(stor2.field_24):
        revert with 0, '!isAutoComp'
    if uint8(stor2.field_8):
        revert with 0, 'isCAKEStaking'
    require ext_code.size(token0Address)
    staticcall token0Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if earnedAddress == token0Address:
        require ext_code.size(token1Address)
        staticcall token1Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if earnedAddress != token1Address:
            if ext_call.return_data[0] > 0:
                require ext_code.size(token1Address)
                staticcall token1Address.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(uniRouterAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[132] = address(uniRouterAddress)
                mem[164] = 2 * ext_call.return_data[0]
                mem[96] = 68
                mem[132 len 28] = Mask(224, 0, stor8)
                mem[128 len 4] = approve(address rg1, uint256 rg2)
                mem[196] = 32
                mem[228] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                if not ext_code.size(token1Address):
                    revert with 0, 'Address: call to non-contract'
                mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                mem[352 len 4] = 0
                mem[324 len 0] = 0
                call token1Address with:
                   funct uint32(stor8)
                     gas gas_remaining wei
                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                        revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                    mem[260] = token1ToEarnedPath.length
                    if not token1ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                        mem[(32 * token1ToEarnedPath.length) + 328] = 64
                        mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                        mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                        require return_data.size >= 32
                        _8609 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                        _8667 = mem[(32 * token1ToEarnedPath.length) + _8609 + 292]
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8609 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8609 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8609 + 292])]
                        mem[64] = (32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                        mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                        mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                        if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                        _12855 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                            mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                        else:
                            if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                            mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12855 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8667) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        mem[0] = 28
                        mem[292] = address(token1ToEarnedPath.field_0)
                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _8611 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _8668 = mem[(32 * token1ToEarnedPath.length) + _8611 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8611 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8611 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8611 + 292])]
                            mem[64] = (32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                            mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _12858 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12858 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8668) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[324] = address(token1ToEarnedPath.field_256)
                            idx = 324
                            s = 1
                            while (32 * token1ToEarnedPath.length) + 260 > idx:
                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _20307 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _20366 = mem[(32 * token1ToEarnedPath.length) + _20307 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20307 + 292])] = mem[(32 * token1ToEarnedPath.length) + _20307 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20307 + 292])]
                            mem[64] = (32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                            mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _27476 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _27476 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                else:
                    mem[260] = return_data.size
                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not return_data.size:
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _8613 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                            _8669 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293])]
                            mem[64] = (32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                            mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _12861 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12861 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8669) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 28
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8615 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8670 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293])]
                                mem[64] = (32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12864 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12864 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8670) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                idx = ceil32(return_data.size) + 325
                                s = 1
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _20309 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _20367 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20309 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20309 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20309 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20309 + 293])]
                                mem[64] = (32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _27479 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27479 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        require return_data.size >= 32
                        if not mem[292]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 371 len 22]
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _8617 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                            _8671 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8617 + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8617 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8617 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8617 + 293])]
                            mem[64] = (32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                            mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _12867 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12867 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8671) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 28
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8619 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8672 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8619 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8619 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8619 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8619 + 293])]
                                mem[64] = (32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12870 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12870 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8672) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                idx = ceil32(return_data.size) + 325
                                s = 1
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _20311 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _20368 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20311 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20311 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20311 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20311 + 293])]
                                mem[64] = (32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _27482 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27482 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
    else:
        if ext_call.return_data[0] <= 0:
            require ext_code.size(token1Address)
            staticcall token1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if earnedAddress != token1Address:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(token1Address)
                    staticcall token1Address.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(uniRouterAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[132] = address(uniRouterAddress)
                    mem[164] = 2 * ext_call.return_data[0]
                    mem[96] = 68
                    mem[132 len 28] = Mask(224, 0, stor8)
                    mem[128 len 4] = approve(address rg1, uint256 rg2)
                    mem[196] = 32
                    mem[228] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                    if not ext_code.size(token1Address):
                        revert with 0, 'Address: call to non-contract'
                    mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                    mem[352 len 4] = 0
                    mem[324 len 0] = 0
                    call token1Address with:
                       funct uint32(stor8)
                         gas gas_remaining wei
                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                        mem[260] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _8625 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _8675 = mem[(32 * token1ToEarnedPath.length) + _8625 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8625 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8625 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8625 + 292])]
                            mem[64] = (32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                            mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _12879 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12879 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8675) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 28
                            mem[292] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                                mem[(32 * token1ToEarnedPath.length) + 328] = 64
                                mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                                mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                                require return_data.size >= 32
                                _8627 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                                _8676 = mem[(32 * token1ToEarnedPath.length) + _8627 + 292]
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8627 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8627 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8627 + 292])]
                                mem[64] = (32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                                mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                                mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                                if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                                _12882 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                    mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                    mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12882 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8676) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[324] = address(token1ToEarnedPath.field_256)
                                idx = 324
                                s = 1
                                while (32 * token1ToEarnedPath.length) + 260 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                                mem[(32 * token1ToEarnedPath.length) + 328] = 64
                                mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                                mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                                require return_data.size >= 32
                                _20315 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                                _20370 = mem[(32 * token1ToEarnedPath.length) + _20315 + 292]
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20315 + 292])] = mem[(32 * token1ToEarnedPath.length) + _20315 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20315 + 292])]
                                mem[64] = (32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 388
                                mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                                mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                                if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                                _27488 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                    mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                    mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27488 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20370) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        mem[260] = return_data.size
                        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8629 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8677 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293])]
                                mem[64] = (32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12885 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12885 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8677) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[0] = 28
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _8631 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _8678 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293])]
                                    mem[64] = (32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                    mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _12888 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _12888 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                    idx = ceil32(return_data.size) + 325
                                    s = 1
                                    while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _20317 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _20371 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20317 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20317 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20317 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20317 + 293])]
                                    mem[64] = (32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                    mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _27491 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _27491 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20371) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            require return_data.size >= 32
                            if not mem[292]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 371 len 22]
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8633 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8679 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8633 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8633 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8633 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8633 + 293])]
                                mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12891 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12891 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[0] = 28
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _8635 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _8680 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8635 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8635 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8635 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8635 + 293])]
                                    mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _12894 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _12894 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                    idx = ceil32(return_data.size) + 325
                                    s = 1
                                    while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _20319 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _20372 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20319 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20319 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20319 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20319 + 293])]
                                    mem[64] = (32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 389
                                    mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _27494 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _27494 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20372) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
        else:
            require ext_code.size(token0Address)
            staticcall token0Address.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(uniRouterAddress)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            mem[132] = address(uniRouterAddress)
            mem[164] = 2 * ext_call.return_data[0]
            mem[96] = 68
            mem[132 len 28] = Mask(224, 0, stor8)
            mem[128 len 4] = approve(address rg1, uint256 rg2)
            mem[196] = 32
            mem[228] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
            if not ext_code.size(token0Address):
                revert with 0, 'Address: call to non-contract'
            mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
            mem[352 len 4] = 0
            mem[324 len 0] = 0
            call token0Address with:
               funct uint32(stor8)
                 gas gas_remaining wei
                args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                mem[260] = token0ToEarnedPath.length
                if not token0ToEarnedPath.length:
                    if block.timestamp + 600 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _8639 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                    _8682 = mem[(32 * token0ToEarnedPath.length) + _8639 + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _8639 + 292])] = mem[(32 * token0ToEarnedPath.length) + _8639 + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _8639 + 292])]
                    mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388
                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _12900 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _34281 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _34469 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 648]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 648])]
                                        mem[64] = (32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _40855 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40855 / 1000
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _40855 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34469) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 28
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _34283 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _34470 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 648]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 648])]
                                            mem[64] = (32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _40858 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40858 / 1000
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40858 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34470) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46907 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47166 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 648]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 648])]
                                            mem[64] = (32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51576 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51576 / 1000
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51576 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47166) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34285 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34471 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649])]
                                            mem[64] = (32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40861 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40861 / 1000
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40861 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34471) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34287 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34472 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649])]
                                                mem[64] = (32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40864 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40864 / 1000
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40864 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34472) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46909 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47167 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46909 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46909 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46909 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46909 + 649])]
                                                mem[64] = (32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51579 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51579 / 1000
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51579 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47167) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34289 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34473 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34289 + 649]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34289 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34289 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34289 + 649])]
                                            mem[64] = (32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40867 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40867 / 1000
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40867 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34473) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34291 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34474 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34291 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34291 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34291 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34291 + 649])]
                                                mem[64] = (32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40870 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40870 / 1000
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40870 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34474) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46911 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47168 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46911 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46911 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46911 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46911 + 649])]
                                                mem[64] = (32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51582 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51582 / 1000
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51582 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47168) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if slippageFactor * mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], slippageFactor * _12900 / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _34265 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _34461 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 648]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 648])]
                                        mem[64] = (32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _40831 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40831 / 1000
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _40831 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34461) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 28
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _34267 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _34462 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 648]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 648])]
                                            mem[64] = (32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _40834 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40834 / 1000
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40834 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34462) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46899 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47162 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 648]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 648])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 680 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 648])]
                                            mem[64] = (32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51564 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51564 / 1000
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51564 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47162) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34269 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34463 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649])]
                                            mem[64] = (32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40837 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40837 / 1000
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40837 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34463) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34271 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34464 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649])]
                                                mem[64] = (32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40840 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40840 / 1000
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40840 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34464) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46901 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47163 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46901 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46901 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46901 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46901 + 649])]
                                                mem[64] = (32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51567 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51567 / 1000
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51567 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47163) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34273 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34465 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34273 + 649]
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34273 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34273 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34273 + 649])]
                                            mem[64] = (32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40843 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40843 / 1000
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40843 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34465) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34275 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34466 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34275 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34275 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34275 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34275 + 649])]
                                                mem[64] = (32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40846 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40846 / 1000
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40846 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34466) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46903 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47164 = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 649]
                                                mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 649])] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 681 len floor32(mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 649])]
                                                mem[64] = (32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51570 = mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51570 / 1000
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51570 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8682) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47164) + (32 * _8682) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                else:
                    mem[0] = 27
                    mem[292] = address(token0ToEarnedPath.field_0)
                    idx = 292
                    s = 0
                    while (32 * token0ToEarnedPath.length) + 260 > idx:
                        mem[idx + 32] = token0ToEarnedPath[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if block.timestamp + 600 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _20331 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                    _20378 = mem[(32 * token0ToEarnedPath.length) + _20331 + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _20331 + 292])] = mem[(32 * token0ToEarnedPath.length) + _20331 + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _20331 + 292])]
                    mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388
                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _27516 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _46933 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _47179 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 648]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 648])]
                                        mem[64] = (32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _51615 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51615 / 1000
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _51615 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47179) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 28
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46935 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47180 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 648]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 648])]
                                            mem[64] = (32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51618 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51618 / 1000
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51618 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47180) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _55227 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _55310 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 648]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 648])]
                                            mem[64] = (32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _56712 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _56712 / 1000
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _56712 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55310) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46937 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47181 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649])]
                                            mem[64] = (32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51621 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51621 / 1000
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51621 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47181) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46939 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47182 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649])]
                                                mem[64] = (32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51624 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51624 / 1000
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51624 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47182) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55229 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55311 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55229 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55229 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55229 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55229 + 649])]
                                                mem[64] = (32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56715 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56715 / 1000
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56715 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55311) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46941 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47183 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46941 + 649]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46941 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46941 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46941 + 649])]
                                            mem[64] = (32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51627 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51627 / 1000
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51627 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47183) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46943 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47184 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649])]
                                                mem[64] = (32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51630 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51630 / 1000
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51630 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47184) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55231 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55312 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649])]
                                                mem[64] = (32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56718 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56718 / 1000
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56718 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55312) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if slippageFactor * mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], slippageFactor * _27516 / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _46917 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _47171 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 648]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 648])]
                                        mem[64] = (32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _51591 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51591 / 1000
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _51591 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47171) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 28
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46919 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47172 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 648]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 648])]
                                            mem[64] = (32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51594 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51594 / 1000
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51594 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47172) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _55219 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _55306 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 648]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 648])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 680 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 648])]
                                            mem[64] = (32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _56700 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _56700 / 1000
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _56700 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55306) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46921 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47173 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649])]
                                            mem[64] = (32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51597 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51597 / 1000
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51597 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47173) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46923 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47174 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649])]
                                                mem[64] = (32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51600 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51600 / 1000
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51600 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47174) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55221 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55307 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55221 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55221 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55221 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55221 + 649])]
                                                mem[64] = (32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56703 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56703 / 1000
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56703 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55307) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46925 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47175 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46925 + 649]
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46925 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46925 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46925 + 649])]
                                            mem[64] = (32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51603 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51603 / 1000
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51603 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47175) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46927 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47176 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46927 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46927 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46927 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46927 + 649])]
                                                mem[64] = (32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51606 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51606 / 1000
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51606 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47176) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55223 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55308 = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 649]
                                                mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 649])] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 681 len floor32(mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 649])]
                                                mem[64] = (32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56706 = mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56706 / 1000
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56706 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20378) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55308) + (32 * _20378) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            else:
                mem[260] = return_data.size
                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _8641 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _8683 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8641 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8641 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8641 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8641 + 293])]
                        mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _12903 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34321 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34489 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650]
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650])]
                                                mem[64] = (32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40917 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40917 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34489) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34323 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34490 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650])]
                                                    mem[64] = (32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40920 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40920 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34490) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46957 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47191 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46957 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46957 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46957 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46957 + 650])]
                                                    mem[64] = (32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51651 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51651 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47191) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34325 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34491 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34325 + 650]
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34325 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34325 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34325 + 650])]
                                                mem[64] = (32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40923 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40923 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34491) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34327 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34492 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34327 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34327 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34327 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34327 + 650])]
                                                    mem[64] = (32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40926 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40926 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34492) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46959 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47192 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46959 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46959 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46959 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46959 + 650])]
                                                    mem[64] = (32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51654 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51654 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47192) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34317 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34487 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34317 + 649]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34317 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34317 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34317 + 649])]
                                            mem[64] = (32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40911 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40911 / 1000
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40911 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34487) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34319 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34488 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34319 + 649]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34319 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34319 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34319 + 649])]
                                                mem[64] = (32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40914 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40914 / 1000
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40914 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34488) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46955 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47190 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46955 + 649]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46955 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46955 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46955 + 649])]
                                                mem[64] = (32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51648 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51648 / 1000
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51648 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47190) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12903 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34305 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34481 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650]
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650])]
                                                mem[64] = (32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40893 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40893 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34481) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34307 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34482 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650])]
                                                    mem[64] = (32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40896 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40896 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34482) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46949 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47187 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46949 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46949 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46949 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46949 + 650])]
                                                    mem[64] = (32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51639 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51639 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47187) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34309 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34483 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34309 + 650]
                                                mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34309 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34309 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34309 + 650])]
                                                mem[64] = (32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40899 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40899 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34483) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34311 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34484 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34311 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34311 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34311 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34311 + 650])]
                                                    mem[64] = (32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40902 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40902 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34484) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46951 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47188 = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46951 + 650]
                                                    mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46951 + 650])] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46951 + 682 len floor32(mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46951 + 650])]
                                                    mem[64] = (32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51642 = mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51642 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47188) + (32 * _8683) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34301 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34479 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34301 + 649]
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34301 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34301 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34301 + 649])]
                                            mem[64] = (32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40887 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40887 / 1000
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40887 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34479) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34303 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34480 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34303 + 649]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34303 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34303 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34303 + 649])]
                                                mem[64] = (32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40890 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40890 / 1000
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40890 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34480) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46947 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47186 = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46947 + 649]
                                                mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46947 + 649])] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46947 + 681 len floor32(mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46947 + 649])]
                                                mem[64] = (32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51636 = mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51636 / 1000
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51636 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47186) + (32 * _8683) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 27
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _20337 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _20381 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20337 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20337 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20337 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20337 + 293])]
                        mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _27527 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46985 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47205 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650])]
                                                mem[64] = (32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51693 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51693 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47205) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46987 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47206 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650])]
                                                    mem[64] = (32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51696 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51696 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47206) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55245 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55319 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55245 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55245 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55245 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55245 + 650])]
                                                    mem[64] = (32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56739 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56739 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55319) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46989 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47207 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46989 + 650]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46989 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46989 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46989 + 650])]
                                                mem[64] = (32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51699 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51699 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47207) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46991 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47208 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46991 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46991 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46991 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46991 + 650])]
                                                    mem[64] = (32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51702 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51702 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47208) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55247 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55320 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55247 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55247 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55247 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55247 + 650])]
                                                    mem[64] = (32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56742 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56742 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55320) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46981 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47203 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46981 + 649]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46981 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46981 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46981 + 649])]
                                            mem[64] = (32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51687 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51687 / 1000
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51687 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47203) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46983 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47204 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46983 + 649]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46983 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46983 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46983 + 649])]
                                                mem[64] = (32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51690 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51690 / 1000
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51690 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47204) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55243 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55318 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55243 + 649]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55243 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55243 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55243 + 649])]
                                                mem[64] = (32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56736 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56736 / 1000
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56736 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55318) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _27527 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46969 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47197 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650])]
                                                mem[64] = (32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51669 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51669 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47197) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46971 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47198 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650])]
                                                    mem[64] = (32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51672 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51672 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47198) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55237 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55315 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55237 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55237 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55237 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55237 + 650])]
                                                    mem[64] = (32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56727 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56727 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55315) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46973 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47199 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46973 + 650]
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46973 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46973 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46973 + 650])]
                                                mem[64] = (32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51675 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51675 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47199) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46975 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47200 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46975 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46975 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46975 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46975 + 650])]
                                                    mem[64] = (32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51678 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51678 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47200) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55239 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55316 = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55239 + 650]
                                                    mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55239 + 650])] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55239 + 682 len floor32(mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55239 + 650])]
                                                    mem[64] = (32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56730 = mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56730 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55316) + (32 * _20381) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46965 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47195 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46965 + 649]
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46965 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46965 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46965 + 649])]
                                            mem[64] = (32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51663 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51663 / 1000
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51663 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47195) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46967 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47196 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46967 + 649]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46967 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46967 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46967 + 649])]
                                                mem[64] = (32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51666 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51666 / 1000
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51666 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47196) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55235 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55314 = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55235 + 649]
                                                mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55235 + 649])] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55235 + 681 len floor32(mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55235 + 649])]
                                                mem[64] = (32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56724 = mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56724 / 1000
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56724 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55314) + (32 * _20381) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    require return_data.size >= 32
                    if not mem[292]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 371 len 22]
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _8643 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _8684 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8643 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8643 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8643 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8643 + 293])]
                        mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _12906 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34357 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34507 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650]
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650])]
                                                mem[64] = (32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40973 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40973 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34507) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34359 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34508 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650])]
                                                    mem[64] = (32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40976 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40976 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34508) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47005 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47215 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47005 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47005 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47005 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47005 + 650])]
                                                    mem[64] = (32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51723 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51723 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47215) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34361 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34509 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34361 + 650]
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34361 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34361 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34361 + 650])]
                                                mem[64] = (32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40979 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40979 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34509) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34363 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34510 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34363 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34363 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34363 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34363 + 650])]
                                                    mem[64] = (32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40982 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40982 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34510) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47007 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47216 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47007 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47007 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47007 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47007 + 650])]
                                                    mem[64] = (32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51726 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51726 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47216) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34353 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34505 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34353 + 649]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34353 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34353 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34353 + 649])]
                                            mem[64] = (32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40967 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40967 / 1000
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40967 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34505) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34355 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34506 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34355 + 649]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34355 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34355 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34355 + 649])]
                                                mem[64] = (32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40970 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40970 / 1000
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40970 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34506) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _47003 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47214 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47003 + 649]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47003 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47003 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47003 + 649])]
                                                mem[64] = (32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51720 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51720 / 1000
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51720 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47214) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12906 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34341 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34499 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650]
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650])]
                                                mem[64] = (32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40949 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40949 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34499) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34343 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34500 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650])]
                                                    mem[64] = (32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40952 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40952 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34500) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46997 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47211 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46997 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46997 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46997 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46997 + 650])]
                                                    mem[64] = (32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51711 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51711 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47211) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34345 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34501 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34345 + 650]
                                                mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34345 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34345 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34345 + 650])]
                                                mem[64] = (32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40955 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40955 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34501) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34347 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34502 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34347 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34347 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34347 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34347 + 650])]
                                                    mem[64] = (32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40958 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40958 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34502) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46999 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47212 = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46999 + 650]
                                                    mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46999 + 650])] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46999 + 682 len floor32(mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46999 + 650])]
                                                    mem[64] = (32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51714 = mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51714 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47212) + (32 * _8684) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34337 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34497 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34337 + 649]
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34337 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34337 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34337 + 649])]
                                            mem[64] = (32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40943 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40943 / 1000
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40943 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34497) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34339 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34498 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34339 + 649]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34339 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34339 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34339 + 649])]
                                                mem[64] = (32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40946 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40946 / 1000
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40946 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34498) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46995 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47210 = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46995 + 649]
                                                mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46995 + 649])] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46995 + 681 len floor32(mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46995 + 649])]
                                                mem[64] = (32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51708 = mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51708 / 1000
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51708 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47210) + (32 * _8684) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 27
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _20343 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _20384 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20343 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20343 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20343 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20343 + 293])]
                        mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _27538 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47033 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47229 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650])]
                                                mem[64] = (32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51765 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51765 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47229) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47035 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47230 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650])]
                                                    mem[64] = (32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51768 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51768 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47230) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55261 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55327 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55261 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55261 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55261 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55261 + 650])]
                                                    mem[64] = (32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56763 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56763 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55327) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47037 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47231 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47037 + 650]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47037 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47037 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47037 + 650])]
                                                mem[64] = (32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51771 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51771 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47231) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47039 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47232 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47039 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47039 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47039 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47039 + 650])]
                                                    mem[64] = (32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51774 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51774 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47232) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55263 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55328 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55263 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55263 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55263 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55263 + 650])]
                                                    mem[64] = (32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56766 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56766 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55328) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _47029 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47227 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47029 + 649]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47029 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47029 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47029 + 649])]
                                            mem[64] = (32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51759 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51759 / 1000
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51759 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47227) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _47031 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47228 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47031 + 649]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47031 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47031 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47031 + 649])]
                                                mem[64] = (32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51762 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51762 / 1000
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51762 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47228) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55259 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55326 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55259 + 649]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55259 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55259 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55259 + 649])]
                                                mem[64] = (32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56760 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56760 / 1000
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56760 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55326) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _27538 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47017 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47221 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650])]
                                                mem[64] = (32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51741 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51741 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47221) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47019 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47222 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650])]
                                                    mem[64] = (32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51744 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51744 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47222) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55253 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55323 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55253 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55253 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55253 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55253 + 650])]
                                                    mem[64] = (32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56751 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56751 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55323) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47021 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47223 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47021 + 650]
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47021 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47021 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47021 + 650])]
                                                mem[64] = (32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51747 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51747 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47223) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 28
                                                mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47023 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47224 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47023 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47023 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47023 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47023 + 650])]
                                                    mem[64] = (32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51750 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51750 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47224) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55255 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55324 = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55255 + 650]
                                                    mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55255 + 650])] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55255 + 682 len floor32(mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55255 + 650])]
                                                    mem[64] = (32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56754 = mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56754 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55324) + (32 * _20384) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _47013 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47219 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47013 + 649]
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47013 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47013 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47013 + 649])]
                                            mem[64] = (32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51735 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51735 / 1000
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51735 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47219) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 28
                                            mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _47015 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47220 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47015 + 649]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47015 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47015 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47015 + 649])]
                                                mem[64] = (32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51738 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51738 / 1000
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51738 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47220) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55251 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55322 = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55251 + 649]
                                                mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55251 + 649])] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55251 + 681 len floor32(mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55251 + 649])]
                                                mem[64] = (32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56748 = mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56748 / 1000
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56748 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55322) + (32 * _20384) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
}



}
